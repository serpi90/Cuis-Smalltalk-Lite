'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 3 December 2010 at 11:38:39 pm'!!classDefinition: #CodeProvider category: #'System-Text'!TextProvider subclass: #CodeProvider	instanceVariableNames: 'acceptedContentsCache currentCompiledMethod contentsSymbol '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 12/3/2010 17:38'!forceRefetch	"En algun caso getTextSelector era nil... en cual?"	"	Problemas con FillInTheBlankMorph... Inspector	"	"	actualContents _ textProvider acceptedContents: getTextSelector.	"	"habilito esto para Inspector (era nil el selector)"	actualContents _ getTextSelector		ifNil: [ textProvider acceptedContents ]		ifNotNil: [			"Esto para FillIntheBlankMorph y otros..."			"Saque #acceptedContents: . Tiene sentido dejar #acceptedContents ?"			Text				initialFont: Preferences standardCodeFont				stringOrText: (textProvider perform: getTextSelector) ]! !!CodeProvider methodsFor: 'contents' stamp: 'jmv 12/3/2010 17:06'!contentsSymbol: aSymbol	"Set the contentsSymbol as indicated.  #source means to show source code, #comment means to show the first comment found in the source code"	contentsSymbol _ aSymbol.	self acceptedContentsChanged! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 12/3/2010 17:06'!updatePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue: [			self hasUnacceptedEdits				ifFalse: [					self acceptedContentsChanged]				ifTrue: [					self changed: #codeChangedElsewhere]]! !!CodeProvider methodsFor: 'message list' stamp: 'jmv 12/3/2010 16:55'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method answer |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			answer _ (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [			tempNames := (class compilerClass new						parse: method getSourceFromFile asString						in: class						notifying: nil) tempNames.			answer _ ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	answer _ (answer asText makeSelectorBoldIn: class).	^ answer copy! !!CodeProvider methodsFor: 'message list' stamp: 'jmv 12/3/2010 16:54'!selectedMessage	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."	| class selector method |	self showingDecompile ifTrue: [		^ self decompiledSourceIntoContentsWithTempNames: false ].	class _ self selectedClassOrMetaClass.	(class isNil or: [(selector _ self selectedMessageName) isNil]) ifTrue: [^ ''].	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ ((self showComment		ifFalse: [self sourceStringPrettifiedAndDiffed]		ifTrue:	[ self commentContents])			copy asText makeSelectorBoldIn: class)! !!Browser methodsFor: 'class list' stamp: 'jmv 12/3/2010 17:03'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex = 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])].	self selectedClass		ifNotNil: [			className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self acceptedContentsChanged! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 12/3/2010 17:02'!systemOrganizer: aSystemOrganizer	"Initialize the receiver as a perspective on the system organizer, 	aSystemOrganizer. Typically there is only one--the system variable 	SystemOrganization."	systemOrganizer _ aSystemOrganizer.	systemCategoryListIndex _ 0.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	metaClassIndicated _ false.	self setClassOrganizer.	self editSelection: #none.! !!Browser methodsFor: 'message category list' stamp: 'jmv 12/3/2010 17:02'!messageCategoryListIndex: anInteger	"Set the selected message category to be the one indexed by anInteger."	messageCategoryListIndex _ anInteger.	messageListIndex _ 0.	self changed: #messageCategorySelectionChanged.	self changed: #messageCategoryListIndex. "update my selection"	self changed: #messageList.	self editSelection: (anInteger > 0		ifTrue: [#newMessage]		ifFalse: [self classListIndex > 0			ifTrue: [#editClass]			ifFalse: [#newClass]]).	self acceptedContentsChanged.! !!Browser methodsFor: 'message functions' stamp: 'jmv 12/3/2010 17:02'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	selector _ (Smalltalk actualParserClass new parseSelector: aString).	(self metaClassIndicated		and: [(self selectedClassOrMetaClass includesSelector: selector) not		and: [Metaclass isScarySelector: selector]])		ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"				(self confirm: ((selector , ' is used in the existing class system.Overriding it could cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))				ifFalse: [^nil]].	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector		ifNil: [^ nil].	selector ~~ selectedMessageName		ifTrue: [			category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ selector! !!Browser methodsFor: 'message list' stamp: 'jmv 12/3/2010 17:05'!messageListIndex: anInteger	"Set the selected message selector to be the one indexed by anInteger."	messageListIndex _ anInteger.	self editSelection: (anInteger > 0		ifTrue: [#editMessage]		ifFalse: [self messageCategoryListIndex > 0			ifTrue: [#newMessage]			ifFalse: [self classListIndex > 0				ifTrue: [#editClass]				ifFalse: [#newClass]]]).	self changed: #messageListIndex. "update my selection"	self acceptedContentsChanged.	self decorateButtons! !!Browser methodsFor: 'message list' stamp: 'jmv 12/3/2010 17:03'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	self showingDecompile ifTrue: [		^ self decompiledSourceIntoContentsWithTempNames: false ].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ ((self showingDocumentation		ifFalse: [ self sourceStringPrettifiedAndDiffed ]		ifTrue: [ self commentContents ])			copy asText makeSelectorBoldIn: class)! !!Browser methodsFor: 'metaclass' stamp: 'jmv 12/3/2010 17:02'!metaClassIndicated: trueOrFalse 	"Indicate whether browsing instance or class messages."	metaClassIndicated _ trueOrFalse.	self setClassOrganizer.	systemCategoryListIndex > 0 ifTrue:		[self editSelection: (classListIndex = 0			ifTrue: [metaClassIndicated				ifTrue: [#none]				ifFalse: [#newClass]]			ifFalse: [#editClass])].	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self acceptedContentsChanged.	self decorateButtons! !!Browser methodsFor: 'system category list' stamp: 'jmv 12/3/2010 17:02'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."	systemCategoryListIndex _ anInteger.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self editSelection: ( anInteger = 0 ifTrue: [#none] ifFalse: [#newClass]).	metaClassIndicated _ false.	self setClassOrganizer.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self acceptedContentsChanged! !!ChangeSorter methodsFor: 'creation' stamp: 'jmv 12/3/2010 16:58'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| csListHeight msgListHeight csMsgListHeight |	csListHeight _ 0.25.	msgListHeight _ 0.25.	csMsgListHeight _ csListHeight + msgListHeight.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: ((PluggableListMorphByItem 				model: self				listGetter: #changeSetList				indexGetter: #currentCngSet				indexSetter: #showChangeSetNamed:				menuGetter: #changeSetMenu:shifted:				keystrokeAction: #changeSetListKey:from:)			autoDeselect: false)		frame: (((0@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:shifted:				keystrokeAction: #classListKey:from:)		frame: (((0.5@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:shifted:				keystrokeAction: #messageListKey:from:)		frame: (((0@csListHeight extent: 1@msgListHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@csMsgListHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil.! !!ChangeSorter methodsFor: 'access' stamp: 'jmv 12/3/2010 17:09'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 12/3/2010 17:09'!clearChangeSet	"Clear out the current change set, after getting a confirmation."	| message |	self okToChange ifFalse: [^ self].	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to\forget all the changes in this set?' withCRs.		(self confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self changed: #classList.	self changed: #messageList.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 12/3/2010 17:09'!uninstallChangeSet	"Attempt to uninstall the current change set, after confirmation."	self okToChange ifFalse: [^ self].	(self confirm: 'Uninstalling a changeSet is unreliable at best.It will only work if the changeSet consists only of singlechanges, additions and removals of methods, and ifno subsequent changes have been to any of them.No changes to classes will be undone.The changeSet will be cleared after uninstallation.Do you still wish to attempt to uninstall this changeSet?')	ifFalse: [^ self].	myChangeSet uninstall.	self changed: #relabel.	self changed: #classList.	self changed: #messageList.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 12/3/2010 17:09'!currentClassName: aString	currentClassName _ aString.	currentSelector _ nil.	"fix by wod"	self changed: #currentClassName.	self changed: #messageList.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 12/3/2010 17:09'!currentSelector: messageName	currentSelector _ messageName.	self changed: #currentSelector.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 12/3/2010 17:09'!acceptedStringOrText	"return the source code that shows in the bottom pane"	| sel class strm changeType answer |	self changed: #clearUserEdits.	currentClassName ifNil: [^ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector)		ifNotNil: [			changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^'Added then removed (see versions)'].			class ifNil: [^'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^'Method was added, but cannot be found!!'].			answer _  (class sourceCodeAt: sel).			(#(prettyPrint prettyLineDiffs prettyWordDiffs) includes: contentsSymbol) ifTrue: [				answer _ (class compilerClass new						format: answer						in: class 						notifying: nil)].			self showingAnyKindOfDiffs				ifTrue: [ answer _ (self diffFromPriorSourceFor: answer) ].			^ answer asText makeSelectorBoldIn: class ]		ifNil: [			strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ strm contents].! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'jmv 12/3/2010 16:59'!openAsMorphIn: window rect: rect	"Add a set of changeSetBrowser views to the given top view offset by the given amount"	| aHeight |	aHeight _ 0.25.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:shifted:				keystrokeAction: #classListKey:from:)		frame: (((0.0@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:shifted:				keystrokeAction: #messageListKey:from:)		frame: (((0.5@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@aHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil! !!Debugger methodsFor: 'accessing' stamp: 'jmv 12/3/2010 17:14'!acceptedStringOrText 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	"Estamos en el horno!!"	"^ String new"	"sera esto valido siempre? cuando? y si no, que hago?"	^self selectedMessage! !!Debugger methodsFor: 'accessing' stamp: 'jmv 12/3/2010 17:00'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		result := self contents: aText notifying: aController.		self acceptedContentsChanged.		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	World		addAlarm: #changed:		withArguments: #(contentsSelection)		for: self		at: (Time millisecondClockValue + 200).	^true! !!Debugger methodsFor: 'context stack (message list)' stamp: 'jmv 12/3/2010 17:00'!selectedMessage	"Answer the source code of the currently selected context."	^self selectedContext debuggerMap sourceText asText makeSelectorBold! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 12/3/2010 17:06'!implement: aMessage inClass: aClass		aClass		compile: aMessage createStubMethod		classified: (self askForCategoryIn: aClass default: 'as yet unclassified').	self selectedContext privRefreshWith: (aClass lookupSelector: aMessage selector).	self selectedContext method numArgs > 0 ifTrue:		[(self selectedContext tempAt: 1) arguments withIndexDo:			[:arg :index|			self selectedContext tempAt: index put: arg]].	self resetContext: self selectedContext.	self debug.! !!Debugger methodsFor: 'private' stamp: 'jmv 12/3/2010 17:00'!contextStackIndex: anInteger oldContextWas: oldContext 	"Change the context stack index to anInteger, perhaps in response to user selection."	| isNewMethod selectedContextSlotName index |	contextStackIndex := anInteger.	anInteger = 0 ifTrue: [		currentCompiledMethod := nil.		self changed: #contextStackIndex.		self decorateButtons.		self acceptedContentsChanged.		contextVariablesInspector object: nil.		receiverInspector object: self receiver.		^self].	selectedContextSlotName := contextVariablesInspector selectedSlotName.	isNewMethod := oldContext == nil					or: [oldContext method ~~ (currentCompiledMethod := self selectedContext method)].	isNewMethod ifTrue: [		self acceptedContentsChanged.		self pcRange ].	self changed: #contextStackIndex.	self decorateButtons.	contextVariablesInspector object: self selectedContext.	((index := contextVariablesInspector fieldList indexOf: selectedContextSlotName) ~= 0	 and: [index ~= contextVariablesInspector selectionIndex]) ifTrue: [		contextVariablesInspector toggleIndex: index].	receiverInspector object: self receiver.	isNewMethod ifFalse: [		self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'jmv 12/3/2010 16:59'!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [ :c | c terminateTimerProcess ].	interruptedProcess _ aProcess.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	errorWasInUIProcess _ false! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'jmv 12/3/2010 16:56'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector answer |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	answer _ (class sourceCodeAt: selector).	Preferences browseWithPrettyPrint ifTrue: [		answer _ (Smalltalk actualCompilerClass new					format: answer					in: class					notifying: nil)].	self showingAnyKindOfDiffs ifTrue: [		answer _ (self			methodDiffFor: answer			class: self selectedClass			selector: self selectedMessageName			meta: self metaClassIndicated)].	^ answer asText makeSelectorBoldIn: class! !!MessageSet methodsFor: 'message list' stamp: 'jmv 12/3/2010 17:06'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex _ anInteger.	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self acceptedContentsChanged.	(messageListIndex ~= 0 and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect].	self decorateButtons! !!MessageSet methodsFor: 'contents' stamp: 'jmv 12/3/2010 17:14'!acceptedStringOrText	"Answer the contents of the receiver"	"ok?"	^ 			messageListIndex = 0 				ifTrue: [					currentCompiledMethod _ nil.					'' ]				ifFalse: [					self showingByteCodes						ifTrue: [ self selectedBytecodes]						ifFalse: [ self selectedMessage]]! !!MessageSet methodsFor: 'private' stamp: 'jmv 12/3/2010 17:03'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].	class ifNil: [^ false].	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:		[oldSelector = #Comment ifTrue:			[class comment: aString stamp: Utilities changeStamp.			self changed: #annotation. 			self changed: #clearUserEdits.			^ false].		oldSelector = #Definition ifTrue:			["self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self changed: #clearUserEdits. 			^ false].		oldSelector = #Hierarchy ifTrue:			[self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector		ifNil: [^ false].	selector == oldSelector ifFalse: [		self reformulateListNoting: selector].	self changed: #annotation.	^ true! !!MessageSet methodsFor: 'private' stamp: 'jmv 12/3/2010 17:05'!initializeMessageList: anArray	| s |	messageList _ OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil: [					s _ class name , ' ' , sel , ' {' , ((class organization categoryOfElement: sel) ifNil: ['']) , '}'.					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s) ]]].	messageListIndex _ messageList isEmpty ifTrue: [0 ] ifFalse: [1]! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 12/3/2010 16:57'!initializeMessageList: anArray	messageList _ anArray.	messageListIndex _ 0! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 12/3/2010 16:57'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	self flag: #mref.	"fix for faster references to methods"	^[		| string strm class sel parens |		string _ self selection asString.		string first == $* ifTrue: [ ^ nil ].		"Ignore lines starting with *"		parens := string includes: $(.					"Does it have open-paren?"		strm := ReadStream on: string.		parens			ifTrue: [				strm skipTo: $(.		"easy case"				class := strm upTo: $).				strm next: 2.				sel := strm upToEnd ]			ifFalse: [				strm position: (string findString: ' class>>').				strm position > 0					ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])]					ifTrue: [						| subString |  "find the next to last space character"						subString := strm contents copyFrom: 1 to: (string findLast: [ :ch | ch == $ ]) - 1.						strm position: (subString findLast: [ :ch | ch == $ ])].				class := strm upTo: $>.				strm next.				sel := strm upToEnd ].		MessageSet parse: (class, ' ', sel) toClassAndSelector: csBlock	]		on: Error 		do: [ :ex | nil ]! !MessageSet removeSelector: #setContentsToForceRefetch!ChangeSorter removeSelector: #setContents!CodeProvider removeSelector: #initialize!CodeProvider removeSelector: #setContentsToForceRefetch!!classDefinition: #CodeProvider category: #'System-Text'!TextProvider subclass: #CodeProvider	instanceVariableNames: 'currentCompiledMethod contentsSymbol'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!TextProvider removeSelector: #acceptedContents:!TextProvider removeSelector: #setContentsToForceRefetch!