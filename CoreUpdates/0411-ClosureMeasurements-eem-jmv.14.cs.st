'From Cuis 2.0 of 4 January 2010 [latest update: #393] on 7 February 2010 at 9:57:43 pm'!!CodeHolder methodsFor: 'annotation' stamp: 'jmv 2/7/2010 21:51'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| stamp sendersCount implementorsCount aCategory separator aString aList aComment aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream _ ReadWriteStream on: ''.	requestList _ self annotationRequests.	separator _ requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | 			aRequest == #firstComment				ifTrue: [aComment _ aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment _ aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment _ aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp _ self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory _ aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount _ (Smalltalk allCallsOn: aSelector) size.					sendersCount _ sendersCount = 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.					implementorsCount _ implementorsCount = 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp _ VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString _ ChangeSorter mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList _ ChangeSorter allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator].			aRequest == #closuresInfo				ifTrue: [aString _ Smalltalk closuresInfoStringForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].		].	^ aStream contents! !!Preferences class methodsFor: 'parameters' stamp: 'jmv 2/7/2010 20:26'!annotationInfo 	"Answer a list of pairs characterizing all the available kinds of annotations; in each pair, the first element is a symbol representing the info type, and the second element is a string providing the corresponding balloon help"	^ #(		(timeStamp				'The time stamp of the last submission of the method.')		(firstComment			'The first comment in the method, if any.')		(masterComment		'The comment at the beginning of the supermost implementor of the method if any.')		(documentation			'Comment at beginning of the method or, if it has none, comment at the beginning of a superclass''s implementation of the method')		(messageCategory		'Which method category the method lies in')		(sendersCount			'A report of how many senders there of the message.')		(implementorsCount	'A report of how many implementors there are of the message.')		(recentChangeSet		'The most recent change set bearing the method.')		(allChangeSets			'A list of all change sets bearing the method.')		(priorVersionsCount	'A report of how many previous versions there are of the method' )		(priorTimeStamp			'The time stamp of the penultimate submission of the method, if any')		(closuresInfo				'Details about BlockClosures in the method')	)! !!Preferences class methodsFor: 'parameters' stamp: 'jmv 2/7/2010 20:54'!setDefaultAnnotationInfo	"Preferences setDefaultAnnotationInfo"	^ Parameters at: #MethodAnnotations put: #(timeStamp messageCategory implementorsCount closuresInfo allChangeSets)! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 10:43'!browseMethodsWithClosuresThatAccessOuterTemps	"	Smalltalk browseMethodsWithClosuresThatAccessOuterTemps	"	self		browseMessageList: (self allSelect: [ :m | 			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |				anyClosureHasCopied ].			])		name: 'Closures that read or write to outer temps'! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 10:43'!browseMethodsWithClosuresThatOnlyReadOuterTemps	"	Smalltalk browseMethodsWithClosuresThatOnlyReadOuterTemps	"	self		browseMessageList: (self allSelect: [ :m | 			self eliotsClosureMeasurementsOn: m over: [ :closuresCount					:hasIndirectTemps :anyClosureHasCopiedValues :anyClosureDoesUAR :anyClosureUsesSelf |				anyClosureHasCopiedValues & hasIndirectTemps not].			])		name: 'Closures that read but not write to outer temps'! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 10:43'!browseMethodsWithClosuresThatWriteOuterTemps	"	Smalltalk browseMethodsWithClosuresThatWriteOuterTemps	"	self		browseMessageList: (self allSelect: [ :m | 			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |				hasIndirectTemps ].			])		name: ' Closures that write to outer temps'! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 11:04'!browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise	"	Smalltalk browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise	"	self		browseMessageList: (self allSelect: [ :m | 			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |				hasIndirectTemps and: [  anyClosureDoesUAR not and: [ anyClosureUsesSelf not ] ] ].			])		name: ' Closures that write to outer temps, but clean otherwise'! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 10:30'!browseMethodsWithMoreThanOneClosure	"	Smalltalk browseMethodsWithMoreThanOneClosure	"	self		browseMessageList: (self allSelect: [ :m | 			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |				closuresCount > 1 ].			])		name: 'Methods with more than one Closure'! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 10:31'!browseMethodsWithOnlyCleanClosures	"	Smalltalk browseMethodsWithOnlyCleanClosures	"	self		browseMessageList: (			self allSelect: [ :m | 				self eliotsClosureMeasurementsOn: m over: [ :closuresCount						:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |					closuresCount > 0 and: [						(anyClosureHasCopied or: [ anyClosureDoesUAR or: [ anyClosureUsesSelf ]]) not ].				]			])		name: 'Methods with only Clean Closures'! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/7/2010 21:52'!closuresInfoStringForClass: aClass selector: aSelector	"	Smalltalk closuresInfoStringFor: PlayingWithClosures class >> #exp01Argument	"	| answer all someDo noneDoes method |	method _ aClass compiledMethodAt: aSelector ifAbsent: [ ^'' ].	self eliotsClosureMeasurementsOn: method over: [ 				:closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |					closuresCount > 0			ifFalse: [ answer _ 'No real (non-optimized) Closures' ]			ifTrue: [				closuresCount = 1					ifTrue: [						answer _ '1 Closure: '.						all _ ''.						someDo _ 'does'. 						noneDoes _ 'does not' ]					ifFalse: [						answer _ closuresCount printString, ' Closures: '.						all _ 'all '.						someDo _ 'some do'. 						noneDoes _ 'none does' ].				(anyClosureHasCopied or: [ anyClosureDoesUAR or: [ anyClosureUsesSelf ]])					ifFalse: [ answer _ answer, all, 'clean' ]					ifTrue: [						answer _ answer, (anyClosureHasCopied							ifTrue: [								hasIndirectTemps									ifTrue: [ someDo, ' write (and maybe ', someDo, ' read)' ]									ifFalse: [ someDo, ' read (but ', noneDoes, ' write)' ] ]							ifFalse: [ noneDoes, ' access' ]), ' outer temps; '.						answer _ answer, (anyClosureDoesUAR							ifTrue: [ someDo ]							ifFalse: [ noneDoes ]), ' ^return; '.						answer _ answer, (anyClosureUsesSelf							ifTrue: [ someDo ]							ifFalse: [ noneDoes ]), ' use self'					].			]		].		^answer! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 11:19'!eliotsClosureMeasurements	"	Smalltalk eliotsClosureMeasurements	From http://www.mirandabanda.org/cogblog/2008/11/14/mechanised-modifications-and-miscellaneous-measurements/	by Eliot Miranda	"      | numMethods numMethodsWithClosure numMethodsWithIndirectTemps         numClosures numClosuresWithCopiedValues numCopiedValuesForClosure         numRemoteTemps numScopesWithRemoteTemps         upArrowReturnsInClosure closureUsesSelfs upArrowReturnAndUsesSelfs numClean |        numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=        numClosures := numClosuresWithCopiedValues := numCopiedValuesForClosure :=        numRemoteTemps := numScopesWithRemoteTemps :=        upArrowReturnsInClosure := closureUsesSelfs := upArrowReturnAndUsesSelfs := numClean := 0.        self allSelect:                 [:m| | s hasClosure hasIndirectTemps blkPc blkSz doesUAR usesSelf hasCopied sel|			sel _ false.                 hasClosure := hasIndirectTemps := false.                 s := InstructionStream on: m.                 s scanFor:                          [:b|                          b = 143 "closure creation" ifTrue:                                   [hasClosure := true.                                   numClosures := numClosures + 1.                                   s followingByte >= 16 ifTrue:                                            [numClosuresWithCopiedValues := numClosuresWithCopiedValues + 1.                                             numCopiedValuesForClosure := numCopiedValuesForClosure + (s followingByte >> 4)]].                          (b = 138 "indirect temp vector creation"                           and: [s followingByte <= 127]) ifTrue:                                   [hasIndirectTemps := true.                                    numScopesWithRemoteTemps := numScopesWithRemoteTemps + 1.                                    numRemoteTemps := numRemoteTemps + s followingByte].                          false].                 numMethods := numMethods + 1.                 hasClosure ifTrue:                          [numMethodsWithClosure := numMethodsWithClosure + 1.                           s pc: m initialPC; scanFor: [:b| b = 143]."jmv-This looks like the correct place to do this"                           hasCopied := s followingByte >= 16.                           blkSz := s interpretNextInstructionFor: BlockStartLocator new.                           blkPc := s pc.                           doesUAR := usesSelf := false."jmv-Doing this here looks like a bug. See the other comment"                           hasCopied := s followingByte >= 16."jmv-Another bug. This only considers the first closure (and any nested closure in it), but not later ones"                           s scanFor:                                   [:b|                                   s pc >= (blkPc + blkSz)                                            ifTrue: [true]                                            ifFalse:                                                     [doesUAR := doesUAR or: [s willReturn and: [s willBlockReturn not]].                                                      usesSelf := usesSelf or: [b = 112 "pushSelf"                                                                                                  or: [b < 16 "pushInstVar"                                                                                                  or: [(b = 128 and: [s followingByte <= 63]) "pushInstVar"                                                                                                  or: [(b between: 96 and: 96 + 7) "storePopInstVar"                                                                                                  or: [(b = 130 and: [s followingByte <= 63]) "storePopInstVar"                                                                                                  or: [(b = 129 and: [s followingByte <= 63]) "storeInstVar"                                                                                                  or: [b = 132 and: [s followingByte = 160]]]]]]]].                                                     false]].                           doesUAR ifTrue:                                   [upArrowReturnsInClosure := upArrowReturnsInClosure + 1].                           usesSelf ifTrue:                                   [closureUsesSelfs := closureUsesSelfs + 1].                           (doesUAR and: [usesSelf]) ifTrue:                                   [upArrowReturnAndUsesSelfs := upArrowReturnAndUsesSelfs + 1].                           (doesUAR or: [usesSelf or: [hasCopied]]) ifFalse:                                   [numClean := numClean + 1]].                 hasIndirectTemps ifTrue: [numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].                 sel].^        { {'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. {'MethodsWithIndirectTemps'. numMethodsWithIndirectTemps}.         {'Closures'. numClosures}. {'CopiedValuesForClosures'. numCopiedValuesForClosure}. {'ClosuresWithCopiedValues'. numClosuresWithCopiedValues}.         {'RemoteTemps'. numRemoteTemps}. {'ScopesWithRemoteTemps'. numScopesWithRemoteTemps}.         {'MethodsWithUpArrowReturnsInClosures'. upArrowReturnsInClosure}. {'MethodsWithReferencesToSelfInClosures'. closureUsesSelfs}. {'Both'. upArrowReturnAndUsesSelfs}.         {'MethodsWithOnlyCleanClosures'. numClean} }! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/5/2010 10:44'!eliotsClosureMeasurements2	"	Smalltalk eliotsClosureMeasurements2	"	| numMethods numMethodsWithClosure numMethodsWithIndirectTemps anyClosureDoesUARCount anyClosureUsesSelfCount bothCount onlyCleanBlocksCount anyClosureHasCopiedCount |	numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=	anyClosureDoesUARCount := anyClosureUsesSelfCount := bothCount := onlyCleanBlocksCount := 0.	anyClosureHasCopiedCount _ 0.	self allSelect: [ :m | 		self eliotsClosureMeasurementsOn: m over: [ :closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |			numMethods := numMethods + 1.			closuresCount > 0 ifTrue: [ numMethodsWithClosure := numMethodsWithClosure + 1 ].			hasIndirectTemps ifTrue: [ numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].			anyClosureDoesUAR ifTrue: [ anyClosureDoesUARCount := anyClosureDoesUARCount + 1].			anyClosureUsesSelf ifTrue: [ anyClosureUsesSelfCount := anyClosureUsesSelfCount + 1].			(anyClosureDoesUAR and: [anyClosureUsesSelf]) ifTrue: [ bothCount := bothCount + 1].			closuresCount > 0 ifTrue: [				(anyClosureDoesUAR or: [anyClosureUsesSelf or: [anyClosureHasCopied]]) ifFalse: [					onlyCleanBlocksCount := onlyCleanBlocksCount + 1]].			anyClosureHasCopied ifTrue: [ anyClosureHasCopiedCount _ anyClosureHasCopiedCount + 1 ].			false.		]	].	^{		{'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. 		{'WithClosuresAccessingOuterTemps'. anyClosureHasCopiedCount}.		{'WithClosuresWritingOuterTemps'. numMethodsWithIndirectTemps}.		{'WithUpArrowReturnsInClosures'. anyClosureDoesUARCount}. 		{'WithReferencesToSelfInClosures'. anyClosureUsesSelfCount}. 		{'BothAbove'. bothCount}.		{'WithOnlyCleanClosures'. onlyCleanBlocksCount}.	}! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/7/2010 20:52'!eliotsClosureMeasurements2On: aMethod	"	A Couple of Clean Closures	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01Argument	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01LocalTemp		Closures reading and writing to outer temps	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTemp	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempWithAssignment	Closure doing an up-arrow return	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01UpArrowReturn	Closures sending messages to self & super	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01SelfSend	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01SuperSend	A couple of non-closures, i.e. blocks that are optimized by the compiler and a closure is never created	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempOptimized	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempOptimizedWithAssignment		A remote temp whose declaration can not be moved inside the block	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempCantBeMovedInside	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempAssignedTwice	A remote temp whose declaration can be moved inside the block	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempCanBeMovedInside	A not-so remote temp. The declaration was moved inside the block, making it a clean block	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01LocalTemp	"	| numMethods numMethodsWithClosure numMethodsWithIndirectTemps anyClosureDoesUARCount anyClosureUsesSelfCount bothCount onlyCleanBlocksCount anyClosureHasCopiedCount |	numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=	anyClosureDoesUARCount := anyClosureUsesSelfCount := bothCount := onlyCleanBlocksCount := 0.	anyClosureHasCopiedCount _ 0.	self eliotsClosureMeasurementsOn: aMethod over: [ :closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |		numMethods := numMethods + 1.		closuresCount > 0 ifTrue: [ numMethodsWithClosure := numMethodsWithClosure + 1 ].		hasIndirectTemps ifTrue: [ numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].		anyClosureDoesUAR ifTrue: [ anyClosureDoesUARCount := anyClosureDoesUARCount + 1].		anyClosureUsesSelf ifTrue: [ anyClosureUsesSelfCount := anyClosureUsesSelfCount + 1].		(anyClosureDoesUAR and: [anyClosureUsesSelf]) ifTrue: [ bothCount := bothCount + 1].		closuresCount > 0 ifTrue: [			(anyClosureDoesUAR or: [anyClosureUsesSelf or: [anyClosureHasCopied]]) ifFalse: [				onlyCleanBlocksCount := onlyCleanBlocksCount + 1]].		anyClosureHasCopied ifTrue: [ anyClosureHasCopiedCount _ anyClosureHasCopiedCount + 1 ].	].	^{		{'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. 		{'WithClosuresAccessingOuterTemps'. anyClosureHasCopiedCount}.		{'WithClosuresWritingOuterTemps'. numMethodsWithIndirectTemps}.		{'WithUpArrowReturnsInClosures'. anyClosureDoesUARCount}. 		{'WithReferencesToSelfInClosures'. anyClosureUsesSelfCount}. 		{'BothAbove'. bothCount}.		{'WithOnlyCleanClosures'. onlyCleanBlocksCount}.	}! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 2/7/2010 20:53'!eliotsClosureMeasurementsOn: m over: aFiveArgBlock	"	See senders.	Or try something like:		Smalltalk			eliotsClosureMeasurementsOn: FileList >> #defaultContents			over: [ :closuresCount :hasCopiedValuesForClosure :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |				(Array with: closuresCount with: hasCopiedValuesForClosure with: hasIndirectTemps with: anyClosureHasCopied with: anyClosureDoesUAR with: anyClosureUsesSelf)]	From http://www.mirandabanda.org/cogblog/2008/11/14/mechanised-modifications-and-miscellaneous-measurements/	by Eliot Miranda	"	| s nextScanStart thisClosureHasCopied closuresCount hasIndirectTemps blkPc blkSz anyClosureHasCopied anyClosureDoesUAR anyClosureUsesSelf analyzedClosures |	closuresCount := 0.	hasIndirectTemps := false.	anyClosureHasCopied :=  anyClosureDoesUAR := anyClosureUsesSelf := false.	s := InstructionStream on: m.	s scanFor: [ :b |		b = 16r8F "16r8F = 143 closure creation" ifTrue: [			closuresCount := closuresCount + 1].		(b = 16r8A "16r8A = 138indirect temp vector creation" and: [ s followingByte <= 127]) ifTrue: [				hasIndirectTemps := true].		false].	nextScanStart := m initialPC.	analyzedClosures := 0.	[ analyzedClosures < closuresCount ] whileTrue: [		s pc: nextScanStart; scanFor: [ :b | b = 16r8F ].	"16r8F = 143 Search for first closure"		analyzedClosures := analyzedClosures + 1.		thisClosureHasCopied := s followingByte >= 16r10.		anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.		blkSz := s interpretNextInstructionFor: BlockStartLocator new.		"Findout size of first closure"		blkPc := s pc.		s scanFor: [ :b |			s pc >= (blkPc + blkSz)				ifTrue: [					nextScanStart := s pc.					true]				ifFalse: [					b = 16r8F ifTrue: [									thisClosureHasCopied := s followingByte >= 16r10.						anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.						analyzedClosures := analyzedClosures + 1 ].					anyClosureDoesUAR := anyClosureDoesUAR or: [s willReturn and: [s willBlockReturn not]].					anyClosureUsesSelf := anyClosureUsesSelf or: [b = 16r70 "pushSelf"										or: [b < 16r10 "pushInstVar"										or: [(b = 16r80 and: [s followingByte <= 16r3F]) "pushInstVar"										or: [(b between: 16r60 and: 16r60 + 7) "storePopInstVar"										or: [(b = 16r82 and: [s followingByte <= 63]) "storePopInstVar"										or: [(b = 16r81 and: [s followingByte <= 63]) "storeInstVar"										or: [b = 16r84 and: [s followingByte = 160]]]]]]]].					false]]].	^aFiveArgBlock valueWithArguments: (Array			with: closuresCount			with: hasIndirectTemps			with: anyClosureHasCopied			with: anyClosureDoesUAR			with: anyClosureUsesSelf)! !"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Preferences setDefaultAnnotationInfo!