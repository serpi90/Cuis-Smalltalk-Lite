'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 18 April 2011 at 3:24:48 pm'!!AbstractSound methodsFor: 'file i/o' stamp: 'FernandoOlivero 4/16/2011 01:40'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."	| bufSize stereoBuffer reverseBytes  |	self reset.	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.	'Storing audio...' displayProgressAt: World activeHand position		from: 0 to: samplesToStore during: [:bar | | remaining out |			remaining _ samplesToStore.			[remaining > 0] whileTrue: [				bar value: samplesToStore - remaining.				stereoBuffer primFill: 0.  "clear the buffer"				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.				self isStereo					ifTrue: [out _ stereoBuffer]					ifFalse: [out _ stereoBuffer extractLeftChannel].				reverseBytes ifTrue: [out reverseEndianness].				(aBinaryStream isKindOf: StandardFileStream)					ifTrue: [  "optimization for files: write sound buffer directly to file"						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"					ifFalse: [  "for non-file streams:"						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].				remaining _ remaining - bufSize]].! !!AbstractSound class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:32'!testFMInteractively	"Experiment with different settings of the FM modulation and multiplier settings interactively by moving the mouse. The top-left corner of the screen is 0 for both parameters. Stop when the mouse is pressed."	"AbstractSound testFMInteractively"	| s mousePt lastVal status mod ratio |	SoundPlayer startPlayerProcessBufferSize: 1100 rate: 11025 stereo: false.	s _ FMSound pitch: 440.0 dur: 200.0 loudness: 0.2.	SoundPlayer playSound: s.	lastVal _ nil.	[Sensor anyButtonPressed] whileFalse: [		mousePt _ Sensor mousePoint.		mousePt ~= lastVal ifTrue: [			mod _ mousePt x asFloat / 20.0.			ratio _ mousePt y asFloat / 20.0.			s modulation: mod ratio: ratio.			lastVal _ mousePt.			status _'mod: ', mod printString, 'ratio: ', ratio printString.			status displayOn: Display at: 10@10]].	SoundPlayer shutDown.! !!BitBlt methodsFor: 'copying' stamp: 'jmv 4/18/2011 14:32'!pixelAt: aPoint put: pixelValue	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPokerToForm:.  Overwrites the pixel at aPoint."	destX _ aPoint x.	destY _ aPoint y.	sourceForm unhibernate. "before poking"	sourceForm bits at: 1 put: pixelValue.	self copyBits"| bb |bb _ (BitBlt bitPokerToForm: Display).[Sensor anyButtonPressed] whileFalse:	[bb pixelAt: Sensor mousePoint put: 55]"! !!BitBlt methodsFor: 'private' stamp: 'jmv 4/18/2011 14:32'!paintBits	"Perform the paint operation, which requires two calls to BitBlt."	| color oldMap saveRule |	sourceForm depth = 1 ifFalse: 		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].	saveRule _ combinationRule.	color _ halftoneForm.  halftoneForm _ nil.	oldMap _ colorMap.	"Map 1's to ALL ones, not just one"	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ color.	combinationRule _ Form under.	self copyBits.	"then OR, with whatever color, into the hole"	colorMap _ oldMap.	combinationRule _ saveRule" | dot |dot _ Form dotOfSize: 32.((BitBlt destForm: Display		sourceForm: dot		fillColor: Color lightGray		combinationRule: Form paint		destOrigin: Sensor mousePoint		sourceOrigin: 0@0		extent: dot extent		clipRect: Display boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !!BitBlt class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:42'!alphaBlendDemo	"To run this demo, use...		Display restoreAfter: [BitBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.		map32toD _ Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	buff _ Form extent: 500@50 depth: 32.	dispToBuff _ BitBlt toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay _ BitBlt toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush _ Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"	dispToBuff colorMap: mapDto32.	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"	brushToBuff sourceForm: brush; sourceOrigin: 0@0.	brushToBuff combinationRule: Form blend.	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor mouseButton2Pressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.		dispToBuff copyFrom: buffRect in: Display to: 0@0.		[Sensor mouseButton1Pressed] whileTrue:			["Here is the painting loop"			p _ Sensor mousePoint - (brush extent // 2).			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p dist: prevP) > buffSize ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				(buffRect containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ brushRect amountToTranslateWithin: buffRect.					buffToBuff copyFrom: buff boundingBox in: buff to: delta.					newBuffRect _ buffRect translateBy: delta negated.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP - buffRect origin									to: p - buffRect origin									withFirstPoint: false.				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.				prevP _ p]]]! !!BitBlt class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:42'!exampleTwo	"This is to test painting with a gray tone. It also tests that the seaming with gray patterns is correct in the microcode. Lets you paint for a while and then automatically stops. This only works at Depth of 1."	| f aBitBlt displayDepth |	"create a small black Form source as a brush. "	displayDepth _ Display depth.	Display newDepth: 1.	f _ Form extent: 20 @ 20.	f fillBlack.	"create a BitBlt which will OR gray into the display. "	aBitBlt _ BitBlt		destForm: Display		sourceForm: f		fillColor: Color gray		combinationRule: Form over		destOrigin: Sensor mousePoint		sourceOrigin: 0 @ 0		extent: f extent		clipRect: Display computeBoundingBox.	"paint the gray Form on the screen for a while. "	[Sensor anyButtonPressed] whileFalse: 		[aBitBlt destOrigin: Sensor mousePoint.		aBitBlt copyBits].	Display newDepth: displayDepth.	"BitBlt exampleTwo"! !!ButtonLW methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:41'!mouseUp: evt	"Handle a mouse up event."	(self containsPoint: evt position)		ifTrue: [self performAction].	pressed _ false.	self updateView! !!ChangeList methodsFor: 'scanning' stamp: 'jmv 4/18/2011 14:32'!scanFile: aFile from: startPosition to: stopPosition	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.	'Scanning ', aFile localName, '...'		displayProgressAt: Sensor mousePoint		from: startPosition to: stopPosition		during: [:bar |			[file position < stopPosition] whileTrue: [ | prevChar |				bar value: file position.				[file atEnd not and: [file peek isSeparator]]					whileTrue: [prevChar _ file next].				(file peekFor: $!!)					ifTrue: [						(prevChar = Character cr or: [prevChar = Character lf])							ifTrue: [self scanCategory]]					ifFalse: [						| itemPosition item |						itemPosition _ file position.						item _ file nextChunk.						file skipStyleChunk.						item size > 0 ifTrue: [							self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)								text: 'do it: ' , (item contractTo: 160)]]]].	listSelections _ Array new: list size withAll: false! !!CheckBoxLW methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:42'!mouseUp: evt	"Handle a mouse up event."	(self containsPoint: evt position) ifTrue: [		selected _ selected not.		target perform: action with: selected.		self updateView]! !!ClosureCompilerTest methodsFor: 'source' stamp: 'jmv 4/18/2011 14:32'!closureCases	^#('| n |n := 1.^n + n''| i |i := 0.[i := i + 1. i <= 10] whileTrue.^i''[:c :s| | mn |mn := Compiler new		compile: (c sourceCodeAt: s)		in: c		notifying: nil		ifFail: [self halt].mn generate: #(0 0 0 0).{mn blockExtentsToTempsMap.  mn encoder schematicTempNames}]			value: ArrayLiteralTest			value: #testSymbols''inject: thisValue into: binaryBlock	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue''runBinaryConditionalJumps: assertPrintBar	"CogIA32CompilerTests new runBinaryConditionalJumps: false"	| mask reg1 reg2 reg3 |	mask := 1 << self processor bitsInWord - 1.	self concreteCompilerClass dataRegistersWithAccessorsDo:		[:n :get :set|		n = 0 ifTrue: [reg1 := get].		n = 1 ifTrue: [reg2 := set].		n = 2 ifTrue: [reg3 := set]].	#(	(JumpAbove > unsigned)			(JumpBelowOrEqual <= unsigned)		(JumpBelow < unsigned)			(JumpAboveOrEqual >= unsigned)		(JumpGreater > signed)			(JumpLessOrEqual <= signed)		(JumpLess < signed)				(JumpGreaterOrEqual >= signed)		(JumpZero = signed)				(JumpNonZero ~= signed)) do:		[:triple|		[:opName :relation :signednessOrResult| | opcode jumpNotTaken jumpTaken nop memory bogus |		self resetGen.		opcode := CogRTLOpcodes classPool at: opName.		self gen: CmpRR operand: 2 operand: 1.		jumpTaken := self gen: opcode.		self gen: MoveCqR operand: 0 operand: 0.		jumpNotTaken := self gen: Jump.		jumpTaken jmpTarget: (self gen: MoveCqR operand: 1 operand: 0).		jumpNotTaken jmpTarget: (nop := self gen: Nop).		memory := self generateInstructions.		bogus := false.		self pairs: (-2 to: 2)  do:			[:a :b| | taken |			self processor				reset;				perform: reg2 with: a signedIntToLong;				perform: reg3 with: b signedIntToLong.			[self processor singleStepIn: memory.			 self processor pc ~= nop address] whileTrue.			taken := (self processor perform: reg1) = 1.			assertPrintBar				ifTrue:					[self assert: taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b])]				ifFalse:					[Transcript						nextPutAll: reg2; nextPut: $(; print: a; nextPutAll: '') ''; nextPutAll: relation; space;						nextPutAll: reg3; nextPut: $(; print: b; nextPutAll: '') = '';						print: taken; cr; flush.					 taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b]) ifFalse:						[bogus := true]]].			 bogus ifTrue:				[self processor printRegistersOn: Transcript.				 Transcript show: (self processor disassembleInstructionAt: jumpTaken address In: memory); cr]]					valueWithArguments: triple]''mapFromBlockStartsIn: aMethod toTempVarsFrom: schematicTempNamesString constructor: aDecompilerConstructor	| map |	map := aMethod				mapFromBlockKeys: aMethod startpcsToBlockExtents keys asSortedCollection				toSchematicTemps: schematicTempNamesString.	map keysAndValuesDo:		[:startpc :tempNameTupleVector| | subMap tempVector numTemps |		subMap := Dictionary new.		"Find how many temp slots there are (direct & indirect temp vectors)		 and for each indirect temp vector find how big it is."		tempNameTupleVector do:			[:tuple|			tuple last isArray				ifTrue:					[subMap at: tuple last first put: tuple last last.					 numTemps := tuple last first]				ifFalse:					[numTemps := tuple last]].		"create the temp vector for this scope level."		tempVector := Array new: numTemps.		"fill it in with any indirect temp vectors"		subMap keysAndValuesDo:			[:index :size|			tempVector at: index put: (Array new: size)].		"fill it in with temp nodes."		tempNameTupleVector do:			[:tuple| | itv |			tuple last isArray				ifTrue:					[itv := tempVector at: tuple last first.					 itv at: tuple last last						put: (aDecompilerConstructor								codeTemp: tuple last last - 1								named: tuple first)]				ifFalse:					[tempVector						at: tuple last						put: (aDecompilerConstructor								codeTemp: tuple last - 1								named: tuple first)]].		"replace any indirect temp vectors with proper RemoteTempVectorNodes"		subMap keysAndValuesDo:			[:index :size|			tempVector				at: index				put: (aDecompilerConstructor						codeRemoteTemp: index						remoteTemps: (tempVector at: index))].		"and update the entry in the map"		map at: startpc put: tempVector].	^map' 'gnuifyFrom: inFileStream to: outFileStream"convert interp.c to use GNU features"	| inData beforeInterpret inInterpret inInterpretVars beforePrimitiveResponse inPrimitiveResponse |	inData := inFileStream upToEnd withSqueakLineEndings.	inFileStream close.	"print a header"	outFileStream		nextPutAll: ''/* This file has been post-processed for GNU C */'';		cr; cr; cr.	beforeInterpret := true.    "whether we are before the beginning of interpret()"	inInterpret := false.     "whether we are in the middle of interpret"	inInterpretVars := false.    "whether we are in the variables of interpret"	beforePrimitiveResponse := true.  "whether we are before the beginning of primitiveResponse()"	inPrimitiveResponse := false.   "whether we are inside of primitiveResponse"	''Gnuifying''		displayProgressAt: Sensor mousePoint		from: 1 to: (inData occurrencesOf: Character cr)		during:			[:bar | | lineNumber |			lineNumber := 0.			inData linesDo:				[ :inLine | | outLine extraOutLine caseLabel |				bar value: (lineNumber := lineNumber + 1).				outLine := inLine. 	"print out one line for each input line; by default, print out the line that was input, but some rules modify it"				extraOutLine := nil.   "occasionally print a second output line..."				beforeInterpret ifTrue: [					inLine = ''#include "sq.h"'' ifTrue: [						outLine := ''#include "sqGnu.h"'' ].					inLine = ''interpret(void) {'' ifTrue: [						"reached the beginning of interpret"						beforeInterpret := false.						inInterpret := true.						inInterpretVars := true ] ]				ifFalse: [				inInterpretVars ifTrue: [					(inLine findString: ''register struct foo * foo = &fum;'') > 0 ifTrue: [						outLine := ''register struct foo * foo FOO_REG = &fum;'' ].					(inLine findString: '' localIP;'') > 0 ifTrue: [						outLine := ''    char* localIP IP_REG;'' ].					(inLine findString: '' localFP;'') > 0 ifTrue: [						outLine := ''    char* localFP FP_REG;'' ].					(inLine findString: '' localSP;'') > 0 ifTrue: [						outLine := ''    char* localSP SP_REG;'' ].					(inLine findString: '' currentBytecode;'') > 0 ifTrue: [						outLine := ''    sqInt currentBytecode CB_REG;'' ].					inLine isEmpty ifTrue: [						"reached end of variables"						inInterpretVars := false.						outLine := ''    JUMP_TABLE;''.						extraOutLine := inLine ] ]				ifFalse: [				inInterpret ifTrue: [					"working inside interpret(); translate the switch statement"					(inLine beginsWith: ''		case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''		CASE('', caseLabel, '')'' ].					inLine = ''			break;'' ifTrue: [						outLine := ''			BREAK;'' ].					inLine = ''}'' ifTrue: [						"all finished with interpret()"						inInterpret := false ] ]				ifFalse: [				beforePrimitiveResponse ifTrue: [					(inLine beginsWith: ''primitiveResponse('') ifTrue: [						"into primitiveResponse we go"						beforePrimitiveResponse := false.						inPrimitiveResponse := true.						extraOutLine := ''    PRIM_TABLE;'' ] ]				ifFalse: [				inPrimitiveResponse ifTrue: [					inLine = ''	switch (primitiveIndex) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					inLine = ''	switch (GIV(primitiveIndex)) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					(inLine beginsWith: ''	case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''	CASE('', caseLabel, '')'' ].					inLine = ''}'' ifTrue: [						inPrimitiveResponse := false ] ]				] ] ] ].				outFileStream nextPutAll: outLine; cr.				extraOutLine ifNotNil: [					outFileStream nextPutAll: extraOutLine; cr ]]].	outFileStream close' )! !!Color methodsFor: 'other' stamp: 'jmv 4/18/2011 14:32'!display	"Show a swatch of this color tracking the cursor until the next mouseClick. "	"Color red display"	| f |	f _ Form extent: 40@20 depth: Display depth.	f fillColor: self.	Cursor blank showWhile:		[f follow: [Sensor mousePoint] while: [Sensor noButtonPressed]]! !!Color class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:33'!showHuesInteractively	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."	"Color showHuesInteractively"	| p s v |	[Sensor anyButtonPressed] whileFalse: [		p _ Sensor mousePoint.		s _ p x asFloat / 300.0.		v _ p y asFloat / 300.0.		self showColors: (self wheel: 12 saturation: s brightness: v)].	^ (s min: 1.0) @ (v min: 1.0)! !!Color class methodsFor: 'color from user' stamp: 'jmv 4/18/2011 14:42'!fromUser	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."	"Note: Since the color chart is cached, you may need to do 'ColorChart _ nil' after changing the oldColorPaletteForDepth:extent: method."	"Color fromUser"	| d startPt save tr oldColor c here s |	d _ Display depth.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart _ self oldColorPaletteForDepth: d extent: (2 * 144)@80].	Sensor mousePoint y < Display center y 		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]		ifFalse: [startPt _ 0@0].	save _ Form fromDisplay: (startPt extent: ColorChart extent).	ColorChart displayAt: startPt.	tr _ ColorChart extent - (50@19) corner: ColorChart extent.	tr _ tr translateBy: startPt.	oldColor _ nil.	[Sensor anyButtonPressed] whileFalse: [		c _ Display colorAt: (here _ Sensor mousePoint).		(tr containsPoint: here)			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]			ifTrue: [				c _ Color transparent.				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].		c = oldColor ifFalse: [			Display fillWhite: (20@61 + startPt extent: 135@19).			c isTransparent				ifTrue: [s _ 'transparent']				ifFalse: [s _ c shortPrintString.						s _ s copyFrom: 7 to: s size - 1].			s displayAt: 20@61 + startPt.			oldColor _ c]].	save displayAt: startPt.	Sensor waitNoButton.	^ c! !!Dictionary methodsFor: 'removing' stamp: 'jmv 4/18/2011 14:35'!unreferencedKeys	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"	^'Scanning for references . . .' 		displayProgressAt: Sensor mousePoint		from: 0		to: Smalltalk classNames size * 2		during: 			[:bar | | currentClass n associations referencedAssociations |			currentClass := nil.			n := 0.			associations := self associations asIdentitySet.			referencedAssociations := IdentitySet new: associations size.			Smalltalk allSelect:				[:m|				m methodClass ~~ currentClass ifTrue:					[currentClass := m methodClass.					 bar value: (n := n + 1)].				m literalsDo:					[:l|					(l isVariableBinding and: [associations includes: l]) ifTrue:						[referencedAssociations add: l]].				false].			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !!DisplayObject methodsFor: 'displaying-generic' stamp: 'jmv 4/18/2011 14:36'!followCursor	"Just show the Form following the mouse. 6/21/96 tk"	Cursor blank showWhile:		[self follow: [Sensor mousePoint] while: [Sensor noButtonPressed]]! !!EntryField2LW methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:43'!handlesMouseDown: evt	^ bounds containsPoint: evt position! !!EntryField2LW methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:43'!mouseDown: evt	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	evt hand newKeyboardFocus: self.	self handleInteraction: [		editor mouseDown: evt index: (self characterIndexAtPoint: evt position) ]! !!EntryField2LW methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:43'!mouseMove: evt	evt mouseButton1Pressed ifFalse: [^ self].	self handleInteraction: [		editor mouseMove: evt index: (self characterIndexAtPoint: evt position) ]! !!FWT methodsFor: 'testing' stamp: 'jmv 4/18/2011 14:36'!viewPhiAndPsi  "(FWT new nSamples: 256 nLevels: 6) viewPhiAndPsi"	"View the scaling function and mother wavelets for this transform"	| p |	Display fillWhite: (0@0 extent: 300@300).	Display border: (0@0 extent: 300@300) width: 2.	[Sensor anyButtonPressed] whileFalse:		["Move mouse around in the outer rectangle to explore"		p _ Sensor mousePoint min: 300@300.		self setAlpha: (p x - 150) / 150.0 * Float pi				beta: (p y - 150) / 150.0 * Float pi.		'alpha=', (alpha roundTo: 0.01) printString, '   ',			'beta=', (beta roundTo: 0.01) printString, '    ' displayAt: 50@5.		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size - 1) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@30 extent: nSamples@100).		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@170 extent: nSamples@100)].	Sensor waitNoButton! !!FilePackage methodsFor: 'reading' stamp: 'jmv 4/18/2011 14:36'!fileInFrom: aStream	| chgRec changes |	changes := (ChangeList new scanFile: aStream from: 0to: aStream size) changeList.	aStream close.	('Processing ', self packageName) 		displayProgressAt: Sensor mousePoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbolwith: chgRec.			].		].! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'jmv 4/18/2011 14:50'!request: queryString 	"Create an instance of me whose question is queryString. Invoke it 	centered at the cursor, and answer the string the user accepts. Answer 	the empty string if the user cancels."	"FillInTheBlank request: 'Your name?'"	^ self		request: queryString		initialAnswer: ''		centerAt: Sensor mousePoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'jmv 4/18/2011 14:50'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given 	initial answer. Invoke it centered at the given point, and answer the 	string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank 		request: 'What is your favorite color?' 		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: Sensor mousePoint! !!Form methodsFor: 'analyzing' stamp: 'jmv 4/18/2011 14:42'!cgForPixelValue: pv orNot: not	"Return the center of gravity for all pixels of value pv.	Note:  If orNot is true, then produce the center of gravity for all pixels	that are DIFFERENT from the supplied (background) value"	| pixCount weighted xAndY |	xAndY _ (Array with: (self xTallyPixelValue: pv orNot: not)					with: (self yTallyPixelValue: pv orNot: not)) collect:		[:profile |	"For both x and y profiles..."		pixCount _ 0.  weighted _ 0.		profile doWithIndex:			[:t :i | pixCount _ pixCount + t.			weighted _ weighted + (t*i)].		pixCount = 0  "Produce average of nPixels weighted by coordinate"			ifTrue: [0.0]			ifFalse: [weighted asFloat / pixCount asFloat - 1.0]].	^ xAndY first @ xAndY last"| f cg |[Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: (Sensor mousePoint extent: 50@50).	cg _ f cgForPixelValue: (Color black pixelValueForDepth: f depth) orNot: false.	f displayAt: 0@0.	Display fill: (cg extent: 2@2) fillColor: Color red].	ScheduledControllers restore"! !!Form methodsFor: 'analyzing' stamp: 'jmv 4/18/2011 14:36'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//self depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt current toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt current toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor mousePoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'analyzing' stamp: 'jmv 4/18/2011 14:36'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."	(BitBlt current toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		tallyMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor mousePoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'jmv 4/18/2011 14:36'!tallyPixelValues	"Return a Bitmap with tallies in it of the number of pixels in this Form that have each pixel value. Note that several Forms may be tallied into the same table by tallyPixelValuesPrimitive:into: with the same table. Also Forms of depth 16 or 32 can be tallied into a tables of size 512, 4096, or 32768 entries by making a direct call with a Bitmap of the given size."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor mousePoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'pixel access' stamp: 'jmv 4/18/2011 14:36'!colorAt: aPoint put: aColor	"Store a Color into the pixel at coordinate aPoint.  "	self pixelValueAt: aPoint put: (self pixelValueFor: aColor)."[Sensor anyButtonPressed] whileFalse:	[Display colorAt: Sensor mousePoint put: Color red]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jmv 4/18/2011 14:42'!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm _ self class extent: self extent depth: depth.	quad _ self boundingBox innerCorners.	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt current toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededFor: newForm);		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jmv 4/18/2011 14:42'!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: aRectangle by: scale smoothing: 1"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor mousePoint extent: 31@41) by: 5@3) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor mousePoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f magnify: f boundingBox by: 5@3.	(f2 shrink: f2 boundingBox by: 5@3) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jmv 4/18/2011 14:42'!magnify: aRectangle by: scale smoothing: cellSize        "Answer a Form created as a scaling of the receiver.        Scale may be a Float, and may be greater or less than 1.0."        | newForm |        newForm _ self blankCopyOf: aRectangle scaledBy: scale.        (WarpBlt current toForm: newForm)                sourceForm: self;                colorMap: (self colormapIfNeededFor: newForm);                cellSize: cellSize;  "installs a new colormap if cellSize > 1"                combinationRule: 3;                copyQuad: aRectangle innerCorners toRect: newForm boundingBox.        ^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:        [(Display magnify: (Sensor mousePoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:        [cp _ Sensor mousePoint.        (f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jmv 4/18/2011 14:36'!magnify: aRectangle to: extent smoothing: cellSize        "Answer a Form created as a scaling of the receiver.        Scale may be a Float, and may be greater or less than 1.0."        | newForm |        newForm _ Form extent: extent depth: depth.        (WarpBlt current toForm: newForm)                sourceForm: self;                colorMap: (self colormapIfNeededFor: newForm);                cellSize: cellSize;  "installs a new colormap if cellSize > 1"                combinationRule: 3;                copyQuad: aRectangle innerCorners toRect: newForm boundingBox.        ^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:        [(Display magnify: (Sensor mousePoint extent: 131@81) to: 300@200 smoothing: 2) display]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jmv 4/18/2011 14:36'!rotateBy: deg	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	^ self rotateBy: deg smoothing: 1" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))		rotateBy: (a _ a+5)) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'jmv 4/18/2011 14:36'!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt current toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededFor: rot);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"! !!Form class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:36'!exampleSketch	"This is a simple drawing algorithm to get a sketch on the display screen.	Draws whenever mouse button down.  Ends with option-click."	| aPen color |	aPen _ Pen new.	color _ 0.	[Sensor mouseButton2Pressed]		whileFalse:		[aPen place: Sensor mousePoint; color: (color _ color + 1).		[Sensor mouseButton1Pressed]			whileTrue: [aPen goto: Sensor mousePoint]].	Sensor waitNoButton.	"Form exampleSketch"! !!Form class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:37'!makeStar  "See the similar example in OpaqueForm"	| sampleForm pen |	sampleForm _ Form extent: 50@50.  "Make a form"	pen _ Pen newOnForm: sampleForm.	pen place: 24@50; turn: 18.		"Draw a 5-pointed star on it."	1 to: 5 do: [:i | pen go: 19; turn: 72; go: 19; turn: -144].	^ sampleForm"Form makeStar follow: [Sensor mousePoint]				while: [Sensor noButtonPressed]"! !!Form class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:37'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors _ Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade _ Form extent: diam@diam offset: (diam//-2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam//2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x*diam//5) displayOn: facade			at: (diam*2//5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball _ Form dotOfSize: diam.	color _ 8.	[ true ] whileTrue:		[port _ BitBlt current toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue _ OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20@-20].		Sensor waitButton.		Sensor mouseButton2Pressed ifTrue: [^ self].		filter _ Sensor mousePoint.		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"		colr2 _ colr alphaMixed: 0.3 with: Color white.		[Sensor mouseButton1Pressed or: [queue size > 0]] whileTrue:			[filter _ filter * 4 + Sensor mousePoint // 5.			point _ Sensor mouseButton1Pressed				ifTrue: [filter] ifFalse: [-20@-20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q _ queue removeFirst) ifNil: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor mouseButton1Pressed ifTrue: [queue addLast: point]]].! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 4/18/2011 14:44'!mousePoint: aPoint 	"Set aPoint to be the current cursor location."	^self primCursorLocPut: aPoint! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 4/18/2011 14:52'!waitButton	"Wait for the user to press any mouse button and then answer with the 	current location of the cursor."	| delay |	delay _ Delay forMilliseconds: 50.	[self anyButtonPressed] whileFalse: [ delay wait ].	^self mousePoint! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 4/18/2011 14:52'!waitButtonOrKeyboard	"Wait for the user to press either any mouse button or any key. 	Answer the current cursor location or nil if a keypress occured."	| delay |	delay := Delay forMilliseconds: 50.	[self anyButtonPressed]		whileFalse: [			delay wait.			self keyboardPressed				ifTrue: [^ nil]].	^ self mousePoint! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 4/18/2011 14:52'!waitNoButton	"Wait for the user to release any mouse button and then answer the current location of the cursor."	| delay |	delay _ Delay forMilliseconds: 50.	[self anyButtonPressed] whileTrue: [ delay wait].	^self mousePoint! !!MessageSet methodsFor: 'filtering' stamp: 'jmv 4/18/2011 14:37'!filterToMessagesThat	"Allow the user to type in a block which will be"	| reply |	reply _ FillInTheBlank		multiLineRequest: 'Type your block here'		centerAt: Sensor mousePoint		initialAnswer: '[:aClass :aSelector |		]'		answerHeight: 200.	reply isEmptyOrNil ifTrue: [^ self].	self filterFrom: (Smalltalk actualCompilerClass evaluate: reply)! !!Morph methodsFor: 'halos and balloon help' stamp: 'FernandoOlivero 4/16/2011 01:46'!editBalloonHelpContent: aString	| reply |	reply _ FillInTheBlank		multiLineRequest: 'Edit the balloon help text for ' , self externalName		centerAt: self world activeHand position		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])		answerHeight: 200.	reply ifNil: [^ self].  "User cancelled out of the dialog"	(reply isEmpty or: [reply asString = self noHelpString])		ifTrue: [self setBalloonText: nil]		ifFalse: [self setBalloonText: reply]! !!BareTextMorph methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:41'!handlesMouseDown: evt	^ self innerBounds containsPoint: evt position.! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:42'!mouseDown: evt	| localPt |	localPt _ evt position - self topLeft.	self deleteAllBalloons.	clickedTranslucency _ TransparentBox containsPoint: localPt.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt)			ifTrue: [^ evt hand grabMorph: self].	].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	self inhibitDragging ifFalse: [self comeToFront].	sourceHand _ evt hand.	self startStepping.! !!ColorPickerMorph methodsFor: 'menu' stamp: 'FernandoOlivero 4/16/2011 01:43'!pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt oldCursor |	aHand _ aMorph isNil		ifTrue: [self world activeHand] 		ifFalse: [ aMorph activeHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullDisplayBounds.	self owner ifNil: [^ self].	oldCursor _ Sensor currentCursor.	ColorPickerMorph eyeDropperCursor show.	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	localPt _World activeHand position - self topLeft.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt) ifTrue:			["Click or drag the drag-dot means to anchor as a modeless picker"			^ self anchorAndRunModeless: aHand].	].	(clickedTranslucency _ TransparentBox containsPoint: localPt)		ifTrue: [selectedColor _ originalColor].	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	aHand newMouseFocus: nil;		flushEvents.	oldCursor show.	self delete.		  ! !!ColorPickerMorph methodsFor: 'other' stamp: 'FernandoOlivero 4/16/2011 01:42'!indicateColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	self pickColorAt: (pt _ World activeHand position ).	isModal ifTrue:		[self world activeHand position: pt.		self world displayWorldSafely; runStepMethods].	^ selectedColor	! !!ColorPickerMorph methodsFor: 'other' stamp: 'FernandoOlivero 4/16/2011 01:43'!trackColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	selectedColor _ originalColor.	self trackColorAt: (pt _ World activeHand position ).	isModal ifTrue:		[self world activeHand position: pt.		self world displayWorldSafely; runStepMethods.		self modalBalloonHelpAtPoint: pt].	^ selectedColor	! !!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 4/18/2011 14:34'!anchorAndRunModeless: aHand	"If user clicks on the drag-dot of a modal picker,	anchor it, and change to modeless operation."	self initializeModal: false; originalColor: originalColor.  "reset as modeless"	aHand flushEvents.  "Drop any events gathered during modal loop"	aHand position: Sensor mousePoint; grabMorph: self.  "Slip into drag operation"! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'FernandoOlivero 4/16/2011 01:44'!request: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph request: 'What is your favorite color?'"	^ self		request: queryString		initialAnswer: ''		centerAt: World activeHand position! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'FernandoOlivero 4/16/2011 01:44'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph		request: 'What is your favorite color?'		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: World activeHand position! !!HaloMorph methodsFor: 'private' stamp: 'jmv 4/18/2011 14:51'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent |self revisar.	evt hand obtainHalo: self."Como podria andar el grow de un morph embebido en otro? andara ahora?"newExtent _ evt position - positionOffset - target bounds topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].	target extent: newExtent.	growHandle position: evt position - (growHandle extent // 2).	self layoutChanged! !!HaloMorph methodsFor: 'private' stamp: 'FernandoOlivero 4/16/2011 01:44'!doRecolor: evt with: aHandle	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"	evt hand obtainHalo: self.	(aHandle containsPoint: evt position)		ifFalse:  "only do it if mouse still in handle on mouse up"			[self delete.			target addHalo: evt]		ifTrue:			[innerTarget changeColor]! !!HaloMorph methodsFor: 'private' stamp: 'FernandoOlivero 4/18/2011 00:19'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |self revisar.	evt hand obtainHalo: self.	degrees _ (evt position - (target externalizePositionFromOwner: target referencePosition to: target world)) degrees.	degrees _ degrees - angleOffset degrees.	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	self removeAllHandlesBut: rotHandle.	target rotationDegrees: degrees.	rotHandle position: evt position - (rotHandle extent // 2).	self layoutChanged! !!HaloMorph methodsFor: 'private' stamp: 'FernandoOlivero 4/16/2011 01:44'!maybeCollapse: evt with: collapseHandle 	"Ask hand to collapse my target if mouse comes up in it."	evt hand obtainHalo: self.	self delete.	(collapseHandle containsPoint: evt position) 		ifFalse: 			[			target addHalo: evt]		ifTrue: 			[			target collapse]! !!HaloMorph methodsFor: 'private' stamp: 'FernandoOlivero 4/16/2011 01:44'!maybeDismiss: evt with: dismissHandle	"Ask hand to dismiss my target if mouse comes up in it."	evt hand obtainHalo: self.	(dismissHandle containsPoint: evt position)		ifFalse: [			self delete.			target addHalo: evt]		ifTrue: [			target resistsRemoval ifTrue:				[(PopUpMenu					confirm: 'Really throw this away'					trueChoice: 'Yes'					falseChoice: 'Um, no, let me reconsider') ifFalse: [^ self]].			self delete.			target dismissViaHalo]! !!HaloMorph methodsFor: 'private' stamp: 'FernandoOlivero 4/16/2011 01:44'!setDismissColor: evt with: dismissHandle	"Called on mouseStillDown in the dismiss handle; set the color appropriately."	| colorToUse |	evt hand obtainHalo: self.	colorToUse _  (dismissHandle containsPoint: evt position)		ifFalse:			[Color red muchLighter]		ifTrue:			[Color lightGray].	dismissHandle color: colorToUse! !!HaloMorph methodsFor: 'private' stamp: 'FernandoOlivero 4/16/2011 01:44'!startGrow: evt with: growHandle	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	| botRt |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.	botRt _ target externalizePositionFromOwner: target bounds bottomRight to: owner.	positionOffset _ (self world viewBox containsPoint: botRt)		ifTrue: [evt position - botRt]		ifFalse: [0@0]! !!HaloMorph methodsFor: 'private' stamp: 'FernandoOlivero 4/16/2011 01:44'!startRot: evt with: rotHandle	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"	self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.	growingOrRotating _ true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset _ evt position - (target externalizePositionFromOwner: target referencePosition to: target world).	angleOffset _ Point			r: angleOffset r			degrees: angleOffset degrees - target rotationDegrees! !!HandMorph methodsFor: 'focus handling' stamp: 'FernandoOlivero 4/16/2011 01:44'!newMouseFocus: aMorph event: event 	aMorph ifNotNil: [ 		targetOffset := event position - aMorph position].	^self newMouseFocus: aMorph! !!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 4/18/2011 14:57'!handPoint	^ hand position adhereTo: owner bounds! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 4/18/2011 14:37'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| w titleString |	titleString _ titleMorph submorphs first.	self visible: false.	w _ ActiveWorld.	aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		titleString contents: string.		titleMorph width: titleString width + 8.		self position: w activeHand position.		self adjustSubmorphsLayout.		self redrawNeeded.		w displayWorld		 "show myself"	]. 	self delete.	w displayWorld! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'FernandoOlivero 4/16/2011 01:46'!dispatchDropEvent: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."	| inside localEvt |	"Try to get out quickly"	(aMorph fullBounds containsPoint: anEvent position)		ifFalse: [ ^#rejected ].	"Give aMorph a chance to repel the dropping morph"	aMorph rejectDropEvent: anEvent.	anEvent wasHandled ifTrue:[^self].	"Go looking if any of our submorphs wants it"	inside _ false.	aMorph submorphsDo: [ :eachChild |		inside ifFalse: [			localEvt _ anEvent internalizedToOwnerOf: eachChild from: aMorph.			(eachChild processEvent: localEvt using: self) == #rejected ifFalse: [				localEvt wasHandled ifTrue: [ ^anEvent wasHandled: true ]. "done"				inside _ true			]]].	inside ifFalse: [ inside _ aMorph containsPoint: anEvent position event: anEvent ].	inside ifTrue: [ ^aMorph handleEvent: anEvent ].	^#rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'FernandoOlivero 4/16/2011 01:46'!dispatchMouseDown: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. Default rules:	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event."	| globalPt localEvt handler inside lastHandler |	"Try to get out quickly"	globalPt _ anEvent position.	(aMorph fullBounds containsPoint: globalPt) ifFalse: [ ^#rejected ].	"Install the prospective handler for the receiver"	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"	handler _ aMorph handlerForMouseDown: anEvent.	handler ifNotNil: [ anEvent handler: handler ].	"Now give our submorphs a chance to handle the event"	inside _ false.	aMorph submorphsDo: [ :eachChild |		inside ifFalse: [			localEvt _ anEvent internalizedToOwnerOf: eachChild from: aMorph.			(eachChild processEvent: localEvt using: self) == #rejected ifFalse: [				"Some child did contain the point so we're part of the top-most chain."				inside _ true.				localEvt wasHandled ifTrue: [ anEvent copyHandlerState: localEvt ].			]]].	(inside or: [ aMorph containsPoint: anEvent position event: anEvent ]) ifTrue:[		"Receiver is in the top-most unlocked, visible chain."		handler ifNotNil: [ handler handleEvent: anEvent ].		"Note: Re-installing the handler is not really necessary but good style."		anEvent handler: lastHandler.		^self ].	"Mouse was not on receiver nor any of its children"	anEvent handler: lastHandler.	^#rejected! !!MouseEvent methodsFor: 'accessing' stamp: 'FernandoOlivero 4/16/2011 01:51'!position	"Answer the location of the cursor's hotspot when this event occured."	^ position! !!MouseEvent methodsFor: 'printing' stamp: 'FernandoOlivero 4/16/2011 01:46'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self position printString; space.	aStream nextPutAll: type; space.	aStream nextPutAll: self modifierString.	aStream nextPutAll: self buttonString.	aStream nextPutAll: timeStamp printString.	aStream nextPut: $].! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:46'!handlesMouseDown: evt	^ self innerBounds containsPoint: evt position! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:46'!mouseDown: evt	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	evt hand newKeyboardFocus: self.	self handleInteraction: [		editor mouseDown: evt index: (self characterIndexAtPoint: evt position) ]! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:46'!mouseMove: evt	evt mouseButton1Pressed ifFalse: [^ self].	self handleInteraction: [		editor mouseMove: evt index: (self characterIndexAtPoint: evt position) ]! !!PasteUpMorph methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:46'!morphToGrab: event	"Return the morph to grab from a mouse down event. If none, return nil."	self submorphsDo:[:m|		((m rejectsEvent: event) not and:[m fullContainsPoint: event position]) ifTrue:[^m].	].	^nil! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jmv 4/18/2011 14:38'!testMouseTracking	"A very simple example of drawing using the mouse. Compare the tracking speed of this example with that of testTabletTracking. Mouse down to draw a stroke, shift-mouse to exit." 	"Pen testMouseTracking"	| pen p |	pen _ Pen newOnForm: Display.	pen roundNib: 8.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ Sensor mousePoint.		     Sensor anyButtonPressed				ifTrue: [pen goto: p]				ifFalse: [					pen color: Color random.					pen place: p]]].! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'FernandoOlivero 4/16/2011 01:47'!mouseUp: evt	isPressed _ false.	mouseIsOver _ false.	(actWhen == #buttonUp and: [self containsPoint: evt position])		ifTrue: [ self performAction ].	self redrawNeeded! !!Point methodsFor: 'point functions' stamp: 'jmv 4/18/2011 14:38'!nearestPointAlongLineFrom: p1 to: p2	"Note this will give points beyond the endpoints.	Streamlined by Gerardo Richarte 11/3/97"	| x21 y21 t x1 y1 |	p1 x = p2 x ifTrue: [^ p1 x @ y].	p1 y = p2 y ifTrue: [^ x @ p1 y].	x1 _ p1 x asFloat.	y1 _ p1 y asFloat.	x21 _ p2 x asFloat - x1.	y21 _ p2 y asFloat - y1.	t _ ((y asFloat - y1 / x21) + (x asFloat - x1 / y21))			/ ((x21 / y21) + (y21 / x21)).	^ (x1 + (t * x21)) @ (y1 + (t * y21))"	| old new |	Pen new place: 200@100; goto: (old _ 500@300).	Display reverse: (old extent: 10@10).	[Sensor anyButtonPressed] whileFalse:		[(new _ (Sensor mousePoint nearestPointAlongLineFrom: 200@100 to: 500@300) )			= old ifFalse:				[Display reverse: (old extent: 10@10).				Display reverse: ((old _ new) extent: 10@10)]]"! !!Point methodsFor: 'point functions' stamp: 'jmv 4/18/2011 14:38'!quadrantOf: otherPoint	"Return 1..4 indicating relative direction to otherPoint.	1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"	^ x <= otherPoint x		ifTrue: [y < otherPoint y ifTrue: [1] ifFalse: [4]]		ifFalse: [y <= otherPoint y ifTrue: [2] ifFalse: [3]]"[Sensor anyButtonPressed] whileFalse:	[(Display boundingBox center quadrantOf: Sensor mousePoint) printString displayAt: 0@0]"! !!Point class methodsFor: 'instance creation' stamp: 'jmv 4/18/2011 14:38'!fromUser	Sensor waitNoButton.	Cursor crossHair show.	Sensor waitButton.	Cursor normal show.	^ Sensor mousePoint"Point fromUser"! !!Point class methodsFor: 'instance creation' stamp: 'jmv 4/18/2011 14:38'!fromUserWithCursor: aCursor	Sensor waitNoButton .	aCursor showWhile: [ Sensor waitButton ] .	^ Sensor mousePoint"Point fromUserWithCursor: Cursor target""Point fromUserWithCursor: Cursor crossHair"! !!PolygonMorph methodsFor: 'editing' stamp: 'jmv 4/18/2011 14:53'!dragVertex: ix event: evt fromHandle: handle	| p |	p _ evt position.	handle referencePosition: p.	self verticesAt: ix put: p.! !!PolygonMorph methodsFor: 'editing' stamp: 'FernandoOlivero 4/16/2011 01:47'!mouseDown: evt	^ evt shiftPressed		ifTrue: [((owner isKindOf: PolygonMorph) and: [owner includesHandle: self])					ifTrue: ["Prevent insertion handles from getting edited"							^ super mouseDown: evt].				self toggleHandles.				handles ifNil: [^ self].				vertices withIndexDo:  "Check for click-to-drag at handle site"					[:vertPt :vertIndex |					((handles at: vertIndex*2-1 ifAbsent: [ ^self ]) containsPoint: evt position) ifTrue:						["If clicked near a vertex, jump into drag-vertex action"						evt hand newMouseFocus: (handles at: vertIndex*2-1)]]]		ifFalse: [super mouseDown: evt]! !!PolygonMorph methodsFor: 'editing' stamp: 'FernandoOlivero 4/16/2011 01:47'!newVertex: ix event: evt fromHandle: handle	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	(self hasProperty: #noNewVertices) ifFalse:		[pt _ evt position.		self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).		evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1)]! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'jmv 4/18/2011 14:39'!fromHand: hand	"Let the user draw a polygon, clicking at each vertex, and ending		by clicking within 5 of the first point..."	| p1 poly oldVerts pN opposite |	Cursor crossHair showWhile:		[[Sensor anyButtonPressed] whileFalse:			[self currentWorld displayWorldSafely; runStepMethods].		p1 _ Sensor mousePoint].	opposite _ (Display colorAt: p1) negated.	opposite = Color transparent ifTrue: [opposite _ Color red].	(poly _ LineMorph from: p1 to: p1 color: opposite width: 2) openInWorld.	oldVerts _ {p1}.	self currentWorld displayWorldSafely; runStepMethods.	[true] whileTrue:		[[Sensor anyButtonPressed] whileTrue:			[pN _ Sensor mousePoint.			poly setVertices: (oldVerts copyWith: pN).			self currentWorld displayWorldSafely; runStepMethods].		(oldVerts size > 1 and: [(pN dist: p1) < 5]) ifTrue:			[hand position: Sensor mousePoint.  "Done -- update hand pos"			^ (poly setVertices: (poly vertices copyWith: p1)) delete].		oldVerts _ poly vertices.		[Sensor anyButtonPressed] whileFalse:			[pN _ Sensor mousePoint.			poly setVertices: (oldVerts copyWith: pN).			self currentWorld displayWorldSafely; runStepMethods]].! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 4/18/2011 14:54'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: Sensor mousePoint! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'FernandoOlivero 4/16/2011 01:48'!startUpWithoutKeyboard	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"		^ self startUpWithCaption: nil at: self world activeHand position allowKeyboard: false! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 4/18/2011 14:39'!fileInAnnouncing: announcement 	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |	announcement 		displayProgressAt: Sensor mousePoint		from: 0		to: self size		during: 			[:bar | 			[self atEnd] whileFalse: 					[bar value: self position.					self skipSeparators.										[val := (self peekFor: $!!) 								ifTrue: [									chunk := self nextChunk.									(chunk beginsWith: 'classDefinition: ')										ifFalse: [(Smalltalk actualCompilerClass evaluate: chunk logged: false) scanFrom: self]]								ifFalse: [									chunk := self nextChunk.									self checkForPreamble: chunk.									Smalltalk actualCompilerClass evaluate: chunk logged: true]] 							on: InMidstOfFileinNotification							do: [:ex | ex resume: true].					self skipStyleChunk].			self close].	"Note:  The main purpose of this banner is to flush the changes file."	Smalltalk logChange: '----End fileIn of ' , self name , '----'.	self flag: #ThisMethodShouldNotBeThere.	"sd"	Smalltalk forgetDoIts.	^val! !!PositionableStream methodsFor: '*packageinfo-base' stamp: 'jmv 4/18/2011 14:39'!untilEnd: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor mousePoint		from: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'jmv 4/18/2011 14:39'!testInnermost	"test the progress code WITHOUT special handling"	^'Now here''s some Real Progress'		displayProgressAt: Sensor mousePoint		from: 0 		to: 10		during: [ :bar |			1 to: 10 do: [ :x | 				bar value: x. (Delay forMilliseconds: 500) wait.				x = 5 ifTrue: [1/0].	"just to make life interesting"			].			'done'		].! !!ReadStream methodsFor: '*packageinfo-base' stamp: 'jmv 4/18/2011 14:39'!untilEnd: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor mousePoint		from: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'jmv 4/18/2011 14:37'!saveContents: fullFileName	"Save the contents of a gzipped file"	| zipped buffer unzipped newName |	newName _ fullFileName copyUpToLast: FileDirectory extensionDelimiter.	unzipped _ FileStream newFileNamed: newName.	unzipped binary.	zipped _ GZipReadStream on: (FileStream readOnlyFileNamed: fullFileName).	buffer _ ByteArray new: 50000.	'Extracting ' , fullFileName		displayProgressAt: Sensor mousePoint		from: 0		to: zipped sourceStream size		during: 			[:bar | 			[zipped atEnd]				whileFalse: 					[bar value: zipped sourceStream position.					unzipped nextPutAll: (zipped nextInto: buffer)].			zipped close.			unzipped close].	^ newName! !!ReadWriteStream methodsFor: '*packageinfo' stamp: 'jmv 4/18/2011 14:39'!untilEnd: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor mousePoint		from: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!Rectangle class methodsFor: 'instance creation' stamp: 'jmv 4/18/2011 14:39'!fromUser	"Answer a Rectangle that is determined by having the user 	designate the top left and bottom right corners."	| originRect |	originRect _ Cursor origin showWhile: 		[(Sensor mousePoint extent: 0@0) newRectFrom:			[:f | Sensor mousePoint  extent: 0@0]].	^ Cursor corner showWhile:		[originRect newRectFrom:			[:f | f origin corner: Sensor mousePoint ]]! !!Rectangle class methodsFor: 'instance creation' stamp: 'jmv 4/18/2011 14:40'!originFromUser: extentPoint	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint."	^ Cursor origin showWhile: 		[(Sensor mousePoint extent: extentPoint) newRectFrom:			[:f | Sensor mousePoint extent: extentPoint]].! !!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 4/18/2011 14:42'!statisticsOfRefs	"Analyze the information in references, the objects being written out"	| parents n kids nm ownerBags tallies owners objParent |	parents _ IdentityDictionary new: references size * 2.	n _ 0.	'Finding Owners...'	displayProgressAt: Sensor mousePoint	from: 0 to: references size	during: [:bar |	references keysDo:		[:parent | bar value: (n _ n+1).		kids _ parent class isFixed			ifTrue: [(1 to: parent class instSize) collect: [:i | parentinstVarAt: i]]			ifFalse: [parent class isBits ifTrue: [Array new]					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt:i]]].		(kids select: [:x | references includesKey: x])			do: [:child | parents at: child put: parent]]].	ownerBags _ Dictionary new.	tallies _ Bag new.	n _ 0.	'Tallying Owners...'	displayProgressAt: Sensor mousePoint	from: 0 to: references size	during: [:bar |	references keysDo:  "For each class of obj, tally a bag of ownerclasses"		[:obj | bar value: (n _ n+1).		nm _ obj class name.		tallies add: nm.		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [			owners add: objParent class name]]].	^ String streamContents: [ :strm | 		tallies sortedCounts do: [ :assn |			n _ assn key.  nm _ assn value.			owners _ ownerBags at: nm.			strm cr; nextPutAll: nm; space; print: n.			owners size > 0 ifTrue: [				strm cr; tab; print: owners sortedCounts]]]! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/18/2011 14:54'!setNextDirectionFromEvent: event	nextPageDirection _ bounds isWide ifTrue: [		event position x >= slider referencePosition x	]	ifFalse: [		event position y >= slider referencePosition y	]! !!SequenceableCollection methodsFor: '*packageinfo-base' stamp: 'jmv 4/18/2011 14:40'!do: aBlock displayingProgress: aString	aString		displayProgressAt: Sensor mousePoint		from: 0 to: self size		during:			[:bar |			self withIndexDo:				[:each :i |				bar value: i.				aBlock value: each]]! !!Set class methodsFor: 'initialization' stamp: 'jmv 4/18/2011 14:40'!quickRehashAllSets  "Set rehashAllSets"	| insts |	self withAllSubclassesDo:		[:c |			insts _ c allInstances.			(insts isEmpty or: [c = MethodDictionary]) ifFalse:			['Rehashing instances of ' , c name				displayProgressAt: Sensor mousePoint				from: 1 to: insts size				during: [:bar | 1 to: insts size do: [:x | bar value: x. (insts at: x) rehash]]			]		]! !!Set class methodsFor: 'initialization' stamp: 'jmv 4/18/2011 14:40'!rehashAllSets  "Set rehashAllSets"	| insts |	self withAllSubclassesDo:		[:c | insts _ c allInstances.		insts isEmpty ifFalse:		['Rehashing instances of ' , c name			displayProgressAt: Sensor mousePoint			from: 1 to: insts size			during: [:bar |			1 to: insts size do:				[:x | bar value: x.				(insts at: x) rehash]]]]! !!SmartRefStream methodsFor: 'read write' stamp: 'jmv 4/18/2011 14:40'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall	ifNil: [		topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor mousePoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		byteStream binary.		'Writing an object file' displayProgressAt: Sensor mousePoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		byteStream padToEndWith: $ .	"really want to truncate file, but can't"		topCall _ progressBar _ nil]	"reset it"	ifNotNil: [		super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'jmv 4/18/2011 14:40'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall		ifNil: [			topCall _ anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor mousePoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			'Writing an object file' displayProgressAt: Sensor mousePoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ progressBar _ nil]	"reset it"		ifNotNil: [			super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 4/18/2011 14:40'!printSpaceAnalysis: threshold on: aStream	"SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')"	"sd-This method should be rewrote to be more coherent within the rest of the class 	ie using preAllocate and spaceForInstanceOf:"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	results _ OrderedCollection new: Smalltalk classNames size.'Taking statistics...'	displayProgressAt: Sensor mousePoint	from: 0 to: Smalltalk classNames size	during: [:bar |	Smalltalk allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x basicSize*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	aStream timeStamp.	aStream		nextPutAll: ('Class' padded: #right to: 30 with: $ );		nextPutAll: ('code space' padded: #left to: 12 with: $ );		nextPutAll: ('# instances' padded: #left to: 12 with: $ );		nextPutAll: ('inst space' padded: #left to: 12 with: $ );		nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue: [		"If inst count threshold > 0, then sort by space"		results _ (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].	results do: [:s |		aStream			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).		percent _ s spaceForInstances*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue: [			aStream nextPutAll: (percent printString padded: #left to: 8 with: $ )].		aStream cr].	aStream		cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ );		nextPutAll: ((totalPercent roundTo: 0.1) printString padded: #left to: 8 with: $ ).! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 4/18/2011 14:40'!compressFile	"Write a new file that has the data in me compressed in GZip format."	| zipped buffer |	self readOnly; binary.	zipped _ self directory newFileNamed: (self name, FileDirectory dot, 'gz').	zipped binary; setFileTypeToObject.		"Type and Creator not to be text, so can be enclosed in an email"	zipped _ GZipWriteStream on: zipped.	buffer _ ByteArray new: 50000.	'Compressing ', self fullName displayProgressAt: Sensor mousePoint		from: 0 to: self size		during: [:bar |			[self atEnd] whileFalse: [				bar value: self position.				zipped nextPutAll: (self nextInto: buffer)].			zipped close.			self close].	^zipped! !!StarMorph methodsFor: 'editing' stamp: 'jmv 4/18/2011 14:54'!dragVertex: label event: evt fromHandle: handle	| ext oldR pt center |	label == #center ifTrue:		[self position: self position + (evt position - handle referencePosition)].	label == #outside ifTrue:		[center _ handles first referencePosition.		pt _ center - evt position.		ext _ pt r.		oldR _ ext.		vertices _ (0 to: 359 by: (360//vertices size)) collect:			[:angle |			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])					degrees: angle + pt degrees)				+ center].		handle align: handle referencePosition with: evt position].	self computeBounds.! !!StreamingMonoSound methodsFor: 'converting' stamp: 'jmv 4/18/2011 14:40'!storeSunAudioOn: aBinaryStream compressionType: compressionName	"Store myself on the given stream as a monophonic sound compressed with the given type of compression. The sampling rate is reduced to 22050 samples/second if it is higher."	| fmt inBufSize samplesPerFrame outCodec compressed outSamplingRate audioWriter samplesRemaining inBuf outBuf counts byteCount |	self pause; reset.  "stop playing and return to beginning"	fmt _ SunAudioFileWriter formatCodeForCompressionType: compressionName.	inBufSize _ 64000.	samplesPerFrame _ 1.	outCodec _ SunAudioFileWriter codecForFormatCode: fmt.	outCodec ifNotNil: [		samplesPerFrame _ outCodec samplesPerFrame.		inBufSize _ inBufSize roundUpTo: (2 * samplesPerFrame).		compressed _ ByteArray new:			(inBufSize // samplesPerFrame) * outCodec bytesPerEncodedFrame].	outSamplingRate _ streamSamplingRate.	streamSamplingRate > 22050 ifTrue: [		streamSamplingRate = 44100 ifFalse: [self error: 'unexpected MP3 sampling rate'].		outSamplingRate _ 22050].	"write audio header"	audioWriter _ SunAudioFileWriter onStream: aBinaryStream.	audioWriter writeHeaderSamplingRate: outSamplingRate format: fmt.	"convert and write sound data"	'Storing audio...' displayProgressAt: Sensor mousePoint		from: 0 to: totalSamples during: [:bar |			samplesRemaining _ totalSamples.			[samplesRemaining > 0] whileTrue: [				bar value: totalSamples - samplesRemaining.				self loadBuffersForSampleCount: (inBufSize min: samplesRemaining).				inBuf _ mixer sounds first samples.				outSamplingRate < streamSamplingRate					ifTrue: [outBuf _ inBuf downSampledLowPassFiltering: true]					ifFalse: [outBuf _ inBuf].				outCodec					ifNil: [audioWriter appendSamples: outBuf]					ifNotNil: [						counts _ outCodec							encodeFrames: (outBuf size // samplesPerFrame)							from: outBuf at: 1							into: compressed at: 1.						byteCount _ counts last.						byteCount = compressed size							ifTrue: [audioWriter appendBytes: compressed]							ifFalse: [audioWriter appendBytes: (compressed copyFrom: 1 to: byteCount)]].				samplesRemaining _ samplesRemaining - inBuf monoSampleCount]].	"update audio header"	audioWriter updateHeaderDataSize.! !!String methodsFor: 'displaying' stamp: 'jmv 4/18/2011 14:40'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)['Now here''s some Real Progress'	displayProgressAt: Sensor mousePoint	from: 0 to: 100	during: [:bar |	1 to: 100 do: [:x | bar value: x.			(Delay forMilliseconds: 100) wait]].] fork	['Now here''s some Real Progress'	displayProgressAt: Sensor mousePoint	from: 0 to: 10	during: [:bar |	1 to: 30 do: [:x | bar value: x \\ 11.			(Delay forMilliseconds: 100) wait]]] fork'Now here''s some Real Progress'	displayProgressAt: Sensor mousePoint	from: 0 to: 10	during: [:bar |	1 to: 30 do: [:x | bar value: nil.			(Delay forMilliseconds: 200) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range.The use of ProgressInitiationException allows for avoiding actualprogress display, by catching the exception."	^ProgressInitiationException 		display: self		at: aPoint 		from: minVal 		to: maxVal 		during: workBlock! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!condenseChanges		"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges"	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor mousePoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f.			class putClassCommentToCondensedChangesFile: f.			class class moveChangesTo: f]].	LastQuitLogPosition _ f position.	f close.	CompiledMethod allInstancesDo:		[ : e | 		e isInstalled ifFalse: [ e destroySourcePointer ] ].	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (StandardFileStream oldFileNamed: oldChanges name).	self inform: 'Changes file has been rewritten!!Check that all is well, and then save/quit. Otherwise, remove new changes,replace it with the former one, andexit without saving the image. '! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!condenseSources		"Move all the changes onto a compacted sources file."	"Smalltalk condenseSources"	| f classCount dir newVersionString newSourcesName |	dir _ FileDirectory default.	newVersionString _ FillInTheBlank request: 'Please designate the versionfor the new source code file...' initialAnswer: SourceFileVersionString.	newVersionString ifNil: [^ self].	newVersionString = SourceFileVersionString ifTrue:		[^ self error: 'The new source file must not be the same as the old.'].	SourceFileVersionString _ newVersionString.	"Write all sources with fileIndex 1"	newSourcesName _ self newSourcesName.	f _ FileStream newFileNamed: newSourcesName.	f timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor mousePoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f close.	CompiledMethod allInstancesDo:		[ : e | 		e isInstalled ifFalse: [ e destroySourcePointer ] ].	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self localChangesName		toBe: self localChangesName , '.old'.	(FileStream newFileNamed: self localChangesName)		timeStamp; close.	LastQuitLogPosition _ 0.	self setMacFileInfoOn: self localChangesName.	self setMacFileInfoOn: newSourcesName.	self openSourceFiles.	self inform: 'Source files have been rewritten!! Check that all is well, and then save/quit. Otherwise, remove new sources/changes,replace them with the former ones, andexit without saving the image. '! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!macroBenchmark1    "Smalltalk macroBenchmark1"	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |	classes _ Smalltalk allClasses select: [:c | c name < 'B3'].	badOnes _ OrderedCollection new.'Decompiling and recompiling...'displayProgressAt: Sensor mousePointfrom: 0 to: (classes detectSum: [:c | c selectors size])during: [:bar | n _ 0.	classes do:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | bar value: (n _ n+1).			oldMethod _ cls compiledMethodAt: selector.			oldCodeString _ (cls decompilerClass new								decompile: selector in: cls method: oldMethod)							decompileString.			methodNode _ cls compilerClass new						compile: oldCodeString						in: cls notifying: nil ifFail: nil.			newMethod _ methodNode generate: #(0 0 0 0).			oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].].	^ badOnes size! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!macroBenchmark3   "Smalltalk macroBenchmark3"	| testBlock tallies prev receiver |	"Runs the stepping simulator with the messageTally tree (like tallySends)."	testBlock _		['Running the context step simulator'			displayProgressAt: Sensor mousePoint			from: 0 to: 200			during:				[:bar |				1 to: 200 do:				[:x | bar value: x.				Float pi printString.				15 factorial printString]]].	tallies _ MessageTally new class: testBlock receiver class							method: testBlock method.	receiver _ nil.	prev _ testBlock.	thisContext sender		runSimulated: testBlock		contextAtEachStep:			[:current |			current == prev ifFalse: [				"call or return"				prev sender ifNotNil: [					"call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev _ current]].! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!obsoleteMethodReferences	"Smalltalk obsoleteMethodReferences"	"Smalltalk browseObsoleteMethodReferences"	"Open a browser on all referenced behaviors that are obsolete"	| obsClasses obsRefs references |	references _ WriteStream on: Array new.	obsClasses _ self obsoleteBehaviors.	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor mousePoint		from: 1 to: obsClasses size during:[:bar|	obsClasses keysAndValuesDo:[:index :each|		bar value: index.		obsRefs _ self pointersTo: each except: obsClasses.		obsRefs do:[:ref|			"Figure out if it may be a global"			((ref isVariableBinding) and:[ref key isKindOf: String "or Symbol"]) ifTrue:[				(self pointersTo: ref) do:[:meth|					(meth isKindOf: CompiledMethod) ifTrue:[						meth methodReference ifNotNil: [ :mref|							references nextPut: mref]]]]]].	].	^references contents! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!removeAllLineFeeds    "Smalltalk removeAllLineFeeds"	"Scan all methods for source code with lineFeeds.	Replaces all occurrences of <CR><LF> by <CR>, noted by beep.	Halts with a message if any other LFs are found."	 | oldCodeString n crlf cr newCodeString oldStamp oldCategory m lf |	crlf _ String crlf.	cr _ String cr.	lf _ String lf.	Smalltalk forgetDoIts.'Scanning sources for LineFeeds.This will take a few moments...'displayProgressAt: Sensor mousePointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0. m _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldCodeString _ (cls sourceCodeAt: selector) asString.			(oldCodeString indexOf: Character lf startingAt: 1) > 0 ifTrue: [				newCodeString _ oldCodeString copyReplaceAll: crlf with: cr.				newCodeString _ oldCodeString copyReplaceAll: lf with: cr.				oldStamp _ Utilities timeStampForMethod: (cls compiledMethodAt: selector).				oldCategory _ cls whichCategoryIncludesSelector: selector.				cls compile: newCodeString classified: oldCategory withStamp: oldStamp notifying: nil.				m _ m + 1]]].].	Transcript cr; show: m printString , ' methods stripped of LFs.'.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!removeTextCode    "Smalltalk removeTextCode"	"Scan all methods for source code that is Text (i.e. with attributes)	Replace it with simpleStrings"	 | oldCodeString n newCodeString oldStamp oldCategory m classComment c o stamp |	Smalltalk forgetDoIts.	'Scanning sources for Text.This will take a few moments...'		displayProgressAt: Sensor mousePoint		from: 0 		to: CompiledMethod instanceCount		during: [:bar | 			n _ 0.			m _ 0.			c _ 0.			Smalltalk allBehaviorsDo: [ :cls | 				cls selectors do: [ :selector  | 					(n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].					oldCodeString _ cls sourceCodeAt: selector.					oldCodeString class = String ifFalse: [						newCodeString _ oldCodeString asString.						oldStamp _ Utilities timeStampForMethod: (cls compiledMethodAt: selector).						oldCategory _ cls whichCategoryIncludesSelector: selector.						cls compile: newCodeString classified: oldCategory withStamp: oldStamp notifying: nil.						m _ m + 1]].				cls isMeta ifFalse: [					o _ cls organization.					classComment _ o classComment.					stamp _ o commentStamp.					classComment class == String ifFalse: [						classComment hasAnyAttribute ifTrue: [							self halt "review" ].						cls classComment: classComment asString stamp: stamp.						c _ c + 1 ]].			].		].		Transcript cr; show: m printString , ' text methods converted to strings.'.		Transcript cr; show: c printString , ' text class comments converted to strings.'.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!testDecompiler	"Smalltalk testDecompiler"	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."	| methodNode oldMethod newMethod badOnes oldCodeString n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.	'Decompiling all classes...'		displayProgressAt: Sensor mousePoint		from: 0		to: CompiledMethod instanceCount		during: [ :bar |			n _ 0.			Smalltalk allBehaviorsDo: [ :cls |				"Transcript cr; show: cls name."				cls selectors do: [ :selector |					(n _ n + 1) \\ 100 = 0 ifTrue: [ bar value: n ].					oldMethod _ cls compiledMethodAt: selector.					oldCodeString _ (cls decompilerClass new						decompile: selector						in: cls						method: oldMethod) decompileString.					methodNode _ cls compilerClass new						compile: oldCodeString						in: cls						notifying: nil						ifFail: nil.					newMethod _ methodNode generate: #(0 0 0 0 ).					oldCodeString =						(cls decompilerClass new							decompile: selector							in: cls							method: newMethod) decompileString ifFalse: [						Transcript							 cr;							 show: '***' , cls name , ' ' , selector.						badOnes add: cls name , ' ' , selector ]]]].	Smalltalk		browseMessageList: badOnes asArray sort		name: 'Decompiler Discrepancies'.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!testFormatter	"Smalltalk testFormatter"	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.	The formatting used will be classic monochrome."	| newCodeString methodNode oldMethod newMethod badOnes n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.	'Formatting all classes...'		displayProgressAt: Sensor mousePoint		from: 0		to: CompiledMethod instanceCount		during: [ :bar |			n _ 0.			Smalltalk allBehaviorsDo: [ :cls |				"Transcript cr; show: cls name."				cls selectors do: [ :selector |					(n _ n + 1) \\ 100 = 0 ifTrue: [ bar value: n ].					newCodeString _ cls compilerClass new						format: (cls sourceCodeAt: selector)						in: cls						notifying: nil.					methodNode _ cls compilerClass new						compile: newCodeString						in: cls						notifying: nil						ifFail: nil.					newMethod _ methodNode generate: #(0 0 0 0 ).					oldMethod _ cls compiledMethodAt: selector.					oldMethod = newMethod ifFalse: [						Transcript							 cr;							 show: '***' , cls name , ' ' , selector.						badOnes add: cls name , ' ' , selector ]]]].	Smalltalk		browseMessageList: badOnes asArray sort		name: 'Formatter Discrepancies'.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/18/2011 14:41'!testFormatter2	"Smalltalk testFormatter2"	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.	The formatting used will be classic monochrome"	| newCodeString badOnes n oldCodeString oldTokens newTokens |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.	'Formatting all classes...'		displayProgressAt: Sensor mousePoint		from: 0		to: CompiledMethod instanceCount		during: [ :bar |			n _ 0.			Smalltalk allBehaviorsDo: [ :cls |				"Transcript cr; show: cls name."				cls selectors do: [ :selector |					(n _ n + 1) \\ 100 = 0 ifTrue: [ bar value: n ].					oldCodeString _ (cls sourceCodeAt: selector) asString.					newCodeString _ cls compilerClass new						format: oldCodeString						in: cls						notifying: nil.					oldTokens _ oldCodeString findTokens: Character separators.					newTokens _ newCodeString findTokens: Character separators.					oldTokens = newTokens ifFalse: [						Transcript							 cr;							 show: '***' , cls name , ' ' , selector.						badOnes add: cls name , ' ' , selector ]]]].	Smalltalk		browseMessageList: badOnes asArray sort		name: 'Formatter Discrepancies'.! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 4/18/2011 14:41'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"	| list classCount adder |	list _ Set new.	adder _ [ :mrClass :mrSel |	list add:		(MethodReference new			setStandardClass: mrClass			methodSymbol: mrSel) ].	'Searching all source code...'		displayProgressAt: Sensor mousePoint		from: 0		to: Smalltalk classNames size		during: [ :bar |			classCount _ 0.			Smalltalk allClassesDo: [ :class |				bar value: (classCount _ classCount + 1).				(Array					with: class					with: class class) do: [ :cl |					cl selectorsDo: [ :sel |						((cl sourceCodeAt: sel)							findString: aString							startingAt: 1							caseSensitive: caseSensitive) > 0 ifTrue: [							sel == #DoIt ifFalse: [								adder									value: cl									value: sel ]]].					(cl organization classComment asString						findString: aString						startingAt: 1						caseSensitive: caseSensitive) > 0 ifTrue: [						adder							value: cl							value: #Comment ]]]].	^ list asArray sort.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/18/2011 14:40'!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	"wod 11/3/1998: zap the organization before rather than after condensing changes."	 | oldCodeString argsAndTemps oldMethods newMethods m bTotal bCount |	(self confirm:'This method will preserve most temp names(up to about 400 characters) while allowingthe sources file to be discarded.-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, choose Yes.If you have any doubts, you may choose Noto back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor mousePoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "			[:cl |  bar value: (bCount _ bCount + 1).			cl selectors do: [:selector |				m _ cl compiledMethodAt: selector.				m fileIndex > 0 ifTrue:				[oldCodeString _ cl sourceCodeAt: selector.				argsAndTemps _ (cl compilerClass new					parse: oldCodeString in: cl notifying: nil)					tempNames.				oldMethods addLast: m.				newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk allBehaviorsDo: [:b | b zapOrganization].	Smalltalk condenseChanges.	Preferences disable: #warnIfNoSourcesFile."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/18/2011 14:40'!abandonTempNames	"Replaces every method by a copy with no source pointer or encoded temp names."	"Smalltalk abandonTempNames"	 | continue oldMethods newMethods n m |	continue _ (self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning all source code, hit Yes.If you have any doubts, hit No,to back out with no harm done.').	continue ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts; garbageCollect.	oldMethods _ OrderedCollection new.	newMethods _ OrderedCollection new.	n _ 0.	'Removing temp names to save space...'		displayProgressAt: Sensor mousePoint		from: 0 to: CompiledMethod instanceCount		during: [:bar |			Smalltalk allBehaviorsDo: [:cl |				cl selectors do: [:sel |					bar value: (n _ n + 1).					m _ cl compiledMethodAt: sel.					oldMethods addLast: m.					newMethods addLast: (m copyWithTrailerBytes: #(0))]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk closeSourceFiles.	Preferences disable: #warnIfNoChangesFile.	Preferences disable: #warnIfNoSourcesFile.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/18/2011 14:41'!removeAllUnSentMessages	"Smalltalk removeAllUnSentMessages"	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 	Smalltalk removeAllUnSentMessages > 0] whileTrue."	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	self presumedSentMessages		do: [:sel | sels				remove: sel				ifAbsent: nil].	sels size = 0		ifTrue: [^ 0].	n _ 0.	Smalltalk		allBehaviorsDo: [:x | n _ n + 1].	'Removing ' , sels size printString , ' messages . . .'		displayProgressAt: Sensor mousePoint		from: 0		to: n		during: [:bar | 			n _ 0.			self				allBehaviorsDo: [:class | 					bar value: (n _ n + 1).					sels						do: [:sel | class removeSelector: sel]]].	^ sels size! !!TextEditor methodsFor: 'events' stamp: 'FernandoOlivero 4/16/2011 01:49'!mouseDown: evt 	| clickPoint b |	oldInterval _ self selectionInterval.	clickPoint _ evt position.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint for: model) ifTrue: [		self markBlock: b.		self pointBlock: b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			self closeTypeIn.			self markBlock: b.			self pointBlock: b ]! !!TextEditor methodsFor: 'events' stamp: 'FernandoOlivero 4/16/2011 01:49'!mouseMove: evt	"Change the selection in response to mouse-down drag"	self pointBlock: (paragraph characterBlockAtPoint: (evt position)).	self storeSelectionInParagraph! !!TextEditor methodsFor: 'events' stamp: 'FernandoOlivero 4/16/2011 01:50'!mouseUp: evt	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	oldInterval = self selectionInterval		ifTrue: [			evt shiftPressed				ifFalse: [					"Not a real double-click, but the second click in the same place, without shift.					Act as if double click (classic Squeak behavior)"					self selectWord ]				ifTrue: [					"Squeak classic behavior for click, move, shift-click sequence "					"self pointBlock: (paragraph characterBlockAtPoint: (evt position))."					"Mac behavior"					cursorBlock _ paragraph characterBlockAtPoint: evt position.					cursorIndex _ cursorBlock stringIndex.					startBlock _ self startBlock min: cursorBlock.					startIndex _ startBlock stringIndex.					stopBlock _ self stopBlock max: cursorBlock.					stopIndex _ stopBlock stringIndex.					(stopIndex - cursorIndex) < (cursorIndex - startIndex)						ifTrue: [							self markBlock: startBlock.							self pointBlock: cursorBlock ]						ifFalse: [							self markBlock: stopBlock.							self pointBlock: cursorBlock ]]].	self setEmphasisHereFromText.	(self isDisjointFrom: oldInterval) ifTrue: [		otherInterval _ oldInterval].	self storeSelectionInParagraph	"store selection , done in this method, (shift click) or perhaps in #mouseDown: (click)"! !!TextModelMorph methodsFor: 'editor access' stamp: 'FernandoOlivero 4/16/2011 01:50'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest cpHere |	selectionInterval _ self editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [event anyButtonPressed]) ifTrue: [  "Check for autoscroll"		cpHere _ scroller externalizePosition: event position to: self.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ textMorph bounds: rectToTest in: self.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jmv 4/18/2011 14:43'!awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw3/31/00 JMM added logic to stop multiple redraws"	| p inside lightForm darkForm isLight |	p _ Sensor mousePoint.	inside _ box insetBy: 1.	isLight _ true.	lightForm _ Form fromDisplay: inside.	darkForm _ lightForm deepCopy reverse.	[Sensor anyButtonPressed] whileTrue:		[doBlock1 value.		(box containsPoint: (p _ Sensor mousePoint))			ifTrue: [doBlock2 value.					isLight ifTrue: 						[isLight _ false.						darkForm displayAt: inside origin]]			ifFalse: [isLight ifFalse:						[isLight _ true.						lightForm displayAt: inside origin]]].	(box containsPoint: p)		ifTrue: [lightForm displayAt: inside origin.				^ succBlock value]! !!Utilities class methodsFor: 'user interface' stamp: 'jmv 4/18/2011 14:41'!informUser: aString during: aBlock 	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUser: 'Just a sec!!' during: [(Delay forSeconds: 1) wait]"	(MVCMenuMorph from: (SelectionMenu labels: '') title: aString) 				displayAt: Sensor mousePoint				during: aBlock! !!Utilities class methodsFor: 'user interface' stamp: 'jmv 4/18/2011 14:41'!informUserDuring: aBlock 	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUserDuring:[:bar|		#(one two three) do:[:info|			bar value: info.			(Delay forSeconds: 1) wait]]"	(MVCMenuMorph from: (SelectionMenu labels: '') title: '						') 				informUserAt: Sensor mousePoint				during: aBlock! !!Utilities class methodsFor: 'closure support' stamp: 'jmv 4/18/2011 14:41'!compileUsingClosures	"Utilities compileUsingClosures"	"Recompile the system and do some minimal clean-ups"	| classes compilationErrors |	Preferences setPreference: #allowBlockArgumentAssignment toValue: false.	compilationErrors := Set new.	classes := Smalltalk forgetDoIts allClasses reject: [:c| c name == #GeniePlugin].	'Recompiling The System' displayProgressAt: Sensor mousePoint		from: 0 to: classes size during:[:bar |			classes withIndexDo:[:c :i|				bar value: i.				{ c. c class } do:[:b|					"Transcript cr; print: b; endEntry."					b selectors "asArray sort" do: [ :s | 						"Transcript cr; show: b asString, '>>', s."						[b recompile: s from: b] on: Error do:[:ex|							Transcript								cr; nextPutAll: 'COMPILATION ERROR: ';								print: b; nextPutAll: '>>'; nextPutAll: s.							compilationErrors add: (MethodReference class: b selector: s)]]]]].	compilationErrors notEmpty ifTrue:[		Smalltalk			browseMessageList: compilationErrors asArray sort			name: 'Compilation Errors' ]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:41'!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor mousePoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:41'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 250@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor mousePoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 250@0).		]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:42'!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor mousePoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt inverseRotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:42'!test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor mousePoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt inverseRotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 4/18/2011 14:42'!test5   "Display restoreAfter: [WarpBlt test5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor mousePoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'jmv 4/18/2011 14:42'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| frameBase coeffs maxVal minVal c scale nullCount frameI outFrameSize threshold outStream cMin val |	threshold _ 2000.	fwt ifNil:		[samplesPerFrame _ self samplesPerFrame.		nLevels _ 8.		"Here are some sample mother wavelets, with the compression achieved on a		sample of my voice at a threshold of 2000:									compression achieved "		alpha _ 0.0.  beta _ 0.0.		"12.1"		alpha _ 1.72.  beta _ 1.51.	"14.0"		alpha _ -1.86.  beta _ -1.53.	"14.4"		alpha _ 1.28.  beta _ -0.86.	"15.9"		alpha _ -1.15.  beta _ 0.69.	"16.0"		fwt _ FWT new.		fwt nSamples: samplesPerFrame nLevels: nLevels.		fwt setAlpha: alpha beta: beta].	(outStream _ WriteStream on: dstByteArray from: dstIndex to: dstByteArray size)		nextNumber: 4 put: frameCount;		nextNumber: 4 put: samplesPerFrame;		nextNumber: 4 put: nLevels;		nextNumber: 4 put: alpha asIEEE32BitWord;		nextNumber: 4 put: beta asIEEE32BitWord.	frameBase _ srcIndex.	1 to: frameCount do:		[:frame | 		"Copy float values into the wavelet sample array"				fwt samples: ((frameBase to: frameBase + samplesPerFrame-1) 				collect: [:i | (srcSoundBuffer at: i) asFloat]).		"Compute the transform"		fwt transformForward: true.		frameI _ outStream position+1.  "Reserve space for frame size"		outStream nextNumber: 2 put: 0.		"Determine and output the scale for this frame"		coeffs _ fwt coeffs.		maxVal _ 0.0.  minVal _ 0.0.		5 to: coeffs size do:			[:i | c _ coeffs at: i.			c > maxVal ifTrue: [maxVal _ c].			c < minVal ifTrue: [minVal _ c]].		scale _ (maxVal max: minVal negated) / 16000.0.  "Will scale all to -16k..16k: 15 bits"		outStream nextNumber: 4 put: scale asIEEE32BitWord.		"Copy scaled values, with run-coded sequences of 0's, to destByteArray"		nullCount _ 0.		cMin _ threshold / scale.		5 to: coeffs size do:			[:i | c _ (coeffs at: i) / scale.			c abs < cMin			ifTrue: ["Below threshold -- count nulls."					nullCount _ nullCount + 1]			ifFalse: ["Above threshold -- emit prior null count and this sample."					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1].						nullCount _ 0].						val _ c asInteger + 16384 + 32768.  "Map -16k..16k into 32k..64k"						outStream nextNumber: 2 put: val]].					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1]].		outFrameSize _ outStream position+1 - frameI - 2.  "Write frame size back at the beginning"		(WriteStream on: dstByteArray from: frameI to: dstByteArray size)			nextNumber: 2 put: outFrameSize.		frameBase _ frameBase + samplesPerFrame]."This displays a temporary indication of compression achieved"(((frameBase - srcIndex) *2.0 / (outStream position+1 - dstIndex) truncateTo: 0.1) printString , ' : 1') displayAt: Sensor mousePoint + (-20@30).	outStream position > dstByteArray size ifTrue:		["The calling routine only provides buffer space for compression of 2:1 or better.  If you are just testing things, you can increase it to, eg, codeFrameSize _ frameSize*3, which would be sufficient for a threshold of 0 (lossless conversion)."		self error: 'Buffer overrun'].	^ Array with: frameBase - srcIndex			with: outStream position+1 - dstIndex! !!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 4/18/2011 14:57'!handPoint	^ hand position! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'jmv 4/18/2011 14:43'!compressAndDecompress: aFile using: tempName stats: stats	| fileSize tempFile result |	aFile		ifNil: [^ nil].	fileSize _ aFile size.	(fileSize < 1"00000" "or:[fileSize > 1000000]") ifTrue:[aFile close. ^nil].	Transcript cr; show:'Testing ', aFile name,' ... '.	tempFile _ StandardFileStream new open: tempName forWrite: true.	'Compressing ', aFile name,'...' displayProgressAt: Sensor mousePoint		from: 1 to: aFile size during:[:bar|			result _ self regressionCompress: aFile into: tempFile notifiying: bar stats: stats].	result ifTrue:[		'Validating ', aFile name,'...' displayProgressAt: Sensor mousePoint			from: 0 to: aFile size during:[:bar|				result _ self regressionDecompress: aFile from: tempFile notifying: bar stats: stats]].	aFile close.	tempFile close.	FileDirectory default deleteFileNamed: tempName ifAbsent: nil.	result ~~ false ifTrue:[		Transcript show:' ok (', (result * 100 truncateTo: 0.01) printString,')'].	^result! !MouseEvent removeSelector: #cursorPoint!DropEvent removeSelector: #cursorPoint!MorphicEvent removeSelector: #cursorPoint!HandMorph removeSelector: #cursorPoint!Morph removeSelector: #cursorPoint!InputSensor removeSelector: #cursorPoint!InputSensor removeSelector: #cursorPoint:!InputSensor removeSelector: #peekPosition!