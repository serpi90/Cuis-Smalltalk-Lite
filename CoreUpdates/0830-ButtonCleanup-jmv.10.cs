'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 1 March 2011 at 2:21:59 pm'!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector getLabelSelector arguments isPressed mouseIsOver '	classVariableNames: 'ButtonGradient ButtonGradientPressed RoundedCornerBL RoundedCornerBLPressed RoundedCornerBR RoundedCornerBRPressed RoundedCornerTL RoundedCornerTLPressed RoundedCornerTR RoundedCornerTRPressed '	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableButtonMorph commentStamp: '<historical>' prior: 0!A PluggableButtonMorph is a combination of an indicator for a boolean value stored in its model and an action button. The action of a button is often, but not always, to toggle the boolean value that it shows. Its pluggable selectors are:		getStateSelector		fetch a boolean value from the model		actionSelector			invoke this button's action on the model		getLabelSelector		fetch this button's lable from the model		getMenuSelector		fetch a pop-up menu for this button from the modelAny of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if getStateSelector is nil, then this button shows the state of a read-only boolean that is always false.The model informs its view(s) of changes by sending #changed: to itself with getStateSelector as a parameter. The view tells the model when the button is pressed by sending actionSelector.If the actionSelector takes one or more arguments, then the following are relevant:		arguments			A list of arguments to provide when the actionSelector is called.		argumentsProvider	The object that is sent the argumentSelector to obtain arguments, if dynamic		argumentsSelector	The message sent to the argumentProvider to obtain the arguments.!!classDefinition: #SimpleButtonMorph category: #'Morphic-Widgets'!BorderedMorph subclass: #SimpleButtonMorph	instanceVariableNames: 'target actionSelector arguments actWhen oldColor label font '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!classDefinition: #SimpleServiceEntry category: #'Tools-FileList'!Model subclass: #SimpleServiceEntry	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 3/1/2011 12:01'!openMorphicWindowForSuspendedProcess: aProcess	| menu rules |	menu _ MenuMorph new.	"nickname  allow-stop  allow-debug"	rules _ ProcessBrowser nameAndRulesFor: aProcess.	menu add: 'Dismiss this menu' target: menu selector: #delete; addLine.	menu add: 'Open Process Browser' target: ProcessBrowser selector: #open.	menu add: 'Resume'		target: self		selector: #resumeProcess:fromMenu:		argumentList: { aProcess . menu }.	menu add: 'Terminate'		target: self		selector: #terminateProcess:fromMenu:		argumentList: { aProcess . menu }.	rules third ifTrue: [		menu add: 'Debug at a lower priority'			target: self			selector: #debugProcess:fromMenu:			argumentList: { aProcess . menu }.	].	menu addTitle: aProcess identityHash asString,		' ', rules first,		' is taking too much time and has been suspended.What do you want to do with it?'.	menu stayUp.	menu popUpInWorld! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'jmv 3/1/2011 11:42'!initializeModal: beModal 	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	isModal := beModal.	self removeAllMorphs.	self addMorph: ((Morph newBounds: (DragBox translateBy: self topLeft))				color: Color transparent;				setBalloonText: 'put me somewhere').	self 		addMorph: ((Morph newBounds: (RevertBox translateBy: self topLeft))				color: Color transparent;				setBalloonText: 'restore original color').	self 		addMorph: ((Morph newBounds: (FeedbackBox translateBy: self topLeft))				color: Color transparent;				setBalloonText: 'shows selected color').	self 		addMorph: ((Morph newBounds: (TransparentBox translateBy: self topLeft))				color: Color transparent;				setBalloonText: 'adjust translucency').	self buildChartForm.	selectedColor ifNil: [selectedColor := Color white].	sourceHand := nil.	deleteOnMouseUp := false.	updateContinuously := true! !!CustomMenu methodsFor: 'compatibility' stamp: 'jmv 3/1/2011 13:51'!add: aString target: anObject selector: aSymbol	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object."	self add: aString		target: anObject		selector: aSymbol		argumentList: #()! !!EventHandler methodsFor: 'initialization' stamp: 'jmv 3/1/2011 10:26'!on: eventName send: selector to: recipient	eventName == #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName == #mouseMove ifTrue:		[mouseMoveRecipient _ recipient.  mouseMoveSelector _ selector. ^ self].	eventName == #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName == #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName == #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName == #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName == #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName == #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName == #click ifTrue:		[clickRecipient _ recipient. clickSelector _ selector. ^ self].	eventName == #doubleClick ifTrue:		[doubleClickRecipient _ recipient. doubleClickSelector _ selector. ^ self].	eventName == #doubleClickTimeout ifTrue:		[doubleClickTimeoutRecipient _ recipient. doubleClickTimeoutSelector _ selector. ^ self].	eventName == #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	eventName == #gesture ifTrue:		[ ^self onGestureSend: selector to: recipient ].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!MenuItemMorph methodsFor: 'events' stamp: 'jmv 3/1/2011 11:53'!mouseEnter: evt	"The mouse entered the receiver"	owner ifNotNil: [owner staysUp ifFalse: [self mouseEnterDragging: evt]]! !!MenuItemMorph methodsFor: 'events' stamp: 'jmv 3/1/2011 11:53'!mouseLeave: evt	"The mouse has left the interior of the receiver..."	owner ifNotNil: [owner staysUp ifFalse: [self mouseLeaveDragging: evt]]! !!MenuItemMorph methodsFor: 'grabbing' stamp: 'jmv 3/1/2011 12:02'!aboutToBeGrabbedBy: aHand	"Don't allow the receiver to act outside a Menu"	| menu box |	(owner notNil and:[owner submorphs size = 1]) ifTrue:[		"I am a lonely menuitem already; just grab my owner"		owner stayUp.		^owner aboutToBeGrabbedBy: aHand].	box _ bounds.	menu _ MenuMorph new defaultTarget: nil.	menu addMorphFront: self.	menu bounds: box.	menu stayUp.	self isSelected: false.	^menu! !!MenuItemMorph methodsFor: 'grabbing' stamp: 'jmv 3/1/2011 12:02'!duplicateMorph: evt	"Make and return a duplicate of the receiver's argument"	| dup menu |	dup _ self duplicate isSelected: false.	menu _ MenuMorph new defaultTarget: nil.	menu addMorphFront: dup.	menu bounds: bounds.	menu stayUp.	evt hand grabMorph: menu from: owner. "duplicate was ownerless so use #grabMorph:from: here"	^menu! !!MenuMorph methodsFor: 'accessing' stamp: 'jmv 3/1/2011 12:01'!stayUp	^ self stayUp: true! !!MenuMorph methodsFor: 'accessing' stamp: 'jmv 3/1/2011 12:00'!staysUp	^ stayUp! !!MenuMorph methodsFor: 'construction' stamp: 'jmv 3/1/2011 12:02'!addStayUpIcons	| closeBox pinBox w |	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])		ifTrue: [		 	self removeProperty: #needsStayUpIcons.			^self ].	titleMorph ifNil: [		"Title not yet there. Flag ourself, so this method is called again when adding title."		self setProperty: #needsStayUpIcons toValue: true.		^ self].	closeBox := IconicButton new target: self;		actionSelector: #delete;		labelGraphic: self class closeIcon;		color: Color transparent;		extent: 14 @ 16;		borderWidth: 0.	pinBox := IconicButton new target: self;		actionSelector: #stayUp;		labelGraphic: self class pushPinIcon;		color: Color transparent;		extent: 14 @ 15;		borderWidth: 0.	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph width ] ifFalse: [ 0 ]) + 42.	self addMorphFront: 		(LayoutMorph newRow			height: (titleMorph height max: 19);			width: w;	"Make room for buttons"			color: Color transparent;			addMorph: closeBox fixedWidth: 16;			addMorph: titleMorph proportionalWidth: 1;			addMorph: pinBox fixedWidth: 16).	self setProperty: #hasStayUpIcons toValue: true.	self removeProperty: #needsStayUpIcons! !!MenuMorph methodsFor: 'menu' stamp: 'jmv 3/1/2011 14:12'!removeStayUpBox	| box |	submorphs isEmpty ifTrue: [^self].	(submorphs first is: #LayoutMorph) ifFalse: [^self].	box := submorphs first submorphs first.	(box isKindOf: IconicButton) 		ifTrue: [			box labelGraphic: (Form extent: box extent depth: 8) ]! !!MessageNames methodsFor: 'initialization' stamp: 'jmv 3/1/2011 13:39'!buildMorphicWindow	"Answer a morphic window with the given initial search string, nil if none""MessageNames openMessageNames"	| window selectorListView firstRow searchButton textMorph secondRow |	textMorph _ TextModelMorph 		textProvider: self		textGetter: #searchString 		textSetter: #searchString:.	textMorph setProperty: #alwaysAccept toValue: true.	textMorph askBeforeDiscardingEdits: false.	textMorph acceptOnCR: true.	textMorph setTextColor: Color brown.	textMorph hideScrollBarsIndefinitely.	textMorph textMorph		on: #mouseEnter send: #selectAll to: textMorph textMorph.	searchButton _ PluggableButtonMorph new 		model: textMorph;		label: 'Search';		action: #accept.	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.	firstRow _ LayoutMorph newRow.	firstRow		addMorph: searchButton proportionalWidth: 0.25;		addMorph: textMorph proportionalWidth: 0.75.	selectorListView _ PluggableListMorph 		model: self		listGetter: #selectorList		indexGetter: #selectorListIndex		indexSetter: #selectorListIndex:		menuGetter: #selectorListMenu		keystrokeAction: #selectorListKey:from:.	secondRow _  LayoutMorph newRow.	secondRow		addMorph: selectorListView proportionalWidth: 0.5;		addAdjusterAndMorph: self buildMorphicMessageList proportionalWidth: 0.5.	window _ SystemWindow new model: self.	window layoutMorph		addMorph: firstRow fixedHeight: self defaultButtonPaneHeight+4;		addAdjusterAndMorph: secondRow proportionalHeight: 0.5;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.	self changed: #editSelection.	window setLabel: 'MessageNames'.	^ window! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 3/1/2011 14:07'!performAction	"Inform the model that this button has been pressed. "	actionSelector ifNotNil: [		model perform: actionSelector ]! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'jmv 3/1/2011 14:05'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model _ model.		Weakly copied""getStateSelector _ getStateSelector.		a Symbol""actionSelector _ actionSelector.		a Symbol""getLabelSelector _ getLabelSelector.		a Symbol""getMenuSelector _ getMenuSelector.		a Symbol"isPressed _ isPressed.mouseIsOver _ mouseIsOver! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 3/1/2011 11:12'!initialize	"initialize the state of the receiver"	super initialize.	model _ nil.	getStateSelector _ nil.	actionSelector _ nil.	isPressed _ false.	mouseIsOver _ false.	self extent: 20 @ 15! !!PluggableButtonMorph methodsFor: 'initialize-release' stamp: 'jmv 3/1/2011 11:11'!model: anObject stateGetter: getStateSel action: actionSel label: aString	self model: anObject.	getStateSelector _ getStateSel.	actionSelector _ actionSel.	self label: aString! !!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jmv 3/1/2011 11:11'!model: anObject stateGetter: getStateSel action: actionSel	^ self new		model: anObject		stateGetter: getStateSel		action: actionSel		label: nil! !!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jmv 3/1/2011 11:10'!model: anObject stateGetter: getStateSel action: actionSel label: aString	^ self new		model: anObject		stateGetter: getStateSel		action: actionSel		label: aString! !!SimpleButtonMorph methodsFor: 'button' stamp: 'jmv 3/1/2011 14:07'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object."	(target notNil and: [actionSelector notNil]) 		ifTrue: [			Cursor normal 				showWhile: [target perform: actionSelector]]! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'jmv 3/1/2011 14:06'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target]! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'jmv 3/1/2011 14:20'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied""actionSelector _ actionSelector.		a Symbol""arguments _ arguments.		All weakly copied"oldColor _ oldColor veryDeepCopyWith: deepCopier."shared"! !!SimpleButtonMorph methodsFor: 'event handling' stamp: 'jmv 3/1/2011 14:15'!mouseDown: evt	| now dt |	super mouseDown: evt.	now _ Time millisecondClockValue.	oldColor _ self fillStyle. 			"Not very pretty implementation of button pressed visual feedback...			PluggableButtonMorph seems to be nicer...			Sometime, merge those 2 classes"			self updateVisualState: evt; refreshWorld .	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait].	self mouseStillDown: evt.! !!SimpleButtonMorph methodsFor: 'event handling' stamp: 'jmv 3/1/2011 14:16'!mouseUp: evt	super mouseUp: evt.	oldColor ifNotNil: [		"if oldColor nil, it signals that mouse had not gone DOWN		inside me, e.g. because of a cmd-drag; in this case we want		to avoid triggering the action!!"		self color: oldColor.		oldColor _ nil.		(self containsPoint: evt cursorPoint)			ifTrue: [self doButtonAction]].! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'jmv 3/1/2011 14:16'!initializeAllButLabel	super initialize.	self color: (Color r: 0.4 g: 0.8 b: 0.6).	self borderColor: self defaultBorderColor.	target _ nil.	actionSelector _ #flash! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'jmv 3/1/2011 14:19'!setDefaultLabel	self labelGraphic: HaloMorph paintIcon! !!SimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'jmv 3/1/2011 14:18'!extent: newExtent	| i |	super extent: newExtent.	submorphs size = 1 ifTrue:		["keep the icon centered"		"NOTE: may want to test more that it IS an icon..."		i _ self firstSubmorph.		i position: self center - (i extent // 2)]! !!SimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'jmv 3/1/2011 14:18'!labelGraphic: aForm	| oldLabel graphicalMorph |	(oldLabel _ self findA: SketchMorph)		ifNotNil: [oldLabel delete].	graphicalMorph _ SketchMorph withForm: aForm.	"this could use a #fitContents method, like the superclass...""	self extent: graphicalMorph extent + (borderWidth + 6)."	graphicalMorph position: self center - (graphicalMorph extent // 2).	self addMorph: graphicalMorph.	graphicalMorph lock! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jmv 3/1/2011 13:46'!buttonToTriggerIn: aFileList 	"Answer a button that will trigger the receiver service in a file list"	| aButton |	argumentProvider _ aFileList.	aButton := PluggableButtonMorph 				model: self				stateGetter: nil				action: #performService.	aButton label: self buttonLabel.	aButton color: (Theme current buttonColorFrom: aFileList class windowColor).	aButton setBalloonText: self description.	^aButton! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jmv 3/1/2011 13:46'!performService	"carry out the service I provide"	^selector numArgs = 0		ifTrue: [provider perform: selector]		ifFalse: [provider perform: selector with: (self getArgumentsFrom: argumentProvider) ]! !!SimpleServiceEntry methodsFor: 'services menu' stamp: 'jmv 3/1/2011 13:47'!addServiceFor: served toMenu: aMenu	argumentProvider _ served.	aMenu add: self label 		target: self 		selector: #performService.	self useLineAfter ifTrue: [ aMenu addLine ].! !!SimpleServiceEntry methodsFor: 'as yet unclassified' stamp: 'jmv 3/1/2011 14:03'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!FileModifyingSimpleServiceEntry methodsFor: 'as yet unclassified' stamp: 'jmv 3/1/2011 13:46'!performService	| retval |	retval _ super performService.	self changed: #fileListChanged.	^retval	"is this used anywhere?"! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/1/2011 14:14'!createExpandBox	^ self createBox 				labelGraphic: self class expandIcon;			 extent: self boxExtent;		 actionSelector: #expandBoxHit;		 setBalloonText: 'expand to full screen'! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 3/1/2011 11:11'!buildFilterButton	| filterButton |	filterButton := PluggableButtonMorph 				model: self				stateGetter: nil				action: #setFilter				label: 'Filter'.	filterButton color: self runButtonColor.	^filterButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 3/1/2011 10:37'!buildMorphicWindow	"TestRunner new openAsMorph"	| window |	window _ SystemWindow new model: self.	window layoutMorph		addMorph: self buildUpperControls proportionalHeight: 0.25;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.	window setLabel: 'SUnit Test Runner'.	self refreshWindow.	window extent: 460 @ 400.	^window! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 3/1/2011 11:11'!buildRefreshButton	| refreshButton |	refreshButton := PluggableButtonMorph 				model: self				stateGetter: nil				action: #refreshTests				label: 'Refresh'.	refreshButton		color: self runButtonColor.	^refreshButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 3/1/2011 11:11'!buildRunButton	| runButton |	runButton := PluggableButtonMorph 				model: self				stateGetter: #runButtonState				action: #runTests				label: 'Run all selected'.	runButton		color: self runButtonColor.	^runButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 3/1/2011 11:11'!buildRunOneButton	| runOneButton |	runOneButton := PluggableButtonMorph 				model: self				stateGetter: #runButtonState				action: #runOneTest				label: 'Run last selected'.	runOneButton		color: self runButtonColor.	^runOneButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 3/1/2011 11:11'!buildStopButton	| stopButton |	stopButton := PluggableButtonMorph 				model: self				stateGetter: #stopButtonState				action: #terminateRun				label: 'Stop'.	stopButton		color: self runButtonColor.	^stopButton! !!TestRunner methodsFor: 'test processing' stamp: 'jmv 3/1/2011 10:37'!showResultSummary	| message summary |	message := (self result runCount = self result correctCount)		ifTrue: ['succeeded']		ifFalse: ['failed'].	Transcript crtab; show: message.	summary :=		self result runCount printString, ' run, ',		self result failureCount printString, ' failed, ',		self result errorCount printString, ' errors'.	Transcript crtab; show: summary.! !!TestRunner methodsFor: 'updating' stamp: 'jmv 3/1/2011 10:39'!updateWindow: aTestResult	aTestResult errors size + aTestResult failures size = 0		ifTrue: [ self updatePartColors: Color green lighter ]		ifFalse: [			aTestResult errors size > 0				ifTrue: [ self updatePartColors: Color red lighter ]				ifFalse: [ self updatePartColors: Color yellow lighter ]].	self updatePassFail: aTestResult.	self updateDetails: aTestResult.	self updateFailures: aTestResult.	self updateErrors: aTestResult! !TestRunner removeSelector: #debugButtonLabel!TestRunner removeSelector: #debugState!TestRunner removeSelector: #debugTest!TestRunner removeSelector: #errorColor!TestRunner removeSelector: #failColor!TestRunner removeSelector: #failureMessage!TestRunner removeSelector: #filterButtonLabel!TestRunner removeSelector: #passColor!TestRunner removeSelector: #refreshButtonLabel!TestRunner removeSelector: #refreshButtonState!TestRunner removeSelector: #resetColor!TestRunner removeSelector: #runButtonLabel!TestRunner removeSelector: #runButtonOffColor!TestRunner removeSelector: #runOneButtonLabel!TestRunner removeSelector: #runSemaphore!TestRunner removeSelector: #stopButtonLabel!TestRunner removeSelector: #successMessage!TestRunner removeSelector: #suite!TestRunner removeSelector: #windowLabel!TestCase class removeSelector: #suite!FileModifyingSimpleServiceEntry removeSelector: #performServiceFor:!SimpleServiceEntry removeSelector: #performServiceFor:!!classDefinition: #SimpleServiceEntry category: #'Tools-FileList'!Model subclass: #SimpleServiceEntry	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!SimpleButtonMorph class removeSelector: #newWithLabel:!IconicButton removeSelector: #addLabelItemsTo:hand:!IconicButton removeSelector: #extent:!IconicButton removeSelector: #labelGraphic:!IconicButton removeSelector: #setDefaultLabel!IconicButton removeSelector: #shedSelvedge!SimpleButtonMorph removeSelector: #actWhen!SimpleButtonMorph removeSelector: #actWhen:!SimpleButtonMorph removeSelector: #addCustomMenuItems:hand:!SimpleButtonMorph removeSelector: #addLabelItemsTo:hand:!SimpleButtonMorph removeSelector: #arguments!SimpleButtonMorph removeSelector: #arguments:!SimpleButtonMorph removeSelector: #clearTarget!SimpleButtonMorph removeSelector: #drawOn:!SimpleButtonMorph removeSelector: #fitContents!SimpleButtonMorph removeSelector: #fontToUse!SimpleButtonMorph removeSelector: #handlesMouseStillDown:!SimpleButtonMorph removeSelector: #initializeWithLabel:!SimpleButtonMorph removeSelector: #label!SimpleButtonMorph removeSelector: #label:!SimpleButtonMorph removeSelector: #label:font:!SimpleButtonMorph removeSelector: #mouseMove:!SimpleButtonMorph removeSelector: #mouseStillDown:!SimpleButtonMorph removeSelector: #setActWhen!SimpleButtonMorph removeSelector: #setActionSelector!SimpleButtonMorph removeSelector: #setArguments!SimpleButtonMorph removeSelector: #setLabel!SimpleButtonMorph removeSelector: #sightTarget:!!classDefinition: #SimpleButtonMorph category: #'Morphic-Widgets'!BorderedMorph subclass: #SimpleButtonMorph	instanceVariableNames: 'target actionSelector oldColor'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!PluggableButtonMorph class removeSelector: #model:stateGetter:action:labelOrGetter:!PluggableButtonMorph removeSelector: #arguments:!PluggableButtonMorph removeSelector: #model:stateGetter:action:labelOrGetter:!PluggableButtonMorph removeSelector: #update:!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector isPressed mouseIsOver'	classVariableNames: 'ButtonGradient ButtonGradientPressed RoundedCornerBL RoundedCornerBLPressed RoundedCornerBR RoundedCornerBRPressed RoundedCornerTL RoundedCornerTLPressed RoundedCornerTR RoundedCornerTRPressed'	poolDictionaries: ''	category: 'Morphic-Windows'!MessageNames removeSelector: #doSearchFrom:!MVCMenuMorph removeSelector: #invokeAt:in:!MenuMorph removeSelector: #add:subMenu:target:selector:argumentList:!MenuMorph removeSelector: #addUpdating:enablementSelector:target:selector:argumentList:!MenuMorph removeSelector: #popUpNoKeyboard!MenuMorph removeSelector: #rootMenu!