'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 18 April 2011 at 3:24:20 pm'!!classDefinition: #HandMorph category: #'Morphic-Kernel'!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch userInitials lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds '	classVariableNames: 'DoubleClickTime EventStats NormalCursor ShowEvents '	poolDictionaries: ''	category: 'Morphic-Kernel'!!HandMorph methodsFor: 'caching' stamp: 'FernandoOlivero 4/16/2011 01:13'!releaseCachedState	| oo |	super releaseCachedState.	oo _ owner.	self removeAllMorphs.	self initialize.	"nuke everything"	self privateOwner: oo.	self releaseAllFoci.! !!HandMorph methodsFor: 'cursor' stamp: 'jmv 4/18/2011 14:15'!cursorBounds	^self position extent: CursorWithMask normal extent! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 4/18/2011 14:16'!drawOn: aCanvas 	"Draw the hand itself (i.e., the cursor)."	 aCanvas		stencil: Cursor move		at: bounds topLeft		color: Color black .	! !!HandMorph methodsFor: 'drawing' stamp: 'FernandoOlivero 4/16/2011 01:14'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ submorphs anySatisfy: [ :ea | ea visible ] ] )		ifTrue: [			"using the software cursor; hide the hardware one"			Sensor currentCursor == Cursor blank ifFalse: [Cursor blank show].			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'FernandoOlivero 4/16/2011 01:14'!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas image: savedPatch at: savedPatch offset.		submorphs notEmpty ifTrue: [ ^self ].		"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."		super			invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset)			from: self.		Sensor currentCursor == Cursor normal ifFalse: [ Cursor normal show ].	"show hardware cursor"		savedPatch _ nil ]! !!HandMorph methodsFor: 'events-processing' stamp: 'FernandoOlivero 4/16/2011 01:07'!handleEvent: anEvent	| evt |	owner ifNil:[^self].	evt _ anEvent.	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.		evt isWindowEvent ifTrue: [		self sendEvent: evt.		^ self mouseOverHandler processMouseOver: lastMouseEvent ].	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt.			lastMouseEventTime _ Time millisecondClockValue].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'initialization' stamp: 'jmv 4/18/2011 14:16'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseFocus _ nil.	bounds _ 0@0 extent: CursorWithMask normal extent.	damageRecorder _ DamageRecorder new.	self initForEvents.! !!HandMorph class methodsFor: 'class initialization' stamp: 'FernandoOlivero 4/16/2011 01:09'!initialize	"HandMorph initialize"	DoubleClickTime _ 350.		! !HandMorph initialize!HandMorph class removeSelector: #showEvents:!HandMorph removeSelector: #hasUserInformation!HandMorph removeSelector: #userInitials!HandMorph removeSelector: #userInitials:andPicture:!HandMorph removeSelector: #userPicture!HandMorph removeSelector: #userPicture:!!classDefinition: #HandMorph category: #'Morphic-Kernel'!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'	classVariableNames: 'DoubleClickTime'	poolDictionaries: ''	category: 'Morphic-Kernel'!!HandMorph reorganize!('accessing' lastEvent mouseOverHandler targetOffset)('balloon help' balloonHelp balloonHelp: deleteBalloonTarget: removePendingBalloonFor: spawnBalloonFor: triggerBalloonFor:after:)('caching' releaseCachedState)('change reporting' invalidRect:from:)('classification' is:)('copying' veryDeepCopyWith:)('cursor' cursorBounds)('double click support' resetClickState waitForClicksOrDrag:event: waitForClicksOrDrag:event:clkSel:dblClkSel:dblClkTimeoutSel:dragSel: waitForClicksOrDragOrSimulatedMouseButton2:event:clkSel:dblClkSel:dblClkTimeoutSel:dragSel: waitForSimulatedMouseButton2:event:dblClkSel:)('drawing' drawOn: fullDrawOn: hasChanged needsToBeDrawn nonCachingFullDrawOn: restoreSavedPatchOn: savePatchFrom: savePatchFrom:appendDamageTo: shadowForm)('drop shadows' shadowOffset)('event handling' cursorPoint flushEvents noticeMouseOver:event: processEvents)('events-processing' handleEvent:)('focus handling' keyboardFocus keyboardFocusNext keyboardFocusPrevious mouseFocus newKeyboardFocus: newMouseFocus: newMouseFocus:event: releaseAllFoci releaseKeyboardFocus releaseKeyboardFocus: releaseMouseFocus releaseMouseFocus:)('grabbing/dropping' attachMorph: dropMorph:event: dropMorphs: grabMorph:from:)('halo handling' halo: obtainHalo: releaseHalo: removeHaloFromClick:on:)('halos and balloon help' halo)('initialization' initForEvents initialize interrupted)('layout' fullBounds)('listeners' addEventListener: addKeyboardListener: addListener:to: addMouseListener: eventListeners eventListeners: keyboardListeners keyboardListeners: mouseListeners mouseListeners: removeEventListener: removeKeyboardListener: removeListener:from: removeMouseListener:)('meta-actions' grabMorph:)('objects from disk' objectForDataStream:)('paste buffer' pasteMorph)('updating' redrawNeeded)('private events' generateKeyboardEvent: generateMouseEvent: generateWindowEvent: mouseTrailFrom: moveToEvent: sendEvent: sendFocusEvent:to:in: sendKeyboardEvent: sendListenEvent:to: sendMouseEvent: shouldControlEmulateAltFor:)!