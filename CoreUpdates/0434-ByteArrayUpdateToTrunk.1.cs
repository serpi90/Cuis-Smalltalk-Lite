'From Cuis 2.0 of 12 February 2010 [latest update: #418] on 23 February 2010 at 1:02:41 pm'!!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index bigEndian: bool 	"Return a 64 bit float starting from the given byte index"	| w1 w2 dbl |	w1 := self unsignedLongAt: index bigEndian: bool.	w2 := self unsignedLongAt: index + 4 bigEndian: bool.	dbl := Float new: 2. 	bool		ifTrue: [dbl basicAt: 1 put: w1.			dbl basicAt: 2 put: w2]		ifFalse: [dbl basicAt: 1 put: w2.			dbl basicAt: 2 put: w1].	^ dbl! !!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index put: value bigEndian: bool 	"Store a 64 bit float starting from the given byte index"	| w1 w2 |	bool		ifTrue: [w1 := value basicAt: 1.			w2 := value basicAt: 2]		ifFalse: [w1 := value basicAt: 2.			w2 := value basicAt: 1]. 	self unsignedLongAt: index put: w1 bigEndian: bool.	self unsignedLongAt: index + 4 put: w2 bigEndian: bool.	^ value! !!ByteArray methodsFor: 'converting' stamp: 'jmv 2/23/2010 12:57'!hex	"Answer an hexa decimal representation of the receiver		        #[122 43 213 7] hex                => ' 7A2BD507'	"	| string v index map |	map := '0123456789ABCDEF'.	string := String new: self size * 2. "hex"	index := 0.	1 to: self size do:[:i| 		v := self at: i.		string at: (index := index + 1) put: (map at: (v bitShift: -4) + 1). 		string at: (index := index + 1) put: (map at: (v bitAnd: 15) + 1).	].	^string! !!ByteArray methodsFor: 'initialize' stamp: 'jmv 2/23/2010 12:53'!readHexFrom: aStream	"Initialize the receiver from a hexadecimal string representation"	| map v ch value |	map := '0123456789ABCDEF'.	1 to: self size do: [ :i |		ch := aStream next.		v := (map indexOf: ch) - 1.		 (v between: 0 and: 15) ifFalse: [ ^self error: 'Hex digit expected' ].		value := v bitShift: 4.		ch := aStream next.		v := (map indexOf: ch) - 1.		(v between: 0 and: 15) ifFalse: [ ^self error: 'Hex digit expected' ].		value := value + v.		self at: i put: value.	]! !!ByteArray methodsFor: 'printing' stamp: 'stephane.ducasse 2/1/2009 22:39'!printOn: aStream	aStream nextPutAll: '#['.	self		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $ ].	aStream nextPut: $]! !!ByteArray methodsFor: 'printing' stamp: 'stephane.ducasse 2/1/2009 22:40'!storeOn: aStream	aStream nextPutAll: '#['.	self		do: [ :each | each storeOn: aStream ]		separatedBy: [ aStream nextPut: $ ].	aStream nextPut: $]! !!ByteArray methodsFor: 'testing' stamp: 'stephane.ducasse 2/1/2009 23:10'!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^ true! !!ByteArray class methodsFor: 'instance creation' stamp: 'jmv 2/23/2010 12:57'!readHexFrom: aString	"Create a byte array from an hexadecimal representation        ByteArray readHexFrom: '7A2BD507'                => #[122 43 213 7]	"	^(self new: aString size // 2) readHexFrom: aString readStream! !!ByteArray class reorganize!('byte based hash' hashBytes:startingWith:)('instance creation' readHexFrom:)!!ByteArray reorganize!('accessing' atAllPut: byteAt: byteAt:put: byteSize bytesPerElement)('platform independent access' doubleAt:bigEndian: doubleAt:put:bigEndian: longAt:bigEndian: longAt:put:bigEndian: shortAt:bigEndian: shortAt:put:bigEndian: unsignedLongAt:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:bigEndian: unsignedShortAt:put:bigEndian:)('converting' asByteArray asString base64Encoded hex)('private' asByteArrayPointer defaultElement replaceFrom:to:with:startingAt:)('comparing' hash)('*FFI' booleanAt: booleanAt:put: doubleAt: doubleAt:put: floatAt: floatAt:put: integerAt:put:size:signed: integerAt:size:signed: isExternalAddress pointerAt:put: signedByteAt: signedByteAt:put: signedCharAt: signedCharAt:put: signedLongAt: signedLongAt:put: signedLongLongAt: signedLongLongAt:put: signedShortAt: signedShortAt:put: structAt:length: structAt:put:length: unsignedByteAt: unsignedByteAt:put: unsignedCharAt: unsignedCharAt:put: unsignedLongAt: unsignedLongAt:put: unsignedLongLongAt: unsignedLongLongAt:put: unsignedShortAt: unsignedShortAt:put: voidAt: voidAt:put:)('initialize' readHexFrom:)('printing' printOn: storeOn:)('testing' isLiteral)!