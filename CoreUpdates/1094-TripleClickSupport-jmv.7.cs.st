'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 27 September 2011 at 8:16:18 am'!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickState firstClickDown clickSelector dblClickSelector dragSelector dragThreshold sendMouseButton2Activity buttonDownCount clickCount lastClickTimestamp clickDone doubleClickDone tripleClickSelector '	classVariableNames: 'DoubleClickTimeout '	poolDictionaries: ''	category: 'Morphic-Kernel'!!MouseClickState commentStamp: '<historical>' prior: 0!MouseClickState is a simple class managing the distinction between clicks, double clicks, and drag operations. It has been factored out of HandMorph due to the many instVars.Instance variables:	clickClient 			<Morph>			The client wishing to receive #click:, #dblClick:, or #drag messages	clickState 			<Symbol>			The internal state of handling the last event (#firstClickDown, #firstClickUp, #firstClickTimedOut)	firstClickDown 		<MorphicEvent>	The #mouseDown event after which the client wished to receive #click: or similar messages	clickSelector 		<Symbol>			The selector to use for sending #click: messages	dblClickSelector 	<Symbol>			The selector to use for sending #doubleClick: messages	tripleClickSelector 	<Symbol>			The selector to use for sending #tripleClick: messages!!LightWidget methodsFor: 'meta actions' stamp: 'jmv 9/26/2011 22:33'!mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: (anEvent externalizedFromOwnerOf: self to: nil).	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent externalizedFromOwnerOf: self to: nil)		clkSel: nil		dblClkSel: nil.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!Morph methodsFor: 'event handling' stamp: 'jmv 9/26/2011 22:41'!mouseDown: evt	"Handle a mouse down event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil: [		self eventHandler mouseDown: evt fromMorph: self ]! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 9/26/2011 22:34'!mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: (anEvent externalizedFromOwnerOf: self to: nil).	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent externalizedFromOwnerOf: self to: nil)		clkSel: nil		dblClkSel: nil.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:11'!mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: event].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 9/26/2011 22:33'!mouseButton3Down: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset _ event position - (target externalizePositionFromOwner: target position to: owner).	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		clkSel: #transferHalo:		dblClkSel: nil! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/26/2011 22:33'!waitForClicksOrDrag: aMorph event: evt	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 		^self 		waitForClicksOrDrag: aMorph 		event: evt 		clkSel: #click:		dblClkSel: #doubleClick:! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/27/2011 08:14'!waitForClicksOrDrag: aMorph event: evt  clkSel: clkSel dblClkSel: dblClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: clkSel 			dblClick: dblClkSel			tripleClick: nil			event: evt			sendMouseButton2Activity: false! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/27/2011 08:14'!waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel dblClkSel: dblClkSel tripleClkSel: tripleClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: clkSel 			dblClick: dblClkSel			tripleClick: tripleClkSel			event: evt			sendMouseButton2Activity: true! !!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/26/2011 23:09'!mouseEnter: evt	"The mouse entered the receiver"	owner ifNil: [ ^self ].	owner selectItem: self event: evt! !!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/26/2011 23:15'!handleMouseEnter: anEvent	"System level event handling."	"Do #mouseEnter: even if button down (others, like LayoutAdjustingMorph need the default behavior)"	self wantsBalloon ifTrue: [		anEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].	(self handlesMouseOver: anEvent) ifTrue:[		anEvent wasHandled: true.		self mouseEnter: anEvent ]! !!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/26/2011 23:15'!handleMouseLeave: anEvent	"System level event handling."	"Do #mouseLeave: even if button down (others, like LayoutAdjustingMorph need the default behavior)"	anEvent hand removePendingBalloonFor: self.	(self handlesMouseOver: anEvent) ifTrue: [		anEvent wasHandled: true.		self mouseLeave: anEvent ]! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:15'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| timedOut distance localEvt |	timedOut _ (evt timeStamp - firstClickDown timeStamp) > DoubleClickTimeout.	localEvt _ evt internalizedToOwnerOf: clickClient from: aHand owner.	distance _ (localEvt position - firstClickDown position) r.	evt isMouseDown ifTrue: [		buttonDownCount _ buttonDownCount + 1  ].	evt isMouseUp ifTrue: [		clickCount _ clickCount + 1.		lastClickTimestamp _ evt timeStamp ].	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."	(buttonDownCount = 1 and: [clickCount = 0]) ifTrue: [		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [			aHand resetClickState.			clickClient mouseButton2Activity.			^true ].		"If we have already moved, then it won't be a double or triple click... why wait?"		distance > 0 ifTrue: [			aHand resetClickState.			self click.			^true ]].	"Simple click."	clickCount = 1 ifTrue: [		self click.		"If timedOut or the client's not interested in dbl clicks get outta here"		(timedOut or: [ dblClickSelector isNil or: [ distance > 0 ]]) ifTrue: [			aHand resetClickState.			^true ].		"This means: if a mouseDown, then don't further process this event (so we can turn it into double click on next buttonUp)"		^ evt isMouseDown not ].	"Double click."	(clickCount = 2 and: [ distance = 0 ]) ifTrue: [		self doubleClick.		"If timedOut or the client's not interested intriple clicks get outta here"		(timedOut or: [ tripleClickSelector isNil ]) ifTrue: [			aHand resetClickState.			^true ].		"This means: if a mouseDown, then don't further process this event (so we can turn it into triple click on next buttonUp)"		^ evt isMouseDown not ].		"Triple click"	(clickCount = 3 and: [ distance = 0 ]) ifTrue: [		aHand resetClickState.		self tripleClick.		^true ].	^true! !!MouseClickState methodsFor: 'initialize' stamp: 'jmv 9/27/2011 08:09'!client: aMorph click: aClickSelector dblClick: aDblClickSelector tripleClick: aTripleClickSelector event: firstClickEvent sendMouseButton2Activity: aBoolean	clickClient _ aMorph.	clickSelector _ aClickSelector.	dblClickSelector _ aDblClickSelector.	tripleClickSelector _ aTripleClickSelector.	firstClickDown _ firstClickEvent.	sendMouseButton2Activity _ aBoolean.	buttonDownCount _ 1.	clickCount _ 0.	lastClickTimestamp _ firstClickEvent timeStamp.	clickDone _ false.	doubleClickDone _ false! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/26/2011 22:37'!click	clickDone ifFalse: [		clickSelector ifNotNil: [			clickClient perform: clickSelector with: firstClickDown ].		clickDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/26/2011 22:37'!doubleClick	doubleClickDone ifFalse: [		dblClickSelector ifNotNil: [			clickClient perform: dblClickSelector with: firstClickDown ].		doubleClickDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/27/2011 08:15'!tripleClick	tripleClickSelector ifNotNil: [		clickClient perform: tripleClickSelector with: firstClickDown ]! !!MouseEvent methodsFor: 'testing' stamp: 'ar 10/5/2000 19:43'!isDraggingEvent	source ifNil:[^false].	source hasSubmorphs ifTrue:[^true].	self anyButtonPressed ifTrue:[^true].	^false! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:12'!mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event hand newKeyboardFocus: self.	self handleInteraction: [		editor mouseDown: event index: (self characterIndexAtPoint: event position) ].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:10'!mouseDown: event	"Handle a mouse down event."	| grabbedMorph |	grabbedMorph _ self morphToGrab: event.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		^event hand grabMorph: grabbedMorph].	event mouseButton2Pressed ifTrue: [^self mouseButton2Activity].	super mouseDown: event.	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: event		clkSel: #click:		dblClkSel: #doubleClick:		tripleClkSel: nil! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:12'!mouseDown: event	event mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].	isPressed _ true.	self redrawNeeded.	actWhen == #buttonDown ifTrue: [		self performAction ].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:13'!mouseDown: event	event mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue: [		scroller submorphs last mouseDown:			(event internalizedTo: scroller from: self)].	event hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/27/2011 08:10'!mouseDown: evt	| row |	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: evt		clkSel: #click:		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])		tripleClkSel: nil! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:12'!mouseDown: event	| oldIndex oldVal row w |	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row _ self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	w _ self ownerThatIsA: SystemWindow.	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 9/27/2011 08:10'!mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph internalizePositionToOwner: evt position from: self)])		ifTrue:[^self toggleExpandedState: aMorph event: evt]. 	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: evt 		clkSel: #click:		dblClkSel: nil		tripleClkSel: nil! !MouseClickState removeSelector: #afterFirstClickDownHandleEvent:from:!MouseClickState removeSelector: #afterFirstClickTimedOutHandleEvent:from:!MouseClickState removeSelector: #afterFirstClickUpOutHandleEvent:from:!MouseClickState removeSelector: #afterSecondClickDownHandleEvent:from:!MouseClickState removeSelector: #client:click:dblClick:drag:event:sendMouseButton2Activity:!MouseClickState removeSelector: #client:click:dblClick:event:sendMouseButton2Activity:!MouseClickState removeSelector: #drag:!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient firstClickDown clickSelector dblClickSelector tripleClickSelector sendMouseButton2Activity buttonDownCount clickCount lastClickTimestamp clickDone doubleClickDone'	classVariableNames: 'DoubleClickTimeout'	poolDictionaries: ''	category: 'Morphic-Kernel'!!MenuItemMorph reorganize!('accessing' arguments arguments: contentString contentString: contents: contents:withMarkers: contents:withMarkers:inverse: hasIcon hasIconOrMarker hasMarker hasSubMenu icon icon: isEnabled isEnabled: selector selector: subMenu subMenu: target target:)('drawing' drawOn:)('events' activateOwnerMenu: activateSubmenu: deselectTimeOut: handleMouseUp: handlesMouseDown: handlesMouseOver: invokeWithEvent: mouseDown: mouseEnter: mouseLeave: mouseUp:)('grabbing' aboutToBeGrabbedBy: duplicateMorph:)('initialization' defaultBounds deleteIfPopUp: initialize)('layout' iconSeparation measureContents minItemWidth)('selecting' deselect: isSelected: select:)('private' offImage onImage)('events-processing' handleMouseEnter: handleMouseLeave:)!HandMorph removeSelector: #waitForClicksOrDrag:event:clkSel:dblClkSel:dragSel:!HandMorph removeSelector: #waitForClicksOrDragOrSimulatedMouseButton2:event:clkSel:dblClkSel:!HandMorph removeSelector: #waitForClicksOrDragOrSimulatedMouseButton2:event:clkSel:dblClkSel:dragSel:!HandMorph removeSelector: #waitForSimulatedMouseButton2:event:dblClkSel:!