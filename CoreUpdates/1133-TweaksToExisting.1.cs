'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 14 November 2011 at 3:33:18 pm'!!classDefinition: #IndentingListItemMorph category: #'Morphic-Views for Models'!StringMorph subclass: #IndentingListItemMorph	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 11/10/2011 16:44'!          paragraphNEW: aParagraph bounds: boundsInWorld color: c	| scanner |	"eventualmente matar el otro, y dejar este..."self flag: #jmvVer.	self setPaintColor: c.	scanner _ DisplayScanner new 		text: aParagraph paragraphText		foreground: (shadowColor ifNil: [ c ])		ignoreColorChanges: self isShadowDrawing."Lo que pasa es que el origen esta mal puesto. Eso aun no lo arregle!!ver #copyOffset:clipRect:Esto deberia ser parte ya de lo que arregle la otra vez para matar el TransformMorph... Quizas sea ya el momento de revivir eso.""origin = (0@0) ifFalse: [	form print.	origin print ].""Porque los bounds son del world ahora"	"original"	"scanner setPort: (port clippedBy: (boundsInWorld translateBy: origin))."	"ahora. El clippingRect est es el usado para el texto"	scanner setPort: (port clippedBy: (boundsInWorld))."original""	(self copyClipRect: bounds)""ahora. El clipping lo quiere en coordenadas globales. BoundsInWorld deberia estar en ellas!!""Este clipping es el usado para la seleccion""	(self copyClipRect: (boundsInWorld translateBy: origin negated))""experim"	(self copyClipRect: boundsInWorld)		displayNEW: aParagraph 		using: scanner		in: boundsInWorld! !!FormCanvas methodsFor: 'private - drawing text' stamp: 'jmv 11/10/2011 18:16'!                          displayNEW: aParagraph using: displayScanner in: boundsInWorld	"Send all visible lines to the displayScanner for display"	|  leftInRun line |	"eventualmente matar el otro, y dejar este..."self flag: #jmvVer.	leftInRun _ 0.	(aParagraph lineIndexForPoint: 0@0)		to: (aParagraph lineIndexForPoint: boundsInWorld extent)		do: [ :i |			line _ aParagraph lines at: i.			aParagraph displaySelectionInLineNEW: line on: self paragraphTopLeft: boundsInWorld topLeft.			leftInRun _ displayScanner displayLine: line paragraphTopLeft: boundsInWorld topLeft leftInRun: leftInRun ]! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 08:34'!          bottom	self flag: #jmvVer. "Eliminar"	^bounds bottom! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 14:55'!                       desiredWidth	^(indentLevel * 12) + 12 + (self font widthOfStringOrText: self contents) + 10! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 08:34'!                left	self flag: #jmvVer. "Eliminar"	^bounds left! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 08:34'!                           right	self flag: #jmvVer. "Eliminar"	^bounds right! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 08:34'!                         top	self flag: #jmvVer. "Eliminar"	^bounds top! !!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 11/11/2011 10:31'! displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor x1 isBold isItalic x0 h w halfW r |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].self flag: #jmvVer. "Aca, x0 y x1 son en coordenadas globales o locales???"	x0 < halfW ifTrue: [		x1 _ x1 - x0 + halfW.		x0 _ halfW ].	r _ bounds right-halfW-1.	r < x1 ifTrue: [		x0 _ x0 + r - x1.		x1 _ r.		].	caretRect _ x0-halfW@ top corner: x1+halfW+1 @ bottom.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/14/2011 15:32'!              displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas paragraphTopLeft: paragraphTopLeft	| caretColor x1 isBold isItalic x0 h w halfW r newCaretRect |"eventualmente matar el otro, y dejar este..."self flag: #jmvVer.	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].	x0-paragraphTopLeft x < halfW ifTrue: [		x1 _ x1 - x0 + halfW+paragraphTopLeft x.		x0 _ halfW+paragraphTopLeft x ].	r _ extentForComposing x-halfW-1.	r < (x1-paragraphTopLeft x) ifTrue: [		x0 _ x0 + r - x1+paragraphTopLeft x.		x1 _ r +paragraphTopLeft x].	lastCaretRectNeedsRedraw _ false.	newCaretRect _ x0-halfW@ top corner: x1+halfW+1 @ (bottom+1).	lastCaretRect ifNotNil: [		lastCaretRect = newCaretRect ifFalse: [			"If we are actually drawing the last position of the text cursor,			but not the current one, request redraw."			((aCanvas isVisible: lastCaretRect) and: [(aCanvas isFullyVisible: newCaretRect) not ])				ifTrue: [					lastCaretRectNeedsRedraw _ true ]]].	lastCaretRect _ newCaretRect.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/10/2011 16:49'!                           displaySelectionInLineNEW: line on: aCanvas paragraphTopLeft: paragraphTopLeft "eventualmente matar el otro, y dejar este..."self flag: #jmvVer.	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |		self displaySelectionStartBlockNEW: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft ]! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/14/2011 09:53'!                      displaySelectionStartBlockNEW: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft 	| leftX rightX idx caretFont t b caretAttributes |"eventualmente matar el otro, y dejar este..."self flag: #jmvVer.	startBlock ifNil: [^self].	"No selection"	startBlock = stopBlock 		ifTrue: [			"Only show caret on line where clicked"			startBlock textLine first = line first ifFalse: [				^self ].			leftX _ paragraphTopLeft x + startBlock left.			idx _ startBlock stringIndex.			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].			caretFont _ caretAttributes				ifNil: [ model actualContents fontAt: idx ]				ifNotNil: [ model actualContents fontIfApplying: caretAttributes ].			b _ paragraphTopLeft y + line top + line baseline + caretFont descent-1.			t _ paragraphTopLeft y + line top + line baseline - caretFont ascent.			showCaret ifTrue: [				self					displayInsertionMarkAtX: leftX					top: t					bottom: b					emphasis: caretFont emphasis					on: aCanvas					paragraphTopLeft: paragraphTopLeft ]]		ifFalse: [			"Test entire selection before or after here"			(stopBlock stringIndex < line first 				or: [startBlock stringIndex > (line last + 1)])					ifTrue: [^self].	"No selection on this line"			(stopBlock stringIndex = line first 				and: [stopBlock textLine ~= line])					ifTrue: [^self].	"Selection ends on line above"			(startBlock stringIndex = (line last + 1) 				and: [stopBlock textLine ~= line])					ifTrue: [^self].			lastCaretRect _ nil.			lastCaretRectNeedsRedraw _ false.			leftX _  paragraphTopLeft x + (startBlock stringIndex < line first 				ifTrue: [ line ]				ifFalse: [ startBlock ]) left.			rightX _  paragraphTopLeft x + ((stopBlock stringIndex > (line last + 1) or: [					stopBlock stringIndex = (line last + 1) 						and: [stopBlock textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [stopBlock left]).			aCanvas				fillRectangle: (leftX @ (line top +  paragraphTopLeft y) corner: rightX @ (line bottom +  paragraphTopLeft y))				colorOrInfiniteForm: self selectionColor].	"Selection begins on line below"! !PluggableListMorph removeSelector: #itemFromPoint:!PluggableListMorph removeSelector: #setSelectedMorph:!