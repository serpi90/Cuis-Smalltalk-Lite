'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 4 November 2011 at 5:14:09 pm'!!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'jmv 11/4/2011 16:41'!                            fileReaderServicesForFile: fullName suffix: suffix	^(suffix = 'st' or: [ suffix = 'cs' or: [ suffix = '*']])		ifTrue: [ self services]		ifFalse: [#()]! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'jmv 11/4/2011 16:43'!                      installChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fileName stream |	fullName ifNil: [^ Beeper beep].	fileName _ fullName.	(fullName endsWith: '.gz')		ifTrue: [			(self confirm: ('{1}appears to be a compressed file.Do you want to uncompress it?' format: { fullName }))				ifFalse: [ ^self ]				ifTrue: [					fileName _ GZipReadStream saveContents: fullName.					stream _ FileStream readOnlyFileNamed: fileName ]]		ifFalse: [			stream _ FileStream readOnlyFileNamed: fileName ].	self newChangesFromStream: stream named: (FileDirectory localNameFor: fileName)! !!CodeFile methodsFor: 'initialize' stamp: 'jmv 11/4/2011 16:52'!                   fromFileNamed: aName	| stream |	fullName_ aName.	stream _ FileStream readOnlyFileNamed: aName.	[ self fileInFrom: stream ] ensure: [ stream close ]! !!CodeFile methodsFor: 'reading' stamp: 'jmv 11/4/2011 16:52'!      fileInFrom: aStream	| chgRec changes |	changes _ (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.	('Processing ', self name) 		displayProgressAt: Sensor mousePoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbol with: chgRec.			].		]! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 11/4/2011 16:41'!                               fileReaderServicesForFile: fullName suffix: suffix	(FileStream isSourceFileSuffix: suffix)		ifTrue: [ ^ { self serviceBrowseCode } ].	suffix = 'mcz'		ifTrue: [ ^ { self serviceBrowseMCZCode. self serviceInstallMonticelloPackage } ].	(fullName endsWith: 'cs.gz')		ifTrue: [ ^ { self serviceBrowseCompressedCode } ].	suffix = 'pck'		ifTrue: [ ^ { self serviceBrowseCode. self serviceInstallPackage } ].	^#()! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 11/4/2011 16:41'!    installMonticelloPackage: aStream	CodeFileBrowserWindow installMonticelloPackageStream: aStream! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 11/4/2011 17:01'!     serviceInstallMonticelloPackage	"Answer the service of installing a PackageFile (a chunk format file for a PackageInfo)"	^ (SimpleServiceEntry		provider: self 		label: 'install Monticello package'		selector: #installMonticelloPackage:		description: 'install the Monticello package, replacing all existing code in the package (if any); create a new change set just for the installation'		buttonLabel: 'install package')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 11/4/2011 16:52'!    browseStream: aStream named: aString	| codeFile organizer browser |	Cursor wait showWhile: [		organizer _ SystemOrganizer defaultList: Array new.		codeFile _ (CodeFile new fullName: aString; fileInFrom: aStream).		aStream close.		organizer 			classifyAll: codeFile classes keys 			under: codeFile name.		(browser _ CodeFileBrowser new)			systemOrganizer: organizer;			codeFile: codeFile].	CodeFileBrowserWindow open: browser label: 'Code File Browser'! !!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 11/4/2011 16:57'!                         installMonticelloPackageStream: aStream		| stream fullName localName pkName |	fullName _ aStream name.	localName _ FileDirectory localNameFor: fullName.	pkName _ localName sansPeriodSuffix.	stream _ aStream asUnZippedStream: 'snapshot/source.st'.	stream ascii.	Cursor wait showWhile: [		PackageFile			installFileStream: stream			packageName: pkName			fullName: fullName ]! !!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 11/4/2011 16:58'!          installPackageStream: aStream	| fullName localName pkName |	fullName _ aStream name.	localName _ FileDirectory localNameFor: fullName.	pkName _ localName sansPeriodSuffix.	Cursor wait showWhile: [		PackageFile			installFileStream: aStream			packageName: pkName			fullName: fullName ]! !!FileStream class methodsFor: 'file reader services' stamp: 'jmv 11/4/2011 16:44'!  fileIn: fullName	"File in the entire contents of the file specified by the name provided"	| fileName stream |	fullName ifNil: [^ Beeper beep].	fileName _ fullName.	(fullName endsWith: '.gz')		ifTrue: [			(self confirm: ('{1}appears to be a compressed file.Do you want to uncompress it?' format:{fullName}))				ifFalse: [ ^self ]				ifTrue: [					fileName _ GZipReadStream saveContents: fullName.					stream _ FileStream readOnlyFileNamed: fileName ]]		ifFalse: [			stream _ FileStream readOnlyFileNamed: fileName ].	stream fileIn! !!FileStream class methodsFor: 'file reader services' stamp: 'jmv 11/4/2011 16:41'!      fileReaderServicesForFile: fullName suffix: suffix	"Answer services for the given file"	^ (self isSourceFileSuffix: suffix)		ifTrue: [ {self serviceFileIn} ]		ifFalse: [ #() ]! !!PackageFile methodsFor: 'initialize' stamp: 'jmv 11/4/2011 17:14'!  installFileStream: aFileStream packageName: pkName fullName: fullFileName	| oldChangeSet |	packageName _pkName.	fullName _fullFileName.	packageInMemory _ (PackageInfo named: packageName).		oldChangeSet _ ChangeSet current.	[		self fileInFrom: aFileStream.		aFileStream reset.		self install: aFileStream.	] ensure: [		ChangeSet newChanges: oldChangeSet.		aFileStream close ]! !!PackageFile methodsFor: 'services' stamp: 'jmv 11/4/2011 17:04'!                      install: aFileStream	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."	| localName newChangeSet 	classesDefined classesExtended	classesToDelete classesToDeleteButCant classesToReallyDelete	methodsToRemove	|		"Compute stuff no longer in package: Should be removed from system."	classesDefined _ Set new.	classesExtended _ Set new.	self classes do: [ :pseudoClass |		pseudoClass hasDefinition			ifTrue: [ classesDefined add: pseudoClass name ]			ifFalse: [ classesExtended add: pseudoClass name ]].	classesToDelete _ (packageInMemory classes asSet collect: [ :each | each name ]) difference: classesDefined.	"Add here:		- classes in classesToDelete, that #allCallsOn answers selectors that aren't in classesToDelete or methodsToRemove		- classes with #subclasses that aren't in classesToDelete.		- classes with existing instances (#instanceCount)? Not really sure... Maybe sole instance referenced from classVar or such...		- something else I forgot?	Warning: This search for stuff that can't be removed must be iterated again until it doesn't find any more."	classesToDeleteButCant _ classesToDelete intersection: classesExtended.	classesToReallyDelete _ classesToDelete difference: classesToDeleteButCant.	"Methods. Could also mean classes that can't be deleted!! (include in the iteration)	Warn if deleting last implementor of sent messages?"	methodsToRemove _ packageInMemory methods asSet difference: self allMethodReferences.	methodsToRemove _ methodsToRemove reject: [ :methodReference | classesToReallyDelete includes: methodReference classSymbol ].	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."	'=============' print.	('classesToDelete: ', classesToDelete printString) print.	('classesToDeleteButCant: ', classesToDeleteButCant printString) print.	('classesToReallyDelete: ', classesToReallyDelete printString) print.	'=============' print.	'methodsToRemove: ' print.	methodsToRemove do: [ :methodReference | methodReference print ].	'=============' print.		"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"	"These were created in #fromFileStream: ... reuse?"	localName _ FileDirectory localNameFor: fullName.	newChangeSet _ ChangeSorter basicNewChangeSetLike: 'install package ', localName.	newChangeSet ifNotNil: [		ChangeSet newChanges: newChangeSet.		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].		classesToDelete do: [ :className | (Smalltalk at: className) removeFromSystem ].		Transcript cr; show: 'Package ', packageName, ' successfully installed'; cr].		"Tirar undeclared al transcript. warning si quedaron undeclared	Es feo que tire an transcript undeclareds que despues no lo son..."	Undeclared removeUnreferencedKeys.	Undeclared print.	"Crear, instalar y devolver una instancia de PackageInfo. Descartar la instancia de PackageFile"! !!PackageFile class methodsFor: 'instance creation' stamp: 'jmv 11/4/2011 16:53'!  installFileStream: aFileStream packageName: pkName fullName: fullFileName	^self new installFileStream: aFileStream packageName: pkName fullName: fullFileName! !PackageFile class removeSelector: #fromFileStream:!PackageFile class removeSelector: #fromFileStream:packageName:fullName:!PackageFile removeSelector: #fromFileStream:!PackageFile removeSelector: #fromFileStream:packageName:fullName:!PackageFile removeSelector: #install!