'From Cuis 2.0 of 12 February 2010 [latest update: #418] on 19 February 2010 at 2:53:03 pm'!!Debugger methodsFor: 'private' stamp: 'jmv 2/19/2010 13:03'!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [ :c | c terminateTimerProcess ].	contents _ nil. 	interruptedProcess _ aProcess.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	errorWasInUIProcess _ false! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 2/19/2010 14:49'!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay time0 |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats _ Smalltalk getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer _ [		[true] whileTrue: [			| startTime observedProcess |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer _ nil ].		"Collect gc statistics"		Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 2/19/2010 14:50'!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess _ Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats _ Smalltalk getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer _ [		[ true ] whileTrue: [			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer _ nil ].		"Collect gc statistics"		Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 2/19/2010 14:44'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess _ aProcess.	myDelay _ Delay forMilliseconds: millisecs.	time0 _ Time millisecondClockValue.	endTime _ time0 + msecDuration.	sem _ Semaphore new.	gcStats _ Smalltalk getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer _ [			[				| startTime |				startTime _ Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess ifTrue: [ observedProcess ] ifFalse: [nil])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal | 		gcStats at: idx put: (gcVal - gcStats at: idx)].	time _ Time millisecondClockValue - time0! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 2/19/2010 14:41'!spyAllOn: aBlock	"Spy on all the processes in the system		[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]		"	| node result |	node _ self new.	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.	(CodeHolder new contents: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 2/19/2010 14:41'!spyOn: aBlock reportOtherProcesses: aBoolean	"	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true	"	| node result |	node _ self new.	node reportOtherProcesses: aBoolean.	result _ node spyEvery: self defaultPollPeriod on: aBlock.	(CodeHolder new contents: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 2/19/2010 14:41'!spyOn: aBlock toFileNamed: fileName reportOtherProcesses: aBoolean	"Spy on the evaluation of aBlock. Write the data collected on a file	named fileName."	| file value node |	node _ self new.	node reportOtherProcesses: aBoolean.	value _ node spyEvery: self defaultPollPeriod on: aBlock.	file _ FileStream newFileNamed: fileName.	node report: file.	file close.	^value! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 2/19/2010 14:41'!spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean	"	Spy on aProcess for a certain amount of time	| p1 p2 |  	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.	p1 resume.	p2 resume.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true	"	| node |	node _ self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	(CodeHolder new		contents: (String				streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 2/19/2010 14:41'!spyOnProcess: aProcess forMilliseconds: msecDuration toFileNamed: fileName reportOtherProcesses: aBoolean	"Spy on the evaluation of aProcess. Write the data collected on a file  	named fileName. Will overwrite fileName"	| file node |	node _ self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	file _ FileStream fileNamed: fileName.	node report: file.	file close! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 2/19/2010 14:41'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [ :current |			current == prev ifFalse: [ "call or return"				prev sender == nil ifFalse: [ "call only"					(receiver == nil or: [ current receiver == receiver ])						ifTrue: [ tallies tally: current by: 1 ]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(CodeHolder new contents:		(String streamContents: [ :s |			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ]]))		openLabel: 'Spy Results' wrap: false! !!MessageTally class methodsFor: 'private' stamp: 'jmv 2/19/2010 14:43'!terminateTimerProcess	Timer ifNotNil: [ Timer terminate ].	Timer _ nil! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 2/19/2010 14:42'!runBlock: aBlock pollingEvery: pollPeriod 	| stream list result |	block := MessageSend 				receiver: self				selector: #runBlock:pollingEvery:				arguments: { 						aBlock.						pollPeriod}.	"so we can re-run it"	tally := MessageTally new.	tally		reportOtherProcesses: false;		maxClassNameSize: 1000;		maxClassPlusSelectorSize: 1000;		maxTabs: 100.	result := tally spyEvery: pollPeriod on: aBlock.	stream := ReadWriteStream 				with: (String streamContents: [ :s | 					tally report: s]).	stream reset.	list := OrderedCollection new.	[stream atEnd] whileFalse: [list add: stream nextLine].	self initializeMessageList: list.	self changed: #messageList.	self changed: #messageListIndex.	^result! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 2/19/2010 14:42'!runProcess: aProcess forMilliseconds: msecDuration pollingEvery: pollPeriod 	| stream list result |	block := MessageSend 				receiver: self				selector: #runProcess:forMilliseconds:pollingEvery: 				arguments: { 						aProcess.						msecDuration.						pollPeriod}.	"so we can re-run it"	tally := MessageTally new.	tally		reportOtherProcesses: false;		maxClassNameSize: 1000;		maxClassPlusSelectorSize: 1000;		maxTabs: 100.	result := tally 				spyEvery: pollPeriod				onProcess: aProcess				forMilliseconds: msecDuration.	stream := ReadWriteStream 				with: (String streamContents: [ :s | 							tally report: s]).	stream reset.	list := OrderedCollection new.	[stream atEnd] whileFalse: [list add: stream nextLine].	self initializeMessageList: list.	self changed: #messageList.	self changed: #messageListIndex.	^result! !MessageTally removeSelector: #close!MessageTally removeSelector: #closeTally!