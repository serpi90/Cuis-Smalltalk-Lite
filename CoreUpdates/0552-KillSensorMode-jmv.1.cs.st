'From Cuis 2.6 of 10 August 2010 [latest update: #540] on 23 August 2010 at 11:25:18 am'!!NewHandleMorph methodsFor: 'stepping and presenter' stamp: 'jmv 8/23/2010 11:20'!step	| ev |	ev _ hand lastEvent.	ev anyButtonPressed		ifTrue: [			waitingForClickInside _ false.			self position: ev cursorPoint - (self extent // 2).			pointBlock value: self center ]		ifFalse: [			waitingForClickInside				ifTrue: [					(self containsPoint: ev cursorPoint) ifFalse: [						"mouse wandered out before clicked"						^ self delete ]]				ifFalse: [					lastPointBlock value: self center.					^ self delete ]].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 8/23/2010 11:23'!spawnPaneFrameHandle: event 	| resizer localPt side growingPane newBounds adjoiningPanes limit cursor |	(self world firstSubmorph isKindOf: NewHandleMorph) 		ifTrue: [^self	"Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight + 4) 		containsPoint: event cursorPoint) 			ifTrue: [^self	"in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s]				near: event cursorPoint.	growingPane ifNil: [^self].	"don't resize pane side coincident with window side - RAA 5 jul 2000"	(growingPane perform: side) = (self innerBounds perform: side) 		ifTrue: [^self].	(side == #top and: [growingPane top = self panelRect top]) ifTrue: [^self].	adjoiningPanes _ paneMorphs 				select: [ :pane | pane bounds bordersOn: growingPane bounds along: side ].	limit _ adjoiningPanes isEmpty 				ifFalse: [					(adjoiningPanes collect: [:pane | pane bounds perform: side]) 						perform: ((#(#top #left) includes: side) ifTrue: [#max] ifFalse: [#min])]				ifTrue: [ bounds perform: side].	cursor _ Cursor resizeForEdge: side.	resizer _ NewHandleMorph new				followHand: event hand					forEachPointDo: [ :p | 						localPt _ self internalizePositionFromWorld: p.						newBounds _ growingPane bounds 							withSideOrCorner: side							setToPoint: localPt							minExtent: 40 @ self minPaneHeightForReframe							limit: limit.						self fastFramingOn 							ifTrue: [								"For fast display, only higlight the rectangle during loop"								Cursor currentCursor == cursor 									ifFalse: [										event hand											visible: false;											refreshWorld;											visible: true.										cursor show].								newBounds _ growingPane bounds newRectButtonPressedDo: [ :f | 									growingPane bounds 										withSideOrCorner: side										setToPoint: (self internalizePositionFromWorld: Sensor cursorPoint)										minExtent: 40 @ self minPaneHeightForReframe										limit: limit ]].								self 									reframePanesAdjoining: growingPane									along: side									to: newBounds]					lastPointDo: [:p | ]					withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 8/23/2010 11:24'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds cursor |	owner ifNil: [^self	"Spurious mouseLeave due to delete"].	self isCollapsed ifTrue: [^self].	((self world ifNil: [^self]) firstSubmorph isKindOf: NewHandleMorph) 		ifTrue: [^self	"Prevent multiple handles"].	pt _ event cursorPoint.	"prevent spurios mouse leave when dropping morphs"	owner 		morphsInFrontOf: self		overlapping: (pt - 2 extent: 4 @ 4)		do: [:m | (m is: #HandMorph) ifFalse: [(m fullContainsPoint: pt) ifTrue: [^self]]].	bounds forPoint: pt		closestSideDistLen: [ :side :dist :len | 			"Check for window side adjust"			dist <= 2 ifTrue: [ptName _ side]].	ptName ifNil: ["Check for pane border adjust"			^self spawnPaneFrameHandle: event].	#(#topLeft #bottomRight #bottomLeft #topRight) do: [ :corner | 			"Check for window corner adjust"			(pt dist: (bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	cursor _ Cursor resizeForEdge: ptName.	resizer _ NewHandleMorph new				followHand: event hand					forEachPointDo: [ :p | 						localPt _ self internalizePositionFromWorld: p.						newBounds _ bounds 									withSideOrCorner: ptName									setToPoint: localPt									minExtent: self minimumExtent.						self fastFramingOn 							ifTrue: [								Cursor currentCursor == cursor 									ifFalse: [										event hand											visible: false;											refreshWorld;											visible: true.										cursor show].								self doFastWindowReframe: ptName]							ifFalse: [								self bounds: newBounds]]					lastPointDo: [ :p | ]					withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !NewHandleMorph removeSelector: #sensorMode!NewHandleMorph removeSelector: #sensorMode:!