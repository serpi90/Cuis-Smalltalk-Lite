'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 8 December 2011 at 11:37:32 pm'!!classDefinition: #ChangeListElement category: #'Tools-Changes'!Object subclass: #ChangeListElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeListElement commentStamp: '<historical>' prior: 0!                             I am the superclass of elements of a ChangeList. My subinstances are built from fileout files.!!classDefinition: #ChangeRecord category: #'Tools-Changes'!ChangeListElement subclass: #ChangeRecord	instanceVariableNames: 'file position type class category meta stamp '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #ClassDeletionChangeRecord category: #'Tools-Changes'!ChangeListElement subclass: #ClassDeletionChangeRecord	instanceVariableNames: 'clsName'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!ClassDeletionChangeRecord commentStamp: '<historical>' prior: 0!                        Polymorphic with ChangeRecord. Used to represent classes that are not part of a PackageFile, but are part of the corresponding PackageInfo: Classes that will be deleted on install.!!classDefinition: #MethodDeletionChangeRecord category: #'Tools-Changes'!ChangeListElement subclass: #MethodDeletionChangeRecord	instanceVariableNames: 'methodReference'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!MethodDeletionChangeRecord commentStamp: '<historical>' prior: 0!               Polymorphic with ChangeRecord. Used to represent methods that are not part of a PackageFile, but are part of the corresponding PackageInfo: Methods that will be deleted on install.!!classDefinition: #PackageFile category: #'Package Support'!CodeFile subclass: #PackageFile	instanceVariableNames: 'packageName packageInMemory classesToRemove methodsToRemove '	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!PackageFile commentStamp: '<historical>' prior: 0!                    Polymorphic with ChangeRecord. Used to represent methods that are not part of a PackageFile, but are part of the corresponding PackageInfo: Methods that will be deleted on install.!!ChangeList methodsFor: 'scanning' stamp: 'jmv 12/8/2011 22:41'!       scanCategory	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp isComment anIndex def isMeta name record methodReference |	itemPosition _ file position.	item _ file nextChunk.	isComment _ (item includesSubString: 'commentStamp:').	(isComment or: 	[item includesSubString: 'methodsFor:'] or: 	[item includesSubString: 'classDefinition:'] or: 	[item includesSubString: 'classRemoval:'] or: 	[item includesSubString: 'methodRemoval:']) ifFalse: [		"Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 160)].	tokens _ Smalltalk actualScannerClass new scanTokens: item.	tokens size >= 2 ifTrue: [		stamp _ ''.		anIndex _ tokens indexOf: #stamp: ifAbsent: nil.		anIndex ifNotNil: [stamp _ tokens at: (anIndex + 1)].		tokens first == #classDefinition: ifTrue: [			itemPosition _ file position.			isMeta _ tokens second includesSubString: ' class'.			name _ isMeta ifTrue: [tokens second substrings first] ifFalse: [tokens second].			def _ file nextChunk.			record _ ChangeRecord new file: file position: itemPosition type: #classDefinition				class: name asSymbol category: tokens last meta: isMeta stamp: nil.			self addItem: record text: 'classDefinition: ', def.			^file skipStyleChunk ].		tokens first == #classRemoval: ifTrue: [			itemPosition _ file position.			item _ file nextChunk.			item size > 0 ifTrue: [				"Ojo. El doIt se puede ejecutar, hacer fileOut, etc... Que conviene mas?!!"				self 					addItem: (ClassDeletionChangeRecord new clsName: tokens second)					text: 'class removal: ', tokens second ].			^file skipStyleChunk ].		tokens first == #methodRemoval: ifTrue: [			itemPosition _ file position.			item _ file nextChunk.			item size > 0 ifTrue: [				isMeta _ tokens third == #class.				isMeta ifTrue: [tokens second substrings first] ifFalse: [tokens second].				methodReference _ (MethodReference new					setClassSymbol: tokens second					classIsMeta: isMeta					methodSymbol: tokens last					stringVersion: tokens second, ' ', (isMeta ifTrue: ['class '] ifFalse: ['']), tokens last) .				"Ojo. El doIt se puede ejecutar, hacer fileOut, etc... Que conviene mas?!!"				self					addItem: (MethodDeletionChangeRecord new methodReference: methodReference)					text: 'method removal: ', methodReference asStringOrText ].			^file skipStyleChunk ].				tokens second == #methodsFor: ifTrue: [			^ self scanCategory: tokens third class: tokens first meta: false stamp: stamp].		tokens third == #methodsFor: ifTrue: [			^ self scanCategory: tokens fourth class: tokens first meta: true stamp: stamp]].	tokens second == #commentStamp:		ifTrue: [			stamp _ tokens third.			self addItem:					(ChangeRecord new file: file position: file position type: #classComment									class: tokens first category: nil meta: false stamp: stamp)					text: 'class comment for ' , tokens first, 						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).			file nextChunk.			^ file skipStyleChunk]! !!ChangeList methodsFor: 'scanning' stamp: 'jmv 12/7/2011 17:58'!           scanFile: aFile from: startPosition to: stopPosition	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.	'Scanning ', aFile localName, '...'		displayProgressAt: Sensor mousePoint		from: startPosition to: stopPosition		during: [:bar |			[file position < stopPosition] whileTrue: [ | prevChar |				bar value: file position.				[file atEnd not and: [file peek isSeparator]]					whileTrue: [prevChar _ file next].				(file peekFor: $!!)					ifTrue: [						(prevChar = Character cr or: [prevChar = Character lf])							ifTrue: [self scanCategory]]					ifFalse: [						| itemPosition item |						itemPosition _ file position.						item _ file nextChunk.						file skipStyleChunk.						item size > 0 ifTrue: [							self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)								text: 'do it: ' , (item contractTo: 160)]]]].	self clearSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/7/2011 17:57'!                     removeDoIts	"Remove doits from the receiver, other than initializes. 1/26/96 sw"	Cursor wait showWhile: [		| newChangeList newList |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		changeList with: list do: [ :chRec :str |			(chRec type ~~ #doIt or: [str endsWith: 'initialize'])				ifTrue: [					newChangeList add: chRec.					newList add: str]].		newChangeList size < changeList size			ifTrue: [				changeList _ newChangeList.				list _ newList.				listIndex _ 0.				self clearSelections ].	].	self changed: #list.	! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/7/2011 17:57'! removeEmptyClassComments	Cursor wait showWhile: [		| newChangeList newList |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		changeList with: list do: [ :chRec :strNstamp | | keep |			keep _ true.			(chRec type == #classComment and: [					Smalltalk includesKey: chRec methodClassName]) ifTrue: [				keep _ chRec text notEmpty			].			keep ifTrue:[				newChangeList add: chRec.				newList add: strNstamp]].		newChangeList size < changeList size ifTrue: [			changeList _ newChangeList.			list _ newList.			listIndex _ 0.			self clearSelections ].	].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/7/2011 23:22'!                removeExistingMethodVersions	"Remove all up to date version of entries from the receiver"	"Modified to also remove up to date classDefinitions and classComments"	Cursor wait showWhile: [		| newChangeList newList |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		changeList with: list do: [ :chRec :strNstamp | | keep cls name |			keep _ chRec isClassDeletion not or: [ chRec methodClass notNil ]. "If a class deletion, and class already gone, don't keep it"			keep ifTrue: [				(cls _ chRec methodClass) ifNotNil: [ | sel str |					str _ chRec string.					sel _ chRec methodSelector.					keep _ (cls sourceCodeAt: sel ifAbsent:['']) asString ~= str.				].			].			(chRec type == #classComment and: [					name _ chRec methodClassName.					Smalltalk includesKey: name]) ifTrue: [				cls _ Smalltalk at: name.				keep _ cls organization classComment ~= chRec text.			].			(chRec type == #classDefinition and: [					name _ chRec methodClassName.					Smalltalk includesKey: name]) ifTrue: [				cls _ Smalltalk at: name.				chRec isMetaClassChange ifTrue: [ cls _ cls class ].				keep _ cls definition ~= chRec text.			].			keep ifTrue:[				newChangeList add: chRec.				newList add: strNstamp]].		newChangeList size < changeList size ifTrue: [			changeList _ newChangeList.			list _ newList.			listIndex _ 0.			self clearSelections ].	].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/7/2011 17:57'!             removeNonSelections	"Remove the unselected items from the receiver."	| newChangeList newList |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	1 to: changeList size do: [ :i | 		(listSelections at: i) ifTrue: [			newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size = 0 ifTrue: [		^ self inform: 'That would remove everything.Why would you want to do that?'].	newChangeList size < changeList size		ifTrue: [			changeList _ newChangeList.			list _ newList.			listIndex _ 0.			self clearSelections ].	self changed: #list	! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/7/2011 17:57'!                           removeOlderMethodVersions	"Remove older versions of entries from the receiver."	Cursor wait showWhile: [		| newChangeList newList found |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		found _ OrderedCollection new.		changeList reverseWith: list do: [ :chRec :strNstamp | | str |			str _ strNstamp copyUpTo: $;.			(found includes: str) ifFalse: [				found add: str.				newChangeList add: chRec.				newList add: strNstamp]].		newChangeList size < changeList size ifTrue: [			changeList _ newChangeList reversed.			list _ newList reversed.			listIndex _ 0.			self clearSelections ].	].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/7/2011 17:58'!           removeSelections	"Remove the selected items from the receiver.  9/18/96 sw"	| newChangeList newList |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	1 to: changeList size do: [ :i |		(listSelections at: i) ifFalse: [			newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size < changeList size		ifTrue: [			changeList _ newChangeList.			list _ newList.			listIndex _ 0.			self clearSelections ].	self changed: #list	! !!ChangeList methodsFor: 'viewing access' stamp: 'jmv 12/8/2011 22:53'!       annotation	"Answer the string to be shown in an annotation pane.  Make plain that the annotation is associated with the current in-image version of the code, not of the selected disk-based version, and if the corresponding method is missing from the in-image version, mention that fact."	| annot change aClass ann1 ann2 |	change _ self currentChange.	(change notNil and: [change type == #classDefinition]) ifTrue: [		ann1 _ change isMetaClassChange ifTrue: ['Metaclass']ifFalse: ['Class'].		ann2 _ (Smalltalk includesKey: change methodClassName) ifTrue: [' already exists'] ifFalse: [' not in system'].		^ann1, ann2	].		annot _ super annotation.	annot asString = '------' ifTrue: [^ annot].	^ (change notNil and: [change methodSelector notNil])		ifFalse:			[annot]		ifTrue:			[((aClass _ change methodClass) isNil or: [(aClass includesSelector: change methodSelector) not])				ifTrue:					[change methodClassName, ' >> ', change methodSelector, ' is not present in the system.']				ifFalse:					['current version: ', annot]]! !!ChangeList methodsFor: 'private' stamp: 'jmv 12/7/2011 17:56'!      clearSelections	listSelections _ Array new: list size withAll: false! !!ChangeList class methodsFor: 'public access' stamp: 'jmv 12/7/2011 16:50'!         browseContents: aStream	"Opens a changeList on a fileStream"	| changeList charCount |	aStream readOnly.	charCount _ aStream size.	charCount > 1000000 ifTrue: [		(self confirm: 'The file ', aStream name , 'is really long (' , charCount printString , ' characters).Would you prefer to view only the last million characters?')			ifTrue: [ charCount _ 1000000 ]].	changeList _ Cursor read showWhile: [		self new			scanFile: aStream from: aStream size-charCount to: aStream size].	aStream close.	ChangeListWindow open: changeList label: aStream localName! !!ChangeList class methodsFor: 'public access' stamp: 'jmv 12/8/2011 09:42'!                            browsePackageContents: aStream	"Opens a changeList on a fileStream"	| changeList fullName pkName packageFile |	fullName _ aStream name.	pkName _ PackageFile packageNameFrom: fullName.	aStream readOnly.	Cursor read showWhile: [		changeList _ self new scanFile: aStream from: 0 to: aStream size.		aStream reset.		packageFile _ PackageFile			buildFileStream: aStream			packageName: pkName			fullName: fullName.		aStream close ].	"Add deletions of methods and classes that are in the PackageInfo (i.e., active in the system)	but are no longer in the PackageFile being viewed."	packageFile methodsToRemove do: [ :methodReference |		changeList			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)			text: 'method no longer in package: ', methodReference asStringOrText ].	packageFile classesToRemove do: [ :clsName |		changeList			addItem: (ClassDeletionChangeRecord new clsName: clsName)			text: 'class no longer in package: ', clsName ].	changeList clearSelections.	ChangeListWindow open: changeList label: aStream localName! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/7/2011 16:51'!     browseCompressedContents: aStream	"Browse the selected file in fileIn format."	| zipped unzipped |	zipped _ GZipReadStream on: aStream.	unzipped _ ReadStream on: zipped contents asString.	ChangeList browseContents: unzipped! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/8/2011 23:33'!              browseMCZContents: aStream	"Browse the selected file."	| unzipped changeList fullName packageFile pkName |		"For Monticello packages we do as we do with our own .pck files: Instead of just browsing	contents, also include what is no longer part of the package (and should therefore be removed on install)	See #browsePackageContents:	However, this was never tested to run!!"	self flag: #jmvVer.	fullName _ aStream name.	pkName _ PackageFile packageNameFrom: fullName.	unzipped _ aStream asUnZippedStream: 'snapshot/source.st'.	unzipped ascii.	changeList _ Cursor read showWhile: [		self new scanFile: unzipped from: 0 to: unzipped size.		aStream reset.		packageFile _ PackageFile			buildFileStream: aStream			packageName: pkName			fullName: fullName ].	"Add deletions of methods and classes that are in the PackageInfo (i.e., active in the system)	but are no longer in the PackageFile being viewed."	packageFile methodsToRemove do: [ :methodReference |		changeList			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)			text: 'method no longer in package: ', methodReference asStringOrText ].	packageFile classesToRemove do: [ :clsName |		changeList			addItem: (ClassDeletionChangeRecord new clsName: clsName)			text: 'class no longer in package: ', clsName ].	changeList clearSelections.	ChangeListWindow open: changeList label: aStream name! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/7/2011 16:54'!                              fileReaderServicesForFile: fullName suffix: suffix	| services |	services _ OrderedCollection new.	(FileStream isSourceFileSuffix: suffix)		ifTrue: [ services add: self serviceBrowseChangeFile ].	suffix = 'pck'		ifTrue: [ services add: self serviceBrowsePackageFile ].	(suffix = 'changes') | (suffix = '*')		ifTrue: [ services add: self serviceBrowseDotChangesFile ].	(suffix = 'mcz' or: [ suffix = '*'])		ifTrue: [ services add: self serviceBrowseMCZContents ].	(suffix = '*' or: [ fullName asLowercase endsWith: '.cs.gz' ])		ifTrue: [ services add: self serviceBrowseCompressedChangeFile ].	^services! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/7/2011 16:49'!            serviceBrowseChangeFile	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'code file contents'		selector: #browseContents:		description: 'open a code file contents tool on this file'		buttonLabel: 'contents')			argumentGetter: [ :fileList | fileList readOnlyStream ]! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/7/2011 16:48'!   serviceBrowseCompressedChangeFile	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'code file contents'		selector: #browseCompressedContents:		description: 'open a code file contents tool on this file'		buttonLabel: 'contents')			argumentGetter: [ :fileList | fileList readOnlyStream ]! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/7/2011 16:45'!               serviceBrowseMCZContents	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'code file contents'		selector: #browseMCZContents:		description: 'open a code file contents tool on this file'		buttonLabel: 'contents')			argumentGetter: [ :fileList | fileList readOnlyStream ]! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/7/2011 16:56'!                               serviceBrowsePackageFile	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'package file contents'		selector: #browsePackageContents:		description: 'open a code file contents tool on this package file'		buttonLabel: 'pck contents')			argumentGetter: [ :fileList | fileList readOnlyStream ]! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 12/7/2011 16:44'!            services	"Answer potential file services associated with this class"	^ { self serviceBrowseChangeFile. 		self serviceBrowseDotChangesFile.		self serviceBrowseCompressedChangeFile.		self serviceBrowseMCZContents }! !!ChangeListElement methodsFor: 'testing' stamp: 'jmv 12/7/2011 23:14'!                         isClassDeletion	^false! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/8/2011 20:53'! fileOutMethodRemovalsFor: class on: stream 	"Write out removals and initialization for this class."	| dict classRecord |	classRecord _ changeRecords at: class name ifAbsent: [^ self].	dict _ classRecord methodChangeTypes.	dict keysSortedSafely do: [ :key | | changeType |		changeType _ dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [				stream nextPut: $!!; nextChunkPut: 'methodRemoval: ', class name, ' ', key storeString; cr.				stream nextChunkPut: class name, ' removeSelector: ', key storeString; cr]].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/8/2011 20:44'!                     fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self inform: 'Warning: no changes to file out'].	classList _ ChangeSet superclassOrder: self changedClasses asOrderedCollection.	"First put out rename, max classDef and comment changes."	classList do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	classList do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	classList reverseDo: [:aClass |		self fileOutMethodRemovalsFor: aClass on: stream.		self fileOutPSFor: aClass on: stream ].	self classRemoves sort do: [ :aClassName |		stream nextPut: $!!; nextChunkPut: ('classRemoval: #', aClassName); cr.		stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/8/2011 20:17'!     fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict classRecord currentDef |	classRecord _ changeRecords at: class name ifAbsent: [^ self].	dict _ classRecord methodChangeTypes.	((dict includesKey:  #initialize) and: [ class isMeta ]) ifTrue: [		stream nextChunkPut: class soleInstance name, ' initialize'; cr].	((classRecord includesChangeType: #change)			and: [(currentDef _ class definition) ~= (self fatDefForClass: class)]) ifTrue: [		stream			nextPut: $!!;			nextChunkPut: class definitionPreamble; cr;			nextChunkPut: currentDef; cr].	(classRecord includesChangeType: #reorganize) ifTrue: [		class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'private' stamp: 'jmv 12/8/2011 20:19'!                          fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue: [		stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream			nextPut: $!!; nextChunkPut: class definitionPreamble; cr;			nextChunkPut: (self fatDefForClass: class); cr.	] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream				nextPut: $!!; nextChunkPut: class definitionPreamble; cr;				nextChunkPut: class definition; cr.		].	].	(self atClass: class includes: #comment) ifTrue: [		class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.		stream cr].! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'jmv 12/7/2011 16:14'!                           fileOutDefinitionForClass: aClass	stream		nextPut: $!!; nextChunkPut: aClass definitionPreamble; cr;		nextChunkPut: aClass definition; cr;		nextPut: $!!; nextChunkPut: aClass class definitionPreamble; cr;		nextChunkPut: aClass class definition; cr;		cr! !!ClassDeletionChangeRecord methodsFor: 'fileIn/fileOut' stamp: 'jmv 12/7/2011 23:06'!fileIn	self methodClass removeFromSystem! !!ClassDeletionChangeRecord methodsFor: 'fileIn/fileOut' stamp: 'jmv 12/8/2011 22:43'!                            fileOutOn: stream	"File the receiver out on the given file stream"		stream nextPut: $!!; nextChunkPut: ('classRemoval: #', clsName); cr.	stream nextChunkPut: 'Smalltalk removeClassNamed: #', clsName; cr! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 17:47'!                            clsName: aSymbol	clsName _ aSymbol! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:03'!       isMetaClassChange	^false! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:08'!                 methodClass	^Smalltalk at: clsName ifAbsent: nil! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:03'!                         methodClassName	^clsName! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:26'!                 methodSelector	^nil! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:19'!                      string	^''! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:03'!                               text	^''! !!ClassDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:01'! type	^ #classDefinition! !!ClassDeletionChangeRecord methodsFor: 'testing' stamp: 'jmv 12/7/2011 23:14'!                    isClassDeletion	^true! !!CodeFile methodsFor: 'reading' stamp: 'jmv 12/8/2011 23:06'!      fileInFrom: aStream	| chgRec changes |	changes _ (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.	('Processing ', self name) 		displayProgressAt: Sensor mousePoint		from: 1		to: changes size		during: [ :bar |			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				chgRec class == MethodDeletionChangeRecord					ifTrue: [ self removedMethod: (chgRec methodClassName, ' removeSelector: ', chgRec methodSelector) with: chgRec ]					ifFalse: [ self perform: (chgRec type copyWith: $:) asSymbol with: chgRec ].			].		]! !!CodeFileBrowser methodsFor: 'infoView' stamp: 'jmv 12/8/2011 22:48'!                       infoViewContents	| theClass |	editSelection == #newClass ifTrue: [^ self infoFor: self selectedCodeFile].	self selectedClass ifNil: [^ ''].	theClass _ Smalltalk at: self selectedClass name asSymbol ifAbsent: nil.	editSelection == #editClass ifTrue: [		^ theClass			ifNotNil: ['Class exists already in the system']			ifNil: ['Class not in the system']].	editSelection == #editMessage ifFalse: [^ ''].	(theClass notNil and: [self metaClassIndicated])		ifTrue: [theClass _ theClass class].	^ (theClass notNil and: [theClass includesSelector: self selectedMessageName])		ifTrue: ['Method already exists' , self extraInfo]		ifFalse: ['Method not in the system']! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 16:49'!       browseCode: aStream	CodeFileBrowserWindow browseStream: aStream named: aStream name! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 16:46'!                 browseCompressedCode: aStream 	"Browse the selected file in fileIn format."	| zipped unzipped |	zipped _ GZipReadStream on: aStream.	unzipped _ ReadStream on:  zipped contents asString.	CodeFileBrowserWindow browseStream: unzipped named: aStream name.! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 16:43'!      browseMCZCode: aStream	"Browse the selected file."	| unzipped |	unzipped _ aStream asUnZippedStream: 'snapshot/source.st'.	unzipped ascii.	CodeFileBrowserWindow browseStream: unzipped named: aStream name! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 16:49'!                      serviceBrowseCode	"Answer the service of opening a file-contents browser"	^ (SimpleServiceEntry		provider: self 		label: 'code-file browser'		selector: #browseCode:		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'		buttonLabel: 'code')			argumentGetter: [ :fileList | fileList readOnlyStream ]! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 16:46'!                         serviceBrowseCompressedCode	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'code-file browser'		selector: #browseCompressedCode:		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'		buttonLabel: 'code')			argumentGetter: [ :fileList | fileList readOnlyStream ]! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 16:45'!                              serviceBrowseMCZCode	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'code-file browser'		selector: #browseMCZCode:		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'		buttonLabel: 'code')			argumentGetter: [ :fileList | fileList readOnlyStream ]! !!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 12/7/2011 17:17'!              installMonticelloPackageStream: aStream		| stream fullName pkName |	fullName _ aStream name.	pkName _ PackageFile packageNameFrom: fullName.	stream _ aStream asUnZippedStream: 'snapshot/source.st'.	stream ascii.	Cursor wait showWhile: [		PackageFile			installFileStream: stream			packageName: pkName			fullName: fullName ]! !!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 12/7/2011 17:04'!                            installPackageStream: aStream	| fullName pkName |	fullName _ aStream name.	pkName _ PackageFile packageNameFrom: fullName.	Cursor wait showWhile: [		PackageFile			installFileStream: aStream			packageName: pkName			fullName: fullName ]! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/8/2011 22:57'!                     isMetaClassChange	^methodReference classIsMeta! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:08'!                          methodClass	^methodReference actualClass! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:24'!methodClassName	^methodReference classIsMeta		ifFalse: [ methodReference classSymbol ]		ifTrue: [ methodReference classSymbol, ' class' ]! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 17:48'!                             methodReference: aMethodReference	methodReference _ aMethodReference! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:09'!    methodSelector	^methodReference selector! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:22'!string	^''! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:09'!                              text	^''! !!MethodDeletionChangeRecord methodsFor: 'accessing' stamp: 'jmv 12/7/2011 23:01'!type	^ #method! !!MethodDeletionChangeRecord methodsFor: 'fileIn/fileOut' stamp: 'jmv 12/7/2011 23:07'!                     fileIn	methodReference actualClass removeSelector: methodReference selector! !!MethodDeletionChangeRecord methodsFor: 'fileIn/fileOut' stamp: 'jmv 12/8/2011 22:55'!                        fileOutOn: stream	"File the receiver out on the given file stream"	stream nextPut: $!!; nextChunkPut: 'methodRemoval: ', self methodClassName, ' ', self methodSelector; cr.	stream nextChunkPut: self methodClassName, ' removeSelector: ', self methodSelector; cr! !!PackageFile methodsFor: 'initialize' stamp: 'jmv 12/7/2011 17:43'!               buildFileStream: aFileStream packageName: pkName fullName: fullFileName	"Just build the PackageFile object. Don't install the code."	| classesDefined classesExtended classesToDeleteButCant classesToReallyDelete |	packageName _pkName.	fullName _fullFileName.	packageInMemory _ (PackageInfo named: packageName).	self fileInFrom: aFileStream.	"Compute stuff no longer in package: Should be removed from system."	classesDefined _ Set new.	classesExtended _ Set new.	self classes do: [ :pseudoClass |		pseudoClass hasDefinition			ifTrue: [ classesDefined add: pseudoClass name ]			ifFalse: [ classesExtended add: pseudoClass name ]].	classesToRemove _ (packageInMemory classes asSet collect: [ :each | each name ]) difference: classesDefined.	"Add here:		- classes in classesToDelete, that #allCallsOn answers selectors that aren't in classesToDelete or methodsToRemove		- classes with #subclasses that aren't in classesToDelete.		- classes with existing instances (#instanceCount)? Not really sure... Maybe sole instance referenced from classVar or such...		- something else I forgot?	Warning: This search for stuff that can't be removed must be iterated again until it doesn't find any more."	classesToDeleteButCant _ classesToRemove intersection: classesExtended.	classesToReallyDelete _ classesToRemove difference: classesToDeleteButCant.	"Methods. Could also mean classes that can't be deleted!! (include in the iteration)	Warn if deleting last implementor of sent messages?"	methodsToRemove _ packageInMemory methods asSet difference: self allMethodReferences.	methodsToRemove _ methodsToRemove reject: [ :methodReference | classesToReallyDelete includes: methodReference classSymbol ]."	'=============' print.	('classesToRemove: ', classesToRemove printString) print.	('classesToDeleteButCant: ', classesToDeleteButCant printString) print.	('classesToReallyDelete: ', classesToReallyDelete printString) print.	'=============' print.	'methodsToRemove: ' print.	methodsToRemove do: [ :methodReference | methodReference print ].	'=============' print."! !!PackageFile methodsFor: 'initialize' stamp: 'jmv 12/7/2011 17:14'!              installFileStream: aFileStream packageName: pkName fullName: fullFileName	| oldChangeSet |	self buildFileStream: aFileStream packageName: pkName fullName: fullFileName.	oldChangeSet _ ChangeSet current.	[		aFileStream reset.		self install: aFileStream.	] ensure: [		ChangeSet newChanges: oldChangeSet ]! !!PackageFile methodsFor: 'services' stamp: 'jmv 12/7/2011 17:45'! install: aFileStream	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."	| localName newChangeSet |	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."	'=============' print.	('classesToRemove: ', classesToRemove printString) print.	'=============' print.	'methodsToRemove: ' print.	methodsToRemove do: [ :methodReference | methodReference print ].	'=============' print.		"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"	"These were created in #fromFileStream: ... reuse?"	localName _ FileDirectory localNameFor: fullName.	newChangeSet _ ChangeSorter basicNewChangeSetLike: 'install package ', localName.	newChangeSet ifNotNil: [		ChangeSet newChanges: newChangeSet.		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].		Transcript cr; show: 'Package ', packageName, ' successfully installed'; cr].		"Tirar undeclared al transcript. warning si quedaron undeclared	Es feo que tire an transcript undeclareds que despues no lo son..."	Undeclared removeUnreferencedKeys.	Undeclared print.	"Crear, instalar y devolver una instancia de PackageInfo. Descartar la instancia de PackageFile"! !!PackageFile methodsFor: 'accessing' stamp: 'jmv 12/7/2011 17:50'!             classesToRemove	^classesToRemove! !!PackageFile methodsFor: 'accessing' stamp: 'jmv 12/7/2011 17:50'!                       methodsToRemove	^methodsToRemove! !!PackageFile class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 17:15'!        buildFileStream: aFileStream packageName: pkName fullName: fullFileName	| instance |	instance _ self new.	[ instance buildFileStream: aFileStream packageName: pkName fullName: fullFileName ]		ensure: [ aFileStream close ].	^instance! !!PackageFile class methodsFor: 'instance creation' stamp: 'jmv 12/7/2011 17:15'!                             installFileStream: aFileStream packageName: pkName fullName: fullFileName	| instance |	instance _ self new.	[ instance installFileStream: aFileStream packageName: pkName fullName: fullFileName ]		ensure: [ aFileStream close ].	^instance! !!PackageFile class methodsFor: 'services' stamp: 'jmv 12/7/2011 17:04'!  packageNameFrom: fullName	| localName |	localName _ FileDirectory localNameFor: fullName.	^(localName prefixAndSuffix: $-)		ifNotNil: [ :ary | ary first ]		ifNil: [ localName sansPeriodSuffix ].! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/8/2011 22:47'!        fileInAnnouncing: announcement 	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |	announcement 		displayProgressAt: Sensor mousePoint		from: 0		to: self size		during: 			[:bar | 			[self atEnd] whileFalse: 					[bar value: self position.					self skipSeparators.										[val := (self peekFor: $!!) 								ifTrue: [									chunk := self nextChunk.									(chunk beginsWith: 'classDefinition: ') |									(chunk beginsWith: 'classRemoval: ') |									(chunk beginsWith: 'methodRemoval: ')										ifFalse: [(Smalltalk actualCompilerClass evaluate: chunk logged: false) scanFrom: self]]								ifFalse: [									chunk := self nextChunk.									self checkForPreamble: chunk.									Smalltalk actualCompilerClass evaluate: chunk logged: true]] 							on: InMidstOfFileinNotification							do: [:ex | ex resume: true].					self skipStyleChunk].			self close].	"Note:  The main purpose of this banner is to flush the changes file."	Smalltalk logChange: '----End fileIn of ' , self name , '----'.	^val! !!VersionsBrowser methodsFor: 'init & update' stamp: 'jmv 12/7/2011 17:58'!                           scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	selectorOfMethod _ selector.	currentCompiledMethod _ method.	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].	changeList _ OrderedCollection new.	list _ OrderedCollection new.	self addedChangeRecord ifNotNil: [ :change |		self addItem: change text: ('{1} (in {2})' format: { change stamp. change fileName }) ].	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x ifNotNil: [ x readOnlyCopy]].	method fileIndex = 0 ifTrue: [^ nil].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [				preamble _ file nextChunk.				file skipSeparators			"Skip any padding"				].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens _ Smalltalk actualScannerClass new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue: [				(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue: [				(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue: [			file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	self clearSelections! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'jmv 12/7/2011 17:58'!scanVersionsOf: class	"Scan for all past versions of the class comment of the given class"	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |	classOfMethod _ class.	oldCommentRemoteStr _ class  organization commentRemoteStr.	currentCompiledMethod _ oldCommentRemoteStr.	selectorOfMethod _ #Comment.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].	sourceFilesCopy _ SourceFiles collect:		[:x | x ifNotNil: [x readOnlyCopy]].	position _ oldCommentRemoteStr position.	file _ sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  " Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [				preamble _ file nextChunk.				file skipSeparators			"Skip any padding"				].		prevPos _ nil.		stamp _ ''.		(preamble findString: 'commentStamp:' startingAt: 1) > 0			ifTrue: [tokens _ Smalltalk actualScannerClass new scanTokens: preamble.				(tokens at: tokens size-3) = #commentStamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]]			ifFalse: ["The stamp get lost, maybe after a condenseChanges"					stamp _ '<historical>']. 		self addItem:				(ChangeRecord new file: file position: position type: #classComment						class: class name category: nil meta: class stamp: stamp)			text: stamp , ' ' , class name , ' class comment'. 		prevPos = 0 ifTrue:[prevPos _ nil].		position _ prevPos.		prevPos notNil 					ifTrue:[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	self clearSelections! !!classDefinition: #PackageFile category: #'Package Support'!CodeFile subclass: #PackageFile	instanceVariableNames: 'packageName packageInMemory classesToRemove methodsToRemove'	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!classDefinition: #ChangeRecord category: #'Tools-Changes'!ChangeListElement subclass: #ChangeRecord	instanceVariableNames: 'file position type class category meta stamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!