'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 3 December 2011 at 2:59:47 am'!!classDefinition: #InnerTextMorph category: #'Morphic-Views for Models'!InnerPluggableMorph subclass: #InnerTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompleter hasEditingConflicts '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!classDefinition: #PluggableScrollPane category: #'Morphic-Views for Models'!PluggableMorph subclass: #PluggableScrollPane	instanceVariableNames: 'scrollBar scroller hScrollBar hideScrollBars currentScrollRange drawKeyboardFocusIndicator '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!classDefinition: #TextModelMorph category: #'Morphic-Views for Models'!PluggableScrollPane subclass: #TextModelMorph	instanceVariableNames: 'hasEditingConflicts '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/3/2011 00:41'!     hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/3/2011 00:41'!                            hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 12/3/2011 02:55'!                         chooseFont	self editor offerFontMenu.	self updateFromParagraph.! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 12/3/2011 00:42'!                      hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		owner redrawNeeded].	aBoolean ifFalse: [ self hasEditingConflicts: false].	"shout:  re-style the text iff aBoolean is true	Do not apply any formatting (i.e. changes to the characters in the text),	just styling (i.e. TextAttributes)"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess ]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/3/2011 00:48'!                processKeyStroke: evt	| action |	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	self pauseBlinking.	evt keyValue = 13 ifTrue: ["CR - check for special action"		action _ self crAction.		action ifNotNil: [			^action value]].	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromParagraph.	self eventHandler ifNotNil: [		"like'super keyStroke: evt'"		self eventHandler keyStroke: evt fromMorph: self].	self scrollSelectionIntoView! !!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 12/3/2011 00:41'!                           initialize	super initialize.	wrapFlag _ true.	acceptOnCR _ false.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.	askBeforeDiscardingEdits _ true! !!InnerTextMorph methodsFor: 'menu' stamp: 'jmv 12/3/2011 02:36'!                          getMenu	^self editor getMenu! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/3/2011 00:18'!                         mouseButton2Activity	"Invoke the menu"	self getMenu ifNotNil: [ :menu |		menu invokeModal ]! !!InnerTextMorph methodsFor: 'shout' stamp: 'jmv 12/3/2011 00:48'!                           stylerStyled	self paragraph composeAll.	self editor recomputeSelection.		self updateFromParagraph.	self editor setEmphasisHereFromText.	self editor blinkParen.	self scrollSelectionIntoView! !!InnerTextMorph methodsFor: 'selection' stamp: 'jmv 12/3/2011 00:47'!                  scrollSelectionIntoView	(owner is: #ScrollPane) ifTrue: [		owner scrollSelectionIntoView ].! !!PluggableScrollPane methodsFor: 'scroll bar events' stamp: 'jmv 12/3/2011 00:33'!         mouseButton2Activity	"Invoke the menu"	self getMenu ifNotNil: [ :menu |		menu invokeModal ]! !!PluggableScrollPane methodsFor: 'testing' stamp: 'jmv 12/3/2011 00:10'!                    is: aSymbol	^ aSymbol == #ScrollPane or: [ super is: aSymbol ]! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 12/3/2011 02:56'!                        offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.	Note: use #baseFont. If emphasis is desired, add it separatedly."	"This is a user command, and generates undo"	| curFont newFont attr startIndex |	startIndex _ self startIndex.	curFont _ model actualContents fontAt: startIndex.	newFont _ StrikeFont fromUser: curFont.	newFont ifNil: [ ^self ].	attr _ TextFontFamilyAndSize			familyName: newFont familyName			pointSize: newFont pointSize.	self applyAttribute: attr.	morph updateFromParagraph.! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 12/3/2011 02:38'!   align	"Align text according to the next greater alignment value,	cycling among leftFlush, rightFlush, center, and justified."	self chooseAlignment! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 12/3/2011 02:38'!chooseAlignment	"This is a user command, and generates undo"	| aList reply  |	aList _ #(leftFlush centered justified rightFlush).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ifNil: [ ^self ].	self applyAttribute: (TextAlignment perform: reply).	morph updateFromParagraph.	^ true! !!TextEditor methodsFor: 'menu' stamp: 'jmv 12/3/2011 02:35'! getMenu		| menu |	menu _ MenuMorph new defaultTarget: self.	^self class paneMenu: menu! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 10/4/2011 10:26'!                            evaluateSelectionAndDo: aBlock ifFail: failBlock	"Treat the current selection as an expression; evaluate it and return the result	3 +4	"	| provider result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	provider _ self codeProvider.	(provider respondsTo: #doItReceiver) 		ifTrue: [				rcvr _ provider doItReceiver.				ctxt _ provider doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new			sourceStreamGetter: #selectionAsStream;		"Cuis specific. Do not remove!!"			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [^ failBlock value]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	morph formatAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."	^ aBlock value: result! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 12/3/2011 00:15'!                browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry browser |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self wordSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) ifNil: [^ morph flash].	aSymbol first isUppercase		ifTrue: [			anEntry _ (Smalltalk				at: aSymbol				ifAbsent: [					Smalltalk browseAllImplementorsOf: aSymbol.					^ nil]).			anEntry ifNil: [^ morph flash].			(anEntry isKindOf: Class)				ifFalse:	[anEntry _ anEntry class].			browser _ Browser new.			browser setClass: anEntry selector: nil.			BrowserWindow open: browser label:'System Browser' ]		ifFalse:			[Smalltalk browseAllImplementorsOf: aSymbol]! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 12/3/2011 00:42'!          drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self textMorph hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self textMorph hasUnacceptedEdits							ifTrue: [								bc _ Color red]]]].	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Theme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 12/3/2011 00:20'!                          mouseButton2Activity	self textMorph mouseButton2Activity! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 12/3/2011 02:40'!           correctFrom: start to: stop with: aString	^ self editor correctFrom: start to: stop with: aString! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 12/3/2011 00:42'!              accept	"Inform the model of text to be accepted, and return true if OK."	| ok prevSelection prevScrollValue |	prevSelection _ self selectionInterval copy.	prevScrollValue _ scrollBar value.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self textMorph hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' ) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			self selectFrom: prevSelection first to: prevSelection last.			WorldState addDeferredUIMessage: [					World activeHand  newKeyboardFocus: self textMorph.					self setScrollDeltas.					scrollBar setValue: prevScrollValue ]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 12/3/2011 02:37'! update: aSymbol	super update: aSymbol.	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents ifTrue: [		"Some day, it would be nice to keep objects and update them		instead of throwing them away all the time for no good reason..."		self textMorph releaseParagraph.		self textMorph formatAndStyleIfNeeded.		^self ].	aSymbol == #acceptedContents ifTrue: [		self textMorph hasUnacceptedEdits ifTrue: [			self textMorph hasEditingConflicts: true.			^self redrawNeeded ].		model refetch.		self setScrollDeltas.		^self ].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self ].	aSymbol == #initialSelection ifTrue: [		^self setSelection: model getSelection; redrawNeeded ].	aSymbol == #autoSelect ifTrue: [		TextEditor abandonChangeText.	"no replacement!!"		self editor			setSearch: model autoSelectString;			findAndReplaceMany: true.		self textMorph updateFromParagraph ].	"Quite ugly"	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #shoutStyle ifTrue: [		self textMorph stylerStyled.		^self redrawNeeded ].! !Workspace removeSelector: #acceptDroppingMorph:event:inMorph:!TextModelMorph removeSelector: #browseIt!TextModelMorph removeSelector: #chooseAlignment!TextModelMorph removeSelector: #classCommentsContainingIt!TextModelMorph removeSelector: #copySelection!TextModelMorph removeSelector: #correctSelectionWithString:!TextModelMorph removeSelector: #cut!TextModelMorph removeSelector: #debugIt!TextModelMorph removeSelector: #doIt!TextModelMorph removeSelector: #explain!TextModelMorph removeSelector: #exploreIt!TextModelMorph removeSelector: #fileItIn!TextModelMorph removeSelector: #find!TextModelMorph removeSelector: #findAgain!TextModelMorph removeSelector: #getMenu!TextModelMorph removeSelector: #handleEdit:!TextModelMorph removeSelector: #hasEditingConflicts!TextModelMorph removeSelector: #hasEditingConflicts:!TextModelMorph removeSelector: #implementorsOfIt!TextModelMorph removeSelector: #initialize!TextModelMorph removeSelector: #inspectIt!TextModelMorph removeSelector: #methodSourceContainingIt!TextModelMorph removeSelector: #methodStringsContainingit!TextModelMorph removeSelector: #offerFontMenu!TextModelMorph removeSelector: #offerUndoHistory!TextModelMorph removeSelector: #paste!TextModelMorph removeSelector: #pasteRecent!TextModelMorph removeSelector: #pasteString!TextModelMorph removeSelector: #printIt!TextModelMorph removeSelector: #redo!TextModelMorph removeSelector: #referencesToIt!TextModelMorph removeSelector: #replaceSelectionWith:!TextModelMorph removeSelector: #sendersOfIt!TextModelMorph removeSelector: #setSearchString!TextModelMorph removeSelector: #stylerStyled!TextModelMorph removeSelector: #undo!!classDefinition: #TextModelMorph category: #'Morphic-Views for Models'!PluggableScrollPane subclass: #TextModelMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!TextModelMorph reorganize!('accessing' editor textMorph wrapFlag:)('dependents access' canDiscardEdits)('drawing' drawOn: wantsFrameAdornments)('editor access' clearSelection scrollSelectionIntoView scrollSelectionIntoView: selectAll)('event handling' doubleClick: handlesKeyboard keyStroke: mouseButton2Activity mouseEnter: tripleClick:)('geometry' innerHeight: scrollDeltaHeight)('initialization' acceptOnCR: innerMorphClass model:)('interactive error protocol' correctFrom:to:with: nextTokenFrom:direction: notify:at:in: selectFrom:to: selectInvisiblyFrom:to: selectionInterval)('menu commands' accept cancel)('model access' setSelection: setTextColor: text)('transcript')('unaccepted edits' askBeforeDiscardingEdits: hasUnacceptedEdits:)('updating' update:)('scrolling' mightNeedHorizontalScrollBar)('focus handling' focusText)('shout' autoCompleter: styler:)('notifications' possiblyChanged)!TextEditor removeSelector: #changeAlignment!TextEditor removeSelector: #changeTextFont!!classDefinition: #PluggableScrollPane category: #'Morphic-Views for Models'!PluggableMorph subclass: #PluggableScrollPane	instanceVariableNames: 'scrollBar scroller hScrollBar hideScrollBars drawKeyboardFocusIndicator'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!InnerTextMorph removeSelector: #chooseAlignment!InnerTextMorph removeSelector: #handleEdit:!!classDefinition: #InnerTextMorph category: #'Morphic-Views for Models'!InnerPluggableMorph subclass: #InnerTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!Object removeSelector: #acceptDroppingMorph:event:inMorph:!