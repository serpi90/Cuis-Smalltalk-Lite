'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 10 September 2010 at 11:44:16 pm'!!classDefinition: #MinimalStringMorph category: #'Morphic-Basic'!Morph subclass: #MinimalStringMorph	instanceVariableNames: 'font emphasis contents hasFocus '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 9/10/2010 22:54'!keyStroke: evt 	| matchString char asc selectable help |	help _ BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.	(evt commandAltKeyPressed and: [self commandKeyHandler notNil]) 		ifTrue: 			[self commandKeyHandler commandKeyTypedIntoMenu: evt.			^self deleteIfPopUp: evt].	char := evt keyCharacter.	asc := char asciiValue.	char = Character cr 		ifTrue: 			[selectedItem ifNotNil: 					[selectedItem hasSubMenu 						ifTrue: 							[evt hand newMouseFocus: selectedItem subMenu.							^evt hand newKeyboardFocus: selectedItem subMenu]						ifFalse: 							["self delete."							^selectedItem invokeWithEvent: evt]].			(selectable := self items) size = 1 				ifTrue: [^selectable first invokeWithEvent: evt].			^self].	asc = 27 		ifTrue: 			["escape key"			self valueOfProperty: #matchString				ifPresentDo: 					[:str | 					str isEmpty 						ifFalse: 							["If filtered, first ESC removes filter"							self setProperty: #matchString toValue: String new.							self selectItem: nil event: evt.							^self displayFiltered: evt]].			"If a stand-alone menu, just delete it"			popUpOwner ifNil: [^self delete].			"If a sub-menu, then deselect, and return focus to outer menu"			self selectItem: nil event: evt.			evt hand newMouseFocus: popUpOwner owner.			^evt hand newKeyboardFocus: popUpOwner owner].	(asc = 28 or: [asc = 29]) 		ifTrue: 			["left or right arrow key"			(selectedItem notNil and: [selectedItem hasSubMenu]) 				ifTrue: 					[evt hand newMouseFocus: selectedItem subMenu.					selectedItem subMenu moveSelectionDown: 1 event: evt.					^evt hand newKeyboardFocus: selectedItem subMenu]].	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: evt].	"up arrow key"	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: evt].	"down arrow key"	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: evt].	"page up key"	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: evt].	"page down key"	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].	matchString := char = Character backspace 				ifTrue: 					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]				ifFalse: [matchString copyWith: evt keyCharacter].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt.	help _ BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.! !!MinimalStringMorph methodsFor: 'initialization' stamp: 'jmv 9/10/2010 22:55'!initWithContents: aString font: aFont emphasis: emphasisCode 	self initialize.		font _ aFont.	emphasis _ emphasisCode.	self contents: aString! !!MinimalStringMorph methodsFor: 'initialization' stamp: 'jmv 9/10/2010 22:55'!initialize	super initialize.	font _ nil.	emphasis _ 0! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/10/2010 12:12'!keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	super keyStroke: evt.	(self scrollByKeyboard: evt) ifTrue: [^self].	scroller submorphs last keyStroke: evt! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/10/2010 22:53'!mouseEnter: event	super mouseEnter: event.	hasFocus _ true.	(owner is: #SystemWindow) ifTrue: [ owner paneTransition: event ].	retractableScrollBar ifTrue: [ self hideOrShowScrollBars ].! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/10/2010 12:09'!mouseLeave: event	super mouseLeave: event.	hasFocus _ false.	retractableScrollBar ifTrue: [		self			vHideScrollBar;			hHideScrollBar].	(owner is: #SystemWindow) ifTrue: [ owner paneTransition: event ]! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/10/2010 12:09'!mouseUp: evt	super mouseUp: evt.	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue: [		scroller submorphs last mouseUp: 		(evt internalizedTo: scroller from: self)]! !!ScrollPane methodsFor: 'change reporting' stamp: 'jmv 9/10/2010 09:55'!invalidateBorderFeedback	| r |	drawKeyboardFocusIndicator ifTrue: [		r _ self focusIndicatorRectangle.		(r areasOutside: (r insetBy: Preferences focusIndicatorWidth))			do: [ :rect | self invalidRect: rect ]]! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jmv 9/10/2010 14:42'!handlesBasicKeys: aBoolean	handlesBasicKeys _ aBoolean! !!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2010 09:55'!drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle			width: Preferences focusIndicatorWidth			color: Preferences focusIndicatorColor ].! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 9/10/2010 12:14'!keyStroke: event 	"Process keys 	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"		| aChar aSpecialKey |	(event commandAltKeyPressed and: [ self focusKeyboardFor: event ])		ifTrue: [ ^ self ].	super keyStroke: event.	(self scrollByKeyboard: event) ifTrue: [^self].	aChar _ event keyCharacter.	aSpecialKey _ aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 9/10/2010 14:12'!specialKeyPressed: asciiValue	"A special key with the given ascii-value was pressed; dispatch it"	| oldSelection nextSelection max howManyItemsShowing |	asciiValue = 27 ifTrue: 		[" escape key"		^ ActiveEvent shiftPressed			ifFalse:				[self yellowButtonActivity: false]].	max _ self maximumSelection.	max > 0 ifFalse: [^ self].	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	asciiValue = 31 ifTrue: 		[" down arrow"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].	asciiValue = 30 ifTrue: 		[" up arrow"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].	asciiValue = 1 ifTrue:		[" home"		nextSelection _ 1].	asciiValue = 4 ifTrue:		[" end"		nextSelection _ max].	howManyItemsShowing _ self numSelectionsInView.	asciiValue = 11 ifTrue:		[" page up"		nextSelection _ 1 max: oldSelection - howManyItemsShowing].	asciiValue = 12 ifTrue:		[" page down"		nextSelection _ oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection = nextSelection ifTrue: [^ self "flash"	"ugly"].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 9/10/2010 14:48'!alertUserContentsChanged	self flash! !!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 9/10/2010 14:48'!verifyContents	"Verify the contents of the receiver, reconstituting if necessary.  Called whenever window is reactivated, to react to possible structural changes.  Also called periodically in morphic if the smartUpdating preference is true"	| newList existingSelection anIndex oldList |	oldList _ list ifNil: [ #() ].	newList _ self getList.	((oldList == newList) "fastest" or: [oldList = newList]) ifTrue: [^ self].	self alertUserContentsChanged.  "list has changed beneath us; give the user a little visual feedback that the contents of the pane are being updated."	existingSelection _ self selectionIndex > 0 ifTrue: [ oldList at: self selectionIndex ].	self updateList.	(existingSelection notNil and: [(anIndex _ list indexOf: existingSelection asStringOrText ifAbsent: nil) notNil])		ifTrue: [			model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifFalse: [			self changeModelSelection: 0]! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2010 09:55'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		((model is: #CodeHolder) and: [model refusesToAcceptCode])			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self hasUnacceptedEdits							ifTrue: [								model wantsDiffFeedback									ifTrue: [										bw _ 4.										bc _ Color green]									ifFalse: [										bc _ Color red]]							ifFalse: [								model wantsDiffFeedback									ifTrue: [										bc _ Color green]									ifFalse: []]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Preferences focusIndicatorColor ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle width: bw color: bc ]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'jmv 9/10/2010 09:10'!selectAll	"Tell my textMorph's editor to select all"	textMorph selectAll! !!PluggableTextMorph methodsFor: 'event handling' stamp: 'jmv 9/10/2010 22:53'!mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: textMorph ]! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/10/2010 09:55'!drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle 			width: Preferences focusIndicatorWidth			color: Preferences focusIndicatorColor ].	selectedMorph  ifNotNil:		[aCanvas fillRectangle:			((selectedMorph bounds: selectedMorph bounds in: self)						intersect: scroller bounds)				color: color blacker].	Preferences showLinesInHierarchyViews ifTrue:[		self drawLinesOn: aCanvas.	].! !!TextEditor methodsFor: 'events' stamp: 'jmv 9/10/2010 11:14'!disregardNextMouseUp	oldInterval _ nil! !!TextMorph methodsFor: 'event handling' stamp: 'jmv 9/10/2010 15:20'!keyStroke: evt	"Handle a keystroke event."	| action |	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	self pauseBlinking.	evt keyValue = 13 ifTrue:["CR - check for special action"		action _ self crAction.		action ifNotNil: [			^action value]].	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromParagraph.	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!TextMorph methodsFor: 'event handling' stamp: 'jmv 9/10/2010 11:41'!mouseDown: evt	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	super mouseDown: evt.	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		editor disregardNextMouseUp.		^evt hand newKeyboardFocus: self].	self handleInteraction: [editor mouseDown: evt]! !!TextMorph methodsFor: 'event handling' stamp: 'jmv 9/10/2010 15:49'!mouseUp: evt	super mouseUp: evt.	self pauseBlinking.	self handleInteraction: [editor mouseUp: evt]! !!TextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/10/2010 10:41'!pauseBlinking	"Show a solid cursor (non blinking) for a short while"	pauseBlinking _ true.	paragraph ifNotNil: [		"Show cursor right now if needed"		paragraph showCaret ifFalse: [			paragraph showCaret: true.			paragraph caretRect ifNotNil: [ :r | self invalidRect: r ]]]! !!TextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/10/2010 10:40'!startBlinking	"And show the cursor"	pauseBlinking _ true.	"Start blinking in a short while"	paragraph ifNotNil: [ paragraph showCaret: true ].	self		startStepping: #onBlinkCursor		at: Time millisecondClockValue		arguments: nil		stepTime: 500.! !!TextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/10/2010 10:42'!stopBlinking	"And do not show cursor anymore."	self stopSteppingSelector: #onBlinkCursor.	paragraph ifNotNil: [		"Hide cursor right now if needed"		paragraph showCaret ifTrue: [			paragraph showCaret: false.			paragraph caretRect ifNotNil: [ :r | self invalidRect: r ]]]! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'jmv 9/10/2010 11:40'!mouseDown: event	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		editor disregardNextMouseUp.		^event hand newKeyboardFocus: self].	super mouseDown: event.	event hand		waitForSimulatedYellow: self 		event: event		dblClkSel: #doubleClick:! !!TextMorphForEditView methodsFor: 'miscellaneous' stamp: 'jmv 9/10/2010 09:12'!selectAll	"Tell my editor to select all the text"	self editor selectAll.	self changed! !!classDefinition: #MinimalStringMorph category: #'Morphic-Basic'!Morph subclass: #MinimalStringMorph	instanceVariableNames: 'font emphasis contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!MenuMorph removeSelector: #drawOn:!