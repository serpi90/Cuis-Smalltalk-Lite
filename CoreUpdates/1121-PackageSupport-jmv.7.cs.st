'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 3 November 2011 at 3:24:30 pm'!!classDefinition: #PackageExporter category: #'Package Support'!Object subclass: #PackageExporter	instanceVariableNames: 'package stream'	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!classDefinition: #ChangeSetPackageExporter category: #'Package Support'!PackageExporter subclass: #ChangeSetPackageExporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!classDefinition: #PackageFile category: #'Package Support'!CodeFile subclass: #PackageFile	instanceVariableNames: 'packageName packageInMemory'	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!PackageFile commentStamp: '<historical>' prior: 0!A PackageFile is a (version or snapshot) of a package that resides in an external file (.pck). It can be installed, and then it turns into a PackageInfo.(PackageFile fromFileNamed: 'PackageInfo.pck') inspect!!classDefinition: #PackageInfo category: #'Package Support'!Object subclass: #PackageInfo	instanceVariableNames: 'packageName methodCategoryPrefix preamble postscript preambleOfRemoval postscriptOfRemoval'	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!PackageInfo commentStamp: '<historical>' prior: 0!A PackageInfo is a package that is currently loaded in the system. If filed out (.pck), then it is stored in a file that can be dealt with as an instance of PackageFile. As the code is already in the system, all we need to know is the packageName.(PackageInfo named: 'TestPackage') inspect; fileOut!!classDefinition: #PackageList category: #'Package Support'!Object subclass: #PackageList	instanceVariableNames: 'selectedPackage packages'	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!classDefinition: 'PackageList class' category: #'Package Support'!PackageList class	instanceVariableNames: 'default'!!classDefinition: #PackageOrganizer category: #'Package Support'!Object subclass: #PackageOrganizer	instanceVariableNames: 'packages'	classVariableNames: ''	poolDictionaries: ''	category: 'Package Support'!!classDefinition: 'PackageOrganizer class' category: #'Package Support'!PackageOrganizer class	instanceVariableNames: 'default'!!Class methodsFor: 'class variables' stamp: 'jmv 11/3/2011 09:54'!removeClassVarName: aString 	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."	| aSymbol |	aSymbol _ aString asSymbol.	(classPool includesKey: aSymbol)		ifFalse: [ ^self error: aString, ' is not a class variable'].	self withAllSubclasses do:[:subclass |		(Array with: subclass with: subclass class) do: [ :classOrMeta |			(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))				isEmpty ifFalse: [					InMidstOfFileinNotification signal ifTrue: [						Transcript cr; show: self name, ' (' , aString , ' is Undeclared) '.						^Undeclared declare: aSymbol from: classPool ].					(self confirm: (aString,' is still used in code of class ', classOrMeta name,						'.\Is it okay to move it to Undeclared?') withCRs)						ifTrue: [ ^Undeclared declare: aSymbol from: classPool ]						ifFalse: [ ^self ]]]].	classPool removeKey: aSymbol.	classPool isEmpty ifTrue: [ classPool _ nil ]! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 11/2/2011 18:37'!fileReaderServicesForFile: fullName suffix: suffix	| services |	services _ OrderedCollection new.	(FileStream isSourceFileSuffix: suffix) | (suffix = 'pck')		ifTrue: [ services add: self serviceBrowseChangeFile ].	(suffix = 'changes') | (suffix = '*')		ifTrue: [ services add: self serviceBrowseDotChangesFile ].	(suffix = 'mcz' or: [ suffix = '*'])		ifTrue: [ services add: self serviceBrowseMCZFile ].	(suffix = '*' or: [ fullName asLowercase endsWith: '.cs.gz' ])		ifTrue: [ services add: self serviceBrowseCompressedChangeFile ].	^services! !!ChangeSorter class methodsFor: 'adding' stamp: 'jmv 11/3/2011 10:05'!basicNewChangeSetLike: baseName	| newSet n newName |	newName _ baseName.	n _ 0.	[ (self changeSetNamed: newName) notNil ] whileTrue: [		n _ n + 1.		newName _ baseName, '-#', n printString ].	newSet _ ChangeSet basicNewNamed: newName.	AllChangeSets add: newSet.	^ newSet! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 11/2/2011 18:44'!fileReaderServicesForFile: fullName suffix: suffix	(FileStream isSourceFileSuffix: suffix)		ifTrue: [ ^ { self serviceBrowseCode } ].	suffix = 'mcz'		ifTrue: [ ^ { self serviceBrowseMCZCode } ].	(fullName endsWith: 'cs.gz')		ifTrue: [ ^ { self serviceBrowseCompressedCode } ].	suffix = 'pck'		ifTrue: [ ^ { self serviceBrowseCode. self serviceInstallPackage } ].	^#()! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 11/2/2011 20:01'!installPackage: aStream	CodeFileBrowserWindow installPackageStream: aStream! !!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 11/2/2011 18:51'!serviceInstallPackage	"Answer the service of installing a PackageFile (a chunk format file for a PackageInfo)"	^ (SimpleServiceEntry		provider: self 		label: 'install package'		selector: #installPackage:		description: 'install the package, replacing all existing code in the package (if any); create a new change set just for the installation'		buttonLabel: 'install package')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 11/2/2011 20:14'!installPackageStream: aStream	Cursor wait showWhile: [		(PackageFile fromFileStream: aStream) install ]! !!Collection methodsFor: '*Package Support' stamp: 'ab 9/30/2002 19:26'!gather: aBlock	^ Array streamContents:		[:stream |		self do: [:ea | stream nextPutAll: (aBlock value: ea)]]! !!MethodReference methodsFor: '*Package Support' stamp: 'ab 5/23/2003 22:58'!category	^ self actualClass organization categoryOfElement: methodSymbol! !!MethodReference methodsFor: '*Package Support' stamp: 'jmv 3/23/2011 15:29'!compiledMethod	^ self actualClass compiledMethodAt: methodSymbol! !!MethodReference methodsFor: '*Package Support' stamp: 'ab 5/23/2003 22:58'!sourceCode	^ self actualClass sourceCodeAt: methodSymbol! !!PackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:47'!fileOut	self subclassResponsibility! !!PackageExporter methodsFor: 'services' stamp: 'jok 9/12/2010 15:30'!package: aPackageInfo	package := aPackageInfo! !!PackageExporter methodsFor: 'services' stamp: 'jok 9/12/2010 15:31'!stream: aStream	stream := aStream! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'jmv 11/2/2011 18:16'!fileOut"	self fileOutSystemCategories."	self fileOutClassDefinitions.	self fileOutClassComments.	self fileOutMethods.	self fileOutInitializers.! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:52'!fileOutClassComments	package classes do:		[:class |		class organization classComment isEmpty			ifFalse: [self fileOutCommentForClass: class ]].		! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'jok 5/30/2008 09:31'!fileOutClassDefinitions	(ChangeSet superclassOrder: package classes)		do: [:class | self fileOutDefinitionForClass: class]		displayingProgress: 'Filing out classes...'.! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:52'!fileOutCommentForClass: aClass	aClass organization		putCommentOnFile: stream		numbered: 0		moveSource: false		forClass: aClass! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'jmv 11/1/2011 22:44'!fileOutDefinitionForClass: aClass	stream		nextChunkPut: aClass definition;		cr;		nextChunkPut: aClass class definition; 		cr; cr! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:55'!fileOutInitializerForClass: aClass	stream nextChunkPut: aClass name, ' initialize'; cr! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:55'!fileOutInitializers			(package classes select: [:c | c class includesSelector: #initialize])		do: [:class | self fileOutInitializerForClass: class].! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:54'!fileOutMethod: aMethodReference	aMethodReference actualClass		printMethodChunk: aMethodReference methodSymbol		withPreamble: true		on: stream		moveSource: false		toFile: 0! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:54'!fileOutMethods	self sortedMethods		do: [:ref | self fileOutMethod: ref]		displayingProgress: 'Filing out methods...'.! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:56'!fileOutSystemCategories	package systemCategories do: [:cat | self fileOutSystemCategory: cat].	stream cr; cr.	! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'ab 5/23/2003 22:50'!fileOutSystemCategory: categoryName	stream		nextChunkPut: 'SystemOrganization addCategory: ', categoryName printString;		cr! !!ChangeSetPackageExporter methodsFor: 'services' stamp: 'jmv 11/1/2011 18:28'!sortedMethods ^ package methods copy sort:		[:a :b |		a methodSymbol < b methodSymbol			or: [a methodSymbol = b methodSymbol					and: [a classSymbol <= b classSymbol]]]! !!PackageExporter class methodsFor: 'services' stamp: 'ab 5/23/2003 23:09'!fileOutPackage: aPackageInfo on: aStream	self new		package: aPackageInfo;		stream: aStream;		fileOut! !!PackageFile methodsFor: 'initialize' stamp: 'jmv 11/2/2011 20:06'!fromFileStream: aFileStream	| localName |	fullName _ aFileStream name.	[ self fileInFrom: aFileStream ] ensure: [ aFileStream close ].	localName _ FileDirectory localNameFor: fullName.	packageName _ localName sansPeriodSuffix.	packageInMemory _ (PackageInfo named: packageName)! !!PackageFile methodsFor: 'services' stamp: 'jmv 11/3/2011 10:07'!install	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."	| stream localName oldChangeSet newChangeSet 	classesDefined classesExtended	classesToDelete classesToDeleteButCant classesToReallyDelete	methodsToRemove	|		"Compute stuff no longer in package: Should be removed from system."	classesDefined _ Set new.	classesExtended _ Set new.	self classes do: [ :pseudoClass |		pseudoClass hasDefinition			ifTrue: [ classesDefined add: pseudoClass name ]			ifFalse: [ classesExtended add: pseudoClass name ]].	classesToDelete _ (packageInMemory classes asSet collect: [ :each | each name ]) difference: classesDefined.	"Add here:		- classes in classesToDelete, that #allCallsOn answers selectors that aren't in classesToDelete or methodsToRemove		- classes with #subclasses that aren't in classesToDelete.		- classes with existing instances (#instanceCount)? Not really sure... Maybe sole instance referenced from classVar or such...		- something else I forgot?	Warning: This search for stuff that can't be removed must be iterated again until it doesn't find any more."	classesToDeleteButCant _ classesToDelete intersection: classesExtended.	classesToReallyDelete _ classesToDelete difference: classesToDeleteButCant.	"Methods. Could also mean classes that can't be deleted!! (include in the iteration)	Warn if deleting last implementor of sent messages?"	methodsToRemove _ packageInMemory methods asSet difference: self allMethodReferences.	methodsToRemove _ methodsToRemove reject: [ :methodReference | classesToReallyDelete includes: methodReference classSymbol ].	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."	'=============' print.	('classesToDelete: ', classesToDelete printString) print.	('classesToDeleteButCant: ', classesToDeleteButCant printString) print.	('classesToReallyDelete: ', classesToReallyDelete printString) print.	'=============' print.	'methodsToRemove: ' print.	methodsToRemove do: [ :methodReference | methodReference print ].	'=============' print.		"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"	"These were created in #fromFileStream: ... reuse?"	localName _ FileDirectory localNameFor: fullName.	stream _ FileStream readOnlyFileNamed: fullName.	oldChangeSet _ ChangeSet current.	newChangeSet _ ChangeSorter basicNewChangeSetLike: 'install package ', localName.	[		newChangeSet ifNotNil: [			ChangeSet newChanges: newChangeSet.			stream fileInAnnouncing: 'Installing ', localName, '...'.			methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].			classesToDelete do: [ :className | (Smalltalk at: className) removeFromSystem ].			Transcript cr; show: 'Package ', packageName, ' successfully installed'; cr].		stream close	] ensure: [		ChangeSet  newChanges: oldChangeSet].		"Tirar undeclared al transcript. warning si quedaron undeclared	Es feo que tire an transcript undeclareds que despues no lo son..."	Undeclared removeUnreferencedKeys.	Undeclared print.	"Crear, instalar y devolver una instancia de PackageInfo. Descartar la instancia de PackageFile"! !!PackageFile class methodsFor: 'instance creation' stamp: 'jmv 11/2/2011 20:03'!fromFileStream: aFileStream	^self new fromFileStream: aFileStream! !!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 00:09'!= other	^ other species = self species and: [other packageName = self packageName]! !!PackageInfo methodsFor: 'comparing' stamp: 'avi 10/11/2003 14:20'!hash	^ packageName hash! !!PackageInfo methodsFor: 'enumerating' stamp: 'jmv 3/23/2011 18:13'!actualMethodsDo: aBlock	"Evaluate aBlock with the actual method objects in this package."	| enum |	self extensionMethods do:		[:mr|		aBlock value: mr compiledMethod].	enum := [:behavior|			behavior organization categories do:				[:cat|				(self isForeignClassExtension: cat) ifFalse:					[(behavior organization listAtCategoryNamed: cat) do:						[:s|						aBlock value: (behavior compiledMethodAt: s)]]]].	self classes do:		[:c| enum value: c; value: c theMetaClass]		! !!PackageInfo methodsFor: 'enumerating' stamp: 'bp 2/26/2010 20:47'!allOverriddenMethodsDo: aBlock	"Evaluates aBlock with all the overridden methods in the system"	^ ProtoObject withAllSubclassesDo: [:class | 		self overriddenMethodsInClass: class do: aBlock]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bf 5/4/2005 16:29'!methodsInCategory: aString ofClass: aClass do: aBlock	((aClass organization listAtCategoryNamed: aString) ifNil: [^self])		do: [:sel | aBlock value: (self referenceForMethod: sel ofClass: aClass)]! !!PackageInfo methodsFor: 'enumerating' stamp: 'bp 2/26/2010 20:46'!overriddenMethodsDo: aBlock	"Enumerates the methods the receiver contains which have been overridden by other packages"	^ self allOverriddenMethodsDo: [:ea |		(self isOverrideOfYourMethod: ea)			ifTrue: [aBlock value: ea]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:35'!overriddenMethodsInClass: aClass do: aBlock	"Evaluates aBlock with the overridden methods in aClass"	^ self overrideCategoriesForClass: aClass do: [:cat |		self methodsInCategory: cat ofClass: aClass do: aBlock]! !!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:28'!overrideCategoriesForClass: aClass do: aBlock	"Evaluates aBlock with all the *foo-override categories in aClass"	^ aClass organization categories do: [:cat |		(self isOverrideCategory: cat) ifTrue: [aBlock value: cat]]! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/13/2003 15:40'!addCoreMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: category		suppressIfDefault: false! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:17'!addExtensionMethod: aMethodReference	| category |	category := self baseCategoryOfMethod: aMethodReference.	aMethodReference actualClass organization		classify: aMethodReference methodSymbol		under: self methodCategoryPrefix, '-', category! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:16'!addMethod: aMethodReference	(self includesClass: aMethodReference class)		ifTrue: [self addCoreMethod: aMethodReference]		ifFalse: [self addExtensionMethod: aMethodReference]! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/13/2003 15:39'!baseCategoryOfMethod: aMethodReference	| oldCat oldPrefix tokens | 	oldCat := aMethodReference category.	({ 'as yet unclassified'. 'all' } includes: oldCat) ifTrue: [ oldCat := '' ].	tokens := oldCat findTokens: '*-' keep: '*'.	"Strip off any old prefixes"	((tokens at: 1 ifAbsent: [ '' ]) = '*') ifTrue: [		[ ((tokens at: 1 ifAbsent: [ '' ]) = '*') ]			whileTrue: [ tokens removeFirst ].		oldPrefix := tokens removeFirst asLowercase.		[ (tokens at: 1 ifAbsent: [ '' ]) asLowercase = oldPrefix ]			whileTrue: [ tokens removeFirst ].	].	tokens isEmpty ifTrue: [^ 'as yet unclassified'].	^ String streamContents:		[ :s |		tokens			do: [ :tok | s nextPutAll: tok ]			separatedBy: [ s nextPut: $- ]]! !!PackageInfo methodsFor: 'modifying' stamp: 'al 3/1/2006 21:42'!externalBehaviors	^self externalClasses , self externalTraits! !!PackageInfo methodsFor: 'modifying' stamp: 'jmv 3/23/2011 18:34'!externalTraits	"No traits in Cuis"	^ #()! !!PackageInfo methodsFor: 'modifying' stamp: 'avi 10/11/2003 15:14'!removeMethod: aMethodReference! !!PackageInfo methodsFor: 'listing' stamp: 'bp 2/26/2010 20:45'!allOverriddenMethods	"search classes and meta classes"	^ Array streamContents: [:stream |		self allOverriddenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'avi 9/14/2004 13:24'!allOverridenMethods	^ ProtoObject withAllSubclasses gather:		[:class |		(self overriddenMethodsInClass: class)]! !!PackageInfo methodsFor: 'listing' stamp: 'jmv 3/23/2011 18:34'!classes	^(self systemCategories gather:		[:cat |		(SystemOrganization listAtCategoryNamed: cat)			collect: [:className | Smalltalk at: className]])				sorted: [:a :b | a className <= b className]! !!PackageInfo methodsFor: 'listing' stamp: 'jmv 3/23/2011 18:13'!classesAndMetaClasses	"Return a Set with all classes and metaclasses belonging to this package"	| baseClasses result |	baseClasses := self classes.	result := (Set new: baseClasses size * 2) 		addAll: baseClasses;		yourself.	baseClasses do: [ :c | 		result add: c theMetaClass].	^result! !!PackageInfo methodsFor: 'listing' stamp: 'ab 11/13/2002 01:23'!coreMethods	^ self classesAndMetaClasses gather: [:class | self coreMethodsForClass: class]! !!PackageInfo methodsFor: 'listing' stamp: 'al 3/1/2006 21:51'!extensionClasses	^ self externalBehaviors reject: [:classOrTrait | (self extensionCategoriesForClass: classOrTrait) isEmpty]! !!PackageInfo methodsFor: 'listing' stamp: 'al 3/1/2006 21:51'!extensionMethods	^ self externalBehaviors gather: [:classOrTrait | self extensionMethodsForClass: classOrTrait]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 12/3/2002 14:38'!foreignClasses	| s |	s := IdentitySet new.	self foreignSystemCategories		do: [:c | (SystemOrganization listAtCategoryNamed: c)				do: [:cl | 					| cls | 					cls := Smalltalk at: cl. 					s add: cls;					  add: cls class]].	^ s! !!PackageInfo methodsFor: 'listing' stamp: 'ab 12/3/2002 14:34'!foreignSystemCategories	^ SystemOrganization categories		reject: [:cat | self includesSystemCategory: cat] ! !!PackageInfo methodsFor: 'listing' stamp: 'jmv 11/1/2011 18:14'!methods	^ (self extensionMethods, self coreMethods) select: [:method |		method isValid ]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 17:40'!overriddenMethods	^ Array streamContents: [:stream |		self overriddenMethodsDo: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'bf 5/4/2005 16:43'!overriddenMethodsInClass: aClass	^Array streamContents: [:stream |		self overriddenMethodsInClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'listing' stamp: 'nk 5/1/2004 08:40'!overrideMethods	^ self extensionMethods select: [:ea | self isOverrideMethod: ea]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 11/14/2002 18:39'!selectors	^ self methods collect: [:ea | ea methodSymbol]! !!PackageInfo methodsFor: 'listing' stamp: 'ab 11/11/2002 21:51'!systemCategories	^ SystemOrganization categories select: [:cat | self includesSystemCategory: cat]! !!PackageInfo methodsFor: 'testing' stamp: 'nk 4/28/2004 14:20'!category: categoryName matches: prefix	| prefixSize catSize |	categoryName ifNil: [ ^false ].	catSize := categoryName size.	prefixSize := prefix size.	catSize < prefixSize ifTrue: [ ^false ].	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1		ifFalse: [ ^false ].	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) = $-! !!PackageInfo methodsFor: 'testing' stamp: 'jmv 3/23/2011 18:15'!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := (tokens after: #methodsFor:) ifNil: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:18'!coreCategoriesForClass: aClass	^ aClass organization categories select: [:cat | (self isForeignClassExtension: cat) not]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:22'!coreMethodsForClass: aClass	^ (aClass selectors difference:		((self foreignExtensionMethodsForClass: aClass) collect: [:r | r methodSymbol]))			asArray collect: [:sel | self referenceForMethod: sel ofClass: aClass]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:20'!extensionCategoriesForClass: aClass	^ aClass organization categories select: [:cat | self isYourClassExtension: cat]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:28'!extensionMethodsForClass: aClass	^ (self extensionCategoriesForClass: aClass)		gather: [:cat | self methodsInCategory: cat ofClass: aClass ]! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 10/18/2002 23:22'!extensionMethodsFromClasses: classes	^classes		gather: [:class | self extensionMethodsForClass: class]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:22'!foreignExtensionCategoriesForClass: aClass	^ aClass organization categories select: [:cat | self isForeignClassExtension: cat]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23'!foreignExtensionMethodsForClass: aClass	^ (self foreignExtensionCategoriesForClass: aClass)		gather: [:cat | (aClass organization listAtCategoryNamed: cat)						  collect: [:sel | self referenceForMethod: sel ofClass: aClass]]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/14/2004 13:34'!includesChangeRecord: aChangeRecord	^ aChangeRecord methodClass notNil and:		[self			includesMethodCategory: aChangeRecord category			ofClass: aChangeRecord methodClass]! !!PackageInfo methodsFor: 'testing' stamp: 'nice 2/15/2011 23:36'!includesClass: aClass	^ self includesSystemCategory: aClass category! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:08'!includesClassNamed: aClassName	^ self includesSystemCategory: ((SystemOrganization categoryOfElement: aClassName) ifNil: [^false])! !!PackageInfo methodsFor: 'testing' stamp: 'ab 12/5/2002 00:16'!includesMethod: aSymbol ofClass: aClass	aClass ifNil: [^ false].	^ self		includesMethodCategory: ((aClass organization categoryOfElement: aSymbol)										ifNil: [' '])		ofClass: aClass! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 9/17/2002 00:18'!includesMethodCategory: categoryName ofClass: aClass	^ (self isYourClassExtension: categoryName)		or: [(self includesClass: aClass)				and: [(self isForeignClassExtension: categoryName) not]]! !!PackageInfo methodsFor: 'testing' stamp: 'dvf 7/23/2003 14:06'!includesMethodCategory: categoryName ofClassNamed: aClass	^ (self isYourClassExtension: categoryName)		or: [(self includesClassNamed: aClass)				and: [(self isForeignClassExtension: categoryName) not]]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/14/2002 18:06'!includesMethodReference: aMethodRef	^ self includesMethod: aMethodRef methodSymbol ofClass: aMethodRef actualClass! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23'!includesSystemCategory: categoryName	^ self category: categoryName matches: self systemCategoryPrefix! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:23'!isForeignClassExtension: categoryName	^ categoryName first = $* and: [(self isYourClassExtension: categoryName) not]! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27'!isOverrideCategory: aString	^ aString endsWith: '-override'! !!PackageInfo methodsFor: 'testing' stamp: 'avi 9/10/2004 18:27'!isOverrideMethod: aMethodReference	^ self isOverrideCategory: aMethodReference category! !!PackageInfo methodsFor: 'testing' stamp: 'ar 12/23/2009 18:32'!isOverrideOfYourMethod: aMethodReference	"Answers true if the argument overrides a method in this package"	^ (self isYourClassExtension: aMethodReference category) not and:		[(self changeRecordForOverriddenMethod: aMethodReference) notNil]! !!PackageInfo methodsFor: 'testing' stamp: 'nk 4/28/2004 14:21'!isYourClassExtension: categoryName	^ categoryName notNil and: [self category: categoryName matches: self methodCategoryPrefix]! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:41'!methodsInCategory: aString ofClass: aClass 	^Array streamContents: [:stream |		self methodsInCategory: aString ofClass: aClass 			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'testing' stamp: 'nice 1/5/2010 14:01'!outsideClasses	^ProtoObject withAllSubclasses asSet difference: self classesAndMetaClasses! !!PackageInfo methodsFor: 'testing' stamp: 'bf 5/4/2005 16:44'!overrideCategoriesForClass: aClass	^Array streamContents: [:stream |		self overrideCategoriesForClass: aClass			do: [:each | stream nextPut: each]]! !!PackageInfo methodsFor: 'testing' stamp: 'ab 11/13/2002 01:25'!referenceForMethod: aSymbol ofClass: aClass	^ MethodReference new setStandardClass: aClass methodSymbol: aSymbol! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/17/2002 00:05'!categoryName	|category|	category := self class category.	^ (category endsWith: '-Info')		ifTrue: [category copyUpToLast: $-]		ifFalse: [category]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 6/10/2003 17:21'!methodCategoryPrefix	^ methodCategoryPrefix ifNil: [methodCategoryPrefix := '*', self packageName asLowercase]! !!PackageInfo methodsFor: 'naming' stamp: 'mist 2/17/2005 12:55'!name^ self packageName! !!PackageInfo methodsFor: 'naming' stamp: 'cmm 1/11/2011 18:22'!packageName	^ packageName		ifNil: [packageName := self class packageName						ifNil: [self categoryName]]! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 16:56'!packageName: aString	packageName := aString! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/28/2002 10:38'!systemCategoryPrefix	^ self packageName! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:16'!externalCallers	^ self 		externalRefsSelect: [:literal | literal isKindOf: Symbol] 		thenCollect: [:l | l].! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 6/10/2003 17:18'!externalClasses	| myClasses |	myClasses := self classesAndMetaClasses.	^ Array streamContents:		[:s |		ProtoObject withAllSubclassesDo:			[:class |			(myClasses includes: class) ifFalse: [s nextPut: class]]]! !!PackageInfo methodsFor: 'dependencies' stamp: 'nice 12/26/2009 19:07'!externalRefsSelect: selBlock thenCollect: colBlock	| pkgMethods dependents extMethods otherClasses otherMethods classNames |	classNames := self classes collect: [:c | c name].	extMethods := self extensionMethods collect: [:mr | mr methodSymbol].	otherClasses := self externalClasses difference: self externalSubclasses.	otherMethods :=  otherClasses gather: [:c | c selectors].	pkgMethods := self methods asSet collect: [:mr | mr methodSymbol].	pkgMethods removeAllFoundIn: otherMethods.	dependents := Set new.	otherClasses do: [:c |		c selectorsAndMethodsDo:			[:sel :compiled |			| refs |			(extMethods includes: sel) ifFalse: 				[refs := compiled literals select: selBlock thenCollect: colBlock.				refs do: [:ea |					((classNames includes: ea) or: [pkgMethods includes: ea])							ifTrue: [dependents add: (self referenceForMethod: sel ofClass: c) -> ea]]]]].	^ dependents! !!PackageInfo methodsFor: 'dependencies' stamp: 'cwp 11/13/2002 00:24'!externalSubclasses	| pkgClasses subClasses |	pkgClasses := self classes.	subClasses := Set new.	pkgClasses do: [:c | subClasses addAll: (c allSubclasses)].	^ subClasses difference: pkgClasses! !!PackageInfo methodsFor: 'dependencies' stamp: 'ab 11/18/2002 01:15'!externalUsers	^ self 		externalRefsSelect: [:literal | literal isVariableBinding] 		thenCollect: [:l | l key]! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 22:43'!hasPostscript	^ postscript notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 22:43'!hasPostscriptOfRemoval	^ postscriptOfRemoval notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/17/2005 22:39'!hasPreamble	^ preamble notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'mist 2/18/2005 22:43'!hasPreambleOfRemoval	^ preambleOfRemoval notNil! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:23'!postscript^ postscript ifNil: [postscript := TextModel withText: '"below, add code to be run after the loading of this package"'].! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:23'!postscript: aStringpostscript := TextModel withText: aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:24'!postscriptOfRemoval^ postscriptOfRemoval ifNil: [postscriptOfRemoval := TextModel withText: '"below, add code to clean up after the unloading of this package"']! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:24'!postscriptOfRemoval: aStringpostscriptOfRemoval := TextModel withText: aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:24'!preamble	^ preamble ifNil: [preamble := TextModel withText: '"below, add code to be run before the loading of this package"'].! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:24'!preamble: aStringpreamble := TextModel withText: aString! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:23'!preambleOfRemoval^ preambleOfRemoval ifNil: [preambleOfRemoval := TextModel withText: '"below, add code to prepare for the unloading of this package"']! !!PackageInfo methodsFor: 'preamble/postscript' stamp: 'jmv 3/23/2011 15:24'!preambleOfRemoval: aStringpreambleOfRemoval := TextModel withText: aString! !!PackageInfo methodsFor: 'source code management' stamp: 'bp 2/26/2010 21:14'!linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	^self methods inject: 0 into: [:sum :each | sum + each compiledMethod linesOfCode]! !!PackageInfo methodsFor: 'printing' stamp: 'bp 2/26/2010 20:37'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self packageName;		nextPut: $)! !!PackageInfo methodsFor: 'registering' stamp: 'avi 11/12/2003 23:12'!register	PackageOrganizer default registerPackage: self! !!PackageInfo methodsFor: 'fileOut' stamp: 'jmv 11/2/2011 19:36'!fileOut	| nameToUse |	nameToUse _ Preferences changeSetVersionNumbers		ifTrue: [ ChangeSet defaultChangeSetDirectory nextNameFor: self packageName extension: 'pck' ]		ifFalse: [ (self packageName , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'pck') asFileName ].	Cursor write		showWhile: [			| file |			file _ ChangeSet defaultChangeSetDirectory newFileNamed: nameToUse.			[				file timeStamp.				self fileOutOnStream: file ]					ensure: [file close]]! !!PackageInfo methodsFor: 'fileOut' stamp: 'jmv 11/1/2011 23:31'!fileOutOnStream: aStream	ChangeSetPackageExporter fileOutPackage: self on: aStream! !!PackageInfo class methodsFor: 'packages access' stamp: 'nk 3/9/2004 10:49'!allPackages	^PackageOrganizer default packages! !!PackageInfo class methodsFor: 'packages access' stamp: 'cmm 1/12/2011 13:52'!named: aString 	"Answer the PackageInfo with name aString."	| original replacement |	original := PackageOrganizer default				packageNamed: aString				ifAbsent: [].	^ (original isNil			or: [original class					~= (self classFor: aString)])		ifTrue: [replacement := self newNamed: aString.			original				ifNotNil: [replacement copySameFrom: original].			replacement register; yourself]		ifFalse: [original]! !!PackageInfo class methodsFor: 'packages access' stamp: 'cmm 1/11/2011 18:15'!packageName	"Subclasses announce their presence for a particular package by	overriding this method, answering the packageName of the package	they wish to represent. This is useful for the #classFor: factory	method. "	^ nil! !!PackageInfo class methodsFor: 'private' stamp: 'cmm 1/19/2011 17:15'!classFor: packageNameString 	self		allSubclassesDo: [:each | (each packageName isString					and: [each packageName sameAs: packageNameString])				ifTrue: [^ each]]! !!PackageInfo class methodsFor: 'private' stamp: 'cmm 1/12/2011 12:24'!newNamed: aString 	^ (self classFor: aString) new packageName: aString;		 yourself! !!PackageInfo class methodsFor: 'compatibility' stamp: 'avi 3/9/2004 16:28'!default	^ self allPackages detect: [:ea | ea class = self] ifNone: [self new register]! !!PackageInfo class methodsFor: 'class initialization' stamp: 'avi 2/18/2004 00:46'!initialize	self allSubclassesDo: [:ea | ea new register]! !!PackageInfo class methodsFor: 'registration / unregistration' stamp: 'ab 11/14/2002 15:05'!registerPackage: aString	"for compatibility with old fileOuts"	^ Smalltalk at: #FilePackageManager ifPresent: [:p | p registerPackage: aString]! !!PackageInfo class methodsFor: 'registration / unregistration' stamp: 'avi 11/11/2003 17:19'!registerPackageName: aString	^ PackageOrganizer default registerPackageNamed: aString! !!PackageList methodsFor: 'actions' stamp: 'jmv 3/23/2011 15:19'!addPackage	| packageName |	packageName := FillInTheBlank request: 'Package name:'.	packageName isEmpty ifFalse:		[selectedPackage := self packageOrganizer registerPackageNamed: packageName.		self changed: #packageSelection]! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:17'!packageOrganizer	^ PackageOrganizer default! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:24'!removePackage	self packageOrganizer unregisterPackage: selectedPackage! !!PackageList methodsFor: 'actions' stamp: 'avi 10/11/2003 00:23'!update: aSymbol	aSymbol = #packages ifTrue:		[packages := nil.		self changed: #packageList; changed: #packageSelection]! !!PackageList methodsFor: 'morphic' stamp: 'jmv 7/14/2011 12:53'!buildWindow	| window |	window := SystemWindow new.	window setLabel: self label.	window model: self.	window layoutMorph addMorphUseAll: (		PluggableListMorph			model: self			listGetter: #packageList			indexGetter: #packageSelection			indexSetter: #packageSelection:			mainView: window			menuGetter: #packageMenu			keystrokeAction: nil).	^ window! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:28'!defaultExtent	^ 200@200! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:36'!label	^ 'Packages'! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:24'!openInWorld	self packageOrganizer addDependent: self.	self buildWindow openInWorldExtent: self defaultExtent! !!PackageList methodsFor: 'morphic' stamp: 'jmv 11/2/2011 19:20'!packageContextMenu: aMenu	aMenu		addLine;		add: 'remove package' action: #removePackage;		add: 'export' action: #exportPackage! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/11/2003 00:10'!packageList	^ self packages collect: [:ea | ea packageName]! !!PackageList methodsFor: 'morphic' stamp: 'jmv 3/23/2011 15:41'!packageMenu	| aMenu |	aMenu _ MenuMorph new.	aMenu		defaultTarget: self;		add: 'add package' action: #addPackage.	selectedPackage ifNotNil: [self packageContextMenu: aMenu].	^ aMenu! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:41'!packageSelection	^ self packages indexOf: selectedPackage! !!PackageList methodsFor: 'morphic' stamp: 'avi 10/10/2003 22:41'!packageSelection: aNumber	selectedPackage := self packages at: aNumber ifAbsent: [].	self changed: #packageSelection! !!PackageList methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 00:18'!packages	^ packages ifNil: [packages := self packageOrganizer packages asSortedCollection:									[:a :b | a packageName <= b packageName]]! !!PackageList class methodsFor: 'as yet unclassified' stamp: 'jmv 7/14/2011 12:48'!initialize	self disableCode: [		TheWorldMenu registerOpenCommand: {'Package List'. {self. #open}}		]! !!PackageList class methodsFor: 'as yet unclassified' stamp: 'avi 10/10/2003 22:38'!open	^ self new openInWorld! !!PackageOrganizer methodsFor: 'registering' stamp: 'ar 6/16/2010 19:57'!flushObsoletePackages: aBlock	"Flush all packages considered obsolete by evaluating the argument block."	packages keys do:[:key|		(aBlock value: (packages at: key)) ifTrue:[packages removeKey: key].	].	self changed: #packages; changed: #packageNames.! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 23:01'!registerPackage: aPackageInfo	packages at: aPackageInfo packageName put: aPackageInfo.	self changed: #packages; changed: #packageNames.! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 21:08'!registerPackageNamed: aString	^ self registerPackage: (PackageInfo named: aString)! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 23:08'!unregisterPackage: aPackageInfo	packages removeKey: aPackageInfo packageName ifAbsent: [].		self changed: #packages; changed: #packageNames.! !!PackageOrganizer methodsFor: 'registering' stamp: 'avi 11/12/2003 21:10'!unregisterPackageNamed: aString	self unregisterPackage: (self packageNamed: aString ifAbsent: [^ self])! !!PackageOrganizer methodsFor: 'initializing' stamp: 'avi 11/12/2003 23:01'!initialize	packages := Dictionary new! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21'!noPackageFound	self error: 'No package found'! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 11/12/2003 23:08'!packageNamed: aString ifAbsent: errorBlock	^ packages at: aString ifAbsent: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21'!packageOfClass: aClass	^ self packageOfClass: aClass ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:22'!packageOfClass: aClass ifNone: errorBlock	^ self packages detect: [:ea | ea includesClass: aClass] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:21'!packageOfMethod: aMethodReference	^ self packageOfMethod: aMethodReference ifNone: [self noPackageFound]! !!PackageOrganizer methodsFor: 'searching' stamp: 'avi 10/11/2003 14:22'!packageOfMethod: aMethodReference ifNone: errorBlock	^ self packages detect: [:ea | ea includesMethodReference: aMethodReference] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 16:02'!packageOfMethodCategory: categoryName ofClass: aClass	^self packageOfMethodCategory: categoryName ofClass: aClass ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 16:02'!packageOfMethodCategory: categoryName ofClass: aClass ifNone: errorBlock	^ self packages detect: [:ea | ea includesMethodCategory: categoryName ofClassNamed: aClass] ifNone: errorBlock		! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 15:55'!packageOfSystemCategory: aSystemCategory	^ self packageOfSystemCategory: aSystemCategory ifNone: [ self noPackageFound ]! !!PackageOrganizer methodsFor: 'searching' stamp: 'nk 6/24/2004 15:54'!packageOfSystemCategory: aSystemCategory ifNone: errorBlock	^ self packages detect: [:ea | ea includesSystemCategory: aSystemCategory] ifNone: errorBlock! !!PackageOrganizer methodsFor: 'accessing' stamp: 'avi 11/12/2003 23:01'!packageNames	^ packages keys! !!PackageOrganizer methodsFor: 'accessing' stamp: 'avi 11/12/2003 23:01'!packages	^ packages values! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'avi 10/11/2003 00:17'!default	^ default ifNil: [default := self new]! !!PackageOrganizer class methodsFor: 'as yet unclassified' stamp: 'avi 10/13/2003 15:25'!new	^ self basicNew initialize! !PackageList initialize!PackageInfo initialize!