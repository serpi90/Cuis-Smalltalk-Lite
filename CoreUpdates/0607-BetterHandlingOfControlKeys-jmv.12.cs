'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 17 September 2010 at 3:39:29 pm'!!classDefinition: #SimpleEditor category: #'System-Text'!Editor subclass: #SimpleEditor	instanceVariableNames: 'string pointIndex markIndex beginTypeInIndex '	classVariableNames: 'CmdActions ShiftCmdActions '	poolDictionaries: ''	category: 'System-Text'!!classDefinition: 'TextEditor class' category: nil!TextEditor class	instanceVariableNames: 'cmdActions shiftCmdActions yellowButtonMenu shiftedYellowButtonMenu '!!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:34'!cursorDown: aKeyboardEvent	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self closeTypeIn.	self		moveCursor: [ :position | | newPos |			newPos _ self sameColumn: position newLine: [ :line | line + 1 ] forward: true.			"Mac standard keystroke"			aKeyboardEvent rawMacOptionKeyPressed ifTrue: [				newPos _ self endOfParagraph: position+1 ].			"Windows / Linux standard keystroke"			aKeyboardEvent controlKeyPressed ifTrue: [				newPos _ self beginningOfNextParagraph: position ].			"Mac standard keystroke"			aKeyboardEvent commandAltKeyPressed ifTrue: [				newPos _ self endOfText ].			newPos ]		forward: true		event: aKeyboardEvent.	^ true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:28'!cursorLeft: aKeyboardEvent	"Private - Move cursor left one character if nothing selected, otherwise move cursor to beginning of selection. If the shift key is down, start selecting or extending current selection. Don't allow cursor past beginning of text"	self closeTypeIn.	self		moveCursor: [ :position | | newPos |			newPos _ position - 1 max: 1.			"Mac standard keystroke"			(aKeyboardEvent rawMacOptionKeyPressed or: [				"Windows / Linux standard keystroke"				aKeyboardEvent controlKeyPressed ])					ifTrue: [						newPos _ self previousWordStart: newPos ].			"Mac standard keystroke"			aKeyboardEvent commandAltKeyPressed ifTrue: [				newPos _ self beginningOfLine: position ].			newPos ]		forward: false		event: aKeyboardEvent.	^ true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 11:19'!cursorPageDown: aKeyboardEvent 	self closeTypeIn.	self 		moveCursor: [:position |			self				sameColumn: position				newLine: [ :lineNo | lineNo + self pageHeight]				forward: true]		forward: true		event: aKeyboardEvent.	^true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 11:19'!cursorPageUp: aKeyboardEvent 	self closeTypeIn.	self 		moveCursor: [:position |			self				sameColumn: position				newLine: [ :lineNo | lineNo - self pageHeight]				forward: false]		forward: false		event: aKeyboardEvent.	^true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:11'!cursorRight: aKeyboardEvent 	"Private - Move cursor right one character if nothing selected, otherwise move cursor to end of selection. If the shift key is down, start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	self closeTypeIn.	self		moveCursor: [ :position | | newPos s |			newPos _ position + 1.			"Mac standard keystroke"			aKeyboardEvent rawMacOptionKeyPressed ifTrue: [				newPos _ self nextWordEnd: newPos ].			"Windows / Linux standard keystroke"			aKeyboardEvent controlKeyPressed ifTrue: [				newPos _ self nextWordStart: newPos ].			"Mac standard keystroke"			aKeyboardEvent commandAltKeyPressed ifTrue: [				newPos _ self endOfLine: position ].			newPos ]		forward: true		event: aKeyboardEvent.	^ true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:39'!cursorUp: aKeyboardEvent 	"Private - Move cursor from position in current line to same position in	prior line. If prior line too short, put at end"	self closeTypeIn.	self		moveCursor: [ :position | | newPos |			newPos _ self sameColumn: position newLine: [ :line | line - 1] forward: false.			"Mac standard keystroke"			(aKeyboardEvent rawMacOptionKeyPressed or: [				"Windows / Linux standard keystroke"				aKeyboardEvent controlKeyPressed ])					ifTrue: [						newPos _ self beginningOfParagraph: newPos-1 ].			"Mac standard keystroke"			aKeyboardEvent commandAltKeyPressed ifTrue: [				newPos _ self beginningOfText ].			newPos ]		forward: false		event: aKeyboardEvent.	^true! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 12:51'!beginningOfLine: position	"Redefined in subclasses using NewParagraph support"	^ self beginningOfParagraph: position! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:33'!beginningOfNextParagraph: position	| s |	s _ self string.	^ (s		indexOf: Character cr		startingAt: position		ifAbsent: [ s size ]) + 1! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:37'!beginningOfParagraph: position	^ (self string		lastIndexOf: Character cr		startingAt: position		ifAbsent: [ 0 ]) + 1.! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:39'!beginningOfText	^1! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:10'!endOfLine: position	"Redefined in subclasses using NewParagraph support"	^self endOfParagraph: position! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:09'!endOfParagraph: position	| s |	s _ self string.	^ s		indexOf: Character cr		startingAt: position		ifAbsent: [ s size + 1 ].! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:25'!endOfText	^self string size + 1! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 11:17'!moveCursor: directionBlock forward: forward event: aKeyboardEvent	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one."	| shift indices newPosition |	shift _ aKeyboardEvent shiftPressed.	indices _ self		setIndices: shift		forward: forward.	newPosition _ directionBlock value: (indices at: #moving).	shift		ifTrue: [			self				selectMark: (indices at: #fixed)				point: newPosition - 1 ]		ifFalse: [ self selectAt: newPosition ]! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:06'!nextWordEnd: position	| string index |	string _ self string.	index _ position.	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers not ]]		whileTrue: [ index _ index + 1 ].	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers ]]		whileTrue: [ index _ index + 1 ].	^ index! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:04'!nextWordStart: position	| string index |	string _ self string.	index _ position.	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers ]]		whileTrue: [ index _ index + 1 ].	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers not ]]		whileTrue: [ index _ index + 1 ].	^ index! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:04'!previousWordStart: position	| string index |	string _ self string.	index _ position.	[ (index between: 1 and: string size) and: [ (string at: index) isGenerallyValidInIdentifiers not ]]		whileTrue: [ index _ index - 1 ].	[ (index between: 1 and: string size) and: [ (string at: index) isGenerallyValidInIdentifiers ]]		whileTrue: [ index _ index - 1 ].	^ index + 1! !!InputSensor methodsFor: 'modifier keys' stamp: 'sw 9/21/2000 12:41'!rawMacOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific.  Clients are discouraged from calling this directly, since it circumvents bert's attempt to eradicate option-key checks"	^ self primMouseButtons anyMask: 32! !!InputSensor class methodsFor: 'public' stamp: 'jmv 9/17/2010 15:38'!installDuplicateKeyEntryFor: c	| key |	key _ c asInteger.	"do control->alt key"	KeyDecodeTable at: { key bitAnd: 16r9F . 2 } put: { key . 8 }! !!InputSensor class methodsFor: 'class initialization' stamp: 'jmv 9/17/2010 15:37'!defaultCrossPlatformKeys	"Answer a list of key letters that are used for common editing operations	on different platforms.""	^{ $c . $x . $v . $a . $s . $f . $g . $z }"	"Duplicating ctrl-a as alt/cmd-a also means duplicating ctrl-home as alt/cmd-a,	because the VM sends the same bit pattern for ctrl-a and ctrl-home.	I guess it is better to have proper ctrl-home.	The others are not much of a problem	"	^{ $c . $x . $v . $s . $f . $g . $z }! !!Morph methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:57'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	(self focusKeyboardFor: anEvent)		ifTrue: [ ^ self ].	self eventHandler ifNotNil: [		self eventHandler keyStroke: anEvent fromMorph: self].! !!Morph methodsFor: 'events-processing' stamp: 'jmv 9/17/2010 15:18'!focusKeyboardFor: aKeyboardEvent	"If aKeyboardEvent is an arrow key, use it to navigate keyboard focus"	"Keyboard focus navigations with alt/command + control + arrows"	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent controlKeyPressed ])		ifFalse: [ ^false ].	^aKeyboardEvent keyValue caseOf: {		[ 28 ] -> [			aKeyboardEvent hand keyboardFocusPrevious.			true ].		[ 29 ] -> [			aKeyboardEvent hand keyboardFocusNext.			true ].		[ 30 ] -> [			aKeyboardEvent hand keyboardFocusPrevious.			true ].		[ 31 ] -> [			aKeyboardEvent hand keyboardFocusNext.			true ] }		otherwise: [ false ]! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:57'!keyStroke: evt	"Handle a keystroke event."	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	"CR - check for special action	Note: Code below assumes that this was some	input field reacting on CR. Break the keyboard	focus so that the receiver can be safely deleted.	jmv - Currently not implemented"	"	evt keyValue = 13 ifTrue: [		action _ self crAction.		action ifNotNil: [			evt hand newKeyboardFocus: nil.			^action value ] ].	"	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromContents.	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:59'!keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	( self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	super keyStroke: evt.	(self scrollByKeyboard: evt)		ifTrue: [ ^self ].	scroller submorphs last keyStroke: evt! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/17/2010 13:59'!scrollByKeyboard: event	"If event is ctrl+up/down then scroll and answer true"	event controlKeyPressed ifFalse: [ ^ false ].	event keyValue = 30 ifTrue: [		scrollBar scrollUp: 3.		^ true ].	event keyValue = 31 ifTrue: [		scrollBar scrollDown: 3.		^ true ].	^ false.! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:57'!keyStroke: event 	"Process keys 	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"		| aChar aSpecialKey |	(self focusKeyboardFor: event)		ifTrue: [ ^ self ].	super keyStroke: event.	(self scrollByKeyboard: event) 		ifTrue: [^self].	aChar _ event keyCharacter.	aSpecialKey _ aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!PluggableTextMorph methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:58'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	textMorph keyStroke: evt.	self eventHandler ifNotNil: [		self eventHandler keyStroke: evt fromMorph: self ]! !!SimpleEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:42'!cursorEnd: aKeyboardEvent	"Private - Move cursor end of current line."	self closeTypeIn.	self		moveCursor: [ :dummy | self endOfText ]		forward: true		event: aKeyboardEvent.	^ true.! !!SimpleEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:42'!cursorHome: aKeyboardEvent 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	self		moveCursor:  [ :dummy | self beginningOfText ]		forward: false		event: aKeyboardEvent.	^true! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 9/17/2010 11:09'!dispatchOn: aKeyboardEvent	"Carry out the action associated with this character, if any."	| asciiValue |	asciiValue _ aKeyboardEvent keyValue.	"We don't support multiple lines. Therefore, we don't process cr as a #normalCharacter:"	asciiValue = 13 ifTrue: [		self closeTypeIn.		^ true].	^ self perform: (KeystrokeActions at: asciiValue + 1) with: aKeyboardEvent! !!SimpleEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/17/2010 13:03'!forwardDelete: aKeyboardEvent	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex stopIndex |	startIndex _ self markIndex.	startIndex > string size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: ''.		^ false].	"Null selection - do the delete forward"	beginTypeInIndex	"no previous typing.  openTypeIn"		ifNil: [self openTypeIn].	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [ stopIndex := (self nextWordStart: stopIndex) - 1 ].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: ''.	self selectFrom: startIndex to: startIndex-1.	^false! !!SimpleEditor class methodsFor: 'class initialization' stamp: 'jmv 9/17/2010 11:38'!initialize 	"SimpleEditor initialize"! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:59'!keyStroke: event 	"Process potential command keys"	| args aCharacter |	(self focusKeyboardFor: event)		ifTrue: [ ^ self ].	(self scrollByKeyboard: event)		ifTrue: [ ^self ].	aCharacter := event keyCharacter.	keystrokeActionSelector ifNil: [^self arrowKey: aCharacter].	(args := keystrokeActionSelector numArgs) = 1 		ifTrue: [^model perform: keystrokeActionSelector with: aCharacter].	args = 2 		ifTrue: [			^model 				perform: keystrokeActionSelector				with: aCharacter				with: self].	^self 		error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/17/2010 12:08'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))			openLabel: 'Comparison to Clipboard Text'! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/17/2010 12:08'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName lastIndex |	stringToSave := paragraph string.	stringToSave size = 0 ifTrue: [^self inform: 'nothing to save.'].	parentWindow := model dependents 				detect: [:dep | dep isKindOf: SystemWindow]				ifNone: nil.	labelToUse := parentWindow ifNil: ['Untitled']				ifNotNil: [parentWindow label].	suggestedName := nil.	#(#('Decompressed contents of: ' '.gz')) do: 			[:leaderTrailer | 			"can add more here..."			(labelToUse beginsWith: leaderTrailer first) 				ifTrue: 					[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1								to: labelToUse size.					(labelToUse endsWith: leaderTrailer last) 						ifTrue: 							[suggestedName := suggestedName copyFrom: 1										to: suggestedName size - leaderTrailer last size]						ifFalse: 							[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].							(lastIndex = 0 or: [lastIndex = 1]) 								ifFalse: [suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil: [suggestedName := labelToUse , '.text'].	fileName := FillInTheBlank request: 'File name?'				initialAnswer: suggestedName.	fileName isEmptyOrNil 		ifFalse: 			[(FileStream newFileNamed: fileName)				nextPutAll: stringToSave;				close]! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 9/17/2010 12:08'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| wasShowing userSelection delta loc |	aString = '#insert period' ifTrue:		[loc _ start.		[(loc _ loc-1)>0 and: [(paragraph string at: loc) isSeparator]]			whileTrue: [loc _ loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing _ selectionShowing) ifTrue: [ self reverseSelection ].	userSelection _ self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString.	delta _ aString size - (stop - start + 1).	self selectInvisiblyFrom:		userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:45'!cursorEnd: aKeyboardEvent 	"Private - Move cursor end of current line."	self closeTypeIn.	self		moveCursor: [ :position | | newPos |			newPos _ Preferences wordStyleCursorMovement				ifTrue: [ self endOfLine: position ]				ifFalse: [ self endOfParagraph: position ].			"Mac standard keystrole"					(aKeyboardEvent commandAltKeyPressed or: [				"Windows / Linux standard keystroke"				aKeyboardEvent controlKeyPressed ])					ifTrue: [ newPos _ self endOfText ].			newPos ]		forward: true		event: aKeyboardEvent.	^true! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:46'!cursorHome: aKeyboardEvent	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	self closeTypeIn.	self		moveCursor: [ :position | | newPos |			newPos _ Preferences wordStyleCursorMovement				ifTrue: [ self beginningOfLine: position ]				ifFalse: [ self beginningOfParagraph: position ].			"Mac standard keystrole"					(aKeyboardEvent commandAltKeyPressed or: [				"Windows / Linux standard keystroke"				aKeyboardEvent controlKeyPressed ])				ifTrue: [ newPos _ self beginningOfText ].			newPos ]		forward: false		event: aKeyboardEvent.	^true! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 9/17/2010 12:07'!blinkPrevParen: aKeyboardEvent	| openDelimiter closeDelimiter level string here hereChar |	string _ paragraph string.	here _ pointBlock stringIndex.	openDelimiter _ aKeyboardEvent keyValue.	closeDelimiter _ '([{' at: (')]}' indexOf: openDelimiter).	level _ 1.	[level > 0 and: [here > 2]]		whileTrue:			[hereChar _ string at: (here _ here - 1).			hereChar = closeDelimiter				ifTrue:					[level _ level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level _ level + 1]]]! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 9/17/2010 12:28'!dispatchOn: aKeyboardEvent	"Carry out the action associated with this character, if any."	| asciiValue |	self clearParens.  	asciiValue _ aKeyboardEvent keyValue.	"Control keys are handled by KeystrokeActions even if they have any modifiers"	(asciiValue >= 32 and: [		Preferences cmdKeysInText and: [ aKeyboardEvent commandAltKeyPressed ]]) ifTrue: [		^self perform: (self class cmdActions at: asciiValue + 1) with: aKeyboardEvent ].	(')]}' includes: aKeyboardEvent keyValue)		ifTrue: [ self blinkPrevParen: aKeyboardEvent ].	^ self perform: (KeystrokeActions at: asciiValue + 1) with: aKeyboardEvent! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/17/2010 12:06'!backWord: aKeyboardEvent	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else, delete the word before the caret."	| startIndex |	self hasCaret ifTrue: [ "a caret, delete at least one character"		startIndex _ 1 max: self markIndex - 1.		[startIndex > 1 and:			[(paragraph string at: startIndex - 1) tokenish]]				whileTrue: [					startIndex _ startIndex - 1]]	ifFalse: [ "a non-caret, just delete it"		startIndex _ self markIndex].	self backTo: startIndex.	^false! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/17/2010 13:03'!forwardDelete: aKeyboardEvent	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ self markIndex.	startIndex > paragraph text size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock ifNil: [	"no previous typing.  openTypeIn"		self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	upara _ UndoParagraph deepCopy.	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection is: #Text) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/17/2010 12:51'!beginningOfLine: position	"Redefined in subclasses using NewParagraph support"	^ (paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:24'!endOfLine: position	"Redefined in subclasses using NewParagraph support"	| targetLine |	targetLine _ paragraph lines at: (paragraph lineIndexOfCharacterIndex: position).	^ targetLine = paragraph lastLine		ifFalse: [ targetLine last ]		ifTrue: [ targetLine last + 1 ]! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/17/2010 11:17'!moveCursor: directionBlock forward: forward event: aKeyboardEvent	super moveCursor: directionBlock forward: forward event: aKeyboardEvent.	self setEmphasisHereFromTextForward: forward! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 9/17/2010 12:09'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc _ start + dir.	str _ paragraph string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc _ loc + dir].	^ loc! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 9/17/2010 12:10'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok _ false.	string _ paragraph string.	stop _ self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop _ stop - 1].	sep _ stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok _ true. sep _ sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/17/2010 11:43'!initializeBasicCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmds _ #(		$a #selectAll: 		$c #copySelection: 		$e #exchange: 		$f #find: 		$g #findAgain: 		$h #setSearchString: 		$v #paste: 		$w #backWord: 		$x #cut: 		$y #swapChars: 		$z #undo:		$C	#compareToClipboard:		$D	#duplicate:		$H	#cursorTopHome:		$J	#doAgainMany:		$K	#changeStyle:		$L	#outdent:		$M	#selectCurrentTypeIn:		$R	#indent:		$S	#search:		$U	#changeLfToCr:		$X	#makeLowercase:		$Y	#makeUppercase:		$Z	#makeCapitalized:	).	1 to: cmds size		by: 2		do: [ :i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions _ cmdMap! !!TextMorph methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:58'!keyStroke: evt	"Handle a keystroke event."	| action |	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	self pauseBlinking.	evt keyValue = 13 ifTrue: ["CR - check for special action"		action _ self crAction.		action ifNotNil: [			^action value]].	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromParagraph.	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!StringMorphEditor methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:58'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor oldSel newSel |	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandAltKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandAltKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	oldSel _ self editor selectionInterval.	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	oldSel = newSel ifTrue:		["There is a bug that causes characters to be misplaced when the second		character typed is wider than the first.  This fixes it (ugh)."		self editor selectFrom: newSel first + 1 to: newSel last + 1].! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:59'!keyStroke: evt	| view |	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].			"Maybe disable? Precludes the use of up and down arrows with control,	that are standard keystrokes in Windows to control the cursor.	Problem: At least Mac and Win VM generate ctrl-up and ctrl-down for	mouse wheel events.	I guess most people would prefer the mouse wheel to work properly..."	(editView scrollByKeyboard: evt)		ifTrue: [ ^self ].	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 9/17/2010 11:54'!rawMacOptionKeyPressed	"Answer whether the option/alt key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific. Please do not confuse with the alt key on Windows and Linux, that is called 'command' on the mac. See #commandAltKeyPressed"	^ buttons anyMask: 32! !!classDefinition: 'TextEditor class' category: nil!TextEditor class	instanceVariableNames: 'cmdActions yellowButtonMenu shiftedYellowButtonMenu'!TextEditor removeSelector: #moveCursor:forward:specialBlock:event:!SimpleEditor initialize!SimpleEditor class removeSelector: #initializeCmdKeyShortcuts!!classDefinition: #SimpleEditor category: #'System-Text'!Editor subclass: #SimpleEditor	instanceVariableNames: 'string pointIndex markIndex beginTypeInIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!Editor removeSelector: #backWord:!Editor removeSelector: #moveCursor:forward:specialBlock:event:!Editor removeSelector: #nextWord:!Editor removeSelector: #previousWord:!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."	Editor initialize.	InputSensor installKeyDecodeTable!