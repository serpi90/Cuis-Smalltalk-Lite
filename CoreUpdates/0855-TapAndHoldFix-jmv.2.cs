'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 10 March 2011 at 4:15:12 pm'!!classDefinition: #HandMorph category: #'Morphic-Kernel'!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder temporaryCursor temporaryCursorOffset hasChanged savedPatch userInitials lastEventBuffer lastKeyDownValue lastMouseEventTime '	classVariableNames: 'DoubleClickTime EventStats NormalCursor ShowEvents '	poolDictionaries: ''	category: 'Morphic-Kernel'!!HandMorph methodsFor: 'event handling' stamp: 'jmv 3/10/2011 15:43'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type hadAny |	ActiveEvent ifNotNil: [		"Meaning that we were invoked from within an event response.		Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent].	hadAny := false.	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [		evt := nil.	"for unknown event types"		type := evtBuf first.		type = EventSensor eventTypeMouse			ifTrue: [ evt := self generateMouseEvent: evtBuf ].		type = EventSensor eventTypeKeyboard 			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].		type = EventSensor eventTypeWindow			ifTrue: [ evt _ self generateWindowEvent: evtBuf ].		"All other events are ignored"		evt			ifNil: [				^hadAny]			ifNotNil: [				"Finally, handle it"				self handleEvent: evt.				hadAny := true.				"For better user feedback, return immediately after a mouse event has been processed."				evt isMouse ifTrue: [ ^hadAny ]]].	"note: if we come here we didn't have any mouse events"	mouseClickState 		ifNotNil: [ 			"No mouse events during this cycle. Make sure click states time out accordingly"			mouseClickState				handleEvent: (lastMouseEvent asMouseMove: (Time millisecondClockValue - lastMouseEventTime max: 0))				from: self ].	^hadAny! !!HandMorph methodsFor: 'events-processing' stamp: 'jmv 3/10/2011 15:40'!handleEvent: anEvent	| evt ofs |	owner ifNil:[^self].	evt _ anEvent.ShowEvents == true ifTrue:[	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.].	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[	Display fill: (0@0 extent: 250@120) rule: Form over fillColor: Color white.	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	self keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.		evt isWindowEvent ifTrue: [		self sendEvent: evt.		^ self mouseOverHandler processMouseOver: lastMouseEvent ].	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt.			lastMouseEventTime _ Time millisecondClockValue].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2011 15:39'!initForEvents	mouseOverHandler _ nil.	lastMouseEvent _ MouseEvent new setType: #mouseMove position: 0@0 buttons: 0 hand: self.	lastMouseEventTime _ Time millisecondClockValue.	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.	self resetClickState.! !!MouseEvent methodsFor: 'converting' stamp: 'jmv 3/10/2011 15:44'!asMouseMove:  deltaTime	"Convert the receiver into a mouse move. adjust timestamp by the provided delta"	^MouseMoveEvent new setType: #mouseMove startPoint: position endPoint: position trail: {position. position} buttons: buttons hand: source stamp: timeStamp + deltaTime! !MouseEvent removeSelector: #asMouseMove!!classDefinition: #HandMorph category: #'Morphic-Kernel'!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder temporaryCursor temporaryCursorOffset hasChanged savedPatch userInitials lastEventBuffer lastKeyDownValue lastMouseEventTime'	classVariableNames: 'DoubleClickTime EventStats NormalCursor ShowEvents'	poolDictionaries: ''	category: 'Morphic-Kernel'!