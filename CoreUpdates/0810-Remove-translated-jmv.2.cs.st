'From Cuis 3.0 of 31 January 2011 [latest update: #790] on 22 February 2011 at 11:12:51 pm'!!classDefinition: #MenuIcons category: #'Morphic-Menus'!Object subclass: #MenuIcons	instanceVariableNames: ''	classVariableNames: 'Icons TranslatedIcons MenuItemIcons '	poolDictionaries: ''	category: 'Morphic-Menus'!!Object methodsFor: 'private' stamp: 'jmv 2/22/2011 22:44'!errorNotIndexable	"Create an error notification that the receiver is not indexable."	self error: ('Instances of {1} are not indexable' format: {self class name})! !!AbstractSoundSystem methodsFor: 'misc' stamp: 'jmv 2/22/2011 22:13'!soundNameFromUser	"Pop up a list of available sound names and answer the one the user chooses, or nil if no choice made"	^ (SelectionMenu selections: self sampledSoundChoices asSortedArray) startUpWithCaption: 'Sounds'"SoundService default soundNameFromUser"! !!Browser methodsFor: 'class functions' stamp: 'jmv 2/22/2011 22:13'!classCommentText	"return the text to display for the comment of the currently selected class"	| theClass |	theClass _ self selectedClassOrMetaClass.	theClass ifNil: [ ^Text 				initialFont: Preferences standardCodeFont 				stringOrText: ''].	^ theClass hasComment		ifTrue: [ 			Text 				initialFont: Preferences standardCodeFont 				stringOrText: theClass comment ]		ifFalse: [			Text 				initialFont: Preferences standardCodeFont				string: 'THIS CLASS HAS NO COMMENT!!' 				attribute: TextColor red ]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 2/22/2011 22:33'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble := self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble := ''].	method := self methodDict at: selector ifAbsent:		[outStream nextPutAll: selector; cr.		outStream tab; nextPutAll: '** ERROR!!  THIS SCRIPT IS MISSING ** '; cr; cr.		outStream nextPutAll: '  '.		^ outStream].	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos := method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: method decompileString]		ifFalse:		[sourceFile := SourceFiles at: method fileIndex.		preamble size > 0			ifTrue:    "Copy the preamble"				[outStream copyPreamble: preamble from: sourceFile at: oldPos]			ifFalse:				[sourceFile position: oldPos].		"Copy the method chunk"		newPos := outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos := outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!ChangeSet class methodsFor: 'defaults' stamp: 'jmv 2/22/2011 22:13'!defaultName	^ self uniqueNameLike: 'Unnamed'! !!ChangeSet class methodsFor: 'defaults' stamp: 'jmv 2/22/2011 22:13'!promptForDefaultChangeSetDirectoryIfNecessary	"Check the Preference (if any), and prompt the user to change it if necessary.	The default if the Preference is unset is the current directory.	Answer the directory."	"ChangeSet promptForDefaultChangeSetDirectoryIfNecessary"	| choice directoryName dir |	directoryName := Preferences				parameterAt: #defaultChangeSetDirectoryName				ifAbsentPut: [''].	[dir := FileDirectory default directoryNamed: directoryName.	dir exists]		whileFalse: [choice := PopUpMenu withCaption: 			('The preferred change set directory (''{1}'') does not exist.Create it or use the default directory ({2})?' format: { directoryName. FileDirectory default pathName })	chooseFrom: (#('Create directory' 'Use default directory and forget preference' 'Choose another directory' ) collect: [ :ea | ea ]).			choice = 1				ifTrue: [ dir assureExistence ].			choice = 3				ifTrue: [ dir := FileList2 modalFolderSelector.					directoryName := dir					ifNil: [ '' ]						ifNotNil: [ dir pathName ]]].		self defaultChangeSetDirectory: directoryName.		^ dir! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'jmv 2/22/2011 22:14'!fileIntoNewChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fileName stream |	fullName ifNil: [^ Beeper beep].	fileName _ fullName.	(fullName endsWith: '.gz')		ifTrue: [			(self confirm: ('{1}appears to be a compressed file.Do you want to uncompress it?' format: { fullName }))				ifTrue: [					fileName _ GZipReadStream saveContents: fullName.					stream _ FileStream readOnlyFileNamed: fileName ]				ifFalse: [ ^self ]]		ifFalse: [			stream _ FileStream readOnlyFileNamed: fileName.			(fullName endsWith: '.mcz')				ifTrue: [					stream _ stream asUnZippedStream: 'snapshot/source.st'.					stream ascii ]].	self newChangesFromStream: stream named: (FileDirectory localNameFor: fileName)! !!Collection methodsFor: 'private' stamp: 'jmv 2/22/2011 22:33'!errorNotKeyed	self error: ('Instances of {1} do not respond to keyed accessing messages.' format: {self class name})! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 2/22/2011 22:36'!askForCategoryIn: aClass default: aString	| categories index category |	categories := OrderedCollection with: 'new ...'. 	categories addAll: (aClass allMethodCategoriesIntegratedThrough: Object).		index := PopUpMenu withCaption: 'Please provide a good category for the new method!!'						chooseFrom: categories.	index = 0 ifTrue: [^ aString].	category := index = 1 ifTrue: [FillInTheBlank request: 'Enter category name:']						ifFalse: [categories at: index].	^ category isEmpty ifTrue: [^ aString] ifFalse: [category]! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'jmv 2/22/2011 22:37'!asString	| result |	result := itemName.	('_*_' match: result)		ifTrue: [ result := (result copyFrom: 2 to: result size - 1) ].	^ result ! !!FileList methodsFor: 'file menu action' stamp: 'jmv 2/22/2011 22:38'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response := FillInTheBlank						request: ('New {1} Name?' format: {aString})						initialAnswer: ('{1}Name' format: {aString}))		isEmpty ifTrue: [^ self].	newName := response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index := list indexOf: newName.	index = 0 ifTrue: [ending := ') ',newName.		index := list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file menu action' stamp: 'jmv 2/22/2011 22:37'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: ('Really delete {1}?' format:{fileName})) ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState _ #FileList.	self get! !!FileList methodsFor: 'file menu action' stamp: 'jmv 2/22/2011 22:38'!renameFile	"Rename the currently selected file"	| newName response |	listIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(response _ FillInTheBlank request: 'NewFileName?' 					initialAnswer: fileName)		isEmpty ifTrue: [^ self].	newName _ response asFileName.	newName = fileName ifTrue: [^ self].	directory rename: fileName toBe: newName.	self updateFileList.	listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = newName].	listIndex > 0 ifTrue: [fileName _ newName].	self changed: #fileListIndex.! !!FileList methodsFor: 'to be transformed in registration' stamp: 'jmv 2/22/2011 22:38'!volumeMenu	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	^ aMenu addList: {			{'recent...'.				#recentDirs}.			#-.			{'delete directory...'.	#deleteDirectory}}.! !!FileList methodsFor: 'private' stamp: 'jmv 2/22/2011 22:37'!defaultContents	acceptedContentsCache _ (list		ifNil: [String new]		ifNotNil: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED'; cr.					s nextPutAll: '  -- Folder Summary --'; cr.					list do: [:item | s nextPutAll: item; cr]]]).	brevityState _ #FileList.	^ acceptedContentsCache! !!FileList methodsFor: 'private' stamp: 'jmv 2/22/2011 22:38'!put: aText	"Private - put the supplied text onto the file"	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [ acceptedContentsCache _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[self inform: 'No fileName is selected'.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	self inform: ('{1} contents cannotmeaningfully be saved at present.' format:{type}).	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'jmv 2/22/2011 22:38'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize := f size) <= 100000]) ifTrue: [		acceptedContentsCache _ f contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ acceptedContentsCache ].	"if brevityFlag is true, don't display long files when first selected"	first5000 := f next: 5000.	f close.	acceptedContentsCache _ ('File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' format: {fileName. fileSize. first5000}).	brevityState := #briefFile.   "don't change till actually read"	^ acceptedContentsCache! !!FileList methodsFor: 'private' stamp: 'jmv 2/22/2011 22:38'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f := directory oldFileOrNoneNamed: self fullName. 	f ifNil: [^ 'For some reason, this file cannot be read'].	((size := f size)) > 5000 & brevity		ifTrue: [data := f next: 10000. f close. brevityState := #briefHex]		ifFalse: [data := f contentsOfEntireFile. brevityState := #fullHex].	s := WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData := s contents.	^ acceptedContentsCache _ ((size > 5000) & brevity		ifTrue: ['File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' format: {fileName. size. hexData}]		ifFalse: [hexData])! !!FileList2 class methodsFor: 'morphic ui' stamp: 'jmv 2/22/2011 22:38'!morphicViewFileSelectorForSuffixes: aList 	"Answer a morphic file-selector tool for the given suffix list"	| dir aFileList window fixedSize midLine gap |	dir := FileDirectory default.	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList okayAndCancelServices.	aList ifNotNil: 			[aFileList 				fileSelectionBlock: 					[:entry :myPattern | 					entry isDirectory 						ifTrue: [false]						ifFalse: [							aList includes: (FileDirectory extensionFor: entry name asLowercase)]] 							].	window := AlignmentMorph proportional				color: Color lightBlue;				borderColor: Color blue;				extent: 600 @ 400.	window setProperty: #fileListModel toValue: aFileList.	aFileList modalView: window.	midLine := 0.4.	fixedSize := 25.	gap := 5.	self addFullPanesTo: window		from: {				{ 					self textRow: 'Please select a file'.					0 @ 0 corner: 1 @ 0.					0 @ 4 corner: 0 @ fixedSize}.				{ 					aFileList optionalButtonRow.					0 @ 0 corner: 1 @ 0.					0 @ fixedSize corner: 0 @ (fixedSize * 2)}.				{ 					aFileList morphicDirectoryTreePane.					0 @ 0 corner: midLine @ 1.					gap @ (fixedSize * 2) corner: gap negated @ 0}.				{ 					aFileList morphicFileListPane.					midLine @ 0 corner: 1 @ 1.					gap @ (fixedSize * 2) corner: gap negated @ 0}}.	aFileList postOpen.	^window! !!FileStream class methodsFor: 'file reader services' stamp: 'jmv 2/22/2011 22:38'!fileIn: fullName	"File in the entire contents of the file specified by the name provided"	| fileName stream |	fullName ifNil: [^ Beeper beep].	fileName _ fullName.	(fullName endsWith: '.gz')		ifTrue: [			(self confirm: ('{1}appears to be a compressed file.Do you want to uncompress it?' format:{fullName}))				ifTrue: [					fileName _ GZipReadStream saveContents: fullName.					stream _ FileStream readOnlyFileNamed: fileName ]				ifFalse: [ ^self ]]		ifFalse: [			stream _ FileStream readOnlyFileNamed: fileName.			(fullName endsWith: '.mcz')				ifTrue: [					stream _ stream asUnZippedStream: 'snapshot/source.st'.					stream ascii ]].	stream fileIn! !!Integer methodsFor: '*Morphic-Explorer' stamp: 'jmv 2/22/2011 22:39'!explorerContents	^#(		('hexadecimal' 16)		('octal' 8)		('binary' 2)) collect: [ :each |			ObjectExplorerWrapper				with: each first				name: (self printStringBase: each second)				model: self ]! !!LightWidget methodsFor: 'debug and other' stamp: 'jmv 2/22/2011 22:40'!buildDebugMenu: aHand 	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpIcons.	self isKnownFailing		ifTrue: 			[aMenu add: 'start drawing again' action: #resumeAfterDrawError.			aMenu addLine].	(self hasProperty: #errorOnStep) 		ifTrue: 			[aMenu add: 'start stepping again' action: #resumeAfterStepError.			aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	aMenu 		add: 'explore morph'		target: self		selector: #explore.	aMenu addLine.	aMenu 		add: 'browse morph class'		target: self		selector: #browseHierarchy.	aMenu addLine.	aMenu		add: 'edit balloon help' action: #editBalloonHelpText.	^aMenu! !!MenuIcons class methodsFor: 'class initialization' stamp: 'jmv 2/22/2011 23:11'!initialize	"self initialize"	| methods |	Icons := IdentityDictionary new.	methods := self class selectors select: [:each | '*Icon' match: each asString].	methods do: [ :each | Icons at: each put: ((MenuIcons perform: each) asFormOfDepth: 32)].	self initializeMenuItemIcons.	Smalltalk addToStartUpList: self.! !!MenuIcons class methodsFor: 'class initialization' stamp: 'jmv 2/22/2011 23:11'!startUp	self initializeMenuItemIcons.! !!MenuIcons class methodsFor: 'menu decoration' stamp: 'jmv 2/22/2011 23:11'!iconForMenuItem: anItem	"Answer the icon (or nil) corresponding to anItem."	^MenuItemIcons at: anItem contents asString asLowercase ifAbsent: nil! !!MenuIcons class methodsFor: 'menu decoration' stamp: 'jmv 2/22/2011 23:10'!initializeMenuItemIcons	"build a dictionary wordings -> icon to decorate the menus all over the image"		MenuItemIcons _ Dictionary new.	{		#('previous project' ) -> self backIcon.		#('jump to project...' ) -> self forwardIcon.		#('open...' ) -> self openIcon.		#('appearance...' ) -> self appearanceIcon.		#('help...' ) -> self helpIcon.		#('windows...' ) -> self windowIcon.		#('print PS to file...' ) -> self printIcon.		#('save' 'save project on file...' ) -> self saveIcon.		#('save as...' 'save as new version' ) -> self saveAsIcon.		#('quit' 'save and quit' ) -> self quitIcon.		""		#('do it (d)' ) -> self doItIcon.		#('inspect it (i)' 'explore it (I)' 'inspect world' 'explore world' 'inspect model' 'inspect morph'		'explore morph' 'inspect owner chain' 'explore' 'inspect' 'explore (I)' 'inspect (i)' 'basic inspect' )			-> self inspectIcon.		#('print it (p)' ) -> self printIcon.		""		#('copy (c)' ) -> self copyIcon.		#('paste (v)' 'paste...' ) -> self pasteIcon.		#('cut (x)' ) -> self cutIcon.		""		#('accept (s)' ) -> self okIcon.		#('cancel (l)' ) -> self cancelIcon.		""		#('do again (j)' ) -> self redoIcon.		#('undo (z)' ) -> self undoIcon.		""		#('find...(f)' 'find again (g)' 'find class... (f)' 'find method...' ) -> self findIcon.		""		#('remove' 'remove class (x)' 'delete method from changeset (d)'		'remove method from system (x)' 'delete class from change set (d)'		'remove class from system (x)' 'destroy change set (X)' )			-> self deleteIcon.		#('add item...' 'new category...' ) -> self newIcon.		""		#('new morph...' 'objects (o)' ) -> self morphsIcon.		""	} do: [ :assoc |		assoc key do: [ :str | MenuItemIcons at: str asLowercase put: assoc value ]]! !!Morph methodsFor: 'debug and other' stamp: 'jmv 2/22/2011 22:42'!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self buildDebugMenu: aHandMorph)! !!Morph methodsFor: 'debug and other' stamp: 'jmv 2/22/2011 22:44'!buildDebugMenu: aHand 	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpIcons.	self isKnownFailing		ifTrue: [			aMenu add: 'start drawing again' action: #resumeAfterDrawError.			aMenu addLine].	(self hasProperty: #errorOnStep) 		ifTrue: [			aMenu add: 'start stepping again' action: #resumeAfterStepError.			aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	self hasModel 		ifTrue: [			aMenu 				add: 'inspect model'				target: self model				action: #inspect].	aMenu 		add: 'explore morph'		target: self		selector: #explore.	aMenu addLine.	aMenu 		add: 'browse morph class'		target: self		selector: #browseHierarchy.	self hasModel 		ifTrue: [			aMenu 				add: 'browse model class'				target: self model				selector: #browseHierarchy].	aMenu addLine.	aMenu		add: 'edit balloon help' action: #editBalloonHelpText.	^aMenu! !!Morph methodsFor: 'drawing' stamp: 'jmv 2/22/2011 22:44'!hasClipSubmorphsString	"Answer a string that represents the clip-submophs checkbox"	^ (self clipsSubmorphs		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'provide clipping'! !!Morph methodsFor: 'e-toy support' stamp: 'jmv 2/22/2011 22:44'!unlockOneSubpart	| unlockables aMenu reply |	unlockables _ self submorphs select:		[ :m | m isLocked].	unlockables size <= 1 ifTrue: [^ self unlockContents].	aMenu _ SelectionMenu labelList: (unlockables collect: [:m | m externalName]) selections: unlockables.	reply _ aMenu startUpWithCaption: 'Who should be be unlocked?'.	reply ifNil: [^ self].	reply unlock! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:42'!addCopyItemsTo: aMenu 	"Add copy-like items to the halo menu"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'copy to paste buffer' action: #copyToPasteBuffer:.	aMenu add: 'copy & print...' subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:42'!addExportMenuItems: aMenu hand: aHandMorph	"Add export items to the menu"	aMenu ifNotNil: [		| aSubMenu |		aSubMenu _ MenuMorph new defaultTarget: self.		aSubMenu add: 'BMP file' action: #exportAsBMP.		aSubMenu add: 'JPEG file' action: #exportAsJPEG.		aSubMenu add: 'PNG file' action: #exportAsPNG.		aMenu add: 'export...' subMenu: aSubMenu]! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:42'!addFillStyleMenuItems: aMenu hand: aHand 	"Add the items for changing the current fill style of the Morph"	aMenu add: 'change color...' action: #changeColor! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:54'!addHaloActionsTo: aMenu 	"Add items to aMenu representing actions requestable via halo"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu addTitle: self externalName.	subMenu addStayUpIcons.	subMenu addLine.	subMenu add: 'delete' action: #dismissViaHalo.	subMenu balloonTextForLastItem: 'Delete this object -- warning -- can be destructive!!' .	self maybeAddCollapseItemTo: subMenu.	subMenu add: 'grab' action: #openInHand.	subMenu balloonTextForLastItem: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' .	subMenu addLine.	subMenu add: 'resize' action: #resizeFromMenu.	subMenu balloonTextForLastItem: 'Change the size of this object'.	subMenu add: 'duplicate' action: #maybeDuplicateMorph.	subMenu balloonTextForLastItem: 'Hand me a copy of this object'.	subMenu 		add: 'set color'		target: self		action: #changeColor.	subMenu balloonTextForLastItem: 'Change the color of this object'.	subMenu 		add: 'inspect'		target: self		action: #inspect.	subMenu balloonTextForLastItem: 'Open an Inspector on this object'.	aMenu add: 'halo actions...' subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:43'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	aMenu add: 'send to back' action: #goBehind.	aMenu add: 'bring to front' action: #comeToFront.	self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	(owner is: #BareTextMorph) ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addDebuggingItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu			add: ('unlock "{1}"' format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:43'!addToggleItemsToHaloMenu: aMenu	"Add standard true/false-checkbox items to the memu"	#(	(resistsRemovalString toggleResistsRemoval 'whether I should be reistant to easy deletion via the pink X handle')	(stickinessString toggleStickiness 'whether I should be resistant to a drag done by mousing down on me')	(lockedString lockUnlockMorph 'when "locked", I am inert to all user interactions')	(hasClipSubmorphsString changeClipSubmorphs 'whether the parts of objects within me that are outside my bounds should be masked.')	(hasDragAndDropEnabledString changeDragAndDrop 'whether I am open to having objects dropped into me')	) do: [ :trip | 			aMenu addUpdating: trip first action: trip second.			aMenu balloonTextForLastItem: trip third ]! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:44'!hasDragAndDropEnabledString	"Answer a string to characterize the drag & drop status of the  	receiver"	^ (self dragNDropEnabled		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'accept drops'! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:44'!lockedString	"Answer the string to be shown in a menu to represent the 	'locked' status"	^ (self isLocked		ifTrue: ['<on>']		ifFalse: ['<off>']), 'be locked'! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:44'!maybeAddCollapseItemTo: aMenu	"If appropriate, add a collapse item to the given menu"	| anOwner |	(anOwner _ self owner) ifNotNil:			[anOwner isWorldMorph ifTrue:				[aMenu add: 'collapse' target: self action: #collapse]]! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:44'!resistsRemovalString	"Answer the string to be shown in a menu to represent the 	'resistsRemoval' status"	^ (self resistsRemoval		ifTrue: ['<on>']		ifFalse: ['<off>']), 'resist being deleted'! !!Morph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:44'!stickinessString	"Answer the string to be shown in a menu to represent the  	stickiness status"	^ (self isSticky		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'resist being picked up'! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 2/22/2011 22:42'!addEmbeddingMenuItemsTo: aMenu hand: aHandMorph	| menu |	menu _ MenuMorph new defaultTarget: self.	self potentialEmbeddingTargets reverseDo: [:m | 		menu 			add: m class name asString 			target: m 			selector: #addMorphFrontFromWorldPosition: 			argumentList: {self}].	aMenu ifNotNil:[		menu submorphCount > 0 			ifTrue:[aMenu add:'embed into' subMenu: menu].	].	^menu! !!Morph methodsFor: 'text-anchor' stamp: 'jmv 2/22/2011 22:44'!hasDocumentAnchorString	^ (self textAnchorType == #document		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'Document'! !!Morph methodsFor: 'text-anchor' stamp: 'jmv 2/22/2011 22:44'!hasInlineAnchorString	^ (self textAnchorType == #inline		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'Inline'! !!Morph methodsFor: 'text-anchor' stamp: 'jmv 2/22/2011 22:44'!hasParagraphAnchorString	^ (self textAnchorType == #paragraph		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'Paragraph'! !!BareTextMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:13'!wrapString	"Answer the string to put in a menu that will invite the user to 	switch word wrap mode"	^ (wrapFlag		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text wrap to bounds'! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:34'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	deleteOnMouseUp		ifTrue: [ aCustomMenu add: 'stay up' action: #toggleDeleteOnMouseUp ]		ifFalse: [ aCustomMenu add: 'do not stay up' action: #toggleDeleteOnMouseUp ].	updateContinuously		ifTrue: [ aCustomMenu add: 'update only at end' action: #toggleUpdateContinuously ]		ifFalse: [ aCustomMenu add: 'update continuously' action: #toggleUpdateContinuously ]! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2011 22:39'!createAcceptButton	"create the [accept] button"	| result frame buttonColor theme |	theme _ Theme current.	theme useUniformColors		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]		ifFalse: [ buttonColor _ theme acceptButton].	result _ PluggableButtonMorph new		 model: self;		 color: buttonColor;		 label: 'Accept';		 action: #accept.	frame _ LayoutFrame fractions: (0.1 @ 0.75 corner: 0.45 @ 0.98).	result layoutFrame: frame.	self addMorph: result.	^ result! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2011 22:39'!createCancelButton	"create the [cancel] button"	| result frame buttonColor theme |	theme _ Theme current.	theme useUniformColors		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]		ifFalse: [ buttonColor _ theme buttonColorFrom: theme cancelButton ].	result _ PluggableButtonMorph new		 model: self;		 color: buttonColor;		 label: 'Cancel';		 action: #cancel.	frame _ LayoutFrame fractions: (0.55 @ 0.75 corner: 0.9 @ 0.98).	result layoutFrame: frame.	self addMorph: result.	^ result! !!HaloMorph methodsFor: 'private' stamp: 'jmv 2/22/2011 22:39'!addHandle: handleSpec on: eventName send: selector to: recipient 	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle aPoint iconName colorToUse |	aPoint := self 				positionIn: haloBox				horizontalPlacement: handleSpec horizontalPlacement				verticalPlacement: handleSpec verticalPlacement.	handle := HaloHandleMorph 				newBounds: (Rectangle center: aPoint extent: HandleSize asPoint)				color: (colorToUse := Color colorFrom: handleSpec color).	self addMorph: handle.	(iconName := handleSpec iconSymbol) ifNotNil: [			| form |			form := Icons at: iconName ifAbsent: [self class perform: iconName].			form ifNotNil: [					handle addMorphCentered: (ImageMorph new								image: form;								color: colorToUse makeForegroundColor;								lock)]].	handle 		on: #mouseUp		send: #endInteraction		to: self.	handle 		on: eventName		send: selector		to: recipient.	handle 		setBalloonText: (target balloonHelpTextForHandle: handle).	^handle! !!HaloMorph methodsFor: 'private' stamp: 'jmv 2/22/2011 22:39'!addHandleAt: aPoint color: aColor icon: iconName on: eventName send: selector to: recipient	"Add a handle centered at the given point with the given color, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle _ EllipseMorph		newBounds: (Rectangle center: aPoint extent: self handleSize asPoint)		color: aColor.	self addMorph: handle.	iconName ifNotNil:		[ | form |		form _ Icons at: iconName ifAbsent: [self class perform: iconName].		form ifNotNil:			[handle addMorphCentered: (ImageMorph new				image: form; 				color: aColor makeForegroundColor;				lock)]].	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle).	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'jmv 2/22/2011 22:39'!maybeDismiss: evt with: dismissHandle	"Ask hand to dismiss my target if mouse comes up in it."	evt hand obtainHalo: self.	(dismissHandle containsPoint: evt cursorPoint)		ifFalse: [			self delete.			target addHalo: evt]		ifTrue: [			target resistsRemoval ifTrue:				[(PopUpMenu					confirm: 'Really throw this away'					trueChoice: 'Yes'					falseChoice: 'Um, no, let me reconsider') ifFalse: [^ self]].			self delete.			target dismissViaHalo]! !!ImageMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:39'!opacityString	^ (self opaque		ifTrue: ['<on>']		ifFalse: ['<off>']), 'opaque'! !!MenuMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:42'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'add title...' action: #addTitle.	aCustomMenu add: 'sight target' action: #sightTarget:.	defaultTarget ifNotNil: [		aCustomMenu add: 'add item...' action: #addItem].	aCustomMenu add: 'add line' action: #addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jmv 2/22/2011 22:44'!addCustomMenuItems: menu hand: aHandMorph 	"Add morph-specific menu itemns to the menu for the hand"	super addCustomMenuItems: menu hand: aHandMorph.	self isWorldMorph 		ifTrue: [			menu 				add: 'desktop menu...'				target: self				action: #putUpDesktopMenu:].	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jmv 2/22/2011 22:49'!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu, given that the receiver is a World"	| unlockables |	self addFillStyleMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addDebuggingItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[ :m | m isLocked].	unlockables size = 1 ifTrue: [		aMenu add: ('unlock "{1}"' format:{unlockables first externalName})action: #unlockContents].	unlockables size > 1 ifTrue: [		aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 22:44'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	(SystemWindow windowsIn: self satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 22:44'!deleteNonWindows	(SelectionMenu confirm:'Do you really want to discard all objectsthat are not in windows?')		ifFalse: [^ self].	self allNonFlapRelatedSubmorphs do:		[:m | m delete]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 22:45'!findWindow: evt 	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."	| menu expanded collapsed nakedMorphs |	menu := MenuMorph new.	expanded := SystemWindow windowsIn: self				satisfying: [:w | w isCollapsed not].	collapsed := SystemWindow windowsIn: self				satisfying: [:w | w isCollapsed].	nakedMorphs := self submorphsSatisfying: [:m | (m is: #SystemWindow) not].	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) 		ifTrue: [^Beeper beep].	(expanded 		asArray sort: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #activateAndForceLabelToShow.				w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) 		ifFalse: [menu addLine].	(collapsed 		asArray sort: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #collapseOrExpand.				w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asArray sort: 			[:w1 :w2 | 			w1 nameForFindWindowFeature 				caseInsensitiveLessOrEqual: w2 nameForFindWindowFeature]) 		do: 			[:w | 			menu 				add: w nameForFindWindowFeature				target: w				action: #comeToFrontAndAddHalo].	menu addTitle: 'find window'.	menu popUpInWorld: self! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 22:45'!mouseButton2ClickOnDesktopWithEvent: evt 	"Put up the world menu when the user clicks on the morphic desktop with the mouseButton2 (usually right mouse button)."	| aMenu |	aMenu := self buildWorldMenu: evt.	aMenu addTitle: 'World'.	aMenu popUpInWorld: self! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 22:45'!putUpDesktopMenu: evt	"Put up the desktop menu"	^ ((self buildWorldMenu: evt) addTitle: Preferences desktopMenuTitle) popUpAt: evt position forHand: evt hand in: self! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 22:45'!putUpWorldMenu: evt	"Put up a menu in response to a click on the desktop, triggered by evt."	| menu |	evt isMouse ifTrue: [		evt mouseButton2Pressed			ifTrue: [^ self mouseButton2ClickOnDesktopWithEvent: evt].		evt shiftPressed ifTrue:[^ self findWindow: evt]].	"put up screen menu"	menu _ self buildWorldMenu: evt.	menu addTitle: Preferences desktopMenuTitle.	menu popUpInWorld: self.	^ menu! !!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 2/22/2011 22:45'!addCustomMenuItems:  aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	aMenu add: 'list font...' target: self action: #setListFont.	aMenu add: 'copy list to clipboard' target: self action: #copyListToClipboard.	aMenu add: 'copy selection to clipboard' target: self action: #copySelectionToClipboard! !!PolygonMorph methodsFor: 'access' stamp: 'jmv 2/22/2011 22:46'!openOrClosePhrase	| curveName |	curveName := self isCurve				ifTrue: ['curve']				ifFalse: ['polygon'].	^ closed		ifTrue: ['make open {1}' format: {curveName}]		ifFalse: ['make closed {1}' format: {curveName}]! !!PolygonMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:49'!addCustomMenuItems: aMenu hand: aHandMorph	| lineName |	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addUpdating: #handlesShowingPhrase target: self action: #showOrHideHandles.	vertices size > 2 ifTrue:		[aMenu addUpdating: #openOrClosePhrase target: self action: #makeOpenOrClosed.		lineName _ (closed ifTrue: ['outline'] ifFalse: ['line']).		self isCurve			ifTrue: [aMenu add: ('make segmented {1}' format: {lineName}) action: #toggleSmoothing]			ifFalse: [aMenu add: ('make smooth {1}' format: {lineName}) action: #toggleSmoothing]]. 	aMenu add: 'specify dashed line' action:  #specifyDashedLine.	self isOpen ifTrue: [		aMenu addLine.		aMenu addWithLabel: '---' enablement: [ self isOpen and: [ arrows ~~ #none ]] action:  #makeNoArrows.		aMenu addWithLabel: '-->' enablement: [ self isOpen and: [ arrows ~~ #forward ]] action:  #makeForwardArrow.		aMenu addWithLabel: '<--' enablement: [ self isOpen and: [ arrows ~~ #back ]] action:  #makeBackArrow.		aMenu addWithLabel: '<->' enablement: [ self isOpen and: [ arrows ~~ #both ]] action:  #makeBothArrows ]! !!PolygonMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:45'!handlesShowingPhrase	^ self showingHandles		ifTrue: ['hide handles']		ifFalse: ['show handles']! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'jmv 2/22/2011 22:46'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"PopUpMenu confirm: 'Are you hungry?'"	^ self confirm: queryString trueChoice: 'Yes' falseChoice: 'No'! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'jmv 2/22/2011 22:46'!confirm: queryString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"	| menu choice |	menu _ PopUpMenu labelArray: {'Yes'. 'No'. 'Cancel'}.	choice _ menu startUpWithCaption: queryString.	choice = 1 ifTrue: [^ true].	choice = 2 ifTrue: [^ false].	^ cancelBlock value! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'jmv 2/22/2011 22:46'!inform: aString	"PopUpMenu inform: 'I like Squeak'"	(PopUpMenu labels: ' OK ') startUpWithCaption: aString! !!Preferences class methodsFor: 'fonts' stamp: 'jmv 2/22/2011 22:54'!fontConfigurationMenu	| aMenu |	aMenu := MenuMorph new defaultTarget: Preferences.	aMenu addTitle: 'Standard System Fonts'.	aMenu addStayUpIcons.	aMenu add: 'default text font...' action: #chooseSystemFont.	aMenu balloonTextForLastItem: 'Choose the default font to be used for code and  in workspaces, transcripts, etc.'.	aMenu lastItem font: StrikeFont default.	aMenu add: 'list font...' action: #chooseListFont.	aMenu lastItem font: Preferences standardListFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in list panes'.	aMenu add: 'menu font...' action: #chooseMenuFont.	aMenu lastItem font: Preferences standardMenuFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in menus'.	aMenu add: 'window-title font...' action: #chooseWindowTitleFont.	aMenu lastItem font: Preferences windowTitleFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in window titles.'.	aMenu add: 'balloon-help font...' action: #chooseBalloonHelpFont.	aMenu lastItem font: Preferences standardBalloonHelpFont.	aMenu balloonTextForLastItem: 'choose the font to be used when presenting balloon help.'.	aMenu add: 'code font...' action: #chooseCodeFont.	aMenu lastItem font: Preferences standardCodeFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in code panes.'.	aMenu addLine.	aMenu add: 'restore default font choices' action: #restoreDefaultFonts.	aMenu balloonTextForLastItem: 'Use the standard system font defaults'.	aMenu add: 'print default font choices' action: #printStandardSystemFonts.	aMenu balloonTextForLastItem: 'Print the standard system font defaults to the Transcript'.	^aMenu! !!Preferences class methodsFor: 'misc' stamp: 'jmv 2/22/2011 22:47'!staggerPolicyString	"Answer the string to be shown in a menu to represent the 	stagger-policy status"	^ ((self valueOfFlag: #reverseWindowStagger)		ifTrue: ['<yes>']		ifFalse: ['<no>']), 'stagger windows'! !!ProgressBarMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addList: {		{'progress color...'. #changeProgressColor:}.		{'progress value...'. #changeProgressValue:}.	}! !!SelectionMorph methodsFor: 'halo commands' stamp: 'jmv 2/22/2011 22:47'!addCustomMenuItems: aMenu hand: aHandMorph	"Add custom menu items to the menu"	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	aMenu add: 'add or remove items' target: self selector: #addOrRemoveItems: argument: aHandMorph! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addLabelItemsTo: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'change when to act' action: #setActWhen.	aCustomMenu add: 'sight target' action: #sightTarget:.	target ifNotNil: [ aCustomMenu add: 'clear target' action: #clearTarget ]! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:48'!addLabelItemsTo: aCustomMenu hand: aHandMorph 	aCustomMenu add: 'change label' action: #setLabel! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jmv 2/22/2011 22:48'!outputPortNumFromUser	"Prompt the user for a MIDI output port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort outputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for output:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 2) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'jmv 2/22/2011 22:50'!buttonLabel: aString 	"Set the receiver's buttonLabel, to be used on a button in a 	tool-pane; this is split out so that a more abbreviated wording 	can be deployed if desired"	buttonLabel := aString! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'jmv 2/22/2011 22:50'!provider: anObject label: aString selector: aSymbol 	"basic initialization message"	provider := anObject.	label := aString.	selector := aSymbol.	stateSelector := #none.	description := ''! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jmv 2/22/2011 22:50'!provider: anObject label: aString selector: aSymbol description: anotherString 	"basic initialization message"	self		provider: anObject		label: aString		selector: aSymbol.	stateSelector := #none.	description := anotherString! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 2/22/2011 22:51'!writeClassRenameMethod: sel was: oldName fromInstVars: oldList 	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "	| tell choice newName answ code oldVer newList newVer instSel |	self flag: #bobconv.	tell := 'Reading an instance of ' , oldName 				, '.Which modern class should it translate to?'.	answ := (PopUpMenu 				labels: 'Let me type the name nowLet me think about itLet me find a conversion file on the disk') 					startUpWithCaption: tell.	answ = 1 		ifTrue: [			tell := 'Name of the modern class {1} should translate to:' format: {oldName}.			choice := FillInTheBlank request: tell.	"class name"			choice size = 0 				ifTrue: [answ := 'conversion method needed']				ifFalse: 					[newName := choice.					answ := Smalltalk at: newName asSymbol								ifAbsent: ['conversion method needed'].					answ class == String 						ifFalse: [renamed at: oldName asSymbol put: answ name]]].	answ = 3 | (answ = 0) 		ifTrue: [			self close.			^'conversion method needed'].	answ = 2 ifTrue: [answ := 'conversion method needed'].	answ = 'conversion method needed' 		ifTrue: [			self close.			newName := 'PutNewClassHere'].	answ class == String 		ifFalse: 			[oldVer := self versionSymbol: (structures at: oldName).			newList := (Array with: answ classVersion) , answ allInstVarNames.			newVer := self versionSymbol: newList.			instSel := 'convert' , oldVer , ':' , newVer , ':'].	code := WriteStream on: (String new: 500).	code		nextPutAll: sel;		cr.	answ class == String 		ifFalse: [			code				cr;				tab;				nextPutAll: 'reshaped at: #' , oldName , ' put: #' , instSel , '.'.			code				cr;				tab;				tab;				nextPutAll: '"Be sure to define that conversion method in class ' 							, answ name , '"'].	code		cr;		tab;		nextPutAll: '^ ' , newName.	"Return new class"	self class compile: code contents classified: 'conversion'.	newName = 'PutNewClassHere' 		ifTrue: [			self 				inform: 'Please complete the following method and then read-in the object file again.'.			Smalltalk browseAllImplementorsOf: sel asSymbol].	self flag: #violateBasicLayerPrinciples.	"SmartRefStream should not refer to UI!!!!!!!!!! (sd)"	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  	If this is true for class Foo, define classVersion in Foo class.  	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."	^answ! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jmv 2/22/2011 22:51'!verifyExistenceOfRecordedSound	"If the receiver has a recorded sound, answer true; if not, put up an informer and answer false"	^ self recordedSound		ifNotNil:			[true]		ifNil: [			self inform: 'please record a sound first'.			false]! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'jmv 2/22/2011 22:54'!getTypedFileName: aResult	| name |	name _ FillInTheBlank 		request: 'Enter a new file name' 		initialAnswer: ''.	name = '' ifTrue: [^self startUpWithCaption: 'Select a File:'].	name _ aResult directory fullNameFor: name.	^ StandardFileMenuResult			directory: (FileDirectory forFileName: name)			name: (FileDirectory localNameFor: name)! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'jmv 2/22/2011 22:54'!oldFileFrom: aDirectory	^(self oldFileMenu: aDirectory)		startUpWithCaption: 'Select a File:'! !!StringMorph methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:51'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change font' action: #changeFont.	aCustomMenu add: 'change emphasis' action: #changeEmphasis.! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'jmv 2/22/2011 22:54'!getFileNameFromUser	| newName |	newName _ FillInTheBlank		request: 'New File Name?'		initialAnswer: (FileDirectory localNameFor: self imageName).	newName isEmpty ifTrue: [^nil].	((FileDirectory default fileOrDirectoryExists: (self fullNameForImageNamed: newName)) or:	 [FileDirectory default fileOrDirectoryExists: (self fullNameForChangesNamed: newName)]) ifTrue: [		(self confirm: ('{1} already exists. Overwrite?' format: {newName})) ifFalse: [^nil]].	^newName! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 2/22/2011 22:52'!createCloseBox	^ self createBox labelGraphic: self class closeIcon;		 extent: self boxExtent;		 actionSelector: #closeBoxHit;		 setBalloonText: 'close this window'! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 2/22/2011 22:52'!createExpandBox	^ self createBox 				labelGraphic: self class expandIcon;			 extent: self boxExtent;		 actWhen: #buttonUp;		 actionSelector: #expandBoxHit;		 setBalloonText: 'expand to full screen'! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 2/22/2011 22:52'!createMenuBox	^ self createBox		 labelGraphic: self class menuIcon;		 extent: self boxExtent;		 actionSelector: #offerWindowMenu;		 setBalloonText: 'window menu'! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 2/22/2011 22:52'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	labelString ifNil: [ labelString := 'Untitled Window'].	isCollapsed := false.	paneMorphs := Array new.	borderColor := #raised.	borderWidth := 2.		self wantsLabel ifTrue: [self initializeLabelArea].	self 		on: #mouseEnter		send: #spawnReframeHandle:		to: self.	self 		on: #mouseLeave		send: #spawnReframeHandle:		to: self.	self extent: 300 @ 200.	updatablePanes := Array new! !!SystemWindow methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:54'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph."template..."	aCustomMenu addLine.	aCustomMenu add: 'edit label...' action: #relabel.! !!SystemWindow methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:54'!buildWindowMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'change title...' action: #relabel.	aMenu addLine.	aMenu add: 'send to back' action: #sendToBack.	aMenu add: 'make next-to-topmost' action: #makeSecondTopmost.	aMenu addLine.	aMenu add: (self isSticky ifTrue: ['make draggable'] ifFalse: ['make undraggable']) action: #toggleStickiness.	aMenu addLine.	aMenu add: 'full screen' action: #fullScreen.	self isCollapsed ifFalse: [aMenu add: 'window color...' action: #setWindowColor].	^aMenu! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 2/22/2011 22:52'!changeEmphasisOrAlignment	| menuStrings aList reply  code align menuList startIndex attribute |	startIndex _ self startIndex.	aList _ #(normal bold italic underlined struckOut leftFlush centered rightFlush justified).		align _ paragraph text alignmentAt: startIndex.	code _ paragraph text emphasisAt: startIndex.	menuList _ WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal'.	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue: [ '<on>', emph asString ]			ifFalse: [ '<off>', emph asString ]]).	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collectWithIndex: [ :type :i |		align = (i-1)			ifTrue: [ '<on>', type asString ]			ifFalse: [ '<off>', type asString ]]).	menuStrings _ menuList contents.	aList _ #(normal bold italic underlined struckOut leftFlush centered rightFlush justified).	reply _ (SelectionMenu labelList: menuStrings lines: #(1 5) selections: aList) startUpWithoutKeyboard.	reply ifNotNil: [		(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue: [				attribute _TextAlignment perform: reply]			ifFalse: [				attribute _ TextEmphasis perform: reply].		((menuStrings at: (aList indexOf: reply)) beginsWith: '<on>')			ifTrue: [ self unapplyAttribute: attribute ]			ifFalse: [ self applyAttribute:  attribute ]].	^ true! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 2/22/2011 22:53'!initializeMenu	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."	"TextEditor initialize"	menu _ SelectionMenu fromArray: {		{'find...(f)'.					#find}.		{'find again (g)'.				#findAgain}.		{'set search string (h)'.		#setSearchString}.		#-.		{'do again (j)'.				#again}.		{'undo (z)'.					#undo}.		#-.		{'copy (c)'.					#copySelection}.		{'cut (x)'.					#cut}.		{'paste (v)'.					#paste}.		{'paste...'.					#pasteRecent}.		#-.		{'set font... (k)'.				#offerFontMenu}.		{'set alignment...'.			#chooseAlignment}.	}! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 2/22/2011 22:51'!initializeMenu	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	menu _ SelectionMenu fromArray: {		{'find...(f)'.				#find}.		{'find again (g)'.			#findAgain}.		{'set search string (h)'.	#setSearchString}.		#-.		{'do again (j)'.			#again}.		{'undo (z)'.				#undo}.		#-.		{'copy (c)'.				#copySelection}.		{'cut (x)'.				#cut}.		{'paste (v)'.				#paste}.		{'paste...'.				#pasteRecent}.		#-.		{'do it (d)'.				#doIt}.		{'print it (p)'.			#printIt}.		{'inspect it (i)'.			#inspectIt}.		{'explore it (I)'.			#exploreIt}.		{'debug it'.				#debugIt}.		#-.		{'explain'.					#explain}.		{'browse it (b)'.				#browseIt}.		{'senders of it (n)'.			#sendersOfIt}.		{'implementors of it (m)'.	#implementorsOfIt}.		{'references to it (N)'.		#referencesToIt}.		#-.		{'accept (s)'.				#accept}.		{'cancel (l)'.					#cancel}.		#-.		{'method strings with it (E)'.	#methodStringsContainingit}.		{'method source with it'.		#methodSourceContainingIt}.		{'class comments with it'.		#classCommentsContainingIt}.		{'change sets with it' .			#browseChangeSetsWithSelector}.	}! !!FileContentsEditor class methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:37'!paneMenu:  aMenu	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| services maybeLine extraLines brevityState fileName theModel |	theModel _ aMenu defaultTarget textProvider.	fileName _ theModel fileName.	fileName ifNotNil: [		brevityState _ theModel brevityState.		services _ OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue: [			services add: theModel serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse: [			services add: theModel serviceGetHex].		maybeLine _ services size.		(#('st' 'cs') includes: theModel suffixOfSelectedFile) ifTrue: [			services addAll:				(theModel servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines _ OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: theModel fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)'.				#find}.			{'find again (g)'.			#findAgain}.			{'set search string (h)'.	#setSearchString}.			#-.			{'do again (j)'.			#again}.			{'undo (z)'.				#undo}.			#-.			{'copy (c)'.				#copySelection}.			{'cut (x)'.				#cut}.			{'paste (v)'.				#paste}.			{'paste...'.				#pasteRecent}.			#-.			{'do it (d)'.				#doIt}.			{'print it (p)'.			#printIt}.			{'inspect it (i)'.			#inspectIt}.			{'fileIn selection (G)'.	#fileItIn}.			#-.			{'accept (s)'.			#accept}.			{'cancel (l)'.				#cancel}}.	^ aMenu! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 2/22/2011 22:53'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' ) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 2/22/2011 22:55'!promptForCancel	"Ask if it is OK to cancel changes to text"	(self confirm:'Changes have not been saved.Is it OK to cancel those changes?')		ifTrue: [ model clearUserEditFlag ]! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 2/22/2011 22:53'!cleanUpWorld	(SelectionMenu confirm:'This will remove all windows except thosecontaining unsubmitted text edits, and willalso remove all non-window morphs (otherthan flaps) found on the desktop.  Are yousure you want to do this?')		ifFalse: [^ self].	myWorld allNonFlapRelatedSubmorphs do:		[:m | m delete].	(SystemWindow windowsIn: myWorld satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 2/22/2011 22:53'!quitSession	Smalltalk 		snapshot: (self confirm: 'Save changes before quitting?' orCancel: [^ self])		andQuit: true! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 2/22/2011 22:53'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result oldDepth allDepths allLabels menu hasBoth |	oldDepth := Display nativeDepth.	allDepths := #(1 -1 2 -2 4 -4 8 -8 16 -16 32 -32) 				select: [:d | Display supportsDisplayDepth: d].	hasBoth := (allDepths anySatisfy: [:d | d > 0]) 				and: [allDepths anySatisfy: [:d | d < 0]].	allLabels := allDepths collect: 					[:d | 					String streamContents: 							[:s | 							s nextPutAll: (d = oldDepth ifTrue: ['<on>'] ifFalse: ['<off>']).							s print: d abs.							hasBoth 								ifTrue: 									[s 										nextPutAll: (d > 0 ifTrue: ['  (big endian)'] ifFalse: ['  (little endian)'])]]].	menu := SelectionMenu labels: allLabels selections: allDepths.	result := menu startUpWithCaption: 'Choose a display depth'.	result ifNotNil: [Display newDepth: result].	oldDepth := oldDepth abs! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 2/22/2011 22:53'!worldMenuHelp	| aList aMenu cnts explanation |	"self currentWorld primaryHand worldMenuHelp"	aList _ OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu windowsMenu appearanceMenu) 		with:	#('help' 'changes' 'open' 'debug' 'windows' 'appearance' ) do:		[:sel :title | aMenu _ self perform: sel.			aMenu items do:				[:it | (((cnts _ it contents) = 'keep this menu up') or: [cnts isEmpty])					ifFalse: [aList add: (cnts, ' - ', title)]]].	aList _ aList asArray sort: [:a :b | a asLowercase < b asLowercase].	explanation _ String streamContents: [:aStream | aList do:		[ :anItem | aStream nextPutAll: anItem; cr ]].	(TextModel new contents: explanation)		openLabel: 'Where in the world menu is...'! !!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 2/22/2011 22:53'!fillIn: aMenu from: dataForMenu	"A menu constructor utility by RAA.  dataForMenu is a list of items which mean:			nil								Indicates to add a line			first element is symbol		Add updating item with the symbol as the wording selector			second element is a list		second element has the receiver and selector			first element is a string		Add menu item with the string as its wording			second element is a list		second element has the receiver and selector			a third element exists			Use it as the balloon text			a fourth element exists		Use it as the enablement selector (updating case only)"	| item |	dataForMenu do: [ :itemData |		itemData ifNil: [aMenu addLine] ifNotNil:			[item _ (itemData first isKindOf: Symbol)				ifTrue: 					[aMenu 						addUpdating: itemData first 						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}]				 ifFalse:					[aMenu 						add: itemData first						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}].			itemData size >= 3 ifTrue:				[aMenu balloonTextForLastItem: itemData third.			itemData size >= 4 ifTrue:				[item enablementSelector: itemData fourth]]]].	^ aMenu! !!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 2/22/2011 22:53'!helpMenu        "Build the help menu for the world."        |  menu |  	menu := self menu: 'help...'.        self fillIn: menu from:        {                {'about this system...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.                {'preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.                nil.               {'command-key help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}	}.	self addGestureHelpItemsTo: menu.	self fillIn: menu from:	{                {'world menu help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.                {'useful expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.                nil.                {'set author initials...' . { Utilities . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.                {'vm statistics' . { self . #vmStatistics}.  'obtain some intriguing data about the vm.'}.			nil.                {'space left' . { self . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.        }.	^menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 2/22/2011 22:55'!newMorph	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."	| menu subMenu catDict shortCat class |	menu _ self menu: 'Add a new morph'.	menu				add: 'from paste buffer'		target: myHand		action: #pasteMorph;				add: 'from alphabetical list'		subMenu: self alphabeticalMorphMenu.	menu addLine.	Preferences classicNewMorphMenu ifTrue: [		menu addLine.		catDict _ Dictionary new.		SystemOrganization categories do: [ :cat |			((cat beginsWith: 'Morphic-') and: [ (#('Morphic-Menus' 'Morphic-Support' ) includes: cat) not ]) ifTrue: [				shortCat _ (cat					copyFrom: 'Morphic-' size + 1					to: cat size).				(SystemOrganization listAtCategoryNamed: cat) do: [ :cName |					class _ Smalltalk at: cName.					((class inheritsFrom: Morph) and: [ class includeInNewMorphMenu ]) ifTrue: [						(catDict includesKey: shortCat)							ifTrue: [ (catDict at: shortCat) addLast: class ]							ifFalse: [								catDict									at: shortCat									put: (OrderedCollection with: class) ]]]]].		catDict keys sort do: [ :categ |			subMenu _ MenuMorph new.			((catDict at: categ) asArray sort: [ :c1 :c2 |				c1 name < c2 name ]) do: [ :cl |				subMenu					add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl ].			menu				add: categ				subMenu: subMenu ]].	self doPopUp: menu.! !!TheWorldMenu methodsFor: 'mechanics' stamp: 'jmv 2/22/2011 22:53'!menu: titleString	"Create a menu with the given title, ready for filling"	| menu |	(menu _ MenuMorph entitled: titleString) 		defaultTarget: self; 		addStayUpIcons;		commandKeyHandler: self.	self colorForDebugging: menu.	^ menu! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 2/22/2011 22:55'!offerCommonRequestsInMorphic	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| aMenu strings aString |	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array]) 		ifTrue: [self initializeCommonRequestStrings].	strings := CommonRequestStrings actualContents.	aMenu := MenuMorph new.	aMenu title: 'Common Requests'.	aMenu addStayUpIcons.	strings asString linesDo: [ :each | 		aString _ each.		aString = '-' 			ifTrue: [ aMenu addLine ]			ifFalse: [				aString size = 0 ifTrue: [ aString := ' ' ].				aMenu 					add: aString					target: self					selector: #eval:					argument: aString]].	aMenu addLine.	aMenu 		add: 'edit this list'		target: self		action: #editCommonRequestStrings.	aMenu popUpInWorld: self currentWorld! !!VersionsBrowser methodsFor: 'init & update' stamp: 'jmv 2/22/2011 22:55'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	selectorOfMethod _ selector.	currentCompiledMethod _ method.	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].	changeList _ OrderedCollection new.	list _ OrderedCollection new.	self addedChangeRecord ifNotNil: [ :change |		self addItem: change text: ('{1} (in {2})' format: { change stamp. change fileName }) ].	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x ifNotNil: [ x readOnlyCopy]].	method fileIndex = 0 ifTrue: [^ nil].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens _ Smalltalk actualScannerClass new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:54'!compareToOtherVersion	"Prompt the user for a reference version, then spawn a window 	showing the diffs between the older and the newer of the current 	version and the reference version as text."	| change1 change2 s1 s2 differDesc diffWords |	change1 := changeList at: listIndex ifAbsent: [ ^self ].	change2 := ((SelectionMenu				labels: (list copyWithoutIndex: listIndex)				selections: (changeList copyWithoutIndex: listIndex)) startUp) ifNil: [ ^self ].		"compare earlier -> later"	"change1 timeStamp < change2 timeStamp		ifFalse: [ | temp | temp _ change1. change1 _ change2. change2 _ temp ]."	s1 := change1 string.	s2 := change2 string.	s1 = s2		ifTrue: [^ self inform: 'Exact Match'].	diffWords _ self shouldDiffWords.	differDesc _ diffWords		ifTrue: [ 'Words']		ifFalse: [ 'Lines'].	(TextModel new		contents: (DifferenceFinder			displayPatchFrom: s1 to: s2			tryWords: diffWords			prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [classOfMethod])))		openLabel: 			(('Comparison from {1} to {2}: ', differDesc, 				(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])) 					format: { change1 stamp. change2 stamp })! !!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 2/22/2011 22:55'!versionsMenu	"Fill aMenu with menu items appropriate to the receiver"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Versions'.	aMenu addStayUpIcons.	listIndex > 0 ifTrue:[		(list size > 1 ) ifTrue: [			aMenu addList: #(				('compare to current'		compareToCurrentVersion		'compare selected version to the current version')				('compare to version...'		compareToOtherVersion		'compare selected version to another selected version'))].		"Note: Revert to selected should be visible for lists of length one for having the ability to revert to an accidentally deleted method"		 aMenu addList: #(			('revert to selected version'	fileInSelections					'resubmit the selected version, so that it becomes the current version') )].	aMenu addList: #(		('remove from changes'	removeMethodFromChanges	'remove this method from the current change set, if present')		('edit current method (O)'	openSingleMessageBrowser	'open a single-message browser on the current version of this method')				('find original change set'	findOriginalChangeSet			'locate the changeset which originally contained this version')		-		('toggle diffing (D)'			toggleDiffing					'toggle whether or not diffs should be shown here')		('update list'				reformulateList					'reformulate the list of versions, in case it somehow got out of synch with reality')		-		('senders (n)'				browseSenders					'browse all senders of this selector')		('implementors (m)'			browseImplementors			'browse all implementors of this selector')		-		('help...'						offerVersionsHelp				'provide an explanation of the use of this tool')).												^aMenu! !!Workspace methodsFor: 'variable declarations' stamp: 'jmv 2/22/2011 22:55'!mustDeclareVariableWording		^ mustDeclareVariables not		ifTrue: ['<yes> automatically create variable declaration']		ifFalse: ['<no> automatically create variable declaration']! !!ZipReadStream methodsFor: 'crc' stamp: 'jmv 2/22/2011 22:55'!verifyCrc	"Verify the CRC-32 checksum calculated from the input against the expected CRC-32, if any.	Answer the calculated CRC-32 in any case.	Note that the CRC-32 used in Zip files is actually the bit inverse of the calculated value, so that is what is returned."	| invertedCrc |	invertedCrc _ crc bitXor: 16rFFFFFFFF.	(expectedCrc notNil and: [ expectedCrc ~= invertedCrc ])		ifTrue: [ ^ self crcError: ('Wrong CRC-32 (expected {1} got {2}) (proceed to ignore)' format: { expectedCrc hex. invertedCrc hex }) ].	^invertedCrc! !String removeSelector: #translated!MenuMorph removeSelector: #addTranslatedList:!MenuIcons initialize!MenuIcons class removeSelector: #initializeTranslations!MenuIcons class removeSelector: #itemsIcons!!classDefinition: #MenuIcons category: #'Morphic-Menus'!Object subclass: #MenuIcons	instanceVariableNames: ''	classVariableNames: 'Icons MenuItemIcons'	poolDictionaries: ''	category: 'Morphic-Menus'!ElementCategory removeSelector: #translated!CustomMenu removeSelector: #addTranslatedList:!