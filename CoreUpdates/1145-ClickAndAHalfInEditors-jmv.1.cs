'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 18 November 2011 at 8:45:14 am'!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient firstClickDown clickSelector dblClickSelector tripleClickSelector sendMouseButton2Activity buttonDownCount clickCount lastClickTimestamp clickDone doubleClickDone lastClickDown clickAndHalfDone clickAndHalfSelector buttonUpCount '	classVariableNames: 'DoubleClickTimeout '	poolDictionaries: ''	category: 'Morphic-Kernel'!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialWordSelStop initialWordSelStart '	classVariableNames: 'ChangeText FindText '	poolDictionaries: ''	category: 'System-Text'!!HandMorph methodsFor: 'double click support' stamp: 'jmv 11/17/2011 21:19'!        waitForClicksOrDrag: aMorph event: evt clkSel: clkSel dblClkSel: dblClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _		MouseClickState new			client: aMorph			click: clkSel			clickAndHalfSelector: nil 			dblClick: dblClkSel			tripleClick: nil			event: evt			sendMouseButton2Activity: false! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 11/17/2011 21:18'!             waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel tripleClkSel: tripleClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _		MouseClickState new			client: aMorph			click: clkSel			clickAndHalfSelector: clkNHalfSel			dblClick: dblClkSel			tripleClick: tripleClkSel			event: evt			sendMouseButton2Activity: Preferences tapAndHoldEmulatesButton2! !!HandMorph methodsFor: 'events-processing' stamp: 'jmv 11/17/2011 17:10'!                        handleEvent: anEvent	| evt |	owner ifNil: [ ^self ].	evt _ anEvent.	evt isMouseOver ifTrue: [ ^self sendMouseEvent: evt ].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.		evt isWindowEvent ifTrue: [		self sendEvent: evt.		^ self mouseOverHandler processMouseOver: lastMouseEvent ].	evt isKeyboard ifTrue: [		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue: [		self sendEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue: [		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt.			lastMouseEventTime _ Time millisecondClockValue].	"Check for pending drag or double click operations."	mouseClickState ifNotNil: [		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something. Do not further process this event."			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].	evt isMove ifTrue: [		self position: evt position.		self sendMouseEvent: evt.	] ifFalse: [		"Issue a synthetic move event if we're not at the position of the event"		evt position = self position ifFalse: [ self moveToEvent: evt ].		"Drop submorphs on button events"		self hasSubmorphs			ifTrue: [ self dropMorphs: evt ]			ifFalse: [ self sendMouseEvent: evt ].	].	self mouseOverHandler processMouseOver: lastMouseEvent! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/17/2011 22:16'!            clickAndHalf: evt	self handleInteraction: [		editor clickAndHalf: (evt translatedBy: bounds topLeft negated) ].	owner scrollSelectionIntoView: evt! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/17/2011 22:18'!                          mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: (event translatedBy: bounds topLeft negated)].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: #clickAndHalf:		dblClkSel: nil		tripleClkSel: #tripleClick:! !!MouseClickState methodsFor: 'initialize' stamp: 'jmv 11/17/2011 22:09'!               client: aMorph click: aClickSelector clickAndHalfSelector: aClickAndHalfSelector dblClick: aDblClickSelector tripleClick: aTripleClickSelector event: firstClickEvent sendMouseButton2Activity: aBoolean	clickClient _ aMorph.	clickSelector _ aClickSelector.	clickAndHalfSelector _ aClickAndHalfSelector.	dblClickSelector _ aDblClickSelector.	tripleClickSelector _ aTripleClickSelector.	sendMouseButton2Activity _ aBoolean.	buttonDownCount _ 1.	buttonUpCount _ 0.	clickDone _ false.	clickAndHalfDone _ false.	doubleClickDone _ false.	lastClickDown _ firstClickEvent! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 11/17/2011 22:09'!                       click	clickDone ifFalse: [		clickSelector ifNotNil: [			clickClient perform: clickSelector with: lastClickDown ].		clickDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 11/17/2011 22:15'!           clickAndAHalf	clickAndHalfDone ifFalse: [		clickAndHalfSelector ifNotNil: [			clickClient perform: clickAndHalfSelector with: lastClickDown ].		clickAndHalfDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 11/17/2011 22:09'!       doubleClick	doubleClickDone ifFalse: [		dblClickSelector ifNotNil: [			clickClient perform: dblClickSelector with: lastClickDown ].		doubleClickDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 11/18/2011 08:45'!                   handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| timedOut distance |	lastClickDown ifNil: [		lastClickDown _ evt ].	timedOut _ (evt timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.	distance _ (evt position - lastClickDown position) r.	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."	evt isMouseDown ifTrue: [		lastClickDown _ evt.		buttonDownCount _ buttonDownCount + 1 ].	evt isMouseUp ifTrue: [		buttonUpCount _ buttonUpCount + 1 ].	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [			aHand resetClickState.			clickClient mouseButton2Activity.			^true ].		"If we have already moved, then it won't be a double or triple click... why wait?"		distance > 0 ifTrue: [			aHand resetClickState.			self click.			^true ]].	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [		aHand resetClickState.		^true ].	"Simple click."	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [		self click ].	"Click & hold"	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [		self clickAndAHalf ].	"Double click."	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [		self doubleClick ].	"Triple click"	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [		self tripleClick ].	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"	^ evt isMouseDown not ! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 11/17/2011 22:09'!     tripleClick	tripleClickSelector ifNotNil: [		clickClient perform: tripleClickSelector with: lastClickDown ]! !!MouseClickState class methodsFor: 'class initialization' stamp: 'jmv 11/17/2011 22:10'!                   initialize	"	MouseClickState initialize	"	DoubleClickTimeout _ 350! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 11/17/2011 22:17'!    clickAndHalf: evt	self handleInteraction: [ editor clickAndHalf: evt ]! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 11/17/2011 22:17'!    mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event hand newKeyboardFocus: self.	self handleInteraction: [		editor mouseDown: event index: (self characterIndexAtPoint: event position) ].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: #clickAndHalf:		dblClkSel: nil		tripleClkSel: nil! !!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 11/17/2011 21:20'!                            mouseDown: event	"Handle a mouse down event."	| grabbedMorph |	grabbedMorph _ self morphToGrab: event.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		^event hand grabMorph: grabbedMorph].	event mouseButton2Pressed ifTrue: [^self mouseButton2Activity].	super mouseDown: event.	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: event		clkSel: #click:		clkNHalf: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/17/2011 21:20'!                        mouseDown: event	event mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].	isPressed _ true.	self redrawNeeded.	actWhen == #buttonDown ifTrue: [		self performAction ].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/17/2011 21:20'!                        mouseDown: event	event mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	scroller mouseDown: event.	event hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: nil		dblClkSel: #doubleClick:		tripleClkSel: #tripleClick:! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/17/2011 21:19'!         mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and: [ aMorph inToggleArea: evt position ])		ifTrue: [ ^self toggleExpandedState: aMorph event: evt ]. 	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [ ^ self mouseButton2Activity ].	aMorph ifNil: [ ^super mouseDown: evt ].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: evt 		clkSel: #click:		clkNHalf: nil		dblClkSel: nil		tripleClkSel: nil! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 11/17/2011 21:20'!        mouseDown: evt	| row |	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: evt		clkSel: #click:		clkNHalf: nil		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])		tripleClkSel: nil! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 11/17/2011 21:20'!                         mouseDown: event	| oldIndex oldVal row w |	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row _ self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	w _ self ownerThatIsA: SystemWindow.	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!SimpleEditor methodsFor: 'events' stamp: 'jmv 11/17/2011 22:17'!                      clickAndHalf: evt	| here |	here _ self pointIndex.	(here between: 2 and: string size)		ifTrue: [ self selectWord ]		ifFalse: [			"if at beginning or end, select entire string"			self selectAll ].! !!TextEditor methodsFor: 'events' stamp: 'jmv 11/17/2011 22:43'!               clickAndHalf: evt	self selectWord.	initialWordSelStart _ self startBlock.	initialWordSelStop _ self stopBlock! !!TextEditor methodsFor: 'events' stamp: 'jmv 11/17/2011 22:42'!          mouseDown: evt 	| clickPoint b |	initialWordSelStart _ nil.	initialWordSelStop _ nil.	"Multiple selection of text.	Windows uses Control, Mac uses Command (i.e. commandAlt)	On the Mac, command-button1 is translated to command-button3 by the VM. do:		Preferences disable: #commandClickOpensHalo	to disable this behavior and make command-button1 work for multiple selection. "	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [		self selectionInterval size > 0 ifTrue: [			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]	ifFalse: [		selectionStartBlocks _ #().		selectionStopBlocks _ #() ].	clickPoint _ evt position.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint) ifTrue: [		markBlock _ b.		pointBlock _ b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			markBlock _ b.			pointBlock _ b ]! !!TextEditor methodsFor: 'events' stamp: 'jmv 11/17/2011 22:42'!                        mouseMove: evt	"Change the selection in response to mouse-down drag"	initialWordSelStart		ifNil: [			pointBlock _ (paragraph characterBlockAtPoint: (evt position)).			self storeSelectionInParagraph ]		 ifNotNil: [			pointBlock _ (paragraph characterBlockAtPoint: (evt position)).			self selectWordLeftDelimiters: '' rightDelimiters: ''.			markBlock _ self startBlock min: initialWordSelStart.			pointBlock _ self stopBlock max: initialWordSelStop.			self storeSelectionInParagraph ]! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 11/17/2011 22:43'! initialize	selectionStartBlocks _ #().	selectionStopBlocks _ #().	initialWordSelStart _ nil.	initialWordSelStop _ nil! !!SmalltalkEditor methodsFor: 'events' stamp: 'jmv 11/17/2011 22:38'!                            clickAndHalf: evt	| here |	here _ self pointIndex.	(here between: 2 and: model textSize)		ifTrue: [			super clickAndHalf: evt]		ifFalse: [			"if at beginning or end, select entire string"			self selectAll ]! !SmalltalkEditor removeSelector: #doubleClick:!TextEditor removeSelector: #doubleClick:!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialWordSelStart initialWordSelStop'	classVariableNames: 'ChangeText FindText'	poolDictionaries: ''	category: 'System-Text'!SimpleEditor removeSelector: #doubleClick:!OneLineEditorMorph removeSelector: #doubleClick:!MouseClickState initialize!MouseClickState removeSelector: #client:click:dblClick:tripleClick:event:sendMouseButton2Activity:!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickSelector clickAndHalfSelector dblClickSelector tripleClickSelector sendMouseButton2Activity buttonDownCount buttonUpCount clickDone clickAndHalfDone doubleClickDone lastClickDown'	classVariableNames: 'DoubleClickTimeout'	poolDictionaries: ''	category: 'Morphic-Kernel'!InnerTextMorph removeSelector: #doubleClick:!HandMorph removeSelector: #waitForClicksOrDragOrSimulatedMouseButton2:event:clkSel:dblClkSel:tripleClkSel:!