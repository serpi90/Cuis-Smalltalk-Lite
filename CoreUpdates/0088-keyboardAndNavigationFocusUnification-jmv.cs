'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 14 November 2008 at 12:43:26 pm'!!classDefinition: #OldHandMorph category: #'Morphic-OldKernel'!OldMorph subclass: #OldHandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder temporaryCursor temporaryCursorOffset hasChanged savedPatch userInitials lastEventBuffer navigationFocus '	classVariableNames: 'DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents '	poolDictionaries: 'EventSensorConstants'	category: 'Morphic-OldKernel'!!Canvas methodsFor: 'drawing-general'!fullDraw: anObject	^anObject fullDrawOn: self! !!LightWidget methodsFor: 'add/remove' stamp: 'jmv 11/11/2008 15:19'!delete	"Remove the receiver as a submorph of its owner and make its 	new owner be nil."	| aWorld |	aWorld := self world ifNil: [World].	"Terminate genie recognition focus"	"I encountered a case where the hand was nil, so I put in a little 	protection - raa "	" This happens when we are in an MVC project and open	  a morphic window. - BG "	aWorld ifNotNil:[		self activeHand			releaseKeyboardFocus: self;			releaseMouseFocus: self].	owner ifNotNil:[ self privateDelete].! !!LightWidget methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 17:17'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes could change their appearance in some way when they are the current keyboard focus. This default implementation does nothing.		Only morphs that answer true to #handlesKeyboard will ever get keyboard focus!!"		self changed! !!ButtonLW methodsFor: 'accessing' stamp: 'jmv 11/11/2008 15:33'!backColor	^self hasKeyboardFocus		ifTrue: [ selectedBackColor ]		ifFalse: [ backColor ]! !!ButtonLW methodsFor: 'accessing' stamp: 'jmv 11/11/2008 15:33'!foreColor	^self hasKeyboardFocus		ifTrue: [ selectedForeColor ]		ifFalse: [ foreColor ]! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 11/11/2008 15:28'!keyStroke: anEvent			(anEvent commandKeyPressed and: [anEvent keyValue = 13]) ifTrue: [		self flag: #jmv.		"?"		"		self hasKeyboardFocus ifFalse: [			evt hand newKeyboardFocus: self ].		"		self performAction.		self updateView].	super keyStroke: anEvent	! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 11/11/2008 15:28'!mouseDown: evt	self flag: #jmv.	"?"	"	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self ].	"	pressed _ true.	self updateView! !!CheckBoxLW methodsFor: 'accessing' stamp: 'jmv 11/11/2008 15:33'!backColor	^self hasKeyboardFocus		ifTrue: [ selectedBackColor ]		ifFalse: [ backColor ]! !!CheckBoxLW methodsFor: 'accessing' stamp: 'jmv 11/11/2008 15:33'!foreColor	^self hasKeyboardFocus		ifTrue: [ selectedForeColor ]		ifFalse: [ foreColor ]! !!CheckBoxLW methodsFor: 'event handling' stamp: 'jmv 11/11/2008 15:28'!keyStroke: anEvent			(anEvent commandKeyPressed and: [anEvent keyValue = 13]) ifTrue: [		self flag: #jmv.		"?"		"		self hasKeyboardFocus ifFalse: [			evt hand newKeyboardFocus: self ].		"		selected _ selected not.		target perform: action with: selected.		self updateView].	super keyStroke: anEvent! !!CheckBoxLW methodsFor: 'event handling' stamp: 'jmv 11/11/2008 15:29'!mouseDown: evt	self flag: #jmv.	"?"	"	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self ].	"! !!CheckBoxLW methodsFor: 'event handling' stamp: 'jmv 11/11/2008 15:29'!mouseUp: evt	"Handle a mouse up event."	(self containsPoint: evt cursorPoint) ifTrue: [		self flag: #jmv.		"?"		"		self hasKeyboardFocus ifFalse: [			evt hand newKeyboardFocus: self ].		"		selected _ selected not.		target perform: action with: selected.		self updateView].! !!ListLW methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 15:50'!ensureVisible: aSubmorph	"Default is to do nothing."		| delta |	delta _ aSubmorph bounds amountToTranslateWithin: bounds.	delta = (0@0) ifFalse: [		submorphs do: [ :m |			m privateFullMoveBy: delta].		self changed]! !!MenuItemLW methodsFor: 'event handling' stamp: 'jmv 11/11/2008 15:29'!mouseUp: evt	self flag: #jmv.	"?"	"	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self ].	"	super mouseUp: evt! !!MenuItemLW methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 17:19'!keyboardFocusChange: aBoolean	aBoolean ifTrue: [		owner ensureVisible: self ].	self changed! !!MenuListLW methodsFor: 'event handling' stamp: 'jmv 11/11/2008 15:34'!mouseDown: evt	| y current |	current _ ActiveHand keyboardFocus.	(current notNil and: [current owner == self]) ifTrue: [		y _ evt position y.		y - bounds top < 30 ifTrue: [			self flag: #jmv.			"jmv - emular boton arriba y abajo. Es para navegar menues con scroll sin teclado (iPhone)"			"			ActiveHand navigationFocusPrevious			"].		bounds bottom - y < 30 ifTrue: [			"			ActiveHand navigationFocusNext			"]	]	! !!OldMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/11/2008 15:19'!delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld := self world ifNil: [World].
	"Terminate genie recognition focus"
	"I encountered a case where the hand was nil, so I put in a little 
	protection - raa "
	" This happens when we are in an MVC project and open
	  a morphic window. - BG "
	aWorld ifNotNil: [
	 	self disableSubmorphFocusForHand: self activeHand.		self activeHand			releaseKeyboardFocus: self;			releaseMouseFocus: self].
	owner ifNotNil:[ self privateDelete].! !!OldFillInTheBlankMorph methodsFor: 'invoking' stamp: 'jmv 11/11/2008 16:37'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w _ self world.	w ifNil: [^ response].	done _ false.	textPane focusText.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^ response! !!OldHandMorph methodsFor: 'events-processing' stamp: 'jmv 11/11/2008 15:37'!handleEvent: anEvent	| evt ofs k |	owner ifNil:[^self].	evt _ anEvent.	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[	Display fill: (0@0 extent: 450@120) rule: Form over fillColor: Color white.	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.	evt isKeyboard ifTrue:[		(evt commandKeyPressed and: [evt isKeystroke]) ifTrue: [		self flag: #jmv. "Se supone que habilitar esto hace que no te puedas ir de los 'dialogos', no?""			(navigationFocus notNil and: [ navigationFocus seizesNavigationFocus ]) ifFalse: ["				k _ evt keyValue.				k = 28 ifTrue: [					self keyboardFocusPrevious.					^self mouseOverHandler processMouseOver: lastMouseEvent].				k = 29 ifTrue: [					self keyboardFocusNext.					^self mouseOverHandler processMouseOver: lastMouseEvent].				k = 30 ifTrue: [					self keyboardFocusPrevious.					^self mouseOverHandler processMouseOver: lastMouseEvent].				k = 31 ifTrue: [					self keyboardFocusNext.					^self mouseOverHandler processMouseOver: lastMouseEvent]."			]."		].		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 16:00'!keyboardFocusNext	| firstCandidate candidate |	firstCandidate _ keyboardFocus isNil		ifTrue: [ World submorphs first ]		ifFalse: [ keyboardFocus nextMorph ].		candidate _ firstCandidate.	candidate handlesKeyboard ifFalse: [		[			candidate _ candidate nextMorph.			candidate handlesKeyboard not and: [ candidate ~~ firstCandidate ] ] whileTrue ].	candidate flash.	candidate activateWindowAndSendTopToBack: true.	self newKeyboardFocus: candidate! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 16:01'!keyboardFocusPrevious	| firstCandidate candidate |	firstCandidate _ keyboardFocus isNil		ifTrue: [ World ]		ifFalse: [ keyboardFocus previousMorph ].	candidate _ firstCandidate.	candidate handlesKeyboard ifFalse: [		[			candidate _ candidate previousMorph.			candidate handlesKeyboard not and: [ candidate ~~ firstCandidate ] ] whileTrue ].	candidate flash.	candidate activateWindow.	self newKeyboardFocus: candidate! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 13:30'!newKeyboardFocus: aMorphOrNil	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	| oldFocus |	oldFocus _ keyboardFocus.	keyboardFocus _ aMorphOrNil.	oldFocus ifNotNil: [oldFocus == aMorphOrNil ifFalse: [oldFocus keyboardFocusChange: false]].	aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true].! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 15:35'!releaseAllFoci	mouseFocus _ nil.	keyboardFocus _ nil! !!OldHandMorph methodsFor: 'private events' stamp: 'jmv 11/11/2008 16:27'!sendKeyboardEvent: anEvent	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."		| w |	keyboardFocus ifNotNil: [		(w _ keyboardFocus world) ifNil: [			keyboardFocus _ nil.			^self ].		^self sendFocusEvent: anEvent to: keyboardFocus in: w]."Si no hay foco de teclado no hacer nada.En realidad, si el world o la hand quiere los teclazos esta bien. Lo que no hay que hacer es buscar a quien mandarselos"self flag: #jmv."	^self sendEvent: anEvent"! !!OldPluggableTextMorph methodsFor: 'focus handling' stamp: 'jmv 11/12/2008 10:16'!focusText	self activeHand newKeyboardFocus: textMorph! !!PersonView methodsFor: 'initialization' stamp: 'jmv 11/11/2008 15:30'!initialize	"initialize the state of the receiver"	| n b a  g |	super initialize.	bounds _ 10@10 extent: 450@400.		n _ LabelLW label:  'Name:'.	n bounds: ((10@20) extent: 90@40).	nameLW _ EntryFieldLW new		aspect: #name;		action: #name:;		bounds: (115 @20 extent: 200@40).	hide _ false.	hideNameLW _ ButtonLW  target: self action:#toogleHideName label:'Hide name'.		hideNameLW bounds: ((115+205) @20 extent: 120@40).		b _ LabelLW label:  'Birthday:'.	b bounds: ((10@65) extent: 100@40).	birthdayLW _ EntryFieldLW new		aspect: #birthday adaptor: #mmddyyyy action: #birthday: adaptor: #asDate;		bounds: (115@65 extent: 200@40).		a _ LabelLW label:  'Age:'.	a bounds: ((10@115) extent: 50@40).	ageLW _ EntryFieldLW new		aspect: #age adaptor: #asString action: #age: adaptor: #asNumber;		bounds: (115@115 extent: 200@40).	sliderLW _ SliderLW new		target: target aspect:#age action: #age:;		bounds:( 115@160 extent: 200@40).	 	g _ LabelLW label:  'Gender:'.	g bounds: ((10@210) extent: 100@40).	genderLW_ ListLW new.	genderLW		bounds: (115@255 extent: 200@55);			addItem: 'Male' action: #male;		addItem: 'Female' action: #female.	self 		addMorphBack: n; addMorphBack: nameLW;		addMorphBack:b; addMorphBack: birthdayLW;addMorphBack: hideNameLW;		addMorphBack: a; addMorphBack: ageLW;addMorphBack: sliderLW;		addMorphBack: g; addMorphBack: genderLW.		ActiveHand newKeyboardFocus: nameLW! !!ProgressPaneLW methodsFor: 'updating' stamp: 'jmv 11/11/2008 15:30'!updateProgressBar	progressBar target: target.	self isOperationInProgress ifTrue:[ActiveHand newKeyboardFocus:  progressBar]! !!ProgressPaneLW methodsFor: 'updating' stamp: 'jmv 11/11/2008 15:30'!updateStart	start		visible:  target percentage = 0;		target: self.		 target percentage = 0 ifTrue:[ActiveHand newKeyboardFocus: start]! !!ProgressPaneLW methodsFor: 'initialization' stamp: 'jmv 11/11/2008 15:30'!initialize	super initialize.	bounds _ 10@10 extent: 250@150.		progressBar _ ProgressBarLW new.	progressBar		bounds:(20@60 extent: 200@30);		aspect:#percentage.	self addMorphBack: progressBar.		indeterminateProgressBar _ IndeterminatePogressBarLW new.	indeterminateProgressBar		bounds:(20@100 extent: 200@30);		target: self aspect:#isOperationInProgress.	self addMorphBack: indeterminateProgressBar.				start _ ButtonLW new.	start		bounds: (20@10 extent: 180@30);		action:#startOperation;		label:'Start operation'.	self addMorphBack: start.			ActiveHand newKeyboardFocus: start			 ! !!StackedPageSample1LW methodsFor: 'initialization' stamp: 'jmv 11/11/2008 15:31'!initialize	| title close menu |	super initialize.	level _ 1.	bounds _ 0 @ 0 extent: 400 @ 300.	title _ LabelLW label: 'Application Start'.	title bounds: (110@30 corner: 300@60).	close _ ButtonLW target: self action: #delete label: 'x'.	close bounds: (0@0 extent: 25@25).	menu _ ListLW new.	menu bounds: (20@150 extent: 340@120).	self		addMorph: title;		addMorph: close;		addMorph: menu.	firstFocus _ menu addItem: 'Go back' action: #delete.	menu		addItem: 'Something to do 1' action: #openChild;		addItem: 'Something to do 2' action: #openChild;		addItem: 'Something to do 3' action: #openChild;		addItem: 'Something to do 4' action: #openChild;		addItem: 'Something to do 5' action: #openChild;		addItem: 'Something to do 6' action: #openChild.	ActiveHand newKeyboardFocus: firstFocus! !!StackedPageSample1LW methodsFor: 'user actions' stamp: 'jmv 11/11/2008 15:31'!delete	ActiveHand newKeyboardFocus: (previous ifNotNil: [previous firstFocus]).	^super delete! !OldSystemWindow removeSelector: #gotNavigationFocus!OldHandMorph removeSelector: #navigationFocus!OldHandMorph removeSelector: #navigationFocus:!OldHandMorph removeSelector: #navigationFocusIn!OldHandMorph removeSelector: #navigationFocusNext!OldHandMorph removeSelector: #navigationFocusOut!OldHandMorph removeSelector: #navigationFocusPrevious!OldHandMorph removeSelector: #releaseNavigationFocus:!!classDefinition: #OldHandMorph category: #'Morphic-OldKernel'!OldMorph subclass: #OldHandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder temporaryCursor temporaryCursorOffset hasChanged savedPatch userInitials lastEventBuffer'	classVariableNames: 'DoubleClickTime EventStats NewEventRules NormalCursor PasteBuffer ShowEvents'	poolDictionaries: 'EventSensorConstants'	category: 'Morphic-OldKernel'!OldMorph removeSelector: #drawHighlightOn:!OldMorph removeSelector: #gotNavigationFocus!OldMorph removeSelector: #gotNavigationFocus:!OldMorph removeSelector: #lostNavigationFocus!OldMorph removeSelector: #skipsNavigationFocus!ListLW removeSelector: #gotNavigationFocus:!CompositeLW removeSelector: #gotNavigationFocus:!CheckBoxLW removeSelector: #drawHighlightOn:!ButtonLW removeSelector: #drawHighlightOn:!LightWidget removeSelector: #drawHighlightOn:!LightWidget removeSelector: #gotNavigationFocus!LightWidget removeSelector: #hasNavigationFocus!LightWidget removeSelector: #lostNavigationFocus!LightWidget removeSelector: #skipsNavigationFocus!Canvas removeSelector: #drawHighlight:label:!