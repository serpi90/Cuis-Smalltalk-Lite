'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 30 December 2011 at 7:48:09 pm'!!classDefinition: #ScrollBar category: #'Morphic-Support'!PluggableMorph subclass: #ScrollBar	instanceVariableNames: 'slider value setValueSelector sliderShadow sliderColor upButton downButton pagingArea scrollDelta pageDelta interval timeOfMouseDown timeOfLastScroll nextPageDirection currentScrollDelay scrollBarAction '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!ScrollBar commentStamp: '<historical>' prior: 0!                              A ScrollBar for general use in Morphic.!!classDefinition: #ScrollbarElement category: #'Morphic-Support'!BorderedMorph subclass: #ScrollbarElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!ScrollbarElement commentStamp: '<historical>' prior: 0!         Superclass for several parts that make up a ScrollBar!!classDefinition: #ScrollbarButton category: #'Morphic-Support'!ScrollbarElement subclass: #ScrollbarButton	instanceVariableNames: 'image selector '	classVariableNames: 'Arrows CurrentSize '	poolDictionaries: ''	category: 'Morphic-Support'!!classDefinition: #ScrollbarPagingArea category: #'Morphic-Support'!ScrollbarElement subclass: #ScrollbarPagingArea	instanceVariableNames: 'image'	classVariableNames: 'Arrows CurrentSize'	poolDictionaries: ''	category: 'Morphic-Support'!!ScrollbarPagingArea commentStamp: '<historical>' prior: 0!  The back-most part of a scrollbar. Clicking there scrolls by 'pages'.!!classDefinition: #ScrollbarSlider category: #'Morphic-Support'!ScrollbarElement subclass: #ScrollbarSlider	instanceVariableNames: 'image'	classVariableNames: 'Arrows CurrentSize'	poolDictionaries: ''	category: 'Morphic-Support'!!ScrollbarSlider commentStamp: '<historical>' prior: 0!                    The sliding part of the scrollbar you can grab with the mouse and move around.!!classDefinition: #ScrollbarSliderShadow category: #'Morphic-Support'!ScrollbarElement subclass: #ScrollbarSliderShadow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!Morph methodsFor: 'accessing' stamp: 'jmv 12/30/2011 19:40'!                adoptWidgetsColor: paneColor	self submorphsDo: [ :m| m adoptWidgetsColor: paneColor]! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'jmv 12/30/2011 16:26'!                       initializeModal: beModal 	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	| tl m |	isModal _ beModal.	self removeAllMorphs.	tl _ bounds topLeft.	m _ Morph new.	m		color: Color transparent;		setBalloonText: 'put me somewhere'.	self addMorph: m.	m bounds: (DragBox translateBy: tl).	m _ Morph new.	m		color: Color transparent;		setBalloonText: 'restore original color'.	self addMorph: m.	m bounds: (RevertBox translateBy: tl).	m _ Morph new.	m		color: Color transparent;		setBalloonText: 'shows selected color'.	self addMorph: m.	m bounds: (FeedbackBox translateBy: tl).	m _ Morph new.	m		color: Color transparent;		setBalloonText: 'adjust translucency'.	self addMorph: m.	m bounds: (TransparentBox translateBy: tl).	self buildChartForm.	selectedColor ifNil: [selectedColor _ Color white].	sourceHand _ nil.	deleteOnMouseUp _ false.	updateContinuously _ true! !!HaloMorph methodsFor: 'private' stamp: 'jmv 12/30/2011 16:27'!                addHandle: handleSpec on: eventName send: selector to: recipient 	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle aPoint iconName colorToUse aMorph |	aPoint := self 				positionIn: haloBox				horizontalPlacement: handleSpec horizontalPlacement				verticalPlacement: handleSpec verticalPlacement.	handle := HaloHandleMorph new.	self addMorph: handle.	handle 		bounds: (Rectangle center: aPoint extent: HandleSize asPoint);		color: (colorToUse := Color colorFrom: handleSpec color).	(iconName := handleSpec iconSymbol) ifNotNil: [			| form |			form := Icons at: iconName ifAbsent: [self class perform: iconName].			form ifNotNil: [				aMorph _ ImageMorph new					image: form;					color: colorToUse makeForegroundColor;					lock.				aMorph position: aPoint - (form extent // 2).				handle addMorphFront: aMorph.				]].	handle 		on: #mouseUp		send: #endInteraction		to: self.	handle 		on: eventName		send: selector		to: recipient.	handle 		setBalloonText: (target balloonHelpTextForHandle: handle).	^handle! !!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 12/30/2011 19:41'!                          adoptWidgetsColor: paneColor	super adoptWidgetsColor: paneColor.	self color: paneColor! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 12/30/2011 19:41'!                     adoptWidgetsColor: paneColor	super adoptWidgetsColor: paneColor.	self color: (Theme current buttonColorFrom: paneColor)! !!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 12/30/2011 19:41'!                        adoptWidgetsColor: paneColor	super adoptWidgetsColor: paneColor.	scrollBar adoptWidgetsColor: paneColor.	hScrollBar adoptWidgetsColor: paneColor! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/30/2011 19:27'!                             focusIndicatorRectangle	| b topLeft bottomRight |	b _ self innerBounds.	topLeft _ b topLeft.	bottomRight _ b bottomRight.	self vIsScrollbarShowing ifTrue: [		bottomRight _ scrollBar bounds left -1@ bottomRight y].	self hIsScrollbarShowing ifTrue: [		bottomRight _ bottomRight x @ 			(bottomRight y - Preferences scrollbarThickness)].	^topLeft corner: bottomRight! !!PluggableScrollPane methodsFor: 'geometry testing' stamp: 'jmv 12/30/2011 15:42'!                   hIsScrollbarShowing	"Return true if a horizontal scroll bar is currently showing"	^hScrollBar visible! !!PluggableScrollPane methodsFor: 'geometry testing' stamp: 'jmv 12/30/2011 15:42'!vIsScrollbarShowing	"Return true if a vertical scroll bar is currently showing"	^scrollBar visible! !!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 12/30/2011 15:47'!     initialize		"initialize the state of the receiver"	super initialize.	hideScrollBars _ false.	"initialize the receiver's scrollBars"	scrollBar _ ScrollBar new model: self setValueSelector: #vScrollBarValue:.	hScrollBar _ ScrollBar new model: self setValueSelector: #hScrollBarValue:.	drawKeyboardFocusIndicator _ true.	scroller _ self innerMorphClass new.	self addMorph: scroller.	self scrollerOffset: 0@ 0.	self addMorph: scrollBar.	self addMorph: hScrollBar.! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 15:41'!                     hHideScrollBar	self hIsScrollbarShowing ifFalse: [		^self scrollerOffset: 0@self scrollerOffset y ].	hScrollBar hide.	self scrollerOffset: 0@self scrollerOffset y.	scroller adjustExtent! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 15:20'!                 hIsScrollbarNeeded	"Return whether the horz scrollbar is needed"	self mightNeedHorizontalScrollBar ifFalse: [ ^false ].		"Don't show it if we were told not to."	hideScrollBars ifTrue: [ ^false ].	^self hLeftoverScrollRange > 0! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 15:43'!     hShowScrollBar	self hIsScrollbarShowing ifTrue: [^self].	hScrollBar show.	scroller adjustExtent! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 15:49'!            hideOrShowScrollBars	"Assume for a moment we don't need an horizontal scrollbar"	self hHideScrollBar.	"Add or remove vertical scrollbar, asuming for a monent there's no horizontal scrollbar,	to determine need of horizontal scrollbar..."	self vIsScrollbarNeeded		ifTrue: [ self vShowScrollBar ]		ifFalse: [ self vHideScrollBar ].	"If we need an horizontal scrollbar, add it."	self hIsScrollbarNeeded ifTrue: [		self hShowScrollBar.		"If horizontal scrollbar is needed, maybe vertical scrollbar will be needed too (even if we previously thoutht it wouldn't be needed)."			"Note that there is no chance of modifying the need of horizontal scrollbar: it was already needed. Therefore, there is no circularity here."		self vIsScrollbarNeeded  ifTrue: [			self vShowScrollBar ]]! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 15:41'!                         vHideScrollBar	self vIsScrollbarShowing ifFalse: [^self].	scrollBar hide.	self scrollerOffset: self scrollerOffset x@ 0.	scroller adjustExtent! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 15:11'!                             vIsScrollbarNeeded	"Return whether the vertical scrollbar is needed"		"Don't show it if we were told not to."	hideScrollBars ifTrue: [ ^false ].	^self vLeftoverScrollRange > 0! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 15:42'!                          vShowScrollBar	self vIsScrollbarShowing ifTrue: [^ self].	scrollBar show.	scroller adjustExtent! !!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/30/2011 16:28'!                    addHandles	| handle newVert tri |	self removeHandles.	handles _ OrderedCollection new.	tri _ Array with: 0@-4 with: 4@3 with: -3@3.	vertices withIndexDo:		[ :vertPt :vertIndex |		handle _ EllipseMorph new.		handle on: #mouseMove send: #dragVertex:event:fromHandle:				to: self withValue: vertIndex.		handle on: #mouseUp send: #dropVertex:event:fromHandle:				to: self withValue: vertIndex.		self addMorph: handle.		handle			bounds: (Rectangle center: vertPt extent: 8@8);			color: Color yellow.		handles addLast: handle.		(closed or: [vertIndex < vertices size]) ifTrue: [			newVert _ PolygonMorph					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])					color: Color green borderWidth: 1 borderColor: Color black.			newVert on: #mouseDown send: #newVertex:event:fromHandle:					to: self withValue: vertIndex.			self addMorph: newVert.			handles addLast: newVert]].	smoothCurve ifTrue: [self updateHandles; someSubmorphPositionOrExtentChanged].	self redrawNeeded! !!ScrollBar methodsFor: 'access' stamp: 'jmv 12/30/2011 19:37'!                             color: aColor	"Change the color of the scrollbar to go with aColor."	| buttonColor |	super color: aColor.	buttonColor _ color alphaMixed: 0.7 with: (Color gray: 0.95).	upButton color: buttonColor.	downButton color: buttonColor.	slider color: buttonColor slightlyLighter.	pagingArea color: (aColor alphaMixed: 0.3 with: Color white)! !!ScrollBar methodsFor: 'access' stamp: 'jmv 12/30/2011 19:10'!         sliderShadow	^sliderShadow! !!ScrollBar methodsFor: 'access' stamp: 'jmv 12/30/2011 19:37'! sliderShadowColor	^ color alphaMixed: 0.2 with: pagingArea color! !!ScrollBar methodsFor: 'accessing' stamp: 'jmv 12/30/2011 19:41'!                        adoptWidgetsColor: aColor	"Adopt the given pane color"	self color: aColor.! !!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/30/2011 19:45'!              extent: newExtent	newExtent = bounds extent ifTrue: [^ self].	bounds isWide		ifTrue: [ super extent: (newExtent x max: 14) @ newExtent y ]		ifFalse: [ super extent: newExtent x @ (newExtent y max: 14) ].			self flag: #jmv.	"Most times it is not necessary to recreate the buttons"	self recreateSubmorphs! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 12/30/2011 19:45'!  initialize	super initialize.	value _ 0.0.	self recreateSubmorphs.	scrollDelta _ 0.02.	pageDelta _ 0.2! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 12/30/2011 17:01'!              initializeDownButton	"initialize the receiver's downButton"	| e |	e _ self buttonExtent.	downButton _ ScrollbarButton new.	self addMorph: downButton.	downButton bounds: (self innerBounds bottomRight - e extent: e).	bounds isWide		ifTrue: [ downButton updateRightButtonImage ]		ifFalse: [ downButton updateDownButtonImage ]! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 12/30/2011 19:03'!            initializePagingArea	pagingArea _ ScrollbarPagingArea new.	self addMorph: pagingArea.	pagingArea bounds: self totalSliderArea! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 12/30/2011 19:45'!                        initializeSlider	"initialize the receiver's slider"			slider _ ScrollbarSlider new.	self addMorph: slider.	slider bounds: self totalSliderArea.	sliderShadow _ ScrollbarSliderShadow new.	"(the shadow must have the pagingArea as its owner to highlight properly)"	pagingArea addMorph: sliderShadow.	sliderShadow bounds: self totalSliderArea.	sliderShadow hide.	self computeSlider! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 12/30/2011 17:01'!                   initializeUpButton	"initialize the receiver's upButton"	upButton _ ScrollbarButton new.	self addMorph: upButton.	upButton		bounds: (self innerBounds topLeft extent: self buttonExtent).	bounds isWide		ifTrue: [ upButton updateLeftButtonImage ]		ifFalse: [ upButton updateUpButtonImage ].! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 12/30/2011 19:46'!                 recreateSubmorphs	self removeAllMorphs.	self		initializeUpButton;		initializeDownButton;		initializePagingArea;		initializeSlider.	"Set color for submorphs"	self color: color.! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 19:02'!  scrollByPage	"Scroll automatically while mouse is down"	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 12/30/2011 19:24'!                            setNextDirectionFromEvent: event	nextPageDirection _ bounds isWide		ifTrue: [ event position x >= slider referencePosition x ]		ifFalse: [ event position y >= slider referencePosition y ]! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 12/30/2011 18:58'!             handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	^true! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 12/30/2011 18:58'!    handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?" 	^true! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 12/30/2011 18:58'!               handlesMouseStillDown: evt	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"	^true! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:00'!                            mouseEnter: evt	"Update visual feedback"! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:00'!    mouseLeave: evt	"Update visual feedback"! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 12/30/2011 18:59'!    mouseStillDownStepRate	"At what rate do I want to receive #mouseStillDown: notifications?"	^40! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 12/30/2011 17:12'!             updateDownButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #bottom size: bounds extent.	selector _ #scrollDown:.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 12/30/2011 17:12'!      updateLeftButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #left size: bounds extent.	selector _ #scrollUp:.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 12/30/2011 17:12'!          updateRightButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #right size: bounds extent.	selector _ #scrollDown:.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 12/30/2011 17:12'!      updateUpButtonImage	"update the receiver's as a upButton. put a new image inside"	image _ self class arrowOfDirection: #top size: bounds extent.	selector _ #scrollUp:.	self redrawNeeded! !!ScrollbarButton methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:01'!                mouseDown: evt	"Update visual feedback""Move visual feedback to superclass, calling a reasonable service."	self borderInset.	owner perform: selector with: 1! !!ScrollbarButton methodsFor: 'event handling' stamp: 'jmv 12/30/2011 17:14'!              mouseStillDown: evt	owner perform: selector with: 1! !!ScrollbarButton methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:00'!                          mouseUp: evt	"Update visual feedback""Move to superclass, calling a reasonable service."	self borderRaised! !!ScrollbarPagingArea methodsFor: 'initialization' stamp: 'jmv 12/30/2011 16:15'!                            defaultBorderWidth	"answer the default border width for the receiver"	^ 0! !!ScrollbarPagingArea methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:04'!                               mouseDown: evt	"Update visual feedback""Move to superclass, calling a reasonable service."	owner setNextDirectionFromEvent: evt.	owner scrollByPage! !!ScrollbarPagingArea methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:02'!                   mouseStillDown: evt	owner scrollByPage! !!ScrollbarSlider methodsFor: 'initialization' stamp: 'jmv 12/30/2011 19:15'!      defaultBorderColor	^#raised! !!ScrollbarSlider methodsFor: 'initialization' stamp: 'jmv 12/30/2011 19:14'!                  defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!ScrollbarSlider methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:14'!   mouseDown: evt	self borderInset.	owner sliderShadow		color: owner sliderShadowColor;		bounds: bounds;		show! !!ScrollbarSlider methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:23'!                              mouseMove: evt	owner scrollAbsolute: evt! !!ScrollbarSlider methodsFor: 'event handling' stamp: 'jmv 12/30/2011 19:13'!     mouseUp: evt	"Update visual feedback""Move to superclass, calling a reasonable service."	self borderRaised.	owner sliderShadow hide! !!ScrollbarSliderShadow methodsFor: 'initialization' stamp: 'jmv 12/30/2011 19:19'!defaultBorderColor	^#inset! !!ScrollbarSliderShadow methodsFor: 'initialization' stamp: 'jmv 12/30/2011 19:18'!             defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!StarMorph methodsFor: 'handles' stamp: 'jmv 12/30/2011 16:35'!               addHandles	| center handle1 handle2 |	self removeHandles.	center _ vertices sum // vertices size.   "Average vertices to get the center"	handle1 _ EllipseMorph new.	handle1		on: #mouseDown send: #dragVertex:event:fromHandle: to: self withValue: #center;		on: #mouseMove send: #dragVertex:event:fromHandle: to: self withValue: #center.	self addMorph: handle1.	handle1 bounds: (Rectangle center: center extent: 8@8); color: Color yellow.				handle2 _ EllipseMorph new.	handle2		on: #mouseDown send: #dragVertex:event:fromHandle: to: self withValue: #outside;		on: #mouseMove send: #dragVertex:event:fromHandle: to: self withValue: #outside.	self addMorph: handle2.	handle2 bounds: (Rectangle center: vertices second extent: 8@8); color: Color yellow.		handles _ { handle1 . handle2 }.	self redrawNeeded! !!Transcripter methodsFor: 'accessing' stamp: 'jmv 12/30/2011 16:01'!    endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue: [		"Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para		setModel: (TextModel withText: c asText);		extentForComposing: frame width-8 @9999.	para composeAll.	d _ para extent y - frame height.	d > 0 ifTrue: [		"Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint:			0@0 + (0@(d+StrikeFont default height)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	Display getCanvas		paragraph: para		bounds: (4@4 + frame topLeft extent: Display extent)		color: Color black		selectionColor: Color blue! !!methodRemoval: SystemWindow #model:!SystemWindow removeSelector: #model:!!ScrollbarSliderShadow reorganize!('initialization' defaultBorderColor defaultBorderWidth)!!ScrollbarSlider reorganize!('initialization' defaultBorderColor defaultBorderWidth)('event handling' mouseDown: mouseMove: mouseUp:)!!ScrollbarPagingArea reorganize!('initialization' defaultBorderWidth)('event handling' mouseDown: mouseStillDown:)!!methodRemoval: ScrollbarButton #bottom!ScrollbarButton removeSelector: #bottom!!methodRemoval: ScrollbarButton #handlesMouseDown:!ScrollbarButton removeSelector: #handlesMouseDown:!!methodRemoval: ScrollbarButton #handlesMouseOver:!ScrollbarButton removeSelector: #handlesMouseOver:!!methodRemoval: ScrollbarButton #handlesMouseStillDown:!ScrollbarButton removeSelector: #handlesMouseStillDown:!!methodRemoval: ScrollbarButton #mouseEnter:!ScrollbarButton removeSelector: #mouseEnter:!!methodRemoval: ScrollbarButton #mouseLeave:!ScrollbarButton removeSelector: #mouseLeave:!!methodRemoval: ScrollbarButton #mouseStillDownStepRate!ScrollbarButton removeSelector: #mouseStillDownStepRate!!methodRemoval: ScrollbarButton #right!ScrollbarButton removeSelector: #right!!classDefinition: #ScrollbarButton category: #'Morphic-Support'!ScrollbarElement subclass: #ScrollbarButton	instanceVariableNames: 'image selector'	classVariableNames: 'Arrows CurrentSize'	poolDictionaries: ''	category: 'Morphic-Support'!!ScrollbarButton reorganize!('initialization' defaultBorderColor defaultBorderWidth updateDownButtonImage updateLeftButtonImage updateRightButtonImage updateUpButtonImage)('drawing' drawOn:)('events-processing' containsPoint:)('event handling' mouseDown: mouseStillDown: mouseUp:)!!ScrollbarElement reorganize!('event handling' handlesMouseDown: handlesMouseOver: handlesMouseStillDown: mouseEnter: mouseLeave: mouseStillDownStepRate)!!methodRemoval: ScrollBar #doScrollByPage!ScrollBar removeSelector: #doScrollByPage!!methodRemoval: ScrollBar #doScrollDown!ScrollBar removeSelector: #doScrollDown!!methodRemoval: ScrollBar #doScrollUp!ScrollBar removeSelector: #doScrollUp!!methodRemoval: ScrollBar #finishedScrolling!ScrollBar removeSelector: #finishedScrolling!!methodRemoval: ScrollBar #left!ScrollBar removeSelector: #left!!methodRemoval: ScrollBar #mouseDownInSlider:!ScrollBar removeSelector: #mouseDownInSlider:!!methodRemoval: ScrollBar #mouseUpInSlider:!ScrollBar removeSelector: #mouseUpInSlider:!!methodRemoval: ScrollBar #pagingArea!ScrollBar removeSelector: #pagingArea!!methodRemoval: ScrollBar #resetTimer!ScrollBar removeSelector: #resetTimer!!methodRemoval: ScrollBar #scrollBarAction!ScrollBar removeSelector: #scrollBarAction!!methodRemoval: ScrollBar #scrollBarAction:!ScrollBar removeSelector: #scrollBarAction:!!methodRemoval: ScrollBar #scrollDelta!ScrollBar removeSelector: #scrollDelta!!methodRemoval: ScrollBar #scrollDownInit!ScrollBar removeSelector: #scrollDownInit!!methodRemoval: ScrollBar #scrollPageInit:!ScrollBar removeSelector: #scrollPageInit:!!methodRemoval: ScrollBar #scrollUpInit!ScrollBar removeSelector: #scrollUpInit!!methodRemoval: ScrollBar #sliderColor!ScrollBar removeSelector: #sliderColor!!methodRemoval: ScrollBar #sliderColor:!ScrollBar removeSelector: #sliderColor:!!methodRemoval: ScrollBar #step!ScrollBar removeSelector: #step!!methodRemoval: ScrollBar #stepTime!ScrollBar removeSelector: #stepTime!!methodRemoval: ScrollBar #thumbColor!ScrollBar removeSelector: #thumbColor!!methodRemoval: ScrollBar #waitForDelay1:delay2:!ScrollBar removeSelector: #waitForDelay1:delay2:!!methodRemoval: ScrollBar #wantsSteps!ScrollBar removeSelector: #wantsSteps!!classDefinition: #ScrollBar category: #'Morphic-Support'!PluggableMorph subclass: #ScrollBar	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton pagingArea scrollDelta pageDelta interval nextPageDirection'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!ScrollBar reorganize!('access' color: interval: scrollDelta:pageDelta: sliderShadow sliderShadowColor value)('accessing' adoptWidgetsColor: model:setValueSelector:)('geometry' buttonExtent computeSlider expandSlider extent: roomToMove sliderExtent totalSliderArea)('initialize' initialize initializeDownButton initializePagingArea initializeSlider initializeUpButton recreateSubmorphs)('model access' setValue: value:)('scrolling' scrollAbsolute: scrollByPage scrollDown: scrollUp: setNextDirectionFromEvent:)('initialization' defaultBorderColor defaultBounds defaultColor)!!methodRemoval: PluggableScrollPane #hIsScrollbarNeeded:!PluggableScrollPane removeSelector: #hIsScrollbarNeeded:!!methodRemoval: PluggableScrollPane #vIsScrollbarNeeded:!PluggableScrollPane removeSelector: #vIsScrollbarNeeded:!!methodRemoval: PluggableMorph #newBounds:!PluggableMorph removeSelector: #newBounds:!!methodRemoval: Morph class #newBounds:!Morph class removeSelector: #newBounds:!!methodRemoval: Morph class #newBounds:color:!Morph class removeSelector: #newBounds:color:!!methodRemoval: Morph #privateColor:!Morph removeSelector: #privateColor:!