'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 14 November 2011 at 4:35:02 pm'!!classDefinition: #PluggableListMorph category: #'Morphic-Views for Models'!PluggableScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list getListSelector getListSizeSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector listMorph menuGetter mainView'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!PluggableListMorph commentStamp: '<historical>' prior: 0!                          ...When a PluggableListMorph is in focus, type in a letter (or severalletters quickly) to go to the next item that begins with that letter.Special keys (up, down, home, etc.) are also supported.!!classDefinition: #PluggableListMorphByItem category: #'Morphic-Views for Models'!PluggableListMorph subclass: #PluggableListMorphByItem	instanceVariableNames: 'itemList'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!classDefinition: #PluggableListMorphOfMany category: #'Morphic-Views for Models'!PluggableListMorph subclass: #PluggableListMorphOfMany	instanceVariableNames: 'dragOnOrOff getSelectionListSelector setSelectionListSelector dragStartRow'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!PluggableListMorphOfMany commentStamp: '<historical>' prior: 0!               A variant of its superclass that allows multiple items to be selected simultaneously.  There is still a distinguished element which is selected, but each other element in the list may be flagged on or off.!!classDefinition: #PluggableMessageCategoryListMorph category: #'Morphic-Views for Models'!PluggableListMorph subclass: #PluggableMessageCategoryListMorph	instanceVariableNames: 'getRawListSelector priorRawList'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!PluggableMessageCategoryListMorph commentStamp: '<historical>' prior: 0!                         A variant of PluggableListMorph designed specially for efficient handling of the --all-- feature in message-list panes.  In order to be able *quickly* to check whether there has been an external change to the list, we cache the raw list for identity comparison (the actual list is a combination of the --all-- element and the the actual list).!!classDefinition: #TextModelMorph category: #'Morphic-Views for Models'!PluggableScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph hasEditingConflicts'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!TextModelMorph commentStamp: '<historical>' prior: 0!          The main morph for text editors!!classDefinition: #BrowserCommentTextMorph category: #'Morphic-Views for Models'!TextModelMorph subclass: #BrowserCommentTextMorph	instanceVariableNames: 'separator separatorHeight proportionalHeight'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!BrowserCommentTextMorph commentStamp: '<historical>' prior: 0!                             I am a TextModelMorph that knows enough to make myself invisible when necessary.!!classDefinition: #LimitedHeightTextMorph category: #'Morphic-Views for Models'!TextModelMorph subclass: #LimitedHeightTextMorph	instanceVariableNames: 'maxHeight'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!LimitedHeightTextMorph commentStamp: '<historical>' prior: 0!                  A TextMorph that will expand and contract vertically to adjust for the contents, but limited to a specific max height. If contents are larger, a scrollbar will be used.LimitedHeightTextMorph new	maxHeight: 48;	model: (TextModel new contents: 'This is some text to test the morph.');	openInWorld!!Clipboard methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:31'!               retrieveMorph	"Answer a Morph or nil."	| answer |		answer _ self retrieveObject.		"If clipboard contents is already a Text or String, answer it."	(answer is: #Morph) ifTrue: [		^ answer ].	"If clipboard contains a Form, prepare a Morph including it."	(answer is: #Form) ifTrue: [		^ ImageMorph new image: answer ].	"If clipboard contents is already a Text or String, answer it."	(answer isString or: [ answer is: #Text ]) ifTrue: [		^ (TextModelMorph withText: answer asText)			embeddedInMorphicWindowLabeled: 'Text editor' ].		"No useful contents"	^nil! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:31'!            createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean	"create the textPane"	| result |	result _ TextModelMorph				textProvider: self				textGetter: #response				textSetter: #response:				selectionGetter: #selectionInterval.	result extent: answerExtent.	result borderWidth: 1; borderColor: Color lightGray.	result hasUnacceptedEdits: true.	result acceptOnCR: acceptBoolean.	result bounds: (14@25 corner: 257@84).	self addMorph: result.	^ result! !!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 11/14/2011 16:33'!                              example4	"	self example4"	| pane |	pane _ LayoutMorph newColumn separation: 5.	pane padding: #shrink.	pane color: Color red.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.'))		layoutSpec: LayoutSpec new useMorphHeight.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.'))		layoutSpec: LayoutSpec new useMorphHeight.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.'))		layoutSpec: LayoutSpec new useMorphHeight.	pane openInWorld.! !!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 11/14/2011 16:33'!                            example5	"	self example5"	| pane |	pane _ LayoutMorph newColumn separation: 5.	pane padding: #shrink.	pane color: Color red.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.')).	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.')).	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.')).	pane openInWorld.! !!PackageList methodsFor: 'morphic' stamp: 'jmv 11/14/2011 16:28'!      buildWindow	| window |	window _ SystemWindow new.	window setLabel: self label.	window model: self.	window layoutMorph addMorphUseAll: (		PluggableListMorph			model: self			listGetter: #packageList			indexGetter: #packageSelection			indexSetter: #packageSelection:			mainView: window			menuGetter: #packageMenu			keystrokeAction: nil).	^ window! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:27'!          rowAtLocation: aPoint	"Return the row at the given point or 0 if outside"	| pointInListMorphCoords |self flag: #jmvVer. "Cuanda haya verdaderos cambios de sistCoord!!"	pointInListMorphCoords _ scroller internalizePosition: aPoint from: self.	^self listMorph rowAtLocation: pointInListMorphCoords.! !!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 16:27'!                         initialize	super initialize.	scroller _ InnerListMorph new.	scroller listSource: self.	scroller width: self width.	"mhhhh"	scroller color: self textColor.	self addMorph: scroller.self flag: #jmvVer.	"O mejor hacer		scrollBar setValue: 0.0.	o algo asi?	De cualquier manera, toda esta basura deberia ponerse a cero en los initialize (del scroller y del scrollBar), no?"	self scrollerOffset: 0@ 0! !!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 16:27'!               listMorphself flag: #jmvVer."Podemos reemplazar los senders locales por accesos directos (el doble encapsulamiento es tonto) una vez que quede definido el shape de la clase!!"	^scroller! !!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:27'!                      drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle			borderWidth: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].! !!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:27'!               highlightSelection! !!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:27'!unhighlightSelection! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:27'!                      handlesKeyboard	^self visible! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:27'!            keyStroke: event 	"Process keys"		| aCharacter |	(self focusKeyboardFor: event)		ifTrue: [ ^ self ].	(self scrollByKeyboard: event) 		ifTrue: [ ^self ].	aCharacter _ event keyCharacter.	(self arrowKey: aCharacter)		ifTrue: [ ^self ].	aCharacter asciiValue = 27 ifTrue: [	" escape key"		^ self mouseButton2Activity].	event anyModifierKeyPressed		ifTrue: [			(self keystrokeAction: aCharacter)				ifTrue: [ ^self ]].	^ self keyboardSearch: aCharacter! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:27'!                          keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	"No. Selection might also be shown differently. Invalidate everything"	false		ifTrue: [ self invalidateBorderFeedback ]		ifFalse: [ self redrawNeeded ]! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:27'!                 mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: self ]! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 16:27'!                         doubleClick: event	| index |	doubleClickSelector ifNil: [^super doubleClick: event].	index _ self rowAtLocation: event position.	index = 0 ifTrue: [^super doubleClick: event].	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."	^ self model perform: doubleClickSelector! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 16:27'!                            mouseDown: evt	| row |	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: evt		clkSel: #click:		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])		tripleClkSel: nil! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 16:27'!                        mouseUp: event	"The mouse came up within the list; take appropriate action"	| row |	row _ self rowAtLocation: event position.	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"	"No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])		ifTrue: [self changeModelSelection: 0]		ifFalse: [self changeModelSelection: row].	Cursor normal show.! !!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 11/14/2011 16:27'!                        handleMouseMove: anEvent	"Reimplemented because we really want #mouseMove when a morph is dragged around"	anEvent wasHandled ifTrue:[^self]. "not interested"	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:27'!           resizeScroller	super resizeScroller.		"Change listMorph's bounds to the new width. It is either the size	of the widest list item, or the size of self, whatever is bigger"	self listMorph adjustWidth! !!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:27'!       scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	^ self font height! !!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:27'!      scrollDeltaWidth"A guess -- assume that the width of a char is approx 1/2 the height of the font"	^ self scrollDeltaHeight // 2! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:27'!        autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect _ trueOrFalse.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:27'!  font	^ self listMorph font! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:27'!              font: aFontOrNil	self listMorph font: aFontOrNil.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:27'!                        initForKeystrokes	lastKeystrokeTime _ 0.	lastKeystrokes _ ''! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:27'!             listItemHeight	"This should be cleaned up.  The list should get spaced by this parameter."	^ 12! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:27'!          model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSelself flag: #jmvVer.	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	mainView _ aMainView.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self		updateList;"		selectionIndex: self getCurrentSelectionIndex;"		"No se acaba de hacer en #updateList???"		initForKeystrokes! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:27'!                        textColor	""	^ Theme current text! !!PluggableListMorph methodsFor: 'menu' stamp: 'jmv 11/14/2011 16:27'!                  getMenu	"Answer the menu for this view"	menuGetter ifNil: [^ nil].	(menuGetter is: #MessageSend) ifTrue: [		^menuGetter value ].	menuGetter numArgs = 0 ifTrue: [		^ mainView perform: menuGetter ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 11/14/2011 16:27'!  addCustomMenuItems:  aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	aMenu add: 'list font...' target: self action: #setListFont.	aMenu add: 'copy list to clipboard' target: self action: #copyListToClipboard.	aMenu add: 'copy selection to clipboard' target: self action: #copySelectionToClipboard! !!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 11/14/2011 16:27'!                   copyListToClipboard	"Copy my items to the clipboard as a multi-line string"	| stream |	stream _ WriteStream on: (String new: list size * 40).	list do: [:ea | stream nextPutAll: ea asString] separatedBy: [stream nextPut: Character cr].	Clipboard storeObject: stream contents! !!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 11/14/2011 16:27'!                             copySelectionToClipboard	"Copy my selected item to the clipboard as a string"	self selection		ifNotNil:			[Clipboard storeObject: self selection asString]		ifNil:			[self flash]! !!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 11/14/2011 16:27'!                            setListFont	"set the font for the list"	Preferences chooseFontWithPrompt: 'choose the font for this list' andSendTo: self withSelector: #font: highlight: self listMorph font! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'!                             changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	setIndexSelector ifNotNil:		[model perform: setIndexSelector with: anInteger].! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'! getCurrentSelectionIndex	"Answer the index of the current selection."	getIndexSelector ifNil: [^0].	^model perform: getIndexSelector! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'!     getList	"Answer the list to be displayed.  Caches the returned list in the 'list' ivar"	getListSelector		ifNil: [^ #()].	list _ model perform: getListSelector.	list		ifNil: [^ #()].	list _ list collect: [ :item | item asStringOrText ].	^ list! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'!                   getListItem: index	"get the index-th item in the displayed list"	list ifNotNil: [ ^list at: index ].	^self getList at: index! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'!              getListSize	"return the current number of items in the displayed list"	getListSizeSelector ifNotNil: [ ^model perform: getListSizeSelector ].	^self getList size! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'!          itemSelectedAmongMultiple: index	"return whether the index-th row is selected.  Always false in PluggableListMorph, but sometimes true in PluggableListMorphOfMany"	^false! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'! keyboardSearch: aChar 	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	milliSeconds _ Time millisecondClockValue.	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"		lastKeystrokes _ ''].	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.	lastKeystrokeTime _ milliSeconds.	nextSelectionList _ OrderedCollection newFrom: (self getList copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self getList copyFrom: 1 to: oldSelection).	"Get rid of blanks and style used in some lists"	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]				ifNone: [^ self flash"match not found"].	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	nextSelection _ self getList findFirst: [:a | a == nextSelectionText].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:27'!                     keystrokeAction: aChar 	| args |	keystrokeActionSelector ifNil: [^false].	args _ keystrokeActionSelector numArgs.	args = 1 ifTrue: [		mainView perform: keystrokeActionSelector with: aChar.		^true ].	args = 2 		ifTrue: [			mainView 				perform: keystrokeActionSelector				with: aChar				with: self.			^true ].	^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'jmv 11/14/2011 16:27'!      hTotalScrollRange"Return the width of the widest item in the list"	^self listMorph hTotalScrollRange! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'jmv 11/14/2011 16:27'!        vTotalScrollRange	"Return the height extent of the receiver's submorphs."		"	(scroller submorphs size > 0) ifFalse:[ ^0 ].	^(scroller submorphs last fullBounds bottom)"self flag: #jmvVer. "Cualquier banana. Dejo el de super"^super vTotalScrollRange! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!                getListSelector	^ getListSelector! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!              maximumSelection	^ self getListSize! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!            minimumSelection	^ 1! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!                           numSelectionsInView	^ self viewableHeight // self listItemHeight! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!               scrollSelectionIntoView	"make sure that the current selection is visible"	| row |	row _ self getCurrentSelectionIndex.	row = 0 ifTrue: [		^ scrollBar setValue: scrollBar value ].	self scrollToShow: (self listMorph drawBoundsForRowEspantoso: row)! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!                     selectedMorph: aMorph"this shouldn't be used any longer""self isThisEverCalled ."Smalltalk beep.true ifTrue: [ ^self ].! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!                    selection 	self selectionIndex = 0 ifTrue: [ ^nil ].	list ifNotNil: [ ^list at: self selectionIndex ].	^ self getListItem: self selectionIndex! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!                               selection: item	"Called from outside to request setting a new selection."	self selectionIndex: (self getList indexOf: item)! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!                  selectionIndex	"return the index we have currently selected, or 0 if none"	^self listMorph selectedRow ifNil: [ 0 ]! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 16:27'!                           selectionIndex: index	"Called internally to select the index-th item."	| row |	self unhighlightSelection.	row _ index ifNil: [ 0 ].	row _ row min: self getListSize.  "make sure we don't select past the end"	self listMorph selectedRow: row.	self highlightSelection.	"Do it once all extents and positions are set"	WorldState addDeferredUIMessage: [		self scrollSelectionIntoView ]! !!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 16:27'!             update: aSymbol 	"Refer to the comment in View|update:."	super update: aSymbol.	aSymbol == getListSelector ifTrue: [		self updateList.		^ self].	aSymbol == getIndexSelector ifTrue: [		self selectionIndex: self getCurrentSelectionIndex ]! !!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 16:27'!                             updateList	| index |	"the list has changed -- update from the model"	self listMorph listChanged.	self setScrollDeltas.self flag: #jmvVer."	scrollBar setValue: 0.0."	"Creo que #selectionIndex: siempre termina ajustando el scrollbar. En todo caso revisar. Detesto hacer basura de mas todo el tiempo!!"	index _ self getCurrentSelectionIndex.	self selectionIndex: index.! !!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 16:27'!                          verifyContents	"Verify the contents of the receiver, reconstituting if necessary.  Called whenever window is reactivated, to react to possible structural changes.  Also called periodically in morphic if the smartUpdating preference is true"	"This is done because our model is not the real one (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	| newList oldList |	oldList _ list ifNil: [ #() ].	newList _ self getList.	((oldList == newList) "fastest" or: [ oldList = newList ]) ifTrue: [ ^ self ].	self updateList.! !!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 11/14/2011 16:27'!                 arrowKey: aChar	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."	| keyEvent oldSelection nextSelection max min howMany answer w |	answer _ false.	keyEvent _ aChar asciiValue.	oldSelection _ self getCurrentSelectionIndex.	nextSelection _ oldSelection.	max _ self maximumSelection.	min _ self minimumSelection.	howMany _ self numSelectionsInView.	"get this exactly??"	keyEvent = 31 ifTrue: [		"down-arrow; move down one, wrapping to top if needed"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [ nextSelection _ 1 ]].	keyEvent = 30 ifTrue: [		"up arrow; move up one, wrapping to bottom if needed"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [ nextSelection _ max ]].	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"	nextSelection = oldSelection ifFalse: [		w _ self ownerThatIsA: SystemWindow.		(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"			self changeModelSelection: nextSelection.			answer _ true ]].	^answer! !!PluggableListMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:27'!          model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^self model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: nil menuGetter: nil keystrokeAction: nil! !!PluggableListMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:27'!    model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^ self new		model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel! !!PluggableListMorphByItem methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:29'! changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].	self update: getIndexSelector.! !!PluggableListMorphByItem methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:29'!                               getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector ifNil: [^ 0].	item _ model perform: getIndexSelector.	^ list findFirst: [ :x | x = item]! !!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 16:29'!  getList	"cache the raw items in itemList"	itemList := getListSelector ifNil: [ #() ] ifNotNil: [ model perform: getListSelector ].	^super getList! !!PluggableListMorphOfMany methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:30'!                       listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListMorphOfMany methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:30'!                      listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:30'!                        mouseDown: event	| oldIndex oldVal row w |	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row _ self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	w _ self ownerThatIsA: SystemWindow.	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:30'!                   mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |self flag: #jmvVer. "Entender. Revisar uso scroller..."	event position y < bounds top 		ifTrue: [			scrollBar scrollUp: 1.			row _ self rowAtLocation: scroller bounds topLeft + (1 @ 1)]		ifFalse: [			row _ event position y > bounds bottom 				ifTrue: [					scrollBar scrollDown: 1.					self rowAtLocation: scroller bounds bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	"No change if model is locked"	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	dragOnOrOff ifNil: [			"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff _ (self listSelectionAt: row) not].	"Set meaning for subsequent dragging of selection"	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [ self changeModelSelection: row ]		ifFalse: [ self changeModelSelection: 0 ].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].		"Select all in between if drag was too fast"	"self listSelectionAt: row put: dragOnOrOff."	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |		self listSelectionAt: r put: dragOnOrOff]! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:30'!          mouseUp: event	dragOnOrOff _ nil.  "So improperly started drags will have not effect"	dragStartRow _ nil! !!PluggableListMorphOfMany methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:30'!                          model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector _ getListSel.	setSelectionListSelector _ setListSel.	self 		model: anObject		listGetter: listSel		indexGetter: getSelectionSel		indexSetter: setSelectionSel		mainView: aMainView		menuGetter: getMenuSel		keystrokeAction: keyActionSel! !!PluggableListMorphOfMany methodsFor: 'updating' stamp: 'jmv 11/14/2011 16:30'!                     update: aSymbol 	super update: aSymbol.	aSymbol == #allSelections ifTrue: [		self selectionIndex: self getCurrentSelectionIndex.		self redrawNeeded]! !!PluggableListMorphOfMany methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:30'!               itemSelectedAmongMultiple: index	^self listSelectionAt: index! !!PluggableListMorphOfMany class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:30'!                             model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	^self new model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 16:31'!                  model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel rawListGetter: getRawSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	mainView _ aMainView.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	getRawListSelector _ getRawSel.	self updateList.	self selectionIndex: self getCurrentSelectionIndex.	self initForKeystrokes! !!PluggableMessageCategoryListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:31'!            getList	"Differs from the generic in that here we obtain and cache the raw list, then cons it together with the special '-- all --' item to produce the list to be used in the browser.  This special handling is done in order to avoid excessive and unnecessary reformulation of the list in the step method"	getRawListSelector ifNil: ["should not happen!!" priorRawList _ nil.  ^ #()].	model classListIndex = 0 ifTrue: [^ priorRawList _ list _ Array new].	priorRawList _ model perform: getRawListSelector.	list := (Array with: ClassOrganizer allCategory), priorRawList.	^list! !!PluggableMessageCategoryListMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 16:31'!                               verifyContents	"This is done because our model is not the real one (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	| newList newRawList |	(model editSelection == #editComment) ifTrue: [^ self].	model classListIndex = 0 ifTrue: [^ self].	newRawList _ model perform: getRawListSelector.	newRawList == priorRawList ifTrue: [^ self].  "The usual case; very fast"	priorRawList _ newRawList.	newList _ (Array with: ClassOrganizer allCategory), priorRawList.	list = newList ifTrue: [^ self].	self updateList! !!PluggableMessageCategoryListMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 16:31'!   model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel rawListGetter: getRawSel	^ self new model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel rawListGetter: getRawSel! !!SystemWindow methodsFor: 'panes' stamp: 'jmv 11/14/2011 16:29'!        setUpdatablePanesFrom: getSelectors	| aList aPane possibles |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList _ OrderedCollection new.	possibles _ OrderedCollection new.	self allMorphsDo: [ :pane | 		(pane isKindOf: PluggableListMorph) ifTrue: [			possibles add: pane.		].	].	getSelectors do: [:sel | 		aPane _ possibles detect: [ :pane | pane getListSelector == sel] ifNone: nil.		aPane			ifNotNil:				[aList add: aPane]			ifNil:				[Transcript cr; show: 'Warning: pane ', sel, ' not found.']].	updatablePanes _ aList asArray! !!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!                       buildMorphicAnnotationsPane	| aTextMorph |	aTextMorph _ TextModelMorph		textProvider: model		textGetter: #annotation.	aTextMorph		askBeforeDiscardingEdits: false;		hideScrollBarsIndefinitely.	^aTextMorph! !!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'! buildMorphicCodePane	"Construct the pane that shows the code.	Respect the Preference for standardCodeFont.".	^TextModelMorph		textProvider: model		textGetter: #acceptedContents		textSetter: #contents:notifying:		selectionGetter: #contentsSelection! !!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:27'!                  buildMorphicClassList	| myClassList |	myClassList _ PluggableListMorph		model: model		listGetter: #classList		indexGetter: #classListIndex		indexSetter: #classListIndex:		mainView: self		menuGetter: #classListMenu		keystrokeAction: #classListKey:from:.	myClassList enableDragNDrop: false.	^myClassList! !!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:33'!                          buildMorphicCommentPane	"Construct the pane that shows the class comment."	| commentPane |	commentPane _ BrowserCommentTextMorph				textProvider: model				textGetter: #classCommentText				textSetter: #newClassComment:.	commentPane styler: nil.	^ commentPane! !!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!        buildMorphicMessageCatList	| myMessageCatList |	myMessageCatList _ PluggableMessageCategoryListMorph		model: model		listGetter: #messageCategoryList		indexGetter: #messageCategoryListIndex		indexSetter: #messageCategoryListIndex:		mainView: self		menuGetter: #messageCategoryMenu		keystrokeAction: nil		rawListGetter: #rawMessageCategoryList.	myMessageCatList enableDragNDrop: false.	^myMessageCatList! !!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:27'!                     buildMorphicMessageList	"Build a morphic message list, with #messageList as its list-getter"	| aListMorph |	aListMorph _ PluggableListMorph		model: model		listGetter: #messageList		indexGetter: #messageListIndex		indexSetter: #messageListIndex:		mainView: self		menuGetter: #messageListMenu		keystrokeAction: #messageListKey:from:.	aListMorph enableDragNDrop: false.	^aListMorph! !!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:27'!           buildMorphicSystemCatList	| dragNDropFlag myCatList |	dragNDropFlag _ false.	myCatList _ PluggableListMorph		model: model		listGetter: #systemCategoryList		indexGetter: #systemCategoryListIndex		indexSetter: #systemCategoryListIndex:		mainView: self		menuGetter: #systemCategoryMenu		keystrokeAction: #systemCatListKey:from:.	myCatList enableDragNDrop: dragNDropFlag.	^myCatList! !!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:27'!            buildNoSysCatMorphicWindow	"A Browser without the class categories list"	| mySingletonList upperPanes |	mySingletonList _ PluggableListMorph				model: model				listGetter: #systemCategorySingleton				indexGetter: #indexIsOne				indexSetter: #indexIsOne:				mainView: self				menuGetter: #systemCatSingletonMenu				keystrokeAction: #systemCatSingletonKey:from:.	mySingletonList enableDragNDrop: false.	mySingletonList hideScrollBarsIndefinitely.	upperPanes _ LayoutMorph newRow.	upperPanes		addMorph: self buildMorphicClassColumn proportionalWidth: 0.3;		addAdjusterAndMorph: self buildMorphicMessageCatList proportionalWidth: 0.3;		addAdjusterAndMorph: self buildMorphicMessageList proportionalWidth: 0.4.	self layoutMorph		addMorph: mySingletonList fixedHeight: Preferences standardCodeFont height + 10;		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.	self setUpdatablePanesFrom: #(classList messageCategoryList messageList).	model changed: #editSelection! !!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!         buildMorphicCodePane	^TextModelMorph		textProvider: model		textGetter: #acceptedContents! !!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:30'!                   buildMorphicWindow	"Open a morphic view for the messageSet, whose label is labelString. 	The listView may be either single or multiple selection type"	| listPane |	listPane _ PluggableListMorphOfMany		model: model		listGetter: #list		primarySelectionGetter: #listIndex		primarySelectionSetter: #toggleListIndex:		listSelectionGetter: #listSelectionAt:		listSelectionSetter: #listSelectionAt:put:		mainView: self		menuGetter: #listMenu		keystrokeAction: #changeListKey:from:.		self layoutMorph		addMorph: listPane proportionalHeight: 0.4;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.6! !!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:29'!                               buildMorphicWindow	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| list1 list2 list3 upperPanes |	model myChangeSet ifNil: [ model myChangeSet: ChangeSet current ].	list1 _ (PluggableListMorphByItem				model: model				listGetter: #changeSetList				indexGetter: #currentCngSet				indexSetter: #showChangeSetNamed:				mainView: self				menuGetter: #changeSetMenu				keystrokeAction: #changeSetListKey:from:)			autoDeselect: false.	list2 _ PluggableListMorphByItem				model: model				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				mainView: self				menuGetter: #classListMenu				keystrokeAction: #classListKey:from:.	upperPanes _ LayoutMorph newRow.	upperPanes		addMorph: list1 proportionalWidth: 0.5;		addAdjusterAndMorph: list2 proportionalWidth: 0.5.	list3 _ PluggableListMorphByItem				model: model				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				mainView: self				menuGetter: #messageMenu				keystrokeAction: #messageListKey:from:.	self layoutMorph		addMorph: upperPanes proportionalHeight: 0.25;		addAdjusterAndMorph: list3 proportionalHeight: 0.25;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.	self setLabel: model labelString! !!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:28'!                              buildMorphicWindow	"Create a pluggable version of all the views for a Browser, including views and controllers."	| list1 list2 upperPanes |	model systemCategoryListIndex: 1.	list1 _ PluggableListMorph			model: model 			listGetter: #systemCategorySingleton			indexGetter: #indexIsOne 			indexSetter: #indexIsOne:			mainView: self			menuGetter: #codeFileListMenu			keystrokeAction: #codeFileListKey:from:.	list1 hideScrollBarsIndefinitely.		list2 _ PluggableListMorph			model: model 			listGetter: #messageCategoryList			indexGetter: #messageCategoryListIndex 			indexSetter: #messageCategoryListIndex:			mainView: self			menuGetter: #messageCategoryMenu			keystrokeAction: nil.	upperPanes _ LayoutMorph newRow.	upperPanes		addMorph: self buildMorphicClassColumn proportionalWidth: 0.3;		addAdjusterAndMorph: list2 proportionalWidth: 0.3;		addAdjusterAndMorph: self buildMorphicMessageList proportionalWidth: 0.4.	self layoutMorph		addMorph: list1 fixedHeight: Preferences standardCodeFont height + 10;		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.	model changed: #editSelection! !!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!          buildMorphicWindow	"Open a full morphic debugger with the given label"	| upperMorph bottomMorph1 bottomMorph2 bottomMorph3 bottomMorph4 bottomMorph |	upperMorph _ PluggableListMorph		model: model 		listGetter: #contextStackList		indexGetter: #contextStackIndex		indexSetter: #toggleContextStackIndex:		mainView: self		menuGetter: #contextStackMenu		keystrokeAction: #contextStackKey:from:.	bottomMorph1 _ PluggableListMorph			model: model receiverInspector			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			mainView: self			menuGetter: #receiverFieldListMenu			keystrokeAction: #inspectorKey:from:.	bottomMorph2 _ TextModelMorph			textProvider: model receiverInspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection.	bottomMorph3 _ PluggableListMorph			model: model contextVariablesInspector 			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			mainView: self			menuGetter: #contextFieldListMenu			keystrokeAction: #inspectorKey:from:.	bottomMorph4 _ TextModelMorph			textProvider: model contextVariablesInspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection.	bottomMorph _ LayoutMorph newRow.	bottomMorph		addMorph: bottomMorph1 proportionalWidth: 0.2;		addAdjusterAndMorph: bottomMorph2 proportionalWidth: 0.3;		addAdjusterAndMorph: bottomMorph3 proportionalWidth: 0.2;		addAdjusterAndMorph: bottomMorph4 proportionalWidth: 0.3.	self layoutMorph		addMorph: upperMorph proportionalHeight: 0.25;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2! !!DualChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:30'!                         buildMorphicUIIn: aLayoutMorph for: aChangeSorter	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| list1 list2 list3 upperPanes realModel |"Aca hay cosas que deben ir a la mitad correcta... Y no quiero duplicar con la otra ventana....pensar"self flag: #jmvVer.	list1 _ (PluggableListMorphByItem				model: aChangeSorter				listGetter: #changeSetList				indexGetter: #currentCngSet				indexSetter: #showChangeSetNamed:				mainView: self				menuGetter: (MessageSend receiver: self selector: #changeSetMenuFor: argument: aChangeSorter)				keystrokeAction: #changeSetListKey:from:)			autoDeselect: false.	list2 _ PluggableListMorphByItem				model: aChangeSorter				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				mainView: self				menuGetter: (MessageSend receiver: self selector: #classListMenuFor: argument: aChangeSorter)				keystrokeAction: #classListKey:from:.	upperPanes _ LayoutMorph newRow.	upperPanes		addMorph: list1 proportionalWidth: 0.5;		addAdjusterAndMorph: list2 proportionalWidth: 0.5.	list3 _ PluggableListMorphByItem				model: aChangeSorter				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				mainView: self				menuGetter: (MessageSend receiver: self selector: #messageMenuFor: argument: aChangeSorter)				keystrokeAction: #messageListKey:from:.	aLayoutMorph addMorph: upperPanes proportionalHeight: 0.25.	aLayoutMorph addAdjusterAndMorph: list3 proportionalHeight: 0.25.	"set aChangeSorter as the model during #buildLowerPanes, as the inherited methods assume a simple model that is a CodeProvider."	realModel _ model.	model _ aChangeSorter.	aLayoutMorph addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.	model _ realModel! !!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!                    morphicFileContentsPane	^TextModelMorph		textProvider: model		textGetter: #acceptedContents 		textSetter: #put:		selectionGetter: #contentsSelection! !!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:28'!                       morphicFileListPane	^(PluggableListMorph		model: model 		listGetter: #fileList 		indexGetter: #fileListIndex		indexSetter: #fileListIndex: 		mainView: self		menuGetter: #fileListMenu		keystrokeAction: nil)			enableDrag: true;			enableDrop: false;			yourself! !!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!    morphicPatternPane	^TextModelMorph		textProvider: model		textGetter: #pattern 		textSetter: #pattern:! !!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!     buildMorphicWindow	" Inspector openAsMorphOn: SystemOrganization "	| contentsText list upperRow evaluatorText |	list _ PluggableListMorph			model: model 			listGetter: #fieldList			indexGetter: #selectionIndex			indexSetter: #toggleIndex:			mainView: self			menuGetter: #fieldListMenu			keystrokeAction: #inspectorKey:from:.	contentsText _ TextModelMorph			textProvider: model			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection.	evaluatorText _ (TextModelMorph textProvider: model)			askBeforeDiscardingEdits: false.	upperRow _ LayoutMorph newRow.	upperRow		addMorph: list proportionalWidth: 0.3;		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.	self layoutMorph		addMorph: upperRow proportionalHeight: 0.7;		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.	self setLabel: ([model object printStringLimitedTo: 64] on: Error do: [ model object class name, ' (printing failed)']).	self setUpdatablePanesFrom: #(fieldList)! !!MessageNamesWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:31'!                           buildMorphicWindow	"Answer a morphic window with the given initial search string, nil if none""MessageNames openMessageNames"	| selectorListView firstRow searchButton textMorph secondRow |	textMorph _ TextModelMorph		textProvider: model		textGetter: #searchString 		textSetter: #searchString:.	textMorph setProperty: #alwaysAccept toValue: true.	textMorph askBeforeDiscardingEdits: false.	textMorph acceptOnCR: true.	textMorph setTextColor: Color brown.	textMorph hideScrollBarsIndefinitely.	textMorph textMorph		on: #mouseEnter send: #selectAll to: textMorph textMorph.	searchButton _ PluggableButtonMorph new 		model: textMorph;		label: 'Search';		action: #accept.	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.	firstRow _ LayoutMorph newRow.	firstRow		addMorph: searchButton proportionalWidth: 0.25;		addMorph: textMorph proportionalWidth: 0.75.	selectorListView _ PluggableListMorph		model: model		listGetter: #selectorList		indexGetter: #selectorListIndex		indexSetter: #selectorListIndex:		mainView: self		menuGetter: #selectorListMenu		keystrokeAction: #selectorListKey:from:.	secondRow _  LayoutMorph newRow.	secondRow		addMorph: selectorListView proportionalWidth: 0.5;		addAdjusterAndMorph: self buildMorphicMessageList proportionalWidth: 0.5.	self layoutMorph		addMorph: firstRow fixedHeight: self defaultButtonPaneHeight+4;		addAdjusterAndMorph: secondRow proportionalHeight: 0.5;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.	model changed: #editSelection! !!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:32'!                           buildMorphicWindow	| listMorph textMorph |	.listMorph _ HierarchicalListMorph			model: model			listGetter: #getList			indexGetter: #getCurrentSelection			indexSetter: #noteNewSelection:			mainView: self			menuGetter: #genericMenu			keystrokeAction: #explorerKey:from:.	listMorph autoDeselect: false.	textMorph _ (TextModelMorph textProvider: model)			askBeforeDiscardingEdits: false.	self layoutMorph		addMorph: listMorph proportionalHeight: 0.8;		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.	self setLabel: (model rootObject printStringLimitedTo: 64)! !!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:32'!              buildMorphicWindowMessage: messageString	| notifyPane |	model expandStack.	messageString		ifNil: [			notifyPane _ PluggableListMorph				model: model				listGetter: #contextStackList				indexGetter: #contextStackIndex				indexSetter: nil				mainView: self				menuGetter: nil				keystrokeAction: nil ]		ifNotNil: [			notifyPane _ TextModelMorph withText: messageString.			notifyPane askBeforeDiscardingEdits: false ].	self layoutMorph		addMorph: (self buttonRowForPreDebugWindow: model) proportionalHeight: 0.2;		addAdjusterAndMorph: notifyPane proportionalHeight: 0.8.	self widgetsColor: Theme current debugger! !!ProcessBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:32'!                      buildMorphicWindow	"Create a pluggable version of me, answer a window"	| aTextMorph list1 list2 upperRow |	list1 _ (PluggableListMorph				model: model				listGetter: #processNameList				indexGetter: #processListIndex				indexSetter: #processListIndex:				mainView: self				menuGetter: #processListMenu				keystrokeAction: #processListKey:from:)			enableDragNDrop: false.	list2 _ (PluggableListMorph				model: model				listGetter: #stackNameList				indexGetter: #stackListIndex				indexSetter: #stackListIndex:				mainView: self				menuGetter: #stackListMenu				keystrokeAction: #stackListKey:from:)			enableDragNDrop: false.	upperRow _ LayoutMorph newRow.	upperRow		addMorph: list1 proportionalWidth: 0.5;		addAdjusterAndMorph: list2 proportionalWidth: 0.5.	aTextMorph _ TextModelMorph				textProvider: model				textGetter: #selectedMethod.	aTextMorph askBeforeDiscardingEdits: false.	self layoutMorph		addMorph: upperRow proportionalHeight: 0.5;		addAdjusterAndMorph: aTextMorph proportionalHeight: 0.5.	self setUpdatablePanesFrom: #(#processNameList #stackNameList ).	self setLabel: 'Process Browser'! !!SystemWindow class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:32'!                        editText: aTextModel label: labelString wrap: aBoolean	| window |	window _ self new model: aTextModel.	window setLabel: labelString.	window layoutMorph		addMorph: ((TextModelMorph withModel: aTextModel)			wrapFlag: aBoolean)		proportionalHeight: 1.	^ window openInWorld! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:32'!                         buildDetailsText	detailsText _ TextModelMorph		textProvider: model		textGetter: #details.	detailsText hideScrollBarsIndefinitely.	^detailsText! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:29'!                            buildErrorsList	^ PluggableListMorph		model: model		listGetter: #errorsList		indexGetter: #selectedErrorTest		indexSetter: #debugErrorTest:		mainView: self		menuGetter: nil		keystrokeAction: nil! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:29'!     buildFailuresList	^ PluggableListMorph		model: model		listGetter: #failuresList		indexGetter: #selectedFailureTest		indexSetter: #debugFailureTest:		mainView: self		menuGetter: nil		keystrokeAction: nil! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:32'!                             buildPassFailText	passFailText _ TextModelMorph		textProvider: model		textGetter: #passFail.	passFailText hideScrollBarsIndefinitely.	^ passFailText! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:30'!                      buildUpperControls	| refreshButton filterButton stopButton runOneButton runButton row column1 column2 column3 theTestsList |	refreshButton _ self buildRefreshButton.	filterButton _ self buildFilterButton.	stopButton _ self buildStopButton.	column1 _ LayoutMorph newColumn.	column1 addMorphs: { refreshButton . filterButton . stopButton }.	theTestsList _ PluggableListMorphOfMany				model: model				listGetter: #tests				primarySelectionGetter: #selectedSuite				primarySelectionSetter: #selectedSuite:				listSelectionGetter: #listSelectionAt:				listSelectionSetter: #listSelectionAt:put:				mainView: self				menuGetter: #listMenu				keystrokeAction: nil.	theTestsList autoDeselect: false.	theTestsList color: Color veryVeryLightGray.	column2 _ LayoutMorph newColumn.	column2		addMorph: theTestsList proportionalHeight: 1;		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.	runOneButton _ self buildRunOneButton.	runButton _ self buildRunButton.		column3 _ LayoutMorph newColumn.	column3 addMorphs: { runOneButton . runButton }.		row _ LayoutMorph newRow.	row		addMorph: column1 fixedWidth: 80;		addMorph: column2 proportionalWidth: 1;		addMorph: column3 fixedWidth: 120.	^row! !!TextEditorTest methodsFor: 'testing' stamp: 'jmv 11/14/2011 16:32'!                            testUndoRedo	"	TextEditorTest new testUndoRedo	"	| editor model paragraph m text1 text0 text2 |	text0 _ ''.	model _ TextModel withText: text0 copy.	editor _ TextEditor new.	m _ InnerTextMorph new.	m setEditView: TextModelMorph new.	editor morph: m.	editor instVarNamed: 'emphasisHere' put: Array new.	editor model: model.	paragraph _ Paragraph new.	paragraph setModel: model extentForComposing: 300@300.	editor changeParagraph: paragraph.	paragraph composeAll.	text1 _ 'some words' asText.	editor addString: text1.	self assert: model actualContents = text1.	editor undo.	self assert: model actualContents = text0.	editor redo.	self assert: model actualContents = text1.	text2 _ ' additional inserted stuff' asText.	editor addString: text2.	self assert: model actualContents = (text1, text2).	editor undo.	self assert: model actualContents = text1.	editor undo.	self assert: model actualContents = text0.	editor redo.	self assert: model actualContents = text1.	editor redo.	self assert: model actualContents = (text1, text2).! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:31'!               editor	^self textMorph editor! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:31'!                      textMorphself flag: #jmvVer."Podemos reemplazar los senders locales por accesos directos (el doble encapsulamiento es tonto) una vez que quede definido el shape de la clase!!"	^ scroller! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:31'!                       wrapFlag: aBoolean	self textMorph wrapFlag: aBoolean! !!TextModelMorph methodsFor: 'dependents access' stamp: 'jmv 11/14/2011 16:31'!                       canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ self textMorph canDiscardEdits! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:31'!                           drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self textMorph hasUnacceptedEdits							ifTrue: [								bc _ Color red]]]].	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Theme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:31'!          wantsFrameAdornments	^model wantsFrameAdornments! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/14/2011 16:31'!                               clearSelection	"Tell my textMorph's editor to select nothing"	self textMorph clearSelection! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/14/2011 16:31'!                  handleEdit: editBlock	| result |	self textMorph handleEdit: [ result _ editBlock value ].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/14/2011 16:31'!            scrollSelectionIntoView	"Scroll my text into view if necessary and return true, else return false"	^ self scrollSelectionIntoView: nil! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/14/2011 16:31'!        scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest cpHere |	selRects _ self textMorph selectionRects.	selRects isEmpty ifTrue: [ ^ false ].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [ event anyButtonPressed ]) ifTrue: [  "Check for autoscroll"self flag: #jmvVer. "Revisar"		cpHere _ scroller externalizePosition: event position to: self.		cpHere y <= bounds top			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]			ifFalse: [				cpHere y >= bounds bottom					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]					ifFalse: [ ^ false ]]].	selRect _ self textMorph bounds: rectToTest in: self.	selRect height > bounds height		ifTrue: [ ^ false ].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true ].	^ false! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/14/2011 16:31'!           selectAll	"Tell my textMorph's editor to select all"	self textMorph selectAll! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:31'!                               doubleClick: event	self textMorph doubleClick: event! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:31'!                          handlesKeyboard	self flag: #jmv.	"Not answering true helps not hitting pluggable texts twice during navigation. Only the internal text morph will receive it.	If some problem is found, introduce a new selector, that answers ^self handlesKeyboard in morph (and LW) 	and only in this class it will answer false""	^self visible" 	^ super handlesKeyboard! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:31'!           keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	self textMorph keyStroke: evt.	self eventHandler ifNotNil: [		self eventHandler keyStroke: evt fromMorph: self ]! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:31'!            mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: self textMorph ]! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:31'!           tripleClick: event	self textMorph tripleClick: event! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:31'!bottom	^bounds bottom! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:31'!                               innerHeight: aNumber	"Adjust height and scrollbar to the new contents height.	Nothing to do here: TextModelMorph height does not depend on contents height."! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:31'!                       resizeScroller	super resizeScroller.	self textMorph extent = self viewableBounds extent		ifFalse: [			self textMorph extent: self viewableBounds extent ]! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:31'!                        scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: [ ^1]."	^ StrikeFont default height! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:31'!                     top	^bounds top! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:31'!                               acceptOnCR: aBoolean	self textMorph acceptOnCR: aBoolean! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:31'!                      initialize	super initialize.	hasEditingConflicts _ false.	scroller _ InnerTextMorph new.	scroller setEditView: self.	self addMorph: scroller.self flag: #jmvVer.	"O mejor hacer		scrollBar setValue: 0.0.	o algo asi?	De cualquier manera, toda esta basura deberia ponerse a cero en los initialize (del scroller y del scrollBar), no?"	self scrollerOffset: 0@ 0! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:31'!                               model: aTextModel	super model: aTextModel.	self textMorph model: model wrappedTo: self viewableWidth.	model refetch! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/14/2011 16:31'!            correctFrom: start to: stop with: aString	^ self handleEdit: [ self editor correctFrom: start to: stop with: aString ]! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/14/2011 16:31'!            correctSelectionWithString: aString	| result newPosition sel |	sel _ self editor selectionInterval.	result _ self correctFrom: sel first to: sel last with: aString.	newPosition _ sel first + aString size.	self setSelection: (newPosition to: newPosition - 1).	^ result! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/14/2011 16:31'!                 nextTokenFrom: start direction: dir	^ self editor nextTokenFrom: start direction: dir! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/14/2011 16:31'!             notify: aString at: anInteger in: aStream	^ self editor notify: aString at: anInteger in: aStream! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/14/2011 16:31'! selectFrom: start to: stop	^ self editor selectFrom: start to: stop! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/14/2011 16:31'!                               selectInvisiblyFrom: start to: stop	^ self editor selectInvisiblyFrom: start to: stop! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/14/2011 16:31'!             selectionInterval	^ self editor selectionInterval! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                              accept	"Inform the model of text to be accepted, and return true if OK."	| ok prevSelection prevScrollValue |	prevSelection _ self selectionInterval copy.	prevScrollValue _ scrollBar value.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' ) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			self selectFrom: prevSelection first to: prevSelection last.			WorldState addDeferredUIMessage: [					World activeHand  newKeyboardFocus: self textMorph.					self setScrollDeltas.					scrollBar setValue: prevScrollValue ]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!     browseIt	self handleEdit: [ self editor browseIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                             cancel	model refetch! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                           chooseAlignment	self handleEdit: [ self editor changeAlignment ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!               classCommentsContainingIt	self handleEdit: [ self editor classCommentsContainingIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                           copySelection	self handleEdit: [ self editor copySelection ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                   cut	self handleEdit: [ self editor cut ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!       debugIt	self handleEdit: [ self editor debugIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                               doIt	self handleEdit: [ self editor evaluateSelectionAndDo: nil ifFail: nil ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!  explain	self handleEdit: [ self editor explain ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                               exploreIt	self handleEdit: [ self editor exploreIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                          fileItIn	self handleEdit: [ self editor fileItIn ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                             find	self handleEdit: [ self editor find ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!     findAgain	self handleEdit: [ self editor findAgain ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                           implementorsOfIt	self handleEdit: [ self editor implementorsOfIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!             inspectIt	self handleEdit: [ self editor inspectIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                           methodSourceContainingIt	self handleEdit: [ self editor methodSourceContainingIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                             methodStringsContainingit	self handleEdit: [ self editor methodStringsContainingit ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                           offerFontMenu	self handleEdit: [ self editor changeTextFont ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                  offerUndoHistory	self handleEdit: [ self editor offerUndoHistory ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!             paste	self handleEdit: [ self editor paste ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!   pasteRecent	"Paste an item chosen from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	self editor clipboardTextPut: clipping.	^ self handleEdit: [ self editor paste ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                       pasteString	self handleEdit: [ self editor pasteString ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                       printIt	| result oldEditor |	self textMorph handleEdit: [		result _ (oldEditor _ self textMorph editor)			evaluateSelectionAndDo: [ :r | r]			ifFail: [^self flash]].	self textMorph installEditorToReplace: oldEditor.	self textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	self scrollSelectionIntoView.! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                       redo	self handleEdit: [ self editor redo ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!     referencesToIt	self handleEdit: [ self editor referencesToIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                 sendersOfIt	self handleEdit: [ self editor sendersOfIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!                       setSearchString	self handleEdit: [ self editor setSearchString ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 16:31'!               undo	self handleEdit: [ self editor undo ]! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:31'!      setSelection: sel	self editor selectFrom: sel first to: sel last.		self flag: #jmvVer.	"hace falta? esta bien?"	self scrollSelectionIntoView ifFalse: [ scroller redrawNeeded ]! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:31'!                              setTextColor: aColor	"Set the color of my text to the given color"	self textMorph color: aColor! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 16:31'!               text	"The returned object should be treated as read-only, and never modified"	^ model actualContents! !!TextModelMorph methodsFor: 'transcript' stamp: 'jmv 11/14/2011 16:31'!             replaceSelectionWith: aText	^ self editor replaceSelectionWith: aText! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/14/2011 16:31'!       askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	self textMorph askBeforeDiscardingEdits: aBoolean! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/14/2011 16:31'!                  hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/14/2011 16:31'!            hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/14/2011 16:31'!               hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag in my morph."	self textMorph hasUnacceptedEdits: aBoolean! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 16:31'!                            update: aSymbol	super update: aSymbol.	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents ifTrue: [		"Some day, it would be nice to keep objects and update them		instead of throwing them away all the time for no good reason..."		self textMorph releaseParagraph.		self textMorph formatAndStyleIfNeeded.		^self].	aSymbol == #acceptedContents ifTrue: [		self textMorph hasUnacceptedEdits ifTrue: [			self hasEditingConflicts: true.				^self redrawNeeded ].		model refetch.		^self].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self].	aSymbol == #initialSelection ifTrue: [		^self setSelection: model getSelection].	aSymbol == #autoSelect ifTrue: [		self handleEdit: [			TextEditor abandonChangeText.	"no replacement!!"			self editor				setSearch: model autoSelectString;				findAndReplaceMany: true ]].	"Quite ugly"	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #shoutStyle ifTrue: [		self stylerStyled.		^self redrawNeeded ].! !!TextModelMorph methodsFor: 'scrolling' stamp: 'jmv 11/14/2011 16:31'!               hTotalScrollRange"Return the width of the widest item in the list"	self textMorph isWrapped ifTrue: [ ^0 ].	^super hTotalScrollRange! !!TextModelMorph methodsFor: 'scrolling' stamp: 'jmv 11/14/2011 16:31'!          mightNeedHorizontalScrollBar	self textMorph isWrapped ifTrue: [ ^false ].	^super mightNeedHorizontalScrollBar! !!TextModelMorph methodsFor: 'focus handling' stamp: 'jmv 11/14/2011 16:31'!                             focusText	self activeHand newKeyboardFocus: self textMorph! !!TextModelMorph methodsFor: 'menu' stamp: 'jmv 11/14/2011 16:31'!                             getMenu	| menu |	menu _ MenuMorph new defaultTarget: self.	^model editorClass paneMenu: menu! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/14/2011 16:31'!                        autoCompleter: anUCompleter		self textMorph autoCompleter: anUCompleter! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/14/2011 16:31'!               styler: anSHTextStyler		self textMorph styler: anSHTextStyler! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/14/2011 16:31'!                         stylerStyled	self textMorph paragraph composeAll.	self editor recomputeSelection.		self textMorph updateFromParagraph.	self editor setEmphasisHereFromText.	self editor blinkParen.	self scrollSelectionIntoView! !!TextModelMorph methodsFor: 'notifications' stamp: 'jmv 11/14/2011 16:31'!                         possiblyChanged	"A hook for notificating possible interested parties	Not used in base system"! !!TextModelMorph methodsFor: 'testing' stamp: 'jmv 11/14/2011 16:31'!                       is: aSymbol	self flag: #jmvVer.	^ aSymbol == #TextModelMorph or: [ super is: aSymbol ]! !!BrowserCommentTextMorph methodsFor: 'displaying' stamp: 'jmv 11/14/2011 16:32'!                 hidePane	self hide.	separator visible ifTrue: [		proportionalHeight _ self layoutSpec proportionalHeight.		separatorHeight _ separator layoutSpec fixedHeight ].	separator layoutSpec fixedHeight: 0.	self layoutSpec proportionalHeight: 0.	separator ifNotNil: [ separator hide ]! !!BrowserCommentTextMorph methodsFor: 'displaying' stamp: 'jmv 11/14/2011 16:32'!               showPane	self show.	proportionalHeight ifNotNil: [		self layoutSpec proportionalHeight: proportionalHeight ].	separator ifNotNil: [		separatorHeight ifNotNil: [			separator layoutSpec fixedHeight: separatorHeight ].		separator show ]! !!BrowserCommentTextMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 16:32'!                           update: anAspect	super update: anAspect.	anAspect == #editSelection ifFalse: [ ^self ].	(model textProvider editSelection == #editClass)		ifTrue: [ self showPane ]		ifFalse: [ self hidePane ]! !!BrowserCommentTextMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:32'!       separator: aMorph	separator _ aMorph! !!LimitedHeightTextMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:32'!      maxHeight: aNumber	maxHeight _ aNumber! !!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:32'!      extent: aPoint	maxHeight _ aPoint y.	super extent: aPoint.! !!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 16:32'!                 innerHeight: aNumber	"Adjust height and scrollbar to the new contents height."	self height: (aNumber + 10 min: maxHeight)! !!LimitedHeightTextMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 16:32'!            initialize	super initialize.	self basicExtent: 200 @ 120.! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:31'!          textProvider: aTextProvider	^ self		textProvider: aTextProvider		textGetter: nil		textSetter: nil		selectionGetter: nil! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:31'!          textProvider: aTextProvider textGetter: getTextSel	^ self		textProvider: aTextProvider		textGetter: getTextSel		textSetter: nil		selectionGetter: nil! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:31'!            textProvider: aTextProvider textGetter: getTextSel textSetter: setTextSel	^ self		textProvider: aTextProvider		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:31'!              textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| newModel answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [  aTextProvider is: #ShoutEnabled ]) ifTrue: [		answer styler: SHTextStylerST80 new ].	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer model: newModel.	answer autoCompleter: newModel autoCompleter.	^answer! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:31'!withModel: aTextModel	|  answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ aTextModel is: #ShoutEnabled ]) ifTrue: [		answer styler: SHTextStylerST80 new ].	answer model: aTextModel.	answer autoCompleter: aTextModel autoCompleter.	^answer! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:31'!                 withText: aTextOrString	^self withModel: (TextModel withText: aTextOrString)! !!BrowserCommentTextMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:32'!               textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| newModel answer |	answer _ self new.	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer model: newModel.	answer autoCompleter: newModel autoCompleter.	^answer! !!LimitedHeightTextMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:32'!   initializedInstance	^self new		maxHeight: 48;		model: (TextModel new contents: 'This is some text to test the morph.')! !!VersionsBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 11/14/2011 16:29'!                buildMorphicWindow	"Open a morphic view for the messageSet, whose label is labelString. 	The listView may be either single or multiple selection type"	| listPane |	listPane _ PluggableListMorph		model: model		listGetter: #list		indexGetter: #listIndex		indexSetter: #toggleListIndex:		mainView: self		menuGetter: #listMenu		keystrokeAction: #changeListKey:from:.		self layoutMorph		addMorph: listPane proportionalHeight: 0.4;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.6! !"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."SystemWindow allSubInstancesDo: [ :a | a delete ].Smalltalk garbageCollect!