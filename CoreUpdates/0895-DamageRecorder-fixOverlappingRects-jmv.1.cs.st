'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 30 March 2011 at 9:29:18 am'!!DamageRecorder methodsFor: 'initialization' stamp: 'jmv 3/30/2011 08:56'!reset	"Clear the damage list."	invalidRects		ifNil: [ invalidRects _ OrderedCollection new: 15 ]		ifNotNil: [ invalidRects removeAll ].	totalRepaint _ false! !!DamageRecorder methodsFor: 'recording' stamp: 'jmv 3/30/2011 08:20'!invalidRectsFullBounds: aRectangle	"Return a collection of damaged rectangles for the given canvas. If a total repaint has been requested, return the given rectangle."	"The collection answered should not be modified outside this method. In addition, it could contain nil objects, that should be ignored."	^totalRepaint		ifTrue: [ Array with: aRectangle ]		ifFalse: [ invalidRects ]! !!DamageRecorder methodsFor: 'recording' stamp: 'jmv 3/30/2011 08:49'!recordInvalidRect: newRect	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle.	jmv: Important. There should be no overlapping rectangles in the list. If there are, translucent morphs might be drawn several times, with visible defects.	WRT performance, the different paths for various intersections seem a bit complicated. I could not find strong evidence of the best way.	Leave it as it is right now."	| mergeRect a indexToReuse |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	invalidRects doWithIndex: [ :rect :index |		rect ifNil: [			indexToReuse ifNil: [ indexToReuse _ index ]]		ifNotNil: [			"No two rectangles should intersect"			(rect intersects: newRect) ifTrue: [				"NewRect already in. Nothing to do then."				(rect containsRect: newRect) ifTrue: [ 					^self ].				"Some rect included in newRect. Remove it. Call recursively, as newRect could still intersect others."				(newRect containsRect: rect) ifTrue: [					invalidRects at: index put: nil.	"Effectively like 'invalidRects remove: rect', but without performance penalty."					indexToReuse ifNil: [ indexToReuse _ index ]].							"Merge rectangles if they overlap significantly"				a _ (rect intersect: newRect) area.				(a > 40					and: ["Avoid combining a vertical and horizontal rects.						  Can make a big diff and we only test when likely."						  a > (newRect area // 4) or: [ a > (rect area // 4)]])				ifTrue: [					"Merge into newRect, as any overlap with forecoming rectangles in the iteration is detected and treated."					newRect						setOrigin: (rect origin min: newRect origin) truncated						corner: (rect corner max: newRect corner) truncated.					invalidRects at: index put: nil.	"Effectively like 'invalidRects remove: rect', but without performance penalty."					indexToReuse ifNil: [ indexToReuse _ index ]]				ifFalse: [					"Avoid intersections!!"					newRect areasOutside: rect do: [ :nonIntersection |						"We have brand new newRects. Start all over with each of them."						self recordInvalidRect: nonIntersection ].					"newRect no longer needed, then."					^self ]]]].	invalidRects size >= 15 ifTrue: [		"if there are too many separate areas, merge them all"		mergeRect _ Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect.		indexToReuse _ nil ].	"add the given rectangle to the damage list"	indexToReuse		ifNil: [			invalidRects addLast: newRect truncated ]		ifNotNil: [			invalidRects at: indexToReuse put: newRect truncated ]! !!DamageRecorder methodsFor: 'testing' stamp: 'jmv 3/30/2011 08:51'!updateIsNeeded	"Return true if the display needs to be updated.	Note: This could give a false positive (i.e. answer true) if invalidRects is not empty but it only contains nils.	Senders should be aware of this."	^totalRepaint or: [ invalidRects notEmpty ]! !!WorldState methodsFor: 'drawing' stamp: 'jmv 3/30/2011 08:56'!drawInvalidAreasWorld: aWorld submorphs: submorphs	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."	initialRectsToRepair _ OrderedCollection new.	(damageRecorder invalidRectsFullBounds: aWorld viewBox) do: [ :r |		r ifNotNil: [ initialRectsToRepair addLast: r ]].	damageRecorder reset.	currentRectsToRepair _ OrderedCollection new.	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.	morphsToDraw _ OrderedCollection new.	rectsForEachMorph _ OrderedCollection new.	thisMorphRects _ OrderedCollection new.	n _ submorphs size.	i _ 1.	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [		morph _ submorphs at: i.		morph visible ifTrue: [			morphBounds _morph fullDisplayBounds.			reuse _ currentRectsToRepair.			currentRectsToRepair _ newRectsToRepair.			newRectsToRepair _ reuse removeAll.			currentRectsToRepair do: [ :r |				(morphBounds intersects: r)					ifTrue: [						morphClipRect _ morphBounds intersect: r.						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]					ifFalse: [						newRectsToRepair add: r ]].			thisMorphRects ifNotEmpty: [				morphsToDraw add: morph.				rectsForEachMorph add: thisMorphRects.				thisMorphRects _ OrderedCollection new.			]].		i _ i + 1 ].	i > n  ifTrue: [		newRectsToRepair do: [ :r |			(canvas copyClipRect: r) drawMorph: aWorld.]].	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |		"Here we could merge all xrects into just one call... Most likely, that would be slower, though.""		rr _ nil."		xrects do: [ :r |"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."			(canvas copyClipRect: r) fullDrawMorph: m 		]."		(canvas copyClipRect: rr) fullDrawMorph: m "	].		"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...	(think of vnc over slow networks)"	^ initialRectsToRepair! !