'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 17 March 2011 at 11:38:30 pm'!!Morph methodsFor: 'accessing' stamp: 'jmv 3/17/2011 23:34'!color	^ color! !!Morph methodsFor: 'accessing' stamp: 'jmv 3/17/2011 23:34'!color: aColor	"Set the receiver's color. "	color = aColor ifFalse: [		color _ aColor.		self redrawNeeded ]! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:29'!drawOn: aCanvas	aCanvas fillRectangle: bounds fillStyle: self color! !!Morph methodsFor: 'menus' stamp: 'jmv 3/17/2011 23:30'!changeColor	"Change the color of the receiver -- triggered, e.g. from a menu"	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: self activeHand;		target: self;		selector: #color:;		originalColor: self color;		putUpFor: self near: self fullDisplayBounds! !!BorderedMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:36'!drawOn: aCanvas	borderColor class == Symbol		ifTrue: [			"This would be better."			"aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor."			"But, for instance, pluggable lists and text in browsers are shown with an inset border, their color is white, and the baseColorForBorder must match the window..."			aCanvas fillRectangle: bounds fillStyle: color borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor			]		ifFalse: [			aCanvas fillRectangle: bounds fillStyle: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ]! !!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:37'!drawOn: aCanvas	| roundCorners |	roundCorners _ Theme current roundWindowCorners.	roundCorners		ifTrue: [			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]		ifFalse: [			super drawOn: aCanvas ].	aCanvas fillRectangle: textPane bounds fillStyle: (Color gray: 0.88)! !!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:36'!drawOn: aCanvas	aCanvas fillRectangle: bounds fillStyle: color borderWidth: 2 borderStyleSymbol: #raised! !!MenuMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:36'!drawOn: aCanvas		| roundCorners |	roundCorners _ Theme current roundWindowCorners.	roundCorners		ifTrue: [			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]		ifFalse: [			super drawOn: aCanvas ]! !!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:36'!drawOn: aCanvas	"draw background image."	backgroundImage		ifNotNil: [			"self clipsSubmorphs ifTrue: [				aCanvas clipBy: self clippingBounds					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"			self clipsSubmorphs ifTrue: [				aCanvas clipBy: self clippingBounds					during: [ :canvas | canvas image: backgroundImage at: bounds topLeft ]]				ifFalse: [ aCanvas image: backgroundImage at: bounds topLeft ]]		ifNil: [			"draw background fill"			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [color class == TranslucentColor])				ifTrue: [					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.					Requires proper handling of translucent Display in the VM.					Seems to work only on Linux when using a composing window manager."					(BitBlt current toForm: Display)						clipRect: aCanvas clipRect;						copy: bounds						from: 0@0 in: nil						fillColor: color rule: Form over]				ifFalse: [ super drawOn: aCanvas ]]! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:36'!draw3DLookOn: aCanvas	| w f center x y borderStyleSymbol c availableW l labelMargin |	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].	c _ color.	self mouseIsOver ifTrue: [ c _ c  lighter ].	aCanvas		fillRectangle: bounds		fillStyle: c		borderWidth: 2		borderStyleSymbol: borderStyleSymbol.	f _ self fontToUse.	center _ bounds center.	label ifNotNil: [		labelMargin _ 4.		w _ f widthOfString: label.		availableW _ bounds width-labelMargin-labelMargin-1.		availableW >= w			ifTrue: [				x _ center x - (w // 2).				l _ label ]			ifFalse: [				x _ bounds left + labelMargin.				l _ label squeezedTo: (label size * availableW / w) rounded ].		y _ center y - (f height // 2).		self isPressed ifTrue: [			x _ x + 1.			y _ y + 1 ].		aCanvas			drawString: l			in: (x@y extent: bounds extent - (labelMargin*2-2@4))			font: f			color: Theme current buttonLabel ]! !!PolygonMorph methodsFor: 'accessing' stamp: 'jmv 3/17/2011 23:34'!color: newColor	self isOpen		ifTrue: [ self borderColor: newColor  "easy access to line color from halo"]		ifFalse: [ super color: newColor]! !!PolygonMorph methodsFor: 'visual properties' stamp: 'jmv 3/17/2011 23:35'!color	self isOpen		ifTrue: [ self borderColor  "easy access to line color from halo"]		ifFalse: [ super color]! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:37'!addPossiblyUncoveredAreasIn: aRectangle to: aCollection	"Answer an array of rectangles encompassing those areas in aRectangle not completely	covered by self. These are the areas that might require further drawing (of morphs below us)	All areas that might possibly be uncovered must be included."	 | r |	color mightBeTranslucent ifTrue: [		aCollection add: aRectangle.		^self ].	"Solid rectangle.	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"	Theme current roundWindowCorners ifFalse: [		aRectangle addAreasOutside: bounds to: aCollection.		^self ].	"The solid rectangle does not include the corners.	Report a couple of rows (top and bottom) or columns (left and right) as uncovered areas.	We could also try to be more careful and answer each rounded corner...	Right now, report top and bottom rows as uncovered areas"	r _ Theme current roundedWindowRadius.	aRectangle addAreasOutside: (bounds insetBy: 0@r) to: aCollection.		! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:37'!drawClassicFrameOn: aCanvas color: titleColor	"Window border encompasses title area. No round corners. No title gradient."	borderColor class == Symbol		ifTrue: [			" This would of course be much better...			""			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor			"			aCanvas fillRectangle: bounds fillStyle: color borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor			]		ifFalse: [			aCanvas fillRectangle: bounds fillStyle: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ].	aCanvas fillRectangle: self titleAreaInnerRect color: titleColor! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/17/2011 23:37'!drawRoundedFrameOn: aCanvas color: widgetsColor	"Title area is not inside window borders"	| bottomFactor topFactor |	Theme current useWindowTitleGradient		ifTrue: [			topFactor _ Theme current titleGradientTopFactor.			bottomFactor _ Theme current titleGradientBottomFactor ]		ifFalse: [			topFactor _ 1.			bottomFactor _ 1 ].	aCanvas		windowFrame: bounds		color: widgetsColor * Theme current titleGradientExtraLightness		radius: Theme current roundedWindowRadius		border: borderWidth		labelHeight: self labelHeight + borderWidth		gradientTop: topFactor		gradientBottom: bottomFactor		insideColor: color! !!SystemWindow methodsFor: 'testing' stamp: 'jmv 3/17/2011 23:37'!isOpaqueMorph	"Not really used, as we also reimplement #possiblyUncoveredAreasIn:"	^(Theme current roundWindowCorners or: [ color mightBeTranslucent ]) not! !PolygonMorph removeSelector: #fillStyle!PolygonMorph removeSelector: #fillStyle:!Morph removeSelector: #fillStyle!Morph removeSelector: #fillStyle:!