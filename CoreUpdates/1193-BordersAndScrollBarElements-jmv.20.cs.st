'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 3 January 2012 at 1:42:20 pm'!"Change Set:		1183-ScrollBarElementsDate:			3 January 2012Author:			Juan Vuletich<your descriptive text goes here>"BorderedMorph allSubInstancesDo: [ :each |	(each instVarNamed: 'borderColor') class == Symbol ifTrue: [		each instVarNamed: 'borderColor' put: Color red ]]!!classDefinition: #ScrollbarElement category: #'Morphic-Support'!BorderedMorph subclass: #ScrollbarElement	instanceVariableNames: 'isPressed mouseIsOver '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!BorderedMorph methodsFor: 'accessing' stamp: 'jmv 1/2/2012 16:22'!                              borderColor: aColor	borderColor = aColor ifFalse: [		borderColor _ aColor.		self redrawNeeded]! !!BorderedMorph methodsFor: 'drawing' stamp: 'jmv 1/2/2012 16:32'!                        drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor! !!BorderedMorph methodsFor: 'testing' stamp: 'jmv 1/2/2012 16:30'!                           isOpaqueMorph	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)	but is not an opaque rectangle covering bounds MUST answer false to this message"	color mightBeTranslucent ifTrue: [		^false ].	borderWidth > 0 ifTrue: [		borderColor mightBeTranslucent ifTrue: [			^false ]].	^true! !!MenuMorph methodsFor: 'initialization' stamp: 'jmv 1/2/2012 15:37'!               setTitleParametersFor: aMenuTitle 	aMenuTitle		color: Theme current menuTitleBar;		borderWidth: 0! !!MenuMorph methodsFor: 'drawing' stamp: 'jmv 1/2/2012 15:46'!                        drawOn: aCanvas		| roundCorners |	roundCorners _ Theme current roundWindowCorners.	roundCorners		ifTrue: [			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]		ifFalse: [			aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #raised baseColorForBorder: color ]! !!PluggableButtonMorph methodsFor: 'testing' stamp: 'jmv 1/2/2012 16:43'!                   isPressed	^isPressed | self getModelState! !!PluggableButtonMorph methodsFor: 'testing' stamp: 'jmv 1/2/2012 16:43'!        mouseIsOver	^mouseIsOver! !!PolygonMorph methodsFor: 'access' stamp: 'jmv 1/2/2012 16:34'! borderColor: aColor 	super borderColor: aColor.	(borderColor isOpaque xor:aColor isOpaque)		ifTrue: [				"Need to recompute fillForm and borderForm					if translucency of border changes."				self releaseCachedState ]! !!PolygonMorph methodsFor: 'drawing' stamp: 'jmv 1/2/2012 16:35'!                           drawDashedBorderOn: aCanvas usingEnds: anArray 	"Display my border on the canvas. NOTE: mostly copied from  	drawBorderOn:"	| lineColor bigClipRect p1i p2i segmentOffset |	(borderColor isNil 		or: [borderColor isTransparent]) ifTrue: [ ^self ].	lineColor := borderColor.	bigClipRect := aCanvas clipRect expandBy: (borderWidth + 1) // 2.	segmentOffset := self borderDashOffset.	self lineSegmentsDo: [ :p1 :p2 | 			p1i := p1 asIntegerPoint.			p2i := p2 asIntegerPoint.			(arrows ~= #none and: [closed not]) 				ifTrue: 					["Shorten line ends so as not to interfere with tip  					of arrow."					((arrows == #back or: [arrows == #both]) and: [p1 = vertices first]) 						ifTrue: [p1i := anArray first asIntegerPoint].					((arrows == #forward or: [arrows == #both]) and: [p2 = vertices last]) 						ifTrue: [p2i := anArray last asIntegerPoint]].			(closed or: 					["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) 						<= ((p1i max: p2i) min: bigClipRect corner)]) 				ifTrue: 					[					segmentOffset := aCanvas 								line: p1i								to: p2i								width: borderWidth								color: lineColor								dashLength: borderDashSpec first								secondColor: borderDashSpec third								secondDashLength: borderDashSpec second								startingOffset: segmentOffset]]! !!PolygonMorph methodsFor: 'drawing' stamp: 'jmv 1/2/2012 16:35'!                     drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue: [		self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft-1 ].	lineColor _ borderColor. 	bigClipRect _ aCanvas clipRect expandBy: borderWidth+1//2.	brush _ nil.	self lineSegmentsDo: [ :p1 :p2 |		p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue: [			borderWidth > 3			ifTrue: [brush ifNil: [						brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil: [		self arrowForms do: [ :f |			f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!PolygonMorph methodsFor: 'private' stamp: 'jmv 1/2/2012 16:36'!                               filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ ColorForm extent: bounds extent+2.	"Draw the border..."	bb _ (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	"Fill it in..."	filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill.	borderColor mightBeTranslucent ifTrue: [		"If border is stored as a form, then erase any overlap now."		filledForm			copy: self borderForm boundingBox			from: self borderForm			to: 1@1			rule: Form erase ].	^ filledForm! !!Preferences class methodsFor: 'menu parameters' stamp: 'jmv 1/2/2012 15:37'!               restoreDefaultMenuParameters	"Restore the four color choices of the original implementors of  	MorphicMenus"	" 	Preferences restoreDefaultMenuParameters	"	Parameters at: #menuBorderWidth put: 2! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:52'!       mouseDown: aMouseEvent	isPressed _ true.	self redrawNeeded.! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:44'!                  mouseEnter: event	"The mouse entered the receiver"	mouseIsOver _ true.	self redrawNeeded.	^super mouseEnter: event! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:44'!                         mouseLeave: event	"The mouse has left the area of the receiver"	mouseIsOver _ false.	self redrawNeeded.	^super mouseLeave: event! !!ScrollbarElement methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:52'!           mouseUp: aMouseEvent	isPressed _ false.	mouseIsOver _ false.	self redrawNeeded! !!ScrollbarElement methodsFor: 'initialization' stamp: 'jmv 1/2/2012 16:44'!                              initialize	"initialize the state of the receiver"	super initialize.	isPressed _ false.	mouseIsOver _ false! !!ScrollbarElement methodsFor: 'testing' stamp: 'jmv 1/2/2012 16:46'!       mouseIsOver	^mouseIsOver! !!ScrollbarElement methodsFor: 'drawing' stamp: 'jmv 1/3/2012 13:25'!                             drawOn: aCanvas	aCanvas		fillRectangle: bounds		colorOrInfiniteForm: color		borderWidth: borderWidth		borderStyleSymbol: (isPressed == true			ifTrue: [#inset]			ifFalse: [#raised])		baseColorForBorder: color! !!ScrollbarButton methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:52'!                       mouseDown: aMouseEvent	"Update visual feedback"	super mouseDown: aMouseEvent.	owner perform: selector with: 1! !!ScrollbarPagingArea methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:52'!                           mouseDown: aMouseEvent	"Update visual feedback"	super mouseDown: aMouseEvent.	owner setNextDirectionFromEvent: aMouseEvent.	owner scrollByPage! !!ScrollbarSlider methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:52'!                             mouseDown: aMouseEvent	super mouseDown: aMouseEvent.	owner sliderShadow		color: owner sliderShadowColor;		bounds: bounds;		show! !!ScrollbarSlider methodsFor: 'event handling' stamp: 'jmv 1/2/2012 16:52'!           mouseUp: aMouseEvent	"Update visual feedback"	super mouseUp: aMouseEvent.	owner sliderShadow hide! !!ScrollbarSliderShadow methodsFor: 'drawing' stamp: 'jmv 1/2/2012 16:55'!            drawOn: aCanvas	aCanvas		fillRectangle: bounds		colorOrInfiniteForm: color		borderWidth: borderWidth		borderStyleSymbol: #inset		baseColorForBorder: color! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 1/2/2012 16:40'!                        drawClassicFrameOn: aCanvas color: titleColor	"Window border encompasses title area. No round corners. No title gradient."	aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.	aCanvas fillRectangle: self titleAreaInnerRect colorOrInfiniteForm: titleColor! !!TaskbarTask methodsFor: 'commands' stamp: 'jmv 1/2/2012 16:20'!                       minimize: aMorph	| button label |	morph _ aMorph.	(morph respondsTo: #label) 		ifTrue: [ label _ morph label ] 		ifFalse: [ label _ morph class name ].	self turnOn.	button _ PluggableButtonMorph			model: self			stateGetter: nil			action: #switch			label: label.	button		layoutSpec: (LayoutSpec proportionalWidth: 1);		borderWidth: 2;		color: Taskbar singleton color.	Taskbar singleton addMorph: button.				morph visible: false! !!methodRemoval: SystemWindow #defaultBorderColor!SystemWindow removeSelector: #defaultBorderColor!!methodRemoval: SystemWindow #raisedColor!SystemWindow removeSelector: #raisedColor!!methodRemoval: ScrollbarSliderShadow #defaultBorderColor!ScrollbarSliderShadow removeSelector: #defaultBorderColor!!methodRemoval: ScrollbarSlider #defaultBorderColor!ScrollbarSlider removeSelector: #defaultBorderColor!!methodRemoval: ScrollbarButton #defaultBorderColor!ScrollbarButton removeSelector: #defaultBorderColor!!methodRemoval: ScrollbarButton #mouseUp:!ScrollbarButton removeSelector: #mouseUp:!!classDefinition: #ScrollbarElement category: #'Morphic-Support'!BorderedMorph subclass: #ScrollbarElement	instanceVariableNames: 'isPressed mouseIsOver'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!methodRemoval: ScrollBar #defaultBorderColor!ScrollBar removeSelector: #defaultBorderColor!!methodRemoval: Preferences class #menuTitleBorderWidth!Preferences class removeSelector: #menuTitleBorderWidth!!methodRemoval: PluggableButtonMorph #defaultBorderColor!PluggableButtonMorph removeSelector: #defaultBorderColor!!methodRemoval: MenuMorph #defaultBorderColor!MenuMorph removeSelector: #defaultBorderColor!!methodRemoval: FillInTheBlankMorph #extent:!FillInTheBlankMorph removeSelector: #extent:!!methodRemoval: FillInTheBlankMorph #updateColor!FillInTheBlankMorph removeSelector: #updateColor!!methodRemoval: EllipseMorph #doesBevels!EllipseMorph removeSelector: #doesBevels!!methodRemoval: BorderedMorph #borderInset!BorderedMorph removeSelector: #borderInset!!methodRemoval: BorderedMorph #borderRaised!BorderedMorph removeSelector: #borderRaised!!methodRemoval: BorderedMorph #doesBevels!BorderedMorph removeSelector: #doesBevels!!methodRemoval: Morph #doesBevels!Morph removeSelector: #doesBevels!!methodRemoval: Morph #raisedColor!Morph removeSelector: #raisedColor!!methodRemoval: InfiniteForm #raisedColor!InfiniteForm removeSelector: #raisedColor!!methodRemoval: Color #raisedColor!Color removeSelector: #raisedColor!