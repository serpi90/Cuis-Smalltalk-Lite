'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 18 January 2011 at 11:14:26 am'!!classDefinition: #TextAnchor category: #'Morphic-Text Support'!TextAttribute subclass: #TextAnchor	instanceVariableNames: 'anchoredMorph anchoredFormOrMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextAnchor commentStamp: 'jmv 1/17/2011 16:45' prior: 0!TextAnchors support anchoring of images in text.  A TextAnchor exists as an attribute of text emphasis, and it gets control like a FontReference, through the emphasizeScanner: message.  Depending on whether its anchoredMorph is a Morph or a Form, it repositions the morph, or displays the form respectively.  The coordination between composition, display and selection can best be understood by browsing the various implementations of placeEmbeddedObject:.In the morphic world, simply embed any morph in text.  In the old world, you can create an image reference using code such as the following."A Form"('Hello', (Text withForm: EllipseMorph new imageForm), 'world') edit"A Morph"((Text withAll: 'foo') , (Text string: '*' asString attribute: (TextAnchor new anchoredFormOrMorph: EllipseMorph new)) , (Text withAll: 'bar')) editIn this case you select a piece of the screen, and it gets anchored to a one-character text in the editor's past buffer.  If you then paste into some other text, you will see the image as an embedded image.!!BareTextMorph methodsFor: 'anchors' stamp: 'jmv 1/17/2011 16:34'!anchorMorph: aMorph at: aPoint type: anchorType	| relPt index newText block |	aMorph owner == self ifTrue:[self removeMorph: aMorph].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	self addMorphFront: aMorph.	aMorph textAnchorType: anchorType.	aMorph relativeTextAnchorPosition: nil.	anchorType == #document ifTrue:[^self].	relPt _ self internalizePosition: aPoint from: self world.	index _ (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ Text string: (String value: 1) attribute: (TextAnchor new anchoredFormOrMorph: aMorph).	anchorType == #inline ifTrue:[		self paragraph replaceFrom: index to: index-1 with: newText.	] ifFalse:[		index _ index min: paragraph text size.		index _ paragraph text string lastIndexOf: Character cr startingAt: index ifAbsent:[0].		block _ paragraph characterBlockForIndex: index+1.		aMorph relativeTextAnchorPosition: (relPt x - bounds left) @ (relPt y - block top ).		self paragraph replaceFrom: index+1 to: index with: newText.	].	self fit.! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 1/17/2011 16:34'!removedMorph: aMorph	| range |	range _ self text find: (TextAnchor new anchoredFormOrMorph: aMorph).	range ifNotNil: [		self paragraph replaceFrom: range first to: range last with: Text new.		self fit ].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	super removedMorph: aMorph! !!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 1/17/2011 16:37'!placeEmbeddedObject	(text attributesAt: lastIndex) do: [ :attr |		attr anchoredFormOrMorph ifNotNil: [ :m |			self placeEmbeddedObject: m ]].! !!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 1/17/2011 16:40'!placeEmbeddedObject: anchoredFormOrMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	"Workaround: The following should really use #textAnchorType"	anchoredFormOrMorph relativeTextAnchorPosition ifNotNil:[^true].	destX _ destX + (w _ anchoredFormOrMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	"Is this needed?"	false ifTrue: [		self setFont.  "Force recalculation of emphasis for next run"	].	^ true! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 1/17/2011 16:40'!placeEmbeddedObject: anchoredFormOrMorph	"Workaround: The following should really use #textAnchorType"	anchoredFormOrMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].	specialWidth _ anchoredFormOrMorph width.	^ true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 1/17/2011 16:41'!placeEmbeddedObject: anchoredFormOrMorph	| descent |	"Workaround: The following should really use #textAnchorType"	anchoredFormOrMorph relativeTextAnchorPosition ifNotNil: [ ^true ].	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: ["It doesn't fit"		"But if it's the first character then leave it here"		lastIndex < line first ifFalse:[			line stop: lastIndex-1.			^ false]].	descent _ lineHeight - baseline.	lineHeight _ lineHeight max: anchoredFormOrMorph height.	baseline _ lineHeight - descent.	line stop: lastIndex.	^ true! !!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 1/17/2011 16:41'!placeEmbeddedObject: anchoredFormOrMorph	anchoredFormOrMorph relativeTextAnchorPosition ifNotNil:[		anchoredFormOrMorph position: 			anchoredFormOrMorph relativeTextAnchorPosition +			(anchoredFormOrMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].	(anchoredFormOrMorph is: #Morph) ifTrue: [		anchoredFormOrMorph position: ((destX - anchoredFormOrMorph width)@lineY) - morphicOffset	] ifFalse: [		destY _ lineY.		runX _ destX.		anchoredFormOrMorph 			displayOn: bitBlt destForm 			at: destX - anchoredFormOrMorph width @ destY			clippingBox: bitBlt clipRect			rule: Form blend			fillColor: nil	].	^ true! !!Text methodsFor: 'accessing' stamp: 'jmv 1/17/2011 16:40'!embeddedMorphs	"return the list of morphs embedded in me"	| morphs |	morphs _ IdentitySet new.	runs withStartStopAndValueDo: [ :start :stop :attribs |		attribs do: [ :attrib |			attrib anchoredFormOrMorph ifNotNil: [ :m |				(m is: #Morph) ifTrue: [					morphs add: m ]]]].	^ morphs! !!Text methodsFor: 'accessing' stamp: 'jmv 1/17/2011 16:39'!embeddedMorphsFrom: start to: stop 	"return the list of morphs embedded in me"	| morphs |	morphs _ IdentitySet new.	runs 		runsFrom: start		to: stop		do: 			[:attribs | 			attribs 				do: [:attr | attr anchoredFormOrMorph ifNotNil: [ :m |					(m is: #Morph) ifTrue: [						morphs add: m]]]].	^morphs! !!Text class methodsFor: 'instance creation' stamp: 'jmv 1/17/2011 16:45'!withForm: aForm	"	('Hello', (Text withForm: EllipseMorph new imageForm), 'world') edit	"	^Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aForm)! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'jmv 1/17/2011 16:37'!anchoredFormOrMorph	"If one hides here, return it"	^nil! !!TextAnchor methodsFor: 'testing' stamp: 'jmv 1/17/2011 16:33'!mayBeExtended	"A textAnchor is designed to modify only a single character, and therefore must not be extended by the ParagraphEditor's emphasisHere facility"	^ false! !!TextAnchor methodsFor: 'accessing' stamp: 'jmv 1/17/2011 16:33'!anchoredFormOrMorph	^anchoredFormOrMorph! !!TextAnchor methodsFor: 'accessing' stamp: 'jmv 1/17/2011 16:33'!anchoredFormOrMorph: aFormOrMorph	anchoredFormOrMorph _ aFormOrMorph! !TextAnchor removeSelector: #anchoredMorph!TextAnchor removeSelector: #anchoredMorph:!!classDefinition: #TextAnchor category: #'Morphic-Text Support'!TextAttribute subclass: #TextAnchor	instanceVariableNames: 'anchoredFormOrMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!TextAttribute removeSelector: #anchoredMorph!