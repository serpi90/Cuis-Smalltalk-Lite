'From Cuis 1.0 of 26 March 2009 [latest update: #154] on 27 March 2009 at 1:53:26 pm'!!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 3/27/2009 09:56'!openMorphicWindowForSuspendedProcess: aProcess 	| menu rules |	menu := OldMenuMorph new.	"nickname  allow-stop  allow-debug"	rules := ProcessBrowser nameAndRulesFor: aProcess.	menu		add: 'Dismiss this menu'			target: menu			selector: #delete;		addLine.	menu 		add: 'Open Process Browser'		target: ProcessBrowser		selector: #open.	menu 		add: 'Resume'		target: self		selector: #resumeProcess:fromMenu:		argumentList: { 				aProcess.				menu}.	menu 		add: 'Terminate'		target: self		selector: #terminateProcess:fromMenu:		argumentList: { 				aProcess.				menu}.	rules third 		ifTrue: 			[menu 				add: 'Debug at a lower priority'				target: self				selector: #debugProcess:fromMenu:				argumentList: { 						aProcess.						menu}].	menu addTitle: aProcess identityHash asString , ' ' , rules first 				, ' is taking too much time and has been suspended.What do you want to do with it?'.	menu stayUp: true.	menu popUpInWorld! !!ChangeSetCategory methodsFor: 'services' stamp: 'jmv 3/27/2009 09:56'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	| aggChangeSet |	aggChangeSet := ChangeSorter assuredChangeSetNamed: #Aggregate.	aggChangeSet clear.	aggChangeSet 		setPreambleToSay: '"Change Set:		AggregateCreated at ' 				, Time now printString , ' on ' 				, Date today printString 					, ' by combining all the changes in all the change sets in the category ' 					, categoryName printString , '"'.	(self elementsInOrder copyWithout: aggChangeSet) 		do: [:aChangeSet | aggChangeSet assimilateAllChangesFoundIn: aChangeSet].	OldSystemWindow wakeUpTopWindowUponStartup! !!CodeHolder methodsFor: 'commands' stamp: 'jmv 3/27/2009 09:56'!copyUpOrCopyDown	"Used to copy down code from a superclass to a subclass or vice-versa in one easy step, if you know what you're doing.  Prompt the user for which class to copy down or copy up to, then spawn a fresh browser for that class, with the existing code planted in it, and with the existing method category also established."	| aClass aSelector allClasses implementors aMenu aColor |	((aClass := self selectedClassOrMetaClass) isNil 		or: [(aSelector := self selectedMessageName) == nil]) 			ifTrue: [^Beeper beep].	allClasses := Utilities hierarchyOfClassesSurrounding: aClass.	implementors := Smalltalk hierarchyOfImplementorsOf: aSelector				forClass: aClass.	aMenu := OldMenuMorph new defaultTarget: self.	aMenu title: aClass name , '.' , aSelector 				, 'Choose where to insert a copy of this method(blue = current, black = available, red = other implementors'.	allClasses do: 			[:cl | 			aColor := cl == aClass 						ifTrue: [#blue]						ifFalse: [(implementors includes: cl) ifTrue: [#red] ifFalse: [#black]].			aColor == #red 				ifFalse: 					[aMenu 						add: cl name						selector: #spawnToClass:						argument: cl]				ifTrue: 					[aMenu 						add: cl name						selector: #spawnToCollidingClass:						argument: cl].			aMenu lastItem color: (Color colorFrom: aColor)].	aMenu popUpInWorld! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 3/27/2009 09:56'!setRecentUpdatesMarker	"Allow the user to change the recent-updates marker"	| result |	result := FillInTheBlank 				request: 'Enter the lowest change-set numberthat you wish to consider "recent"?(note: highest change-set numberin this image at this time is ' 						, self class highestNumberedChangeSet asString , ')'				initialAnswer: self class recentUpdateMarker asString.	(result notNil and: [result startsWithDigit]) 		ifTrue: 			[self class recentUpdateMarker: result asInteger.			OldSystemWindow wakeUpTopWindowUponStartup]! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 3/27/2009 09:56'!contextStackMenu: aMenu shifted: shifted 	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"	^shifted 		ifFalse: 			[self selectedContext selector = #doesNotUnderstand: 				ifTrue: 					[aMenu 						add: 'implement in...'						subMenu: (self populateImplementInMenu: (OldMenuMorph new defaultTarget: self))						target: nil						selector: nil						argumentList: #(nil)].			aMenu 				labels: 'fullStack (f)restart (r)proceed (p)step (t)step through (T)send (e)where (w)peel to first like thistoggle break on entrysenders of... (n)implementors of... (m)inheritance (i)versions (v)inst var refs...inst var defs...class var refs...class variablesclass refs (N)browse full (b)file out more...'				lines: #(8 9 13 15 18 21)				selections: #(#fullStack #restart #proceed #doStep #stepIntoBlock #send #where #peelToFirst #toggleBreakOnEntry #browseSendersOfMessages #browseMessages #methodHierarchy #browseVersions #browseInstVarRefs #browseInstVarDefs #browseClassVarRefs #browseClassVariables #browseClassRefs #browseMethodFull #fileOutMessage #shiftedYellowButtonActivity)]		ifTrue: 			[aMenu 				labels: 'browse class hierarchybrowse classbrowse method (O)implementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionremove from current change setrevert & remove from changesmore...'				lines: #(5 7 10)				selections: #(#classHierarchy #browseClass #openSingleMessageBrowser #browseAllMessages #findMethodInChangeSets #inspectInstances #inspectSubInstances #revertToPreviousVersion #removeFromCurrentChanges #revertAndForget #unshiftedYellowButtonActivity)]! !!Imports methodsFor: 'images' stamp: 'jmv 3/27/2009 09:56'!viewImages	"Open up a special Form inspector on the dictionary of graphical imports."	"Imports default viewImages"	imports size isZero 		ifTrue: 			[^self 				inform: 'The ImageImports repository is currently empty,so there is nothing to view at this time.  You canuse a file list to import graphics from external filesinto Imports, and once you have done that,you will find this command more interesting.'].	OldGraphicalDictionaryMenu openOn: imports withLabel: 'Graphical Imports'! !!OldBorderedMorph methodsFor: 'menu' stamp: 'jmv 3/27/2009 09:57'!changeBorderWidth: evt 	| handle origin aHand newWidth |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	handle := OldHandleMorph new forEachPointDo: 					[:newPoint | 					handle removeAllMorphs.					handle addMorph: (OldLineMorph 								from: origin								to: newPoint								color: Color black								width: 1).					newWidth := (newPoint - origin) r asInteger // 5.					self borderWidth: newWidth]				lastPointDo: 					[:newPoint | 					handle deleteBalloon.					self halo ifNotNilDo: [:halo | halo addHandles]].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle 		showBalloon: 'Move cursor farther fromthis point to increase border width.Click when done.'		hand: evt hand.	handle startStepping! !!OldGraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'jmv 3/27/2009 09:57'!showMenu	"Show the receiver's menu"	| aMenu |	aMenu := OldMenuMorph new defaultTarget: self.	aMenu title: 'Graphics Library'.	aMenu addStayUpItem.	aMenu addList: #(#('remove' #removeEntry 'Remove this entry from the dictionary') #('rename' #renameEntry 'Rename this entry') #- #('browse symbol references' #browseIconReferences 'Browse methods that refer to this icon''s name') #('browse string references' #browseStringIconReferences '													' #Browse #methods #that #refer #to #string #constants #that #contian #this #icon '' #s #name) #('copy name' #copyName 'Copy the name of this graphic to the clipboard') #- #('find...' #findEntry 'Find an entry by name') #('find again' #findAgain 'Find the next match for the keyword previously searched for') ).	aMenu popUpInWorld! !!OldMenuItemMorph methodsFor: 'private' stamp: 'jmv 3/27/2009 09:57'!notObsolete	"Provide backward compatibility with messages being sent to the Hand.  Remove this when no projects made prior to 2.9 are likely to be used.  If this method is removed early, the worst that can happen is a notifier when invoking an item in an obsolete menu."	(OldHandMorph canUnderstand: selector) ifTrue: [^true].	"a modern one"	self 		inform: 'This world menu is obsolete.Please dismiss the menu and open a new one.'.	^false! !!OldPasteUpMorph methodsFor: 'world menu' stamp: 'jmv 3/27/2009 09:57'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu 		confirm: 'Do you really want to close all windowsexcept those with unaccepted edits?' 				translated) 			ifFalse: [^self].	(OldSystemWindow windowsIn: self satisfying: [:w | w model canDiscardEdits]) 		do: [:w | w delete]! !!OldPluggableTextMorph methodsFor: 'menu commands' stamp: 'jmv 3/27/2009 09:57'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: 			[(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	textToAccept := textMorph asText.	ok := setTextSelector isNil or: 					[setTextSelector numArgs = 2 						ifTrue: 							[model 								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [model perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: 			[self setText: self getText.			self hasUnacceptedEdits: false.			(model dependents detect: 					[:dep | 					(dep isKindOf: OldPluggableTextMorph) 						and: [dep getTextSelector == #annotation]]				ifNone: [nil]) ifNotNilDo: [:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: 			["(don't bother if there was an error during compile)"			(model isKindOf: CodeHolder) ifTrue: [model updateCodePaneIfNeeded].			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			OldWorldState addDeferredUIMessage: 					[self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: []! !!OldPluggableTextMorph methodsFor: 'menu commands' stamp: 'jmv 3/27/2009 09:57'!toggleAnnotationPaneSize	| handle origin aHand siblings newHeight lf prevBottom m ht |	self flag: #bob.	"CRUDE HACK to enable changing the size of the annotations pane"	owner ifNil: [^self].	siblings := owner submorphs.	siblings size > 3 ifTrue: [^self].	siblings size < 2 ifTrue: [^self].	aHand := self primaryHand.	origin := aHand position.	handle := OldHandleMorph new forEachPointDo: 					[:newPoint | 					handle removeAllMorphs.					newHeight := (newPoint - origin) y asInteger min: owner height - 50 max: 16.					lf := siblings last layoutFrame.					lf bottomOffset: newHeight.					prevBottom := newHeight.					siblings size - 1 to: 1						by: -1						do: 							[:index | 							m := siblings at: index.							lf := m layoutFrame.							ht := lf bottomOffset - lf topOffset.							lf topOffset: prevBottom.							lf bottomOffset = 0 ifFalse: [lf bottomOffset: prevBottom + ht].							prevBottom := prevBottom + ht].					owner layoutChanged]				lastPointDo: 					[:newPoint | 					handle deleteBalloon.					self halo ifNotNilDo: [:halo | halo addHandles]].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle 		showBalloon: 'Move cursor farther fromthis point to increase pane.Click when done.'		hand: aHand.	handle startStepping! !!OldPolygonMorph methodsFor: 'menu' stamp: 'jmv 3/27/2009 09:57'!customizeArrows: evt 	| handle origin aHand |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	handle := OldHandleMorph new forEachPointDo: 					[:newPoint | 					handle removeAllMorphs.					handle addMorph: (OldLineMorph 								from: origin								to: newPoint								color: Color black								width: 1).					self arrowSpec: (newPoint - origin) / 5.0]				lastPointDo: 					[:newPoint | 					handle deleteBalloon.					self halo ifNotNilDo: [:halo | halo addHandles]].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle 		showBalloon: 'Move cursor left and rightto change arrow length and style.Move it up and down to change width.Click when done.'		hand: evt hand.	handle startStepping! !!OldTextMorph methodsFor: 'menu' stamp: 'jmv 3/27/2009 09:57'!changeMargins: evt 	| handle origin aHand newMargin |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	handle := OldHandleMorph new forEachPointDo: 					[:newPoint | 					handle removeAllMorphs.					handle addMorph: (OldLineMorph 								from: origin								to: newPoint								color: Color black								width: 1).					newMargin := (newPoint - origin max: 0 @ 0) // 5.					self margins: newMargin]				lastPointDo: 					[:newPoint | 					handle deleteBalloon.					self halo ifNotNilDo: [:halo | halo addHandles]].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle 		showBalloon: 'Move cursor down and to the rightto increase margin inset.Click when done.'		hand: evt hand.	handle startStepping! !!OldTheWorldMenu methodsFor: 'commands' stamp: 'jmv 3/27/2009 09:57'!cleanUpWorld	(SelectionMenu 		confirm: 'This will remove all windows except thosecontaining unsubmitted text edits, and willalso remove all non-window morphs (otherthan flaps) found on the desktop.  Are yousure you want to do this?' 				translated) 			ifFalse: [^self].	myWorld allNonFlapRelatedSubmorphs do: [:m | m delete].	(OldSystemWindow windowsIn: myWorld		satisfying: [:w | w model canDiscardEdits]) do: [:w | w delete]! !!OldTheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'jmv 3/27/2009 09:57'!windowsMenu	"Build the windows menu for the world."	^self fillIn: (self menu: 'windows')		from: { 				{ 					'find window'.					{ 						#myWorld.						#findWindow:}.					'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.				{ 					'find changed browsers...'.					{ 						#myWorld.						#findDirtyBrowsers:}.					'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.				{ 					'find changed windows...'.					{ 						#myWorld.						#findDirtyWindows:}.					'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.				nil.				{ 					'find a transcript (t)'.					{ 						#myWorld.						#findATranscript:}.					'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'}.				{ 					'find a fileList (L)'.					{ 						#myWorld.						#findAFileList:}.					'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'}.				{ 					'find a change sorter (C)'.					{ 						#myWorld.						#findAChangeSorter:}.					'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.				{ 					'find message names (W)'.					{ 						#myWorld.						#findAMessageNamesWindow:}.					'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'}.				nil.				{ 					#staggerPolicyString.					{ 						self.						#toggleWindowPolicy}.					'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.'}.				nil.				{ 					'collapse all windows'.					{ 						#myWorld.						#collapseAll}.					'Reduce all open windows to collapsed forms that only show titles.'}.				{ 					'expand all windows'.					{ 						#myWorld.						#expandAll}.					'Expand all collapsed windows back to their expanded forms.'}.				{ 					'close top window (w)'.					{ 						OldSystemWindow.						#closeTopWindow}.					'Close the topmost window if possible.'}.				{ 					'send top window to back (\)'.					{ 						OldSystemWindow.						#sendTopWindowToBack}.					'Make the topmost window become the backmost one, and activate the window just beneath it.'}.				{ 					'move windows onscreen'.					{ 						#myWorld.						#bringWindowsFullOnscreen}.					'Make all windows fully visible on the screen'}.				nil.				{ 					'delete unchanged windows'.					{ 						#myWorld.						#closeUnchangedWindows}.					'Deletes all windows that do not have unsaved text edits.'}.				{ 					'delete non-windows'.					{ 						#myWorld.						#deleteNonWindows}.					'Deletes all non-window morphs lying on the world.'}.				{ 					'delete both of the above'.					{ 						self.						#cleanUpWorld}.					'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}}! !!Parser methodsFor: 'error correction' stamp: 'jmv 3/27/2009 09:49'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges _ false.	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:			((temp , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end _ tempsMark.			["Beginning at right temp marker..."			start _ end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)					and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]			whileFalse:				["Search left for the unused temp"				end _ requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start _ start-1].				requestor correctFrom: start to: end with: ''.				str _ str copyReplaceFrom: start to: end with: ''. 				madeChanges _ true.				tempsMark _ tempsMark - (end-start+1)]]			ifFalse:			[self inform:'You''ll first have to remove thestatement where it''s stored into']]].	madeChanges ifTrue: [ParserRemovedUnusedTemps signal]! !!Time class methodsFor: 'benchmarks' stamp: 'jmv 3/27/2009 09:57'!benchmarkMillisecondClock		"Time benchmarkMillisecondClock"	"Benchmark the time spent in a call to Time>>millisecondClockValue.	On the VM level this tests the efficiency of calls to ioMSecs()."	"PII/400 Windows 98: 0.725 microseconds per call"	| temp1 temp2 temp3 delayTime nLoops time |	delayTime _ 5000. "Time to run benchmark is approx. 2*delayTime"	"Don't run the benchmark if we have an active delay since	we will measure the additional penalty in the primitive dispatch	mechanism (see #benchmarkPrimitiveResponseDelay)."	Delay anyActive ifTrue:[		^self notify:'Some delay is currently active.Running this benchmark will not give any useful result.'].	"Flush the cache for this benchmark so we will have	a clear cache hit for each send to #millisecondClockValue below"	Object flushCache.	temp1 _ 0.	temp2 _ self. "e.g., temp1 == Time"	temp3 _ self millisecondClockValue + delayTime.	"Now check how often we can run the following loop in the given time"	[temp2 millisecondClockValue < temp3]		whileTrue:[temp1 _ temp1 + 1].	nLoops _ temp1. "Remember the loops we have run during delayTime"	"Setup the second loop"	temp1 _ 0.	temp3 _ nLoops.	"Now measure how much time we spend without sending #millisecondClockValue"	time _ Time millisecondClockValue.	[temp1 < temp3]		whileTrue:[temp1 _ temp1 + 1].	time _ Time millisecondClockValue - time.	"And compute the number of microseconds spent per call to #millisecondClockValue"	^((delayTime - time * 1000.0 / nLoops) truncateTo: 0.001) printString,		' microseconds per call to Time>>millisecondClockValue'! !!Time class methodsFor: 'benchmarks' stamp: 'jmv 3/27/2009 09:57'!benchmarkPrimitiveResponseDelay	"Time benchmarkPrimitiveResponseDelay"	"Benchmark the overhead for primitive dispatches with an active Delay.	On the VM level, this tests the efficiency of ioLowResMSecs."	"PII/400 Windows98: 0.128 microseconds per prim"	"ar 9/6/1999: This value is *extremely* important for stuff like sockets etc.	I had a bad surprise when Michael pointed this particular problem out:	Using the hardcoded clock() call for ioLowResMSecs on Win32 resulted in an overhead	of 157.4 microseconds per primitive call - meaning you can't get no more than	approx. 6000 primitives per second on my 400Mhz PII system with an active delay!!	BTW, it finally explains why Squeak seemed soooo slow when running PWS or 	other socket stuff. The new version (not using clock() but some Windows function) 	looks a lot better (see above; approx. 8,000,000 prims per sec with an active delay)."	| nLoops bb index baseTime actualTime delayTime |	delayTime _ 5000. "Time to run this test is approx. 3*delayTime"	Delay anyActive ifTrue:[		^self notify:'Some delay is currently active.Running this benchmark will not give any useful result.'].	bb _ Array new: 1. "The object we send the prim message to"	"Compute the # of loops we'll run in a decent amount of time"	[(Delay forMilliseconds: delayTime) wait] 		forkAt: Processor userInterruptPriority.	nLoops _ 0.	[Delay anyActive] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		nLoops _ nLoops + 1.	].	"Flush the cache and make sure #basicSize is in there"	Object flushCache.	bb basicSize.	"Now run the loop without any active delay	for getting an idea about its actual speed."	baseTime _ self millisecondClockValue.	index _ nLoops.	[index > 0] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		index _ index - 1.	].	baseTime _ self millisecondClockValue - baseTime.	"Setup the active delay but try to never make it active"	[(Delay forMilliseconds: delayTime + delayTime) wait] 		forkAt: Processor userInterruptPriority.	"And run the loop"	actualTime _ self millisecondClockValue.	index _ nLoops.	[index > 0] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		index _ index - 1.	].	actualTime _ self millisecondClockValue - actualTime.	"And get us some result"	^((actualTime - baseTime) * 1000 asFloat / (nLoops * 10) truncateTo: 0.001) printString,		' microseconds overhead per primitive call'! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 3/27/2009 09:57'!initializeCommonRequestStrings	"Initialize the common request strings, a directly-editable list of expressions that can be evaluated from the 'do...' menu."	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapse.Utilities closeAllDebuggers.-Sensor keyboard.ParagraphEditor abandonChangeText.Cursor normal show.-CommandHistory resetAllHistory.Project allInstancesDo: [:p | p displayDepth: 16].Form fromUser bitEdit.Display border: (0@0 extent: 640@480) width: 2.-Undeclared inspect.Undeclared removeUnreferencedKeys; inspect.Transcript clear.Utilities grabScreenAndSaveOnDisk.FrameRateMorph new openInHand.-Utilities reconstructTextWindowsFromFileNamed: ''TW''.Utilities storeTextWindowContentsToFileNamed: ''TW''.ChangeSorter removeEmptyUnnamedChangeSets.ChangeSorter reorderChangeSets.-ActiveWorld installVectorVocabulary.ActiveWorld abandonVocabularyPreference.Smalltalk saveAsNewVersion'"Utilities initializeCommonRequestStrings"! !