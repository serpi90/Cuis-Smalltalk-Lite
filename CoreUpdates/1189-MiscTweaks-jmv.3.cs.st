'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 29 December 2011 at 5:02:19 pm'!!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'jmv 12/29/2011 15:10'!       ln	^DomainError signal: 'ln is only defined for x > 0' "from: 0 ???"! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'jmv 12/29/2011 15:11'!                            log	^DomainError signal: 'log is only defined for x > 0' "from: 0 ???"! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 15:07'!   clickAndHalf: evt	self handleInteraction: [ self editor clickAndHalf: evt ]! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 15:05'!                               keyStroke: aKeyboardEvent	"Handle a keystroke event."	(self focusKeyboardFor: aKeyboardEvent)		ifTrue: [ ^ self ].	(self closeWindowFor: aKeyboardEvent)		ifTrue: [ ^ self ].	"CR - check for special action	Note: Code below assumes that this was some	input field reacting on CR. Break the keyboard	focus so that the receiver can be safely deleted.	jmv - Currently not implemented"	"	evt keyValue = 13 ifTrue: [		action _ self crAction.		action ifNotNil: [			evt hand newKeyboardFocus: nil.			^action value ] ].	"	self pauseBlinking.	self handleInteraction: [ self editor processKeyStroke: aKeyboardEvent ].	self updateFromContents.	super keyStroke: aKeyboardEvent  "sends to keyStroke event handler, if any"! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 15:06'!                   mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event hand newKeyboardFocus: self.	self handleInteraction: [		self editor mouseDown: event index: (self characterIndexAtPoint: event position) ].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: #clickAndHalf:		dblClkSel: nil		dblClkNHalfSel: nil		tripleClkSel: nil! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 15:06'!                            mouseMove: evt	evt mouseButton1Pressed ifFalse: [^ self].	self handleInteraction: [		self editor mouseMove: evt index: (self characterIndexAtPoint: evt position) ]! !!OneLineEditorMorph methodsFor: 'private' stamp: 'jmv 12/29/2011 15:05'!            updateFromContents	"O contents deberia ser un StringHolder????"	contents _ self editor string.	self redrawNeeded! !!SimpleEditor methodsFor: 'events' stamp: 'jmv 12/29/2011 14:51'!    mouseDown: evt index: index	evt shiftPressed		ifFalse: [			self markIndex: index pointIndex: index ]		ifTrue: [			self mouseMove: evt index: index ]! !!SocketStream class methodsFor: 'example' stamp: 'jmv 12/29/2011 15:12'!                       finger: userName	"SocketStream finger: 'stp'"	| addr s |	addr := NetNameResolver promptUserForHostAddress.	s := SocketStream openConnectionToHost: addr port: 79.  "finger port number"	Transcript show: '---------- Connecting ----------'; cr.	s sendCommand: userName.	Transcript show: s nextLine.	s close.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!String methodsFor: 'paragraph support' stamp: 'jmv 4/11/2011 21:26'!                encompassParagraph: anInterval	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.	Answer starts at the position following a cr (or eventually 1) and ends at a cr (or eventually at self size).	Look also for null characters. Never include null characters in the answer.	See also #encompassLine:"	| left rightCr rightNull |	left _ (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	rightCr _ (self indexOf: Character cr startingAt: (anInterval last max: anInterval first) ifAbsent: [self size]).	rightNull _ (self indexOf: Character null startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.	^left to: (rightCr min: rightNull)! !!TextEditor methodsFor: 'events' stamp: 'jmv 12/29/2011 16:59'!        mouseMove: evt	"Change the selection in response to mouse-down drag"	| b interval i1 i2 |	doWordSelection ifTrue: [		pointBlock _ (paragraph characterBlockAtPoint: (evt position)).		self selectWordLeftDelimiters: '' rightDelimiters: ''.		markBlock _ self startBlock min: initialSelectionStart.		pointBlock _ self stopBlock max: initialSelectionStop.		self storeSelectionInParagraph.		^self ].	doParagraphSelection ifTrue: [		b _ paragraph characterBlockAtPoint: evt position.		i1 _ b stringIndex min: initialSelectionStart stringIndex.		i2 _ b stringIndex max: initialSelectionStop stringIndex-1.		interval _ self privateCurrentString encompassParagraph: (i1 to: i2).		self selectFrom: interval first to: interval last.		markBlock _ self startBlock min: initialSelectionStart.		pointBlock _ self stopBlock max: initialSelectionStop.		self storeSelectionInParagraph.		^self ].	pointBlock _ (paragraph characterBlockAtPoint: (evt position)).	self storeSelectionInParagraph! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/29/2011 15:21'!                       applyAttribute: aTextAttribute	"The user selected aTextAttribute via shortcut, menu or other means.	If there is a selection, apply the attribute to the selection.	In any case use the attribute for the user input (emphasisHere)"	"This generates undo"	| anythingDone |	anythingDone _ false.	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.	self selectionIntervalsDo: [ :interval |		(interval notEmpty or: [ aTextAttribute isParagraphAttribute ])			ifTrue: [				anythingDone _ true.				model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.				paragraph recomposeFrom: interval first to: interval last delta: 0 ]].	anythingDone ifTrue: [		self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"		self userHasEdited ].	"Even if nothing done, emphasisHere might have changed"	morph possiblyChanged! !