'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 12 March 2012 at 10:38:28 am'!!PackageFile methodsFor: 'services' stamp: 'jmv 3/12/2012 10:16'! install: aFileStream	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."	| localName newChangeSet |	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."	'=============' print.	('classesToRemove: ', classesToRemove printString) print.	'=============' print.	'methodsToRemove: ' print.	methodsToRemove do: [ :methodReference | methodReference print ].	'=============' print.		"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"	"These were created in #fromFileStream: ... reuse?"	localName _ FileDirectory localNameFor: fullName.	newChangeSet _ ChangeSorter basicNewChangeSetLike: 'install package ', localName.	newChangeSet ifNotNil: [		ChangeSet newChanges: newChangeSet.		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].		Transcript cr; show: 'Package ', packageName, ' successfully installed'; cr].		"Tirar undeclared al transcript. warning si quedaron undeclared	Es feo que tire an transcript undeclareds que despues no lo son..."	Smalltalk cleanOutUndeclared.	Undeclared print.	"Crear, instalar y devolver una instancia de PackageInfo. Descartar la instancia de PackageFile"! !!ScrollBar methodsFor: 'geometry' stamp: 'jmv 3/12/2012 10:32'!                    extent: newExtent	| newExtentToUse |	newExtent = bounds extent ifTrue: [^ self].	newExtentToUse _ bounds isWide		ifTrue: [ (newExtent x max: 14) @ newExtent y ]		ifFalse: [ newExtent x @ (newExtent y max: 14) ].	newExtentToUse = bounds extent ifTrue: [^ self].	super extent: newExtentToUse.			self flag: #jmv.	"Most times it is not necessary to recreate the buttons"	self recreateSubmorphs! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 3/12/2012 10:37'!                               browseUndeclaredReferences	"	Smalltalk browseUndeclaredReferences	"	| anythingToShow |	Smalltalk cleanOutUndeclared.	anythingToShow _ false.	Undeclared keys do: [ :k |		anythingToShow _ true.		self			browseMessageList: (Smalltalk allCallsOn: (Undeclared associationAt: k))			name: 'References to Undeclared: ', k printString ].	"undeclared not in Undeclared - "	"This happened in Pharo. See http://lists.gforge.inria.fr/pipermail/pharo-project/2012-March/061270.html	Maybe do something like this in Cuis too???	lostUndeclared _ Smalltalk allSelect: [:m|		m literals anySatisfy: [:l|			l isVariableBinding				and: [l key isSymbol ""avoid class-side methodClass literals""				and: [(m methodClass bindingOf: l key) isNil				and: [(Undeclared includesAssociation: l) not]]]]].	"	anythingToShow ifFalse: [		 (PopUpMenu labels: ' OK ')				startUpWithCaption: 'There are no Undeclared at all' ]! !!Utilities class methodsFor: 'closure support' stamp: 'jmv 3/12/2012 10:17'!                           postRecompileCleanup	"Utilities postRecompileCleanup"	"Cleanup after loading closure bootstrap"	"Before doing this, please start a new UI process (for example, by hitting alt-period and closing the debugger)."	| unboundMethods contexts |	World removeAllKnownFailing.	ProcessorScheduler startUp.	WeakArray restartFinalizationProcess.	MethodChangeRecord allInstancesDo:[:x| x noteNewMethod: nil].	Smalltalk cleanOutUndeclared.	Delay startTimerEventLoop.	EventSensor install.	WorldState allInstancesDo:[:ws| ws convertAlarms; convertStepList].	Workspace allInstancesDo:[:ws| ws initializeBindings].	Smalltalk garbageCollect.	Smalltalk		at: #DebuggerMethodMap		ifPresent: [ :dmm | dmm voidMapCache ].	Smalltalk garbageCollect.	unboundMethods _ CompiledMethod unboundMethods.	unboundMethods notEmpty ifTrue: [		unboundMethods inspectWithLabel: 'Unbound Methods'].	Smalltalk at: #BlockContext ifPresent: [ :bc |		contexts _ bc allInstances.		contexts ifNotEmpty: [			contexts inspect. 			self inform: 'There are left-over BlockContexts'.			^self ]].	unboundMethods isEmpty ifTrue:[		self inform:'Congratulations - The bootstrap is now complete.'.	]! !