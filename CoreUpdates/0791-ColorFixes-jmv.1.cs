'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 31 January 2011 at 9:55:22 am'!!Color methodsFor: 'access' stamp: 'jmv 1/31/2011 09:25'!alpha	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TranslucentColors."	^ 1.0! !!Color methodsFor: 'transformations' stamp: 'jmv 1/31/2011 09:25'!alpha: alphaValue	"Return a new TranslucentColor with the given amount of opacity ('alpha')."	alphaValue = 1.0 ifFalse:[		^ TranslucentColor basicNew setRgb: rgb alpha: alphaValue ]! !!Color class methodsFor: 'instance creation' stamp: 'jmv 1/31/2011 09:27'!colorFromPixelValue: p depth: d	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.	The real rule is that pixelValue=0 means transparent.	This method is updated to reflect that."	| r g b alpha |	d = 8 ifTrue: [^ IndexedColors at: (p bitAnd: 16rFF) + 1].	d = 4 ifTrue: [^ IndexedColors at: (p bitAnd: 16r0F) + 1].	d = 2 ifTrue: [^ IndexedColors at: (p bitAnd: 16r03) + 1].	d = 1 ifTrue: [^ IndexedColors at: (p bitAnd: 16r01) + 1].	"pixelValue = 0, (i.e. all components, including alpha if present, are zero) means transparent"	p = 0 ifTrue: [ ^Color transparent ].	(d = 16) | (d = 15) ifTrue: [		"five bits per component"		r _ (p bitShift: -10) bitAnd: 16r1F.		g _ (p bitShift: -5) bitAnd: 16r1F.		b _ p bitAnd: 16r1F.		(r = 0 and: [g = 0]) ifTrue: [			b = 1 ifTrue: [^Color black]].		^ Color r: r g: g b: b range: 31].	d = 32 ifTrue: [		"eight bits per component; 8 bits of alpha"		alpha _ p bitShift: -24.		alpha = 0 ifTrue: [ ^Color transparent ].		r _ (p bitShift: -16) bitAnd: 16rFF.		g _ (p bitShift: -8) bitAnd: 16rFF.		b _ p bitAnd: 16rFF.		^alpha < 255			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]			ifFalse: [ Color r: r g: g b: b range: 255 ]].	d = 12 ifTrue: [		"four bits per component"		r _ (p bitShift: -8) bitAnd: 16rF.		g _ (p bitShift: -4) bitAnd: 16rF.		b _ p bitAnd: 16rF.		^ Color r: r g: g b: b range: 15].	d = 9 ifTrue: [		"three bits per component"		r _ (p bitShift: -6) bitAnd: 16r7.		g _ (p bitShift: -3) bitAnd: 16r7.		b _ p bitAnd: 16r7.		^ Color r: r g: g b: b range: 7].	self error: 'unknown pixel depth: ', d printString! !!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:11'!cachedColormapFrom: sourceDepth to: destDepth	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"	"Warning: The behavior is incorrect for 32bpp Forms with translucency.	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,	that is R=0, G=0, B=0, Alpha=0.	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."	| srcIndex map |	CachedColormaps		ifNil: [CachedColormaps _ (1 to: 9) collect: [:i | Array new: 32]].		srcIndex _ sourceDepth.	sourceDepth > 8 ifTrue: [srcIndex _ 9].	((CachedColormaps at: srcIndex) at: destDepth) ifNotNil: [ :m | ^ m ].	map _ self computeColormapFrom: sourceDepth to: destDepth.	(CachedColormaps at: srcIndex) at: destDepth put: map.	^ map! !!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:11'!computeColormapFrom: sourceDepth to: destDepth	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."	"Warning: The behavior is incorrect for 32bpp Forms with translucency.	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,	that is R=0, G=0, B=0, Alpha=0.	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."	| map bitsPerColor |	sourceDepth < 16 ifTrue: [		"source is 1-, 2-, 4-, or 8-bit indexed color"		map _ (IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))					collect: [:c | c pixelValueForDepth: destDepth].		map _ map as: Bitmap.	] ifFalse: [		"source is 16-bit or 32-bit RGB"		destDepth > 8			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"			ifFalse: [bitsPerColor _ 4].		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].	"Note: zero is transparent except when source depth is one-bit deep"	sourceDepth > 1 ifTrue: [map at: 1 put: 0].	^ map! !!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:10'!computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."	"Warning: The behavior is incorrect for 32bpp Forms with translucency.	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,	that is R=0, G=0, B=0, Alpha=0.	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."	| mask map c |	(#(3 4 5) includes: bitsPerColor)		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].	mask _ (1 bitShift: bitsPerColor) - 1.	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).	0 to: map size - 1 do: [:i |		c _ Color			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)			b: ((i bitShift: 0) bitAnd: mask)			range: mask.		map at: i + 1 put: (c pixelValueForDepth: destDepth)].	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"	^ map! !!Color class methodsFor: 'other' stamp: 'jmv 1/31/2011 09:30'!maskingMap: depth	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."	"Warning: The behavior is incorrect if depth = 32.	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,	that is R=0, G=0, B=0, Alpha=0.	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."	| sizeNeeded |	depth <= 8		ifTrue: [sizeNeeded _ 1 bitShift: depth]		ifFalse: [sizeNeeded _ 4096].	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.		MaskingMap at: 1 put: 0.  "transparent"].	^ MaskingMap! !!Form methodsFor: 'color mapping' stamp: 'jmv 1/30/2011 23:10'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	"Warning: The behavior is incorrect for 32bpp Forms with translucency.	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,	that is R=0, G=0, B=0, Alpha=0.	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."	| map |	self depth < 16		ifTrue: [map _ (Color cachedColormapFrom: self depth to: self depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map _ Color computeRGBColormapFor: self depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'color mapping' stamp: 'jmv 1/31/2011 09:21'!maskingMap	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."	"Warning: The behavior is incorrect for 32bpp Forms with translucency.	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,	that is R=0, G=0, B=0, Alpha=0.	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."	^Color maskingMap: self depth! !!Form methodsFor: 'pixel access' stamp: 'jmv 1/31/2011 09:45'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	| p d |	d _ self depth.	"no transparency at depth 1"	d = 1 ifTrue: [^ false].		"Check inside the palette"	d <= 8 ifTrue: [ 		^(self colorAt: aPoint) isTransparent ].	p _ self pixelValueAt: aPoint.	"pixel pattern 0 is transparent for RGB"	d <= 16 ifTrue: [		^p = 0 ].	"32bpp, rgba. Pixels with alpha = 0 are transparent"	^(p anyMask: 16rFF000000) not! !