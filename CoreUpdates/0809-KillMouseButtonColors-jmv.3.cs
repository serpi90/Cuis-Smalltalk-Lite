'From Cuis 3.0 of 31 January 2011 [latest update: #790] on 22 February 2011 at 10:12:15 pm'!!FileContentsBrowser commentStamp: '<historical>' prior: 0!I am a class browser view on a fileout (either a source file (.st) or change set (.cs)). I do not actually load the code into to the system, nor do I alter the classes in the image. Use me to vet code in a comfortable way before loading it into your image.From a FileList, I can be invoked by selecting a source file and selecting the "browse code" menu item from the context (right click) menu.I use PseudoClass, PseudoClassOrganizers, and PseudoMetaclass to model the class structure of the source file.!!EventSensor commentStamp: 'jmv 2/22/2011 22:00' prior: 0!EventSensor is a replacement for InputSensor based on a set of (optional) event primitives. An EventSensor updates its state when events are received so that all state based users of Sensor (e.g., Sensor keyboard, Sensor leftShiftDown, Sensor mouseButtons) will work exactly as before, by moving the current VM mechanisms into EventSensor itself. An optional input semaphore is part of the new design.For platforms that support true asynchronous event notification, the semaphore will be signaled to indicate pending events.On platforms that do not support asynchronous notifications about events, the UI will have to poll EventSensor periodically to read events from the VM.Instance variables:	mouseButtons <Integer>	- mouse button state as replacement for primMouseButtons	mousePosition <Point>	- mouse position as replacement for primMousePt	keyboardBuffer <SharedQueue>	- keyboard input buffer	interruptKey <Integer>			- currently defined interrupt key	interruptSemaphore <Semaphore>	- the semaphore signaled when the interruptKey is detected	eventQueue <SharedQueue>	- an optional event queue for event driven applications	inputSemaphore <Semaphore>- the semaphore signaled by the VM if asynchronous event notification is supported	lastEventPoll <Integer>		- the last millisecondClockValue at which we called fetchMoreEvents	hasInputSemaphore <Boolean>	- true if my inputSemaphore has actually been signaled at least once.Class variables:	EventPollPeriod <Integer>	- the number of milliseconds to wait between polling for more events in the userInterruptHandler.	EventTicklerProcess <Process>	- the process that makes sure that events are polled for often enough (at least every EventPollPeriod milliseconds).Event format:The current event format is very simple. Each event is recorded into an 8 element array. All events must provide some SmallInteger ID (the first field in the event buffer) and a time stamp (the second field in the event buffer), so that the difference between the time stamp of an event and the current time can be reported.Currently, the following events are defined:Null event=============The Null event is returned when the ST side asks for more events but no more events are available.Structure:[1]		- event type 0[2-8]	- unusedMouse event structure==========================Mouse events are generated when mouse input is detected.Structure:[1]	- event type 1[2]	- time stamp[3]	- mouse x position[4]	- mouse y position[5]	- button state; bitfield with the following entries:		1	-	mouseButton2 (e.g., right) button		2	-	mouseButton3 (e.g., middle) button		4	-	mouseButton1 (e.g., left) button		[all other bits are currently undefined][6]	- modifier keys; bitfield with the following entries:		1	-	shift key		2	-	ctrl key		4	-	(Mac specific) option key		8	-	Cmd/Alt key		[all other bits are currently undefined][7]	- reserved.[8]	- reserved.Keyboard events====================Keyboard events are generated when keyboard input is detected.[1]	- event type 2[2]	- time stamp[3]	- character code		For now the character code is in Mac Roman encoding.[4]	- press state; integer with the following meaning		0	-	character		1	-	key press (down)		2	- 	key release (up)[5]	- modifier keys (same as in mouse events)[6]	- reserved.[7]	- reserved.[8]	- reserved.!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickState firstClickDown firstClickUp firstClickTime clickSelector dblClickSelector dblClickTime dblClickTimeoutSelector dragSelector dragThreshold sendYellowButtonActivity sendMouseButton2Activity '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!!BitBlt class methodsFor: 'examples' stamp: 'jmv 2/22/2011 17:01'!alphaBlendDemo	"To run this demo, use...		Display restoreAfter: [BitBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.		map32toD _ Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	buff _ Form extent: 500@50 depth: 32.	dispToBuff _ BitBlt toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay _ BitBlt toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush _ Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"	dispToBuff colorMap: mapDto32.	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"	brushToBuff sourceForm: brush; sourceOrigin: 0@0.	brushToBuff combinationRule: Form blend.	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor mouseButton2Pressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor cursorPoint - (buffSize // 2) extent: buff extent.		dispToBuff copyFrom: buffRect in: Display to: 0@0.		[Sensor mouseButton1Pressed] whileTrue:			["Here is the painting loop"			p _ Sensor cursorPoint - (brush extent // 2).			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p dist: prevP) > buffSize ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				(buffRect containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ brushRect amountToTranslateWithin: buffRect.					buffToBuff copyFrom: buff boundingBox in: buff to: delta.					newBuffRect _ buffRect translateBy: delta negated.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP - buffRect origin									to: p - buffRect origin									withFirstPoint: false.				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.				prevP _ p]]]! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 2/22/2011 17:12'!openExtraMenu	"Offer the shifted selector-list menu"	^ self shiftedMessageListMenu popUpInWorld! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 2/22/2011 17:12'!openMenu	"Offer the unshifted selector-list menu"	^ self messageListMenu popUpInWorld! !!Browser methodsFor: 'message functions' stamp: 'jmv 2/22/2011 17:12'!messageListMenu	"Answer the message-list menu"	"Changed by emm to include menu-item for breakpoints"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addList:#(			('what to show...'				offerWhatToShowMenu)                	('toggle break on entry'		toggleBreakOnEntry)            		-			('browse full (b)' 				browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'						fileOutMessage)			-			('senders of... (n)'				browseSendersOfMessages)			('implementors of... (m)'			browseMessages)			('inheritance (i)'					methodHierarchy)			('versions (v)'					browseVersions)			-			('inst var refs...'					browseInstVarRefs)			('inst var defs...'				browseInstVarDefs)			('class var refs...'				browseClassVarRefs)			('class variables'				browseClassVariables)			('class refs (N)'					browseClassRefs)			-			('remove method (x)'			removeMessage)			-			('more...'						openExtraMenu)).	^ aMenu! !!Browser methodsFor: 'message functions' stamp: 'jmv 2/22/2011 17:14'!shiftedMessageListMenu	"Fill aMenu with the items appropriate when the shift key is held down"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpIcons.	aMenu addList: #(		('toggle diffing (D)'						toggleDiffing)		('implementors of sent messages'			browseAllMessages)		-		('local senders of...'						browseLocalSendersOfMessages)		('local implementors of...'				browseLocalImplementors)		-		('spawn sub-protocol'					spawnProtocol)		('spawn full protocol'					spawnFullProtocol)		-		('sample instance'						makeSampleInstance)		('inspect instances'						inspectInstances)		('inspect subinstances'					inspectSubInstances)).	self addExtraShiftedItemsTo: aMenu.	aMenu addList: #(		-		('change category...'					changeCategory)).	self canShowMultipleMessageCategories ifTrue: [ aMenu addList:		 #(('show category (C)'					showHomeCategory))].	aMenu addList: #(		-		('change sets with this method'			findMethodInChangeSets)		('revert to previous version'			revertToPreviousVersion)		('remove from current change set'		removeFromCurrentChanges)		('revert & remove from changes'		revertAndForget)		('add to current change set'			adoptMessageInCurrentChangeset)		-		('more...' 								openMenu)).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 2/22/2011 17:13'!messageMenu	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'message list'.	aMenu addStayUpIcons.	parent ifNotNil:		[aMenu addList: #(			('copy method to other side'			copyMethodToOther)			('move method to other side'			moveMethodToOther))].	aMenu addList: #(			('delete method from changeSet (d)'	forget)			-			('remove method from system (x)'		removeMessage)				-			('browse full (b)'						browseMethodFull)			('browse hierarchy (h)'					spawnHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut'								fileOutMessage)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'							methodHierarchy)			('versions (v)'							browseVersions)			-			('more...'								openExtraMenu)).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 2/22/2011 17:14'!shiftedMessageMenu	"Arm the menu so that it holds items appropriate to the message-list while the shift key is down.  Answer the menu."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addList: #(		-		('toggle diffing (D)'					toggleDiffing)		('implementors of sent messages'	browseAllMessages)		('change category...'				changeCategory)			-		('sample instance'					makeSampleInstance)		('inspect instances'					inspectInstances)		('inspect subinstances'				inspectSubInstances)		-		('change sets with this method'		findMethodInChangeSets)		('revert to previous version'		revertToPreviousVersion)		('revert & remove from changes'	revertAndForget)		-		('more...'							openMenu)).	^aMenu! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 2/22/2011 17:13'!contextStackMenu	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addList: {			{'fullStack (f)'.				#fullStack}.			{'restart (r)'.				#restart}.			{'proceed (p)'.				#proceed}.			{'step (t)'.					#doStep}.			{'step through (T)'.			#stepIntoBlock}.			{'send (e)'.					#send}.			{'where (w)'.				#where}.			{'peel to first like this'.		#peelToFirst}.			#-.			{'return entered value'.		#returnValue}.			#-.			{'toggle break on entry'.	#toggleBreakOnEntry}.			{'senders of... (n)'.			#browseSendersOfMessages}.			{'implementors of... (m)'.	#browseMessages}.			{'inheritance (i)'.			#methodHierarchy}.			#-.			{'versions (v)'.				#browseVersions}.			{'inst var refs...'.			#browseInstVarRefs}.			#-.			{'inst var defs...'.			#browseInstVarDefs}.			{'class var refs...'.			#browseClassVarRefs}.			{'class variables'.			#browseClassVariables}.			#-.			{'class refs (N)'.			#browseClassRefs}.			{'browse full (b)'.			#browseMethodFull}.			{'file out '.					#fileOutMessage}.			#-.			{'more...'.					#openExtraMenu}.		}.	^aMenu! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 2/22/2011 17:15'!shiftedContextStackMenu	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addList: {			{'browse class hierarchy'.				#classHierarchy}.			{'browse class'.						#browseClass}.			{'browse method (O)'.					#openSingleMessageBrowser}.			{'implementors of sent messages'.		#browseAllMessages}.			{'change sets with this method'.		#findMethodInChangeSets}.			#-.			{'inspect instances'.					#inspectInstances}.			{'inspect subinstances'.				#inspectSubInstances}.			#-.			{'revert to previous version'.			#revertToPreviousVersion}.			{'remove from current change set'.	#removeFromCurrentChanges}.			{'revert & remove from changes'.		#revertAndForget}.			#-.			{'more...'.								#openMenu}. 		}.	^aMenu! !!EventHandler methodsFor: 'events' stamp: 'jmv 2/22/2011 16:51'!mouseDown: event fromMorph: sourceMorph 	"Take double-clicks into account."	((self handlesClickOrDrag: event) and:[event mouseButton1Pressed]) ifTrue:[		event hand waitForClicksOrDrag: sourceMorph event: event.	].	^self		send: mouseDownSelector		to: mouseDownRecipient		withEvent: event		fromMorph: sourceMorph.! !!Form class methodsFor: 'examples' stamp: 'jmv 2/22/2011 17:01'!exampleSketch	"This is a simple drawing algorithm to get a sketch on the display screen.	Draws whenever mouse button down.  Ends with option-click."	| aPen color |	aPen _ Pen new.	color _ 0.	[Sensor mouseButton2Pressed]		whileFalse:		[aPen place: Sensor cursorPoint; color: (color _ color + 1).		[Sensor mouseButton1Pressed]			whileTrue: [aPen goto: Sensor cursorPoint]].	Sensor waitNoButton.	"Form exampleSketch"! !!Form class methodsFor: 'examples' stamp: 'jmv 2/22/2011 17:01'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors _ Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade _ Form extent: diam@diam offset: (diam//-2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam//2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x*diam//5) displayOn: facade			at: (diam*2//5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball _ Form dotOfSize: diam.	color _ 8.	[ true ] whileTrue:		[port _ BitBlt current toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue _ OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20@-20].		Sensor waitButton.		Sensor mouseButton2Pressed ifTrue: [^ self].		filter _ Sensor cursorPoint.		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"		colr2 _ colr alphaMixed: 0.3 with: Color white.		[Sensor mouseButton1Pressed or: [queue size > 0]] whileTrue:			[filter _ filter * 4 + Sensor cursorPoint // 5.			point _ Sensor mouseButton1Pressed				ifTrue: [filter] ifFalse: [-20@-20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q _ queue removeFirst) ifNil: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor mouseButton1Pressed ifTrue: [queue addLast: point]]].! !!Form class methodsFor: 'examples' stamp: 'jmv 2/22/2011 17:01'!xorHack: size  "Display restoreAfter: [Form xorHack: 256]"	"Draw a smiley face or stick figure, and end with option-click.	Thereafter image gets 'processed' as long as you have button down.	If you stop at just the right time, you'll see you figure upside down,	and at the end of a full cycle, you'll see it perfectly restored.	Dude -- this works in color too!!"	| rect form i bb |	rect _ 5@5 extent: size@size.	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	Display border: (rect topRight - (0@2) extent: rect extent*2 + 4) width: 2.	Form exampleSketch.	form _ Form fromDisplay: rect.	bb _ form boundingBox.	i _ 0.	[Sensor mouseButton2Pressed] whileFalse:		[[Sensor mouseButton1Pressed] whileTrue:			[i _ i + 1.			(Array with: 0@1 with: 0@-1 with: 1@0 with: -1@0) do:				[:d | form copyBits: bb from: form at: d					clippingBox: bb rule: Form reverse fillColor: nil].			form displayAt: rect topLeft.			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].		(form magnify: form boundingBox by: 2@2) displayAt: rect topRight + (2@0).		Sensor waitButton].! !!InputSensor methodsFor: 'keyboard' stamp: 'jmv 2/22/2011 17:01'!kbdTest	"	Sensor kbdTest	"	"This test routine will print the unmodified character, its keycode,	and the OR of all its modifier bits, until the character x is typedAlso useful:	Sensor test	"	| char |	char _ nil.	[ char = $x ] whileFalse: [		[ self keyboardPressed ] whileFalse.		char _ self characterForKeycode: self keyboard.		Display fill: (5@5 extent: 400@20) fillColor: Color white.		(String streamContents: [ :s |			s				nextPut: $-;				nextPut: char;				nextPut: $-;				space;				print: char asciiValue;				space.			self mouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].			self mouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].			self mouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])		displayAt: 10 @ 10 ].! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 2/22/2011 21:50'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific."	self notifyWithLabel: 'Portability note:InputSensor>>macOptionKeyPressed is not portable.Please use InputSensor>>mouseButton2Pressed instead!!'.	^ self rawMacOptionKeyPressed! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/22/2011 16:49'!anyButtonPressed	"Answer whether at least one mouse button is currently being pressed."	^ self primMouseButtons anyMask: InputSensor anyMouseButton! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/22/2011 22:07'!mouseButton1Pressed	"Answer true if only the mouseButton1 is being pressed.	This is the first mouse button, usually the one at the left."	^ (self primMouseButtons bitAnd: 7) = InputSensor mouseButton1! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/22/2011 22:05'!mouseButton2Pressed	"Answer whether only the mouseButton2 is being pressed. 	This is the usually the right mouse button or option+click on the Mac."	^ (self primMouseButtons bitAnd: 7) = InputSensor mouseButton2! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/22/2011 22:08'!mouseButton3Pressed	"Answer whether only the mouseButton3 is being pressed. 	This is the third mouse button, usually the wheel or button at the center, or cmd+click on the Mac."	^ (self primMouseButtons bitAnd: 7) = InputSensor mouseButton3! !!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 2/22/2011 21:49'!mapButtons: buttons modifiers: modifiers	"Map the buttons to mouseButton2 or mouseButton3 based on the given modifiers.	If only the mouseButton1 is pressed, then map		Cmd-mouseButton1 -> mouseButton2.		Ctrl-mouseButton1 -> mouseButton3.	"	(buttons = InputSensor mouseButton1)		ifFalse: [ ^ buttons ].	(modifiers allMask: EventSensor macOptionKey) 		ifTrue: [ ^ InputSensor mouseButton3 ].	(modifiers allMask: EventSensor commandAltKey) 		ifTrue: [ ^ InputSensor mouseButton2 ].	^buttons! !!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 2/22/2011 22:01'!processEvent: evt	"Process a single event. This method is run at high priority."	| type |	type _ evt at: 1.	"Check if the event is a user interrupt"	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [		((evt at: 3) bitOr: ((evt at: 5) bitShift: 8)) = interruptKey]])			 ifTrue: [				"interrupt key is meta - not reported as event"				^interruptSemaphore signal].	"Store the event in the queue if there's any"	type = EventSensor eventTypeMouse ifTrue: [		"Only swap secondary and tertiary buttons if there is no modifier keys.		This swap is done so a 3-button mouse  is			left -> mouseButton1 (select)			center -> mouseButton3 (halo)			right -> mouseButton2 (menu).		This is only needed on the Mac, Window VM does this mapping by default.		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:			left -> mouseButton1			macOption + left -> mouseButton3			command + left -> mouseButton2,		but Mac users are already used to 			macOption + left -> menu			command + left -> halo.		See #installMouseDecodeTable"		(evt at: 6) = 0 ifTrue: [			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].	self queueEvent: evt.	"Update state for InputSensor."	type = EventSensor eventTypeMouse ifTrue: [ self processMouseEvent: evt ].	type = EventSensor eventTypeKeyboard ifTrue: [ self processKeyboardEvent: evt ]! !!InputSensor class methodsFor: 'class initialization' stamp: 'jmv 2/22/2011 21:51'!installMouseDecodeTable	"Create a decode table that swaps the lowest-order 2 bits if not on Windows.	This is to make right mouse button be the mouseButton2, i.e. open menus, and middle (wheel) button open halos (mouseButton3).	See #processEvent:"	ButtonDecodeTable _ Smalltalk platformName = 'Win32'		ifTrue: [ ByteArray withAll: (0 to: 255) ]		ifFalse: [			ByteArray withAll:				((0 to: 255) collect: [ :ea |					((ea bitAnd: 1) << 1 bitOr: (ea bitAnd: 2) >> 1) bitOr: (ea bitAnd: 252) ]) ]! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/22/2011 16:49'!anyMouseButton	^ 7! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/22/2011 16:50'!mouseButton1	^ 4! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/22/2011 17:01'!mouseButton2	^ 2! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/22/2011 16:54'!mouseButton3	^ 1! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 2/22/2011 16:56'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent wasHandled: true.	self activateWindow.	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent mouseButton3Changed ifTrue:[^self mouseButton3Down: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 2/22/2011 16:57'!handleMouseUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand mouseFocus == self ifFalse:[^self]. "Not interested in other parties"	anEvent hand releaseMouseFocus: self.	anEvent wasHandled: true.	anEvent mouseButton3Changed		ifTrue:[self mouseButton3Up: anEvent]		ifFalse:[self mouseUp: anEvent.				self stopSteppingSelector: #handleMouseStillDown:].! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 2/22/2011 16:54'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	anEvent mouseButton3Pressed ifTrue:[^self handlerForMouseButton3Down: anEvent].	anEvent controlKeyPressed ifTrue:[^self handlerForMetaMenu: anEvent].	(self handlesMouseDown: anEvent) ifFalse:[^nil]. "not interested"	anEvent handler ifNil:[^self]. "Nobody else was interested"	self mouseDownPriority >= anEvent handler mouseDownPriority 		ifTrue:[^self] "Same priority but I am innermost"		ifFalse:[^nil]. "Other guy has higher priority than I"! !!LightWidget methodsFor: 'meta actions' stamp: 'jmv 2/22/2011 21:56'!handlerForMouseButton3Down: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event.	Note: Halos handle mouseButton3 events themselves so we will only be asked if there is currently no halo on top of us."	self wantsHaloFromClick ifFalse: [ ^nil ].	anEvent handler ifNil: [ ^self ].	anEvent handler isPlayfieldLike ifTrue: [ ^self ]. "by default exclude playfields"	^anEvent shiftPressed		ifFalse: [ nil ] "let outer guy have it"		ifTrue: [ self ] "let me have it"! !!LightWidget methodsFor: 'meta actions' stamp: 'jmv 2/22/2011 16:56'!mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: (anEvent externalizedFromOwnerOf: self to: nil).	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent externalizedFromOwnerOf: self to: nil)		clkSel: nil		dblClkSel: nil		dblClkTimeoutSel: nil		dragSel: #dragTarget:.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!LightWidget methodsFor: 'meta actions' stamp: 'jmv 2/22/2011 21:54'!mouseButton3Up: anEvent	"Ignored. Theoretically we should never get here since control is transferred to the halo on #mouseButton3Down: but subclasses may implement this differently."! !!EntryField2LW methodsFor: 'event handling' stamp: 'jmv 2/22/2011 16:51'!mouseMove: evt	evt mouseButton1Pressed ifFalse: [^ self].	self handleInteraction: [		editor mouseMove: evt index: (self characterIndexAtPoint: evt cursorPoint) ]! !!Morph methodsFor: 'event handling' stamp: 'jmv 2/22/2011 16:56'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent wasHandled: true.	self activateWindow.	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent mouseButton3Changed ifTrue:[^self mouseButton3Down: anEvent].	self mouseDown: anEvent.	anEvent hand removeHaloFromClick: anEvent on: self.	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!Morph methodsFor: 'events-processing' stamp: 'jmv 2/22/2011 16:57'!handleMouseUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand mouseFocus == self ifFalse:[^self]. "Not interested in other parties"	anEvent hand releaseMouseFocus: self.	anEvent wasHandled: true.	anEvent mouseButton3Changed		ifTrue:[self mouseButton3Up: anEvent]		ifFalse:[self mouseUp: anEvent.				self stopSteppingSelector: #handleMouseStillDown:].! !!Morph methodsFor: 'events-processing' stamp: 'jmv 2/22/2011 16:55'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	anEvent mouseButton3Pressed ifTrue:[^self handlerForMouseButton3Down: anEvent].	anEvent controlKeyPressed ifTrue:[^self handlerForMetaMenu: anEvent].	(self handlesMouseDown: anEvent) ifFalse:[^nil]. "not interested"	anEvent handler ifNil:[^self]. "Nobody else was interested"	self mouseDownPriority >= anEvent handler mouseDownPriority 		ifTrue:[^self] "Same priority but I am innermost"		ifFalse:[^nil]. "Other guy has higher priority than I"! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 2/22/2011 21:57'!handlerForMouseButton3Down: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event.	Note: Halos handle mouseButton3 events themselves so we will only be asked if there is currently no halo on top of us."	self wantsHaloFromClick ifFalse: [ ^nil ].	anEvent handler ifNil: [ ^self ].	anEvent handler isPlayfieldLike ifTrue: [ ^self ]. "by default exclude playfields"	^anEvent shiftPressed		ifFalse: [ nil ] "let outer guy have it"		ifTrue: [ self ] "let me have it"! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 2/22/2011 16:56'!mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: (anEvent externalizedFromOwnerOf: self to: nil).	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent externalizedFromOwnerOf: self to: nil)		clkSel: nil		dblClkSel: nil		dblClkTimeoutSel: nil		dragSel: #dragTarget:.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 2/22/2011 21:54'!mouseButton3Up: anEvent	"Ignored. Theoretically we should never get here since control is transferred to the halo on #mouseButton3Down: but subclasses may implement this differently."! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2011 17:06'!mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		editor ifNotNil: [ editor disregardNextMouseUp ].		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: event].	event hand		waitForSimulatedMouseButton2: self 		event: event		dblClkSel: #doubleClick:! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2011 16:51'!mouseMove: evt	| editEvt |	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].	self handleInteraction: [editor mouseMove: evt].	editEvt _ evt externalizedFromOwnerOf: self to: editView.	(editEvt position y between: editView top and: editView bottom) ifFalse: [		"Start auto-scrolling"		self startStepping: #autoScrollView:			at: Time millisecondClockValue			arguments: (Array with: editEvt)			stepTime: 100. "fast enough"	] ifTrue: [		self stopSteppingSelector: #autoScrollView:.	]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 2/22/2011 17:06'!mouseButton2Activity	^ editView mouseButton2Activity! !!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 2/22/2011 21:54'!containsPoint: aPoint event: anEvent	"mouseButton3 events are handled by the halo"	(anEvent isMouse and: [ anEvent isMouseDown and: [ anEvent mouseButton3Pressed ]])		ifFalse:  [^super containsPoint: aPoint event: anEvent ].	^self fullBounds containsPoint: anEvent position! !!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 2/22/2011 21:55'!handlerForMouseButton3Down: anEvent	"mouseButton3 (usually mouse wheel) was clicked within the receiver"	^self! !!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 2/22/2011 16:56'!mouseButton3Down: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset _ event position - (target externalizePositionFromOwner: target position to: owner).	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		clkSel: #transferHalo:		dblClkSel: nil		dblClkTimeoutSel: nil		dragSel: #dragTarget:! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 2/22/2011 16:58'!waitForClicksOrDrag: aMorph event: evt  clkSel: clkSel dblClkSel: dblClkSel dblClkTimeoutSel: dblClkTimeoutSel dragSel: dragSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: clkSel 			dblClick: dblClkSel			dblClickTime: DoubleClickTime 			dblClickTimeout: dblClkTimeoutSel			drag: dragSel			event: evt			sendMouseButton2Activity: false! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 2/22/2011 16:59'!waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel dblClkSel: dblClkSel dblClkTimeoutSel: dblClkTimeoutSel dragSel: dragSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: clkSel 			dblClick: dblClkSel			dblClickTime: DoubleClickTime 			dblClickTimeout: dblClkTimeoutSel			drag: dragSel			event: evt			sendMouseButton2Activity: true! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 2/22/2011 17:00'!waitForSimulatedMouseButton2: aMorph event: evt dblClkSel: dblClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: nil 			dblClick: dblClkSel			dblClickTime: DoubleClickTime 			dblClickTimeout: nil			drag: nil			event: evt			sendMouseButton2Activity: true! !!MagnifierMorph methodsFor: 'events' stamp: 'jmv 2/22/2011 17:01'!handlesMouseDown: evt	^evt mouseButton2Pressed		or: [super handlesMouseDown: evt]! !!MagnifierMorph methodsFor: 'events' stamp: 'jmv 2/22/2011 17:02'!mouseDown: evt	evt mouseButton2Pressed		ifTrue: [self chooseMagnification: evt]		ifFalse: [super mouseDown: evt]! !!MenuItemMorph methodsFor: 'events' stamp: 'jmv 2/22/2011 16:57'!handleMouseUp: anEvent	"The handling of control between menu item requires them to act on mouse up even if not the current focus. This is different from the default behavior which really only wants to handle mouse ups when they got mouse downs before"	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand releaseMouseFocus: self.	anEvent wasHandled: true.	anEvent mouseButton3Changed		ifTrue:[self mouseButton3Up: anEvent]		ifFalse:[self mouseUp: anEvent].! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 2/22/2011 21:52'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag distance |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt internalizedToOwnerOf: clickClient from: aHand owner.	distance _ (localEvt position - firstClickDown position) r.	isDrag _ distance > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag or sendMouseButton2Activity if requested"			clickState _ #firstClickTimedOut.			(sendMouseButton2Activity not and: [ dragSelector isNil ]) ifTrue: [				aHand resetClickState.				self doubleClickTimeout; click "***"].			^true].		localEvt isMouseUp ifTrue:[			(timedOut or: [ dblClickSelector isNil ]) ifTrue:[				self click.				aHand resetClickState.				^true ].			"Otherwise transfer to #firstClickUp"			firstClickUp _ evt copy.			clickState _ #firstClickUp.			"If timedOut or the client's not interested in dbl clicks get outta here"			self click.			aHand handleEvent: firstClickUp.			^false ].		isDrag ifTrue: [ "drag start"			self doubleClickTimeout. "***"			aHand resetClickState.			dragSelector "If no drag selector send #click instead"				ifNil: [ self click ]				ifNotNil: [ self drag: firstClickDown ].			^true ].		^false ].	clickState == #firstClickTimedOut ifTrue: [		localEvt isMouseUp ifTrue:[ "neither drag nor double click"			aHand resetClickState.			self doubleClickTimeout; click. "***"			^true ].		isDrag ifTrue: [ "drag start"			aHand resetClickState.			self doubleClickTimeout; drag: firstClickDown. "***"			^true ].		"Neither drag nor double click. Simulate mouseButton2 click. This is useful, for example, for pen computers"		(sendMouseButton2Activity and: [ distance = 0 ]) ifTrue: [			aHand resetClickState.			clickClient mouseButton2Activity.			^true ].		^false ].	clickState = #firstClickUp ifTrue:[		timedOut ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			aHand resetClickState.			self doubleClickTimeout. "***"			^true ].		localEvt isMouseDown ifTrue:[ "double click"			clickState _ #secondClickDown.			^false ]].	clickState == #secondClickDown ifTrue: [		localEvt isMouseUp ifTrue: ["double click"			aHand resetClickState.			self doubleClick.			^false ]	].	^true! !!MouseClickState methodsFor: 'initialize' stamp: 'jmv 2/22/2011 16:58'!client: aMorph click: aClickSelector dblClick: aDblClickSelector dblClickTime: timeOut dblClickTimeout: aDblClickTimeoutSelector drag: aDragSelector event: firstClickEvent sendMouseButton2Activity: aBoolean	clickClient _ aMorph.	clickSelector _ aClickSelector.	dblClickSelector _ aDblClickSelector.	dblClickTime _ timeOut.	dblClickTimeoutSelector _ aDblClickTimeoutSelector.	dragSelector _ aDragSelector.	dragThreshold _ 4.	firstClickDown _ firstClickEvent.	firstClickTime _ firstClickEvent timeStamp.	clickState _ #firstClickDown.	sendMouseButton2Activity _ aBoolean! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2011 16:51'!mouseMove: evt	evt mouseButton1Pressed ifFalse: [^ self].	self handleInteraction: [		editor mouseMove: evt index: (self characterIndexAtPoint: evt cursorPoint) ]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 21:52'!mouseButton2ClickOnDesktopWithEvent: evt 	"Put up the world menu when the user clicks on the morphic desktop with the mouseButton2 (usually right mouse button)."	| aMenu |	aMenu := self buildWorldMenu: evt.	aMenu addTitle: 'World' translated.	aMenu popUpInWorld: self! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 2/22/2011 17:05'!putUpWorldMenu: evt	"Put up a menu in response to a click on the desktop, triggered by evt."	| menu |	evt isMouse ifTrue: [		evt mouseButton2Pressed			ifTrue: [^ self mouseButton2ClickOnDesktopWithEvent: evt].		evt shiftPressed ifTrue:[^ self findWindow: evt]].	"put up screen menu"	menu _ self buildWorldMenu: evt.	menu addTitle: Preferences desktopMenuTitle translated.	menu popUpInWorld: self.	^ menu! !!Pen methodsFor: 'geometric designs' stamp: 'jmv 2/22/2011 17:02'!web   "Display restoreAfter: [Pen new web]"	"Draw pretty web-like patterns from the mouse movement on the screen.	Press the mouse button to draw, option-click to exit.	By Dan Ingalls and Mark Lentczner. "	| history newPoint ancientPoint lastPoint filter color |	"self erase."	color _ 1.	[ true ] whileTrue:		[ history _ OrderedCollection new.		Sensor waitButton.		Sensor mouseButton2Pressed ifTrue: [^ self].		filter _ lastPoint _ Sensor mousePoint.		20 timesRepeat: [ history addLast: lastPoint ].		self color: (color _ color + 1).		[ Sensor mouseButton1Pressed ] whileTrue: 			[ newPoint _ Sensor mousePoint.			(newPoint = lastPoint) ifFalse:				[ ancientPoint _ history removeFirst.				filter _ filter * 4 + newPoint // 5.				self place: filter.				self goto: ancientPoint.				lastPoint _ newPoint.				history addLast: filter ] ] ]! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2011 17:06'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	evt mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	(self containsPoint: evt cursorPoint) ifTrue: [		isPressed _ true.		self changed].	evt hand		waitForSimulatedMouseButton2: self		event: evt		dblClkSel: #doubleClick:! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 2/22/2011 17:06'!mouseButton2Activity	"Nothing to do right now..."! !!RecentMessageSet methodsFor: 'message functions' stamp: 'jmv 2/22/2011 17:13'!messageListMenu	"Answer the message-list menu"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addList:#(			('what to show...'						offerWhatToShowMenu)			-			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'								fileOutMessage)			('copy selector (c)'						copySelector)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'							methodHierarchy)			('versions (v)'							browseVersions)			-			('inst var refs...'							browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			('remove from RecentSubmissions'		removeFromRecentSubmissions)			-			('more...'								openExtraMenu)).	^ aMenu! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 2/22/2011 17:06'!mouseDown: evt	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue: [		scroller submorphs last mouseDown:			(evt internalizedTo: scroller from: self)].	evt hand 		waitForSimulatedMouseButton2: self 		event: evt		dblClkSel: #doubleClick:! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'jmv 2/22/2011 17:06'!mouseButton2Activity	"Invoke the text-editing menu"	self getMenu ifNotNil: [ :menu |		menu setInvokingView: self.		menu invokeModal]! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 2/22/2011 17:06'!mouseDown: evt	| row |	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: evt		clkSel: #click:		dblClkSel: (doubleClickSelector ifNotNil:[#doubleClick:])		dblClkTimeoutSel: nil		dragSel: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil])! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 2/22/2011 17:06'!specialKeyPressed: asciiValue	"A special key with the given ascii-value was pressed; dispatch it"	| oldSelection nextSelection max howManyItemsShowing |	asciiValue = 27 ifTrue: 		[" escape key"		^ ActiveEvent shiftPressed			ifFalse:				[self mouseButton2Activity]].	max _ self maximumSelection.	max > 0 ifFalse: [^ self].	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	asciiValue = 31 ifTrue: 		[" down arrow"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].	asciiValue = 30 ifTrue: 		[" up arrow"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].	asciiValue = 1 ifTrue:		[" home"		nextSelection _ 1].	asciiValue = 4 ifTrue:		[" end"		nextSelection _ max].	howManyItemsShowing _ self numSelectionsInView.	asciiValue = 11 ifTrue:		[" page up"		nextSelection _ 1 max: oldSelection - howManyItemsShowing].	asciiValue = 12 ifTrue:		[" page down"		nextSelection _ oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection = nextSelection ifTrue: [^ self "flash"	"ugly"].	^ self changeModelSelection: nextSelection! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 2/22/2011 17:06'!mouseDown: event	| oldIndex oldVal row |	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row := self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifTrue: ["No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForSimulatedMouseButton2: self		event: event		dblClkSel: #doubleClick:! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2011 17:07'!mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph internalizePositionToOwner: evt position from: self)])		ifTrue:[^self toggleExpandedState: aMorph event: evt]. 	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: evt 		clkSel: #click:		dblClkSel: nil		dblClkTimeoutSel: nil		dragSel:  (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil])! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'jmv 2/22/2011 17:02'!toggleExpandedState: aMorph event: event	| oldState |	"self setSelectedMorph: aMorph."	event mouseButton2Pressed ifTrue: [		oldState _ aMorph isExpanded.		scroller submorphs copy do: [ :each |			(each canExpand and: [each isExpanded = oldState]) ifTrue: [				each toggleExpandedState.			].		].	] ifFalse: [		aMorph toggleExpandedState.	].	self adjustSubmorphPositions.	! !!TextEditor methodsFor: 'events' stamp: 'jmv 2/22/2011 21:49'!mouseDown: evt 	| clickPoint b |	oldInterval _ self selectionInterval.	clickPoint _ evt cursorPoint.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint for: model) ifTrue: [		self markBlock: b.		self pointBlock: b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			self closeTypeIn.			self markBlock: b.			self pointBlock: b ]! !!TextEditor methodsFor: 'events' stamp: 'jmv 2/22/2011 21:49'!mouseUp: evt	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	oldInterval = self selectionInterval		ifTrue: [			evt shiftPressed				ifFalse: [					"Not a real double-click, but the second click in the same place, without shift.					Act as if double click (classic Squeak behavior)"					self selectWord ]				ifTrue: [					"Squeak classic behavior for click, move, shift-click sequence "					"self pointBlock: (paragraph characterBlockAtPoint: (evt cursorPoint))."					"Mac behavior"					cursorBlock _ paragraph characterBlockAtPoint: evt cursorPoint.					cursorIndex _ cursorBlock stringIndex.					startBlock _ self startBlock min: cursorBlock.					startIndex _ startBlock stringIndex.					stopBlock _ self stopBlock max: cursorBlock.					stopIndex _ stopBlock stringIndex.					(stopIndex - cursorIndex) < (cursorIndex - startIndex)						ifTrue: [							self markBlock: startBlock.							self pointBlock: cursorBlock ]						ifFalse: [							self markBlock: stopBlock.							self pointBlock: cursorBlock ]]].	self setEmphasisHereFromText.	(self isDisjointFrom: oldInterval) ifTrue: [		otherInterval _ oldInterval].	self storeSelectionInParagraph	"store selection , done in this method, (shift click) or perhaps in #mouseDown: (click)"! !!TextEditor methodsFor: 'menu commands' stamp: 'jmv 2/22/2011 17:18'!offerMenuFromEsc: aKeyboardEvent	"The escape key was hit while the receiver has the keyboard focus; take action"	^ ActiveEvent shiftPressed		ifFalse: [			self openMenu]! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 2/22/2011 17:18'!openMenu	(morph respondsTo: #editView)		ifTrue: [morph editView mouseButton2Activity].	^ true! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 2/22/2011 21:53'!initializeMenu	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."	"TextEditor initialize"	menu _ SelectionMenu fromArray: {		{'find...(f)' translated.					#find}.		{'find again (g)' translated.				#findAgain}.		{'set search string (h)' translated.		#setSearchString}.		#-.		{'do again (j)' translated.				#again}.		{'undo (z)' translated.					#undo}.		#-.		{'copy (c)' translated.					#copySelection}.		{'cut (x)' translated.					#cut}.		{'paste (v)' translated.					#paste}.		{'paste...' translated.					#pasteRecent}.		#-.		{'set font... (k)' translated.				#offerFontMenu}.		{'set alignment...' translated.			#chooseAlignment}.	}! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 2/22/2011 21:53'!initializeMenu	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	menu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.	#setSearchString}.		#-.		{'do again (j)' translated.			#again}.		{'undo (z)' translated.				#undo}.		#-.		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.				#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.				#pasteRecent}.		#-.		{'do it (d)' translated.				#doIt}.		{'print it (p)' translated.				#printIt}.		{'inspect it (i)' translated.			#inspectIt}.		{'explore it (I)' translated.			#exploreIt}.		{'debug it' translated.				#debugIt}.		#-.		{'explain' translated.					#explain}.		{'browse it (b)' translated.				#browseIt}.		{'senders of it (n)' translated.			#sendersOfIt}.		{'implementors of it (m)' translated.	#implementorsOfIt}.		{'references to it (N)' translated.		#referencesToIt}.		#-.		{'accept (s)' translated.				#accept}.		{'cancel (l)' translated.				#cancel}.		#-.		{'method strings with it (E)' translated.		#methodStringsContainingit}.		{'method source with it' translated.		#methodSourceContainingIt}.		{'class comments with it' translated.		#classCommentsContainingIt}.		{'change sets with it' translated.			#browseChangeSetsWithSelector}.	}! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 2/22/2011 21:50'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific."	self notifyWithLabel: 'Portability note:MorphicEvent>>macOptionKeyPressed is not portable.Please use MorphicEvent>>mouseButton2Pressed instead!!'.	^ self rawMacOptionKeyPressed! !!UserInputEvent methodsFor: 'printing' stamp: 'jmv 2/22/2011 17:03'!buttonString	"Return a string identifying the currently pressed buttons"	| string |	string _ ''.	self mouseButton1Pressed ifTrue: [ string _ string, 'mouseButton1 ' ].	self mouseButton2Pressed ifTrue: [ string _ string, 'mouseButton2 ' ].	self mouseButton3Pressed ifTrue: [ string _ string, 'mouseButton3 ' ].	^string! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/22/2011 16:49'!anyButtonPressed	"Answer true if any mouse button is being pressed."	^ buttons anyMask: InputSensor anyMouseButton! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/22/2011 22:07'!mouseButton1Pressed	"Answer true if the rmouseButton1 is being pressed.	This is the first mouse button, usually the one at the left."	^ buttons anyMask: InputSensor mouseButton1! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/22/2011 22:05'!mouseButton2Pressed	"Answer true if the mouseButton2 is being pressed.	This is usually the right mouse button or option+click on the Mac."	^ buttons anyMask: InputSensor mouseButton2! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/22/2011 22:09'!mouseButton3Pressed	"Answer true if the mouseButton3 is being pressed.	This is usually the center (wheel) mouse button or cmd+click on the Mac."	^ buttons anyMask: InputSensor mouseButton3! !!MouseButtonEvent methodsFor: 'accessing' stamp: 'jmv 2/22/2011 22:07'!mouseButton1Changed	"Answer true if the mouseButton1 has changed.	This is usually the left mouse button."	^ whichButton anyMask: InputSensor mouseButton1! !!MouseButtonEvent methodsFor: 'accessing' stamp: 'jmv 2/22/2011 22:05'!mouseButton2Changed	"Answer true if the mouseButton2 has changed.	This is the usually the right mouse button or option+click on the Mac."	^ whichButton anyMask: InputSensor mouseButton2! !!MouseButtonEvent methodsFor: 'accessing' stamp: 'jmv 2/22/2011 22:08'!mouseButton3Changed	"Answer true if the mouseButton3 has changed.	This is usually the center (wheel) mouse button or cmd+click on the Mac."	^ whichButton anyMask: InputSensor mouseButton3! !MouseButtonEvent removeSelector: #blueButtonChanged!MouseButtonEvent removeSelector: #redButtonChanged!MouseButtonEvent removeSelector: #yellowButtonChanged!MouseEvent removeSelector: #blueButtonPressed!MouseEvent removeSelector: #redButtonPressed!MouseEvent removeSelector: #yellowButtonPressed!TextEditor removeSelector: #raiseContextMenu:!ScrollPane removeSelector: #yellowButtonActivity!PluggableButtonMorph removeSelector: #yellowButtonActivity!PasteUpMorph removeSelector: #yellowButtonClickOnDesktopWithEvent:!MouseClickState removeSelector: #client:click:dblClick:dblClickTime:dblClickTimeout:drag:event:sendYellowButtonActivity:!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickState firstClickDown firstClickUp firstClickTime clickSelector dblClickSelector dblClickTime dblClickTimeoutSelector dragSelector dragThreshold sendMouseButton2Activity'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!HandMorph removeSelector: #waitForClicksOrDragOrSimulatedYellow:event:clkSel:dblClkSel:dblClkTimeoutSel:dragSel:!HandMorph removeSelector: #waitForClicksOrDragOrSimulatedYellowButton:event:clkSel:dblClkSel:dblClkTimeoutSel:dragSel:!HandMorph removeSelector: #waitForSimulatedYellow:event:dblClkSel:!HandMorph removeSelector: #waitForSimulatedYellowButton:event:dblClkSel:!HaloMorph removeSelector: #blueButtonDown:!HaloMorph removeSelector: #handlerForBlueButtonDown:!BareTextMorph removeSelector: #yellowButtonActivity!Morph removeSelector: #blueButtonDown:!Morph removeSelector: #blueButtonUp:!Morph removeSelector: #handlerForBlueButtonDown:!LightWidget removeSelector: #blueButtonDown:!LightWidget removeSelector: #blueButtonUp:!LightWidget removeSelector: #handlerForBlueButtonDown:!InputSensor class removeSelector: #anyButton!InputSensor class removeSelector: #blueButton!InputSensor class removeSelector: #redButton!InputSensor class removeSelector: #yellowButton!InputSensor removeSelector: #blueButtonPressed!InputSensor removeSelector: #redButtonPressed!InputSensor removeSelector: #yellowButtonPressed!CodeProvider removeSelector: #mouseButton2Activity!CodeProvider removeSelector: #shiftedYellowButtonActivity!CodeProvider removeSelector: #unshiftedYellowButtonActivity!