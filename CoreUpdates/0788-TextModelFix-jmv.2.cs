'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 28 January 2011 at 10:38:58 am'!!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 1/27/2011 16:28'!contentsAsIs: stringOrText	"Accept new text contents with line breaks only as in the text.	Fit my width and height to the result."	wrapFlag _ false.	model basicActualContents: stringOrText! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 1/27/2011 16:35'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change class s1 s2 differDesc diffWords |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])		ifTrue: [			s1 _ (class sourceCodeAt: change methodSelector) asString.			s2 _ change string.			s1 = s2				ifTrue: [^ self inform: 'Exact Match'].			diffWords _ self shouldDiffWords.			differDesc _ diffWords				ifTrue: [ 'Words']				ifFalse: [ 'Lines'].			(TextModel				withText: (					(DifferenceFinder						displayPatchFrom: s1 to: s2						tryWords: diffWords						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))							font: Preferences standardCodeFont))				openLabel: 'Comparison to Current Version: ', differDesc, 					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]		ifFalse: [self flash]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 1/27/2011 16:35'!assurePreambleExists	"Make sure there is a TextModel holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble actualContents isEmptyOrNil])		ifTrue: [preamble _ TextModel withText: self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 1/27/2011 16:35'!postscriptString: aString	postscript _ TextModel withText: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 1/27/2011 16:35'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	preamble _ TextModel withText: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 1/27/2011 16:35'!setPreambleToSay: aString	"Make aString become the preamble of this change set"	preamble _ TextModel withText: aString! !!Clipboard methodsFor: 'accessing' stamp: 'jmv 1/27/2011 16:35'!retrieveMorph	"Answer a Morph or nil."	| answer |		answer _ self retrieveObject.		"If clipboard contents is already a Text or String, answer it."	(answer is: #Morph) ifTrue: [		^ answer ].	"If clipboard contains a Form, prepare a Text including it."	(answer is: #Form) ifTrue: [		^ ImageMorph new image: answer ].	"If clipboard contents is already a Text or String, answer it."	(answer isString or: [ answer is: #Text ]) ifTrue: [		^ (TextModelMorph			withModel: (TextModel withText: answer asText))				embeddedInMorphicWindowLabeled: 'Text editor' ].		"No useful contents"	^nil! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 1/27/2011 16:35'!spyAllOn: aBlock	"Spy on all the processes in the system		[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]		"	| node result |	node _ self new.	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.	(TextModel withText: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 1/27/2011 16:35'!spyOn: aBlock reportOtherProcesses: aBoolean	"	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true	"	| node result |	node _ self new.	node reportOtherProcesses: aBoolean.	result _ node spyEvery: self defaultPollPeriod on: aBlock.	(TextModel withText: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 1/27/2011 16:35'!spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean	"	Spy on aProcess for a certain amount of time	| p1 p2 |  	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.	p1 resume.	p2 resume.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true	"	| node |	node _ self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	(TextModel withText: (String				streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 1/27/2011 16:35'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [ :current |			current == prev ifFalse: [ "call or return"				prev sender ifNotNil: [ "call only"					(receiver == nil or: [ current receiver == receiver ])						ifTrue: [ tallies tally: current by: 1 ]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(TextModel withText:		(String streamContents: [ :s |			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ]]))		openLabel: 'Spy Results' wrap: false! !!MethodNode methodsFor: 'converting' stamp: 'jmv 1/27/2011 16:35'!asColorizedSmalltalk80Text	"Answer a colorized Smalltalk-80-syntax string description of the parse tree whose root is the receiver."	| printText |	printText _ self printString asText.	^(Smalltalk at: #SHTextStylerST80 ifAbsent: nil)		ifNotNil: [ :stylerClass |			stylerClass new				textModel: (TextModel withText: printText);				formattedAndStyledText ]		ifNil: [ printText ]! !!SHTextStyler methodsFor: 'styling' stamp: 'jmv 1/27/2011 16:42'!formatAndStyle	"Do the styling on a copy of the model text.	After finishing, send it to the model, via #stylerStyled:checkForChanges:	The model should grab the TextAttributes we added to the copy, as appropriate."	self terminateBackgroundStylingProcess.	formattedText _ textModel actualContents.	self privateFormatAndConvert.	textModel basicActualContents: formattedText.	formattedText size < 4096		ifTrue: [			formattedText _ textModel actualContents copy.			textModel privateStyleWith: self.			textModel stylerStyled: formattedText checkForChanges: false ]		ifFalse: [ self styleInBackgroundProcess ].! !!TextModel methodsFor: 'accessing' stamp: 'jmv 1/27/2011 16:48'!actualContents: aTextOrString	actualContents _ aTextOrString ifNotNil: [ aTextOrString asText ].	self changed: #actualContents! !!TextModel methodsFor: 'accessing' stamp: 'jmv 1/27/2011 16:42'!basicActualContents: aTextOrString	"Do not throw events... Not nice... Use with care... Clean some day..."	actualContents _ aTextOrString ifNotNil: [ aTextOrString asText ]! !!TextModel methodsFor: 'accessing' stamp: 'jmv 1/27/2011 16:38'!contents: aTextOrString	"Does not update any view...	The kind of stuff that needs to be cleaned some day..."	self basicActualContents: aTextOrString! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 1/27/2011 17:18'!refetch	"Answer true if actualContents was actually fetched."	textGetter		ifNil: [			actualContents ifNil: [				self actualContents: Text new ].			^false ]		ifNotNil: [			self actualContents: (Text				initialFont: Preferences standardCodeFont				stringOrText: (textProvider perform: textGetter)).			self changed: #refetched.			^true ]! !!SyntaxError methodsFor: 'initialization' stamp: 'jmv 1/27/2011 16:37'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Smalltalk actualScannerClass classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,•£¢§¶ªº–—“‘”’…ÚæÚ¯˘¿«»`~`' asSet.	badChar := aString detect: [:aChar | (types at: aChar asciiValue ifAbsent: [#xLetter]) == #xBinary and: [			(printables includes: aChar) not]] ifNone: nil.	self basicActualContents: (badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString]).	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!TextModel class methodsFor: 'instance creation' stamp: 'jmv 1/27/2011 16:36'!withText: aTextOrString	^self new basicActualContents: aTextOrString! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 1/27/2011 17:19'!model: aTextModel	editorClass _ aTextModel editorClass.	super model: aTextModel.	styler ifNotNil: [ styler textModel: model ].	textMorph		model: model wrappedTo: self viewableWidth.	model refetch! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 1/27/2011 17:19'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 1/27/2011 17:19'!cancel	model refetch! !!TextModelMorph methodsFor: 'transcript' stamp: 'jmv 1/27/2011 16:39'!changeText: aText	"The paragraph to be edited is changed to aText.	Ugly. We call the method that won't throw events..."	model basicActualContents: aText! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 1/27/2011 17:20'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents 		ifTrue: [			"Some day, it would be nice to keep objects and update them			instead of throwing them away all the time for no good reason..."			textMorph releaseParagraph.			self formatAndStyleIfNeeded.			^self].	aSymbol == #acceptedContents ifTrue: [		model refetch.		^self].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self].	aSymbol == #initialSelection 		ifTrue: [^self setSelection: model getSelection].	aSymbol == #autoSelect 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: model autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			textMorph releaseParagraph.			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ].	aSymbol == #shoutStyle		ifTrue: [			self stylerStyled.			^self changed ].! !!Transcripter methodsFor: 'initialization' stamp: 'jmv 1/27/2011 16:36'!initInFrame: rect	frame _ rect insetBy: 2.  "Leave room for border"	para _ Paragraph new.	para		model: (TextModel withText: self contents asText)		in: ((frame insetBy: 4) withHeight: 9999)! !!Transcripter methodsFor: 'accessing' stamp: 'jmv 1/27/2011 16:36'!endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue: [		"Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para		model: (TextModel withText: c asText)		in: ((frame insetBy: 4) withHeight: 9999).	para positionWhenComposed: 0@0.	d _ para extent y - frame height.	d > 0 ifTrue: [		"Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint:			para compositionRectangle topLeft + (0@(d+StrikeFont default height)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	Display getCanvas		paragraph: para 		bounds: (0@0 extent: Display extent) 		color: Color black! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 1/27/2011 16:36'!initializeCommonRequestStrings	"Initialize the common request strings, a directly-editable list of expressions that can be evaluated from the 'do...' menu."	CommonRequestStrings _ TextModel withText: 'Utilities saveScreenshot.Utilities saveDisplay.Cursor normal show.Transcript clear.-Undeclared inspect.Undeclared removeUnreferencedKeys; inspect.-ChangeSorter removeEmptyUnnamedChangeSets.ChangeSorter reorderChangeSets.'"Utilities initializeCommonRequestStrings"! !