'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 26 September 2011 at 6:08:06 pm'!!classDefinition: #EventHandler category: #'Morphic-Events'!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseMoveRecipient mouseMoveSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient doubleClickTimeoutSelector doubleClickTimeoutRecipient clickSelector clickRecipient '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickState firstClickDown firstClickUp firstClickTime clickSelector dblClickSelector dblClickTime dblClickTimeoutSelector dragSelector dragThreshold sendMouseButton2Activity lastClickTimestamp clickCount clickDone doubleClickDone buttonDownCount '	classVariableNames: 'DoubleClickTimeout '	poolDictionaries: ''	category: 'Morphic-Kernel'!!MouseClickState commentStamp: '<historical>' prior: 0!MouseClickState is a simple class managing the distinction between clicks, double clicks, and drag operations. It has been factored out of HandMorph due to the many instVars.Instance variables:	clickClient 			<Morph>			The client wishing to receive #click:, #dblClick:, or #drag messages	clickState 			<Symbol>			The internal state of handling the last event (#firstClickDown, #firstClickUp, #firstClickTimedOut)	firstClickDown 		<MorphicEvent>	The #mouseDown event after which the client wished to receive #click: or similar messages	clickSelector 		<Symbol>			The selector to use for sending #click: messages	dblClickSelector 	<Symbol>			The selector to use for sending #doubleClick: messages	dragSelector 		<Symbol>			The selector to use for sending #drag: messages	dragThreshold 		<Integer>			Threshold used for determining if a #drag: message is sent (pixels!!)!!EventHandler methodsFor: 'initialization' stamp: 'jmv 9/26/2011 15:38'!on: eventName send: selector to: recipient	eventName == #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName == #mouseMove ifTrue:		[mouseMoveRecipient _ recipient.  mouseMoveSelector _ selector. ^ self].	eventName == #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName == #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName == #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName == #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName == #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName == #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName == #click ifTrue:		[clickRecipient _ recipient. clickSelector _ selector. ^ self].	eventName == #doubleClick ifTrue:		[doubleClickRecipient _ recipient. doubleClickSelector _ selector. ^ self].	eventName == #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	eventName == #gesture ifTrue:		[ ^self onGestureSend: selector to: recipient ].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!LightWidget methodsFor: 'meta actions' stamp: 'jmv 9/26/2011 15:40'!mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: (anEvent externalizedFromOwnerOf: self to: nil).	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent externalizedFromOwnerOf: self to: nil)		clkSel: nil		dblClkSel: nil		dragSel: #dragTarget:.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 9/26/2011 15:41'!mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: (anEvent externalizedFromOwnerOf: self to: nil).	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent externalizedFromOwnerOf: self to: nil)		clkSel: nil		dblClkSel: nil		dragSel: #dragTarget:.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 9/26/2011 15:40'!mouseButton3Down: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset _ event position - (target externalizePositionFromOwner: target position to: owner).	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		clkSel: #transferHalo:		dblClkSel: nil		dragSel: #dragTarget:! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/26/2011 16:54'!resetClickState	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	mouseClickState _ nil.! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/26/2011 15:40'!waitForClicksOrDrag: aMorph event: evt	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 		^self 		waitForClicksOrDrag: aMorph 		event: evt 		clkSel: #click:		dblClkSel: #doubleClick:		dragSel: #startDrag:! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/26/2011 15:53'!waitForClicksOrDrag: aMorph event: evt  clkSel: clkSel dblClkSel: dblClkSel dragSel: dragSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: clkSel 			dblClick: dblClkSel			drag: dragSel			event: evt			sendMouseButton2Activity: false! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/26/2011 15:53'!waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel dblClkSel: dblClkSel dragSel: dragSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: clkSel 			dblClick: dblClkSel			drag: dragSel			event: evt			sendMouseButton2Activity: true! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 9/26/2011 15:53'!waitForSimulatedMouseButton2: aMorph event: evt dblClkSel: dblClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _ 		MouseClickState new			client: aMorph 			click: nil 			dblClick: dblClkSel			drag: nil			event: evt			sendMouseButton2Activity: true! !!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 9/26/2011 17:13'!keyStroke: evt 	| matchString char asc selectable help |	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withCRs.	help popUpForHand: self activeHand.	char := evt keyCharacter.	asc := char asciiValue.	char = Character cr 		ifTrue: 			[selectedItem ifNotNil: 					[selectedItem hasSubMenu 						ifTrue: 							[evt hand newMouseFocus: selectedItem subMenu.							^evt hand newKeyboardFocus: selectedItem subMenu]						ifFalse: 							["self delete."							^selectedItem invokeWithEvent: evt]].			(selectable := self items) size = 1 				ifTrue: [^selectable first invokeWithEvent: evt].			^self].	asc = 27 		ifTrue: 			["escape key"			self valueOfProperty: #matchString				ifPresentDo: 					[:str | 					str isEmpty 						ifFalse: 							["If filtered, first ESC removes filter"							self setProperty: #matchString toValue: String new.							self selectItem: nil event: evt.							^self displayFiltered: evt]].			"If a stand-alone menu, just delete it"			popUpOwner ifNil: [^self delete].			"If a sub-menu, then deselect, and return focus to outer menu"			self selectItem: nil event: evt.			evt hand newMouseFocus: popUpOwner owner.			^evt hand newKeyboardFocus: popUpOwner owner].	(asc = 28 or: [asc = 29]) 		ifTrue: 			["left or right arrow key"			(selectedItem notNil and: [selectedItem hasSubMenu]) 				ifTrue: 					[evt hand newMouseFocus: selectedItem subMenu.					selectedItem subMenu moveSelectionDown: 1 event: evt.					^evt hand newKeyboardFocus: selectedItem subMenu]].	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: evt].	"up arrow key"	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: evt].	"down arrow key"	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: evt].	"page up key"	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: evt].	"page down key"	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].	matchString := char = Character backspace 				ifTrue: 					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]				ifFalse: [matchString copyWith: evt keyCharacter].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt.	help _ HoverHelpMorph contents: 'Enter text to\narrow selection down\to matching items ' withCRs.	help popUpForHand: self activeHand.! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 9/26/2011 17:04'!afterFirstClickDownHandleEvent: evt from: aHand	| localEvt timedOut isDrag distance |	timedOut _ (evt timeStamp - firstClickDown timeStamp) > DoubleClickTimeout.		evt isMouseUp ifTrue: [		"If timedOut or the client's not interested in dbl clicks get outta here"		(timedOut or: [ dblClickSelector isNil ]) ifTrue: [			self click.			aHand resetClickState.			^true ].		"Otherwise transfer to #firstClickUp"		clickState _ #firstClickUp.		self click.		aHand handleEvent: evt copy.		^false ].	"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"	timedOut ifTrue: [		"timeout before #mouseUp -> keep waiting for drag or sendMouseButton2Activity if requested"		clickState _ #firstClickTimedOut.		(sendMouseButton2Activity not and: [ dragSelector isNil ]) ifTrue: [			aHand resetClickState.			self click ].		^true].	localEvt _ evt internalizedToOwnerOf: clickClient from: aHand owner.	distance _ (localEvt position - firstClickDown position) r.	isDrag _ distance > dragThreshold.	isDrag ifTrue: [ "drag start"		aHand resetClickState.		dragSelector "If no drag selector send #click instead"			ifNil: [ self click ]			ifNotNil: [ self drag: firstClickDown ].		^true ].	^false! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 9/26/2011 17:09'!afterFirstClickTimedOutHandleEvent: evt from: aHand	| localEvt isDrag distance |	evt isMouseUp ifTrue:[ "neither drag nor double click"		aHand resetClickState.		self click.		^true ].	localEvt _ evt internalizedToOwnerOf: clickClient from: aHand owner.	distance _ (localEvt position - firstClickDown position) r.	isDrag _ distance > dragThreshold.	isDrag ifTrue: [ "drag start"		aHand resetClickState.		self drag: firstClickDown.		^true ].	"Neither drag nor double click. Simulate mouseButton2 click.	This is useful, for example, for pen computers"	(sendMouseButton2Activity and: [ distance = 0 ]) ifTrue: [		aHand resetClickState.		clickClient mouseButton2Activity.		^true ].	^false! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 9/26/2011 17:02'!afterFirstClickUpOutHandleEvent: evt from: aHand	| timedOut |	timedOut _ (evt timeStamp - firstClickDown timeStamp) > DoubleClickTimeout.	timedOut ifTrue: [		"timed out after mouseUp - send #click: and mouseUp"		aHand resetClickState.		^true ].	evt isMouseDown ifTrue:[ "double click"		clickState _ #secondClickDown.		^false ].	^ true! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 9/26/2011 17:02'!afterSecondClickDownHandleEvent: evt from: aHand	evt isMouseUp ifTrue: [ "double click"		aHand resetClickState.		self doubleClick.		^false ].	^ true! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 9/26/2011 18:07'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| timedOut distance isDrag localEvt |	timedOut _ (evt timeStamp - firstClickDown timeStamp) > DoubleClickTimeout."timedOut print.(evt timeStamp - lastClickTimestamp) print.	"	localEvt _ evt internalizedToOwnerOf: clickClient from: aHand owner.	distance _ (localEvt position - firstClickDown position) r.	isDrag _ distance > dragThreshold.	evt isMouseDown ifTrue: [		buttonDownCount _ buttonDownCount + 1  ].	evt isMouseUp ifTrue: [		clickCount _ clickCount + 1.		clickCount print.		lastClickTimestamp _ evt timeStamp ]. 	true ifTrue: [	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."	(buttonDownCount = 1 and: [clickCount = 0]) ifTrue: [		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [			aHand resetClickState.			clickClient mouseButton2Activity.			^true ]].	"Simple click."	clickCount = 1 ifTrue: [		self click.		"If timedOut or the client's not interested in dbl clicks get outta here"		(timedOut or: [ dblClickSelector isNil ]) ifTrue: [			aHand resetClickState.			^true ].		"This means: if a mouseDown, then don't further process this event (so we can turn it into double click)"		^ evt isMouseDown not ].	"Double click."	clickCount = 2 ifTrue: [		self doubleClick.		"If timedOut or the client's not interested intriple clicks get outta here"		(timedOut "or: [ tripleClickSelector isNil ]") ifTrue: [			aHand resetClickState.			^true ].		"This means: if a mouseDown, then don't further process this event (so we can turn it into triple click)"		^ evt isMouseDown not ].		clickCount = 3 ifTrue: [		aHand resetClickState.		self tripleClick.		^true	].	{isDrag}.] ifFalse: [			clickState == #firstClickDown ifTrue: [		^self afterFirstClickDownHandleEvent: evt from: aHand].	clickState == #firstClickTimedOut ifTrue: [		^ self afterFirstClickTimedOutHandleEvent: evt from: aHand ].	clickState == #firstClickUp ifTrue:[		^self afterFirstClickUpOutHandleEvent: evt from: aHand].	clickState == #secondClickDown ifTrue: [		^self afterSecondClickDownHandleEvent: evt from: aHand].].	^true! !!MouseClickState methodsFor: 'initialize' stamp: 'jmv 9/26/2011 18:01'!client: aMorph click: aClickSelector dblClick: aDblClickSelector drag: aDragSelector event: firstClickEvent sendMouseButton2Activity: aBoolean'' print.'empezamos!!' print.	clickClient _ aMorph.	clickSelector _ aClickSelector.	dblClickSelector _ aDblClickSelector.	dragSelector _ aDragSelector.	dragThreshold _ 4.	firstClickDown _ firstClickEvent.	clickState _ #firstClickDown.	sendMouseButton2Activity _ aBoolean.	buttonDownCount _ 1.	clickCount _ 0.	lastClickTimestamp _ firstClickEvent timeStamp.	clickDone _ false.	doubleClickDone _ false! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/26/2011 16:53'!click	clickDone ifFalse: [		'click' print.		clickSelector ifNotNil: [			clickClient perform: clickSelector with: firstClickDown ].		clickDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/26/2011 17:59'!doubleClick	doubleClickDone ifFalse: [		'doubleClick' print.		dblClickSelector ifNotNil: [			clickClient perform: dblClickSelector with: firstClickDown ].		doubleClickDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/26/2011 16:01'!drag: event	dragSelector ifNotNil: [		clickClient perform: dragSelector with: event]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 9/26/2011 18:01'!tripleClick	'tripleClick' print."	dblClickSelector ifNotNil: [		clickClient perform: dblClickSelector with: firstClickDown ]"! !!MouseClickState class methodsFor: 'class initialization' stamp: 'jmv 9/26/2011 17:53'!initialize	"	MouseClickState initialize	"	DoubleClickTimeout _ 500! !!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 9/26/2011 15:41'!mouseDown: event	"Handle a mouse down event."	| grabbedMorph |	grabbedMorph _ self morphToGrab: event.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		^event hand grabMorph: grabbedMorph].	event mouseButton2Pressed ifTrue: [^self mouseButton2Activity].	super mouseDown: event.	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: event		clkSel: #click:		dblClkSel: #doubleClick:		dragSel: nil! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/26/2011 15:41'!mouseDown: evt	| row |	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: evt		clkSel: #click:		dblClkSel: (doubleClickSelector ifNotNil:[#doubleClick:])		dragSel: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil])! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 9/26/2011 15:41'!mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph internalizePositionToOwner: evt position from: self)])		ifTrue:[^self toggleExpandedState: aMorph event: evt]. 	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: evt 		clkSel: #click:		dblClkSel: nil		dragSel:  (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil])! !MouseClickState initialize!MouseClickState removeSelector: #client:click:dblClick:dblClickTime:dblClickTimeout:drag:event:sendMouseButton2Activity:!MouseClickState removeSelector: #doubleClickTimeout!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickState firstClickDown clickSelector dblClickSelector dragSelector dragThreshold sendMouseButton2Activity buttonDownCount clickCount lastClickTimestamp clickDone doubleClickDone'	classVariableNames: 'DoubleClickTimeout'	poolDictionaries: ''	category: 'Morphic-Kernel'!HandMorph removeSelector: #waitForClicksOrDrag:event:clkSel:dblClkSel:dblClkTimeoutSel:dragSel:!HandMorph removeSelector: #waitForClicksOrDragOrSimulatedMouseButton2:event:clkSel:dblClkSel:dblClkTimeoutSel:dragSel:!Morph removeSelector: #doubleClickTimeout:!EventHandler removeSelector: #doubleClickTimeout:fromMorph:!!classDefinition: #EventHandler category: #'Morphic-Events'!Object subclass: #EventHandler	instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseMoveRecipient mouseMoveSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient clickSelector clickRecipient'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Events'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."ActiveHand resetClickState!