'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 3 October 2011 at 9:24:27 am'!!Color methodsFor: 'conversions' stamp: 'jmv 10/3/2011 09:13'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.	Note that 		Color transparent class = TranslucentColor	this special case is handled in TranslucentColor >> #pixelValueForDepth:	"	| bitBltFakeBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits set to all ones (opaque alpha)"		val := LargePositiveInteger new: 4.		val at: 3 put: ((rgb bitShift: -22) bitAnd: 16rFF).		val at: 2 put: ((rgb bitShift: -12) bitAnd: 16rFF).		val at: 1 put: ((rgb bitShift: -2) bitAnd: 16rFF).		val at: 4 put: 16rFF.  "opaque alpha"		^ val normalize].	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val := (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val := (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val := (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color class methodsFor: 'instance creation' stamp: 'jmv 10/3/2011 09:24'!colorFromPixelValue: p depth: d	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha).	The real rule is that pixelValue=0 means transparent.	And that darkest blue must be used instead of black, but only for depths >8 and < 32 (no indexed colors, no alpha)	This method is updated to reflect that."	| r g b alpha |	d = 8 ifTrue: [^ IndexedColors at: (p bitAnd: 16rFF) + 1].	d = 4 ifTrue: [^ IndexedColors at: (p bitAnd: 16r0F) + 1].	d = 2 ifTrue: [^ IndexedColors at: (p bitAnd: 16r03) + 1].	d = 1 ifTrue: [^ IndexedColors at: (p bitAnd: 16r01) + 1].	d = 32 ifTrue: [		"eight bits per component; 8 bits of alpha"		alpha _ p bitShift: -24.		alpha = 0 ifTrue: [ ^Color transparent ].		r _ (p bitShift: -16) bitAnd: 16rFF.		g _ (p bitShift: -8) bitAnd: 16rFF.		b _ p bitAnd: 16rFF.		^alpha < 255			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]			ifFalse: [ Color r: r g: g b: b range: 255 ]].	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."	p = 0 ifTrue: [ ^Color transparent ].	(d = 16) | (d = 15) ifTrue: [		"five bits per component"		r _ (p bitShift: -10) bitAnd: 16r1F.		g _ (p bitShift: -5) bitAnd: 16r1F.		b _ p bitAnd: 16r1F.		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [			^Color black ].		^ Color r: r g: g b: b range: 31].	d = 12 ifTrue: [		"four bits per component"		r _ (p bitShift: -8) bitAnd: 16rF.		g _ (p bitShift: -4) bitAnd: 16rF.		b _ p bitAnd: 16rF.		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [			^Color black ].		^ Color r: r g: g b: b range: 15].	d = 9 ifTrue: [		"three bits per component"		r _ (p bitShift: -6) bitAnd: 16r7.		g _ (p bitShift: -3) bitAnd: 16r7.		b _ p bitAnd: 16r7.		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [			^Color black ].		^ Color r: r g: g b: b range: 7].	self error: 'unknown pixel depth: ', d printString! !!Form methodsFor: 'pixel access' stamp: 'jmv 10/3/2011 09:18'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	| p d |	d _ self depth.	"no transparency at depth 1"	d = 1 ifTrue: [^ false].		"Check inside the palette"	d <= 8 ifTrue: [ 		^(self colorAt: aPoint) isTransparent ].	p _ self pixelValueAt: aPoint.	"32bpp, rgba. Pixels with alpha = 0 are transparent"	d = 32 ifTrue: [		^(p anyMask: 16rFF000000) not ].	"pixel pattern 0 is transparent for RGB"	^p = 0! !!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 10/3/2011 09:12'!pixelValueForDepth: d	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	| basicPixelWord |	"In 32bpp, if alpha = 0, ignore any color components, and answer R=0, G=0, B=0, Alpha=0.	In depths > 8 and < 32, pixelValue zero is the special value used by BitBlt to denote transparent."	alpha = 0 ifTrue: [^ 0].	basicPixelWord _ super pixelValueForDepth: d.	d < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !