'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 5 December 2010 at 11:12:22 pm'!!classDefinition: #PluggableTextModel category: #'System-Text'!TextModel subclass: #PluggableTextModel	instanceVariableNames: 'textProvider getTextSelector setTextSelector selectionGetter textSetter textGetter '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #TextModelMorph category: #'Morphic-Windows'!ScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph getTextSelector setTextSelector getSelectionSelector hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval hasEditingConflicts editorClass styler '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ObjectExplorer methodsFor: 'accessing' stamp: 'jmv 12/5/2010 23:10'!explorerFor: anObject 	| window listMorph |	rootObject := anObject.	window := (SystemWindow labelled: (rootObject printStringLimitedTo: 64)) model: self.	window		addMorph: (listMorph := SimpleHierarchicalListMorph 			model: self			listGetter: #getList			indexGetter: #getCurrentSelection			indexSetter: #noteNewSelection:			menuGetter: #genericMenu:			keystrokeAction: #explorerKey:from:)		frame: (0 @ 0 corner: 1 @ 0.8).	window 		addMorph: ((TextModelMorph textProvider: self)			askBeforeDiscardingEdits: false)		frame: (0 @ 0.8 corner: 1 @ 1).	listMorph autoDeselect: false.	^ window! !!ProcessBrowser methodsFor: 'views' stamp: 'jmv 12/5/2010 23:10'!asPrototypeInWindow	"Create a pluggable version of me, answer a window"	| window aTextMorph |	window _ SystemWindow new model: self.	window		addMorph: ((PluggableListMorph				model: self				listGetter: #processNameList				indexGetter: #processListIndex				indexSetter: #processListIndex:				menuGetter: #processListMenu:				keystrokeAction: #processListKey:from:)				enableDragNDrop: false)		frame: (0 @ 0 extent: 0.5 @ 0.5).	window		addMorph: ((PluggableListMorph				model: self				listGetter: #stackNameList				indexGetter: #stackListIndex				indexSetter: #stackListIndex:				menuGetter: #stackListMenu:				keystrokeAction: #stackListKey:from:)				enableDragNDrop: false)		frame: (0.5 @ 0.0 extent: 0.5 @ 0.5).	aTextMorph _ TextModelMorph				textProvider: self				textGetter: #selectedMethod.	window		addMorph: aTextMorph		frame: (0 @ 0.5 corner: 1 @ 1).	window setLabel: 'Process Browser'.	^ window! !!ProcessBrowser methodsFor: 'views' stamp: 'jmv 12/5/2010 23:10'!openAsMorph	"Create a pluggable version of me, answer a window"	| window aTextMorph |	window _ SystemWindow new				model: self.	deferredMessageRecipient _ WorldState.	window		addMorph: ((PluggableListMorph				model: self				listGetter: #processNameList				indexGetter: #processListIndex				indexSetter: #processListIndex:				menuGetter: #processListMenu:				keystrokeAction: #processListKey:from:)				enableDragNDrop: false)		frame: (0 @ 0 extent: 0.5 @ 0.5).	window		addMorph: ((PluggableListMorph				model: self				listGetter: #stackNameList				indexGetter: #stackListIndex				indexSetter: #stackListIndex:				menuGetter: #stackListMenu:				keystrokeAction: #stackListKey:from:)				enableDragNDrop: false)		frame: (0.5 @ 0.0 extent: 0.5 @ 0.5).	aTextMorph _ TextModelMorph				textProvider: self				textGetter: #selectedMethod.	aTextMorph askBeforeDiscardingEdits: false.	window		addMorph: aTextMorph		frame: (0 @ 0.5 corner: 1 @ 1).	window setUpdatablePanesFrom: #(#processNameList #stackNameList ).	(window setLabel: 'Process Browser') openInWorld.	startedCPUWatcher ifTrue: [ self setUpdateCallbackAfter: 7 ].	^ window! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 12/5/2010 23:10'!buildDetailsText	detailsText _ TextModelMorph		textProvider: self		textGetter: #details.	detailsText hideScrollBarsIndefinitely.	^detailsText! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 12/5/2010 23:11'!buildPassFailText	passFailText _ TextModelMorph		textProvider: self		textGetter: #passFail.	passFailText hideScrollBarsIndefinitely.	^ passFailText! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 12/5/2010 23:05'!openInMorphicWindowLabeled: labelString wrap: aBoolean	| window |	window _ (SystemWindow labelled: labelString) model: self.	window		addMorph: ((TextModelMorph textModel: self)			wrapFlag: aBoolean)		frame: (0@0 corner: 1@1).	^ window openInWorld! !!TextModel methodsFor: 'misc' stamp: 'jmv 12/5/2010 22:28'!getSelection	"Answer the model's selection interval."	^ 1 to: 0	"null selection"! !!TextModel methodsFor: 'testing' stamp: 'jmv 12/5/2010 21:02'!wantsFrameAdornments	^false! !!TextModel methodsFor: 'commands' stamp: 'jmv 12/5/2010 22:16'!acceptFrom: aTextModelMorph	"Nothing to do here.	Anyway, maybe this implementor should be removed..."! !!PluggableTextModel methodsFor: 'accessing' stamp: 'jmv 12/5/2010 22:32'!textGetter: symbol1 textSetter: symbol2 selectionGetter: symbol3	textGetter _ symbol1.	textSetter _ symbol2.	selectionGetter _ symbol3! !!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 12/5/2010 21:04'!is: aSymbol	^ aSymbol == #hasTextProvider or: [ super is: aSymbol ]! !!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 12/5/2010 22:20'!wantsFrameAdornments	(textProvider is: #CodeProvider) ifFalse: [ ^false ].	^ (#(annotation searchString infoViewContents) includes: textGetter) not! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 12/5/2010 22:54'!autoSelectString	^textProvider autoSelectString! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 12/5/2010 22:29'!getSelection	"Answer the model's selection interval."	selectionGetter ifNil: [ ^ 1 to: 0 ].	"null selection"	^ textProvider perform: selectionGetter! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 12/5/2010 22:21'!refetch	actualContents _ textGetter		ifNil: [ Text new ]		ifNotNil: [			Text				initialFont: Preferences standardCodeFont				stringOrText: (textProvider perform: textGetter) ]! !!PluggableTextModel methodsFor: 'updating' stamp: 'jmv 12/5/2010 22:26'!update: aSymbol	"We are being notified of a change in our provider.	Notify our dependents"	"	self changed: aSymbol	"	aSymbol == textGetter ifTrue: [ ^self changed: #acceptedContents ].	aSymbol == selectionGetter ifTrue: [ ^self changed: #initialSelection ].	self changed: aSymbol! !!PluggableTextModel methodsFor: 'commands' stamp: 'jmv 12/5/2010 22:22'!acceptFrom: aTextModelMorph	textSetter ifNil: [ ^ true ].	^ textSetter numArgs = 2		ifTrue: [			textProvider				perform: textSetter				with: actualContents				with: aTextModelMorph ]		ifFalse: [			textProvider				perform: textSetter				with: actualContents ].! !!PluggableTextModel methodsFor: '*Shout-Styling' stamp: 'jmv 12/5/2010 22:56'!shoutAboutToStyle: aSHTextStyler	"This is a notification that aSHTextStyler is about to re-style its text.	Set the classOrMetaClass in aSHTextStyler, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	^textProvider shoutAboutToStyle: aSHTextStyler! !!SyntaxError class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 23:05'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph 			model: aSyntaxError 			listGetter: #list			indexGetter: #listIndex 			indexSetter: nil 			menuGetter: #listMenu:)		frame: (0@0 corner: 1@0.15).	window		addMorph: (TextModelMorph textModel: aSyntaxError)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 12/5/2010 21:03'!wantsFrameAdornments	^model wantsFrameAdornments! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 12/5/2010 22:38'!textModel: aTextModel	editorClass _ aTextModel editorClass.	self model: aTextModel.	model refetch.	self maybeStyle.		self setSelection: model getSelection! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 12/5/2010 22:15'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true 		ifTrue: [			model refetch.			self maybeStyle.			self hasUnacceptedEdits: false ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 12/5/2010 22:29'!cancel	model refetch.	self maybeStyle.	self setSelection: model getSelection! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 12/5/2010 22:48'!promptForCancel	"Ask if it is OK to cancel changes to text"	(self confirm:'Changes have not been saved.Is it OK to cancel those changes?' translated)		ifTrue: [ model clearUserEditFlag ]! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 12/5/2010 22:54'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #acceptedContents 		ifTrue: [			model refetch.			self maybeStyle.			"Some day, it would be nice to keep objects and update them			instead of throwing them away all the time for no good reason..."			textMorph releaseParagraph.			^self setSelection: model getSelection].	aSymbol == #initialSelection 		ifTrue: [^self setSelection: model getSelection].	aSymbol == #autoSelect 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: model autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ]! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 12/5/2010 22:56'!okToStyle	styler ifNil: [ ^false ].	^model shoutAboutToStyle: styler! !!BrowserCommentTextMorph methodsFor: 'displaying' stamp: 'jmv 12/5/2010 22:46'!hideOrShowPane	(model textProvider editSelection == #editClass)		ifTrue: [ self showPane ]		ifFalse: [ self hidePane ]! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 22:40'!textModel: aTextModel	|  answer styler |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ aTextModel respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer textModel: aTextModel.	^answer! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 23:11'!textProvider: aTextProvider	^ self		textProvider: aTextProvider		textGetter: nil		textSetter: nil		selectionGetter: nil! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 23:11'!textProvider: aTextProvider textGetter: getTextSel	^ self		textProvider: aTextProvider		textGetter: getTextSel		textSetter: nil		selectionGetter: nil! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 23:02'!textProvider: aTextProvider textGetter: getTextSel textSetter: setTextSel	^ self		textProvider: aTextProvider		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 23:12'!textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| styler newModel answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ aTextProvider respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer textModel: newModel.	^answer! !!BrowserCommentTextMorph class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 22:38'!textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| newModel answer |	answer _ self new.	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer textModel: newModel.	^answer! !!TextProvider methodsFor: 'user edits' stamp: 'jmv 12/5/2010 22:52'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 12/5/2010 23:02'!addOptionalAnnotationsTo: window at: fractions plus: verticalOffset	"Add an annotation pane to the window if preferences indicate a desire for it, and return the incoming verticalOffset plus the height of the added pane, if any"	| aTextMorph divider delta |	self wantsAnnotationPane ifFalse: [^ verticalOffset].	aTextMorph _ TextModelMorph		textProvider: self		textGetter: #annotation.	aTextMorph		askBeforeDiscardingEdits: false;		borderWidth: 0;		hideScrollBarsIndefinitely.	divider _ BorderedSubpaneDividerMorph forBottomEdge.	delta _ self defaultAnnotationPaneHeight.	window 		addMorph: aTextMorph 		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!Browser methodsFor: 'class comment pane' stamp: 'jmv 12/5/2010 23:01'!buildMorphicCommentPane	"Construct the pane that shows the class comment.	Respect the Preference for standardCodeFont."	| commentPane |	commentPane := BrowserCommentTextMorph				textProvider: self				textGetter: #classCommentText				textSetter: #newClassComment:.	commentPane styler: nil.	^ commentPane! !!Browser methodsFor: 'class comment pane' stamp: 'jmv 12/5/2010 22:07'!newClassComment: aText	"The user has just entered aText.	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."	| theClass cleanedText redRange |	theClass _ self selectedClassOrMetaClass.	theClass ifNotNil: [		cleanedText _ aText asText.		redRange _ cleanedText			rangeOf: TextColor red			startingAt: 1.		redRange size = cleanedText size ifTrue: [			cleanedText				removeAttribute: TextColor red				from: 1				to: redRange last ].		theClass classComment: aText ].	self changed: #classCommentText.	^ true! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/5/2010 23:02'!buildMorphicCodePaneWith: editString	| codePane |	codePane _ TextModelMorph		textProvider: self		textGetter: #acceptedContents.	editString ifNotNil: [		codePane editString: editString.		codePane hasUnacceptedEdits: true	].	^codePane! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 12/5/2010 23:04'!buildMorphicNotifierLabelled: label message: messageString 	| notifyPane window contentTop extentToUse |	self expandStack.	window := (SystemWindow labelled: label) model: self.	contentTop := 0.2.	extentToUse := 650 @ 320.	"nice and wide to show plenty of the error msg"	window addMorph: self buttonRowForPreDebugWindow		frame: (0 @ 0 corner: 1 @ contentTop).	messageString 		ifNil: [			notifyPane := PluggableListMorph 						model: self						listGetter: #contextStackList						indexGetter: #contextStackIndex						indexSetter: #debugAt:						menuGetter: nil						keystrokeAction: nil]		ifNotNil: [			notifyPane _ TextModelMorph textProvider: self.			notifyPane				editString: messageString;				askBeforeDiscardingEdits: false].	window addMorph: notifyPane frame: (0 @ contentTop corner: 1 @ 1).	^window openInWorldExtent: extentToUse! !!FileContentsBrowser methodsFor: 'creation' stamp: 'jmv 12/5/2010 23:04'!addLowerPanesTo: window at: nominalFractions with: editString	| verticalOffset column codePane infoPane infoHeight divider |	column _ AlignmentMorph proportional.	codePane _ TextModelMorph 		textProvider: self		textGetter: #acceptedContents 		textSetter: #contents:notifying:		selectionGetter: #contentsSelection.	infoPane _ TextModelMorph 		textProvider: self		textGetter: #infoViewContents.	infoPane askBeforeDiscardingEdits: false.	verticalOffset _ 0.	infoHeight _ 20.	column 		addMorph: (codePane borderWidth: 0)		fullFrame: (			LayoutFrame 				fractions: (0@0 corner: 1@1) 				offsets: (0@verticalOffset corner: 0@infoHeight negated)		).	divider _ BorderedSubpaneDividerMorph forTopEdge.	column 		addMorph: divider		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@infoHeight negated corner: 0@(1-infoHeight))		).	column 		addMorph: (infoPane borderWidth: 0; hideScrollBarsIndefinitely)		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@(1-infoHeight) corner: 0@0)		).	window 		addMorph: column		frame: nominalFractions.	column on: #mouseEnter send: #paneTransition: to: window.	column on: #mouseLeave send: #paneTransition: to: window! !!Inspector class methodsFor: 'instance creation' stamp: 'jmv 12/5/2010 23:09'!openAsMorphOn: anObject withLabel: aLabel	" Inspector openAsMorphOn: SystemOrganization "	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel) model: inspector.	window		addMorph: (PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: inspector 			listGetter: #fieldList			indexGetter: #selectionIndex			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu:			keystrokeAction: #inspectorKey:from:)		frame: (0@0 corner: self horizontalDividerProportion @ self verticalDividerProportion).	window		addMorph: (TextModelMorph			textProvider: inspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection)		frame: (self horizontalDividerProportion @0 corner: 1@self verticalDividerProportion).	window		addMorph: ((TextModelMorph textProvider: inspector)			askBeforeDiscardingEdits: false)		frame: (0@self verticalDividerProportion corner: 1@1).	window setUpdatablePanesFrom: #(fieldList).	^ window! !!MessageNames methodsFor: 'search' stamp: 'jmv 12/5/2010 22:11'!searchString: aString	"Take what the user typed and find all selectors containing it"	searchString _ aString asString copyWithout: $ .	self containingWindow setLabel: 'Message names containing "', searchString asLowercase, '"'.	selectorList _ nil.	self changed: #selectorList.	self changed: #messageList.	^ true! !!MessageNames methodsFor: 'initialization' stamp: 'jmv 12/5/2010 22:12'!inMorphicWindowWithInitialSearchString: initialString	"Answer a morphic window with the given initial search string, nil if none""MessageNames openMessageNames"	| window selectorListView firstDivider secondDivider horizDivider typeInPane searchButton plugTextMor |	window _ (SystemWindow labelled: 'Message Names') model: self.	firstDivider _ 0.07.	secondDivider _ 0.5.	horizDivider _ 0.5.	typeInPane _ AlignmentMorph proportional height: 14.	plugTextMor _ TextModelMorph 		textProvider: self		textGetter: #searchString 		textSetter: #searchString:.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor textMorph		on: #mouseEnter send: #selectAll to: plugTextMor textMorph.	searchButton _ SimpleButtonMorph new 		target: self;		beTransparent;		label: 'Search';		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.	typeInPane addInProportionalRow: { searchButton. plugTextMor. }.	initialString isEmptyOrNil ifFalse:		[plugTextMor changeText: initialString].	window addMorph: typeInPane frame: (0@0 corner: horizDivider @ firstDivider).	selectorListView _ PluggableListMorph 		model: self		listGetter: #selectorList		indexGetter: #selectorListIndex		indexSetter: #selectorListIndex:		menuGetter: #selectorListMenu:		keystrokeAction: #selectorListKey:from:.	window addMorph: selectorListView frame: (0 @ firstDivider corner: horizDivider @ secondDivider).	window addMorph: self buildMorphicMessageList frame: (horizDivider @ 0 corner: 1@ secondDivider).	self 		addLowerPanesTo: window 		at: (0 @ secondDivider corner: 1@1) 		with: nil.	initialString isEmptyOrNil ifFalse: [		self searchString: initialString ].	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'jmv 12/5/2010 23:11'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window		addMorph: (TextModelMorph textProvider: self)		frame: (0@0 corner: 1@1).	^ window openInWorld! !MessageNames removeSelector: #searchString:notifying:!Browser removeSelector: #classComment:notifying:!!TextProvider reorganize!('self-updating' updatePaneIfNeeded)('contents' acceptedContents acceptedContentsChanged acceptedStringOrText)('services' offerMenuFrom:shifted: perform:orSendTo:)('accessing' contentsSelection editorClass)('user edits' okToChange)!TextModelMorph class removeSelector: #model:!TextModelMorph class removeSelector: #textModel:selectionGetter:!TextModelMorph class removeSelector: #textModel:textGetter:textSetter:selectionGetter:!TextModelMorph removeSelector: #getSelection!TextModelMorph removeSelector: #model:selectionGetter:!TextModelMorph removeSelector: #pluggableTextModel:!TextModelMorph removeSelector: #textModel:selectionGetter:!TextModelMorph removeSelector: #textModel:textGetter:textSetter:selectionGetter:!TextModelMorph removeSelector: #textProvider!!classDefinition: #TextModelMorph category: #'Morphic-Windows'!ScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval hasEditingConflicts editorClass styler'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!PluggableTextModel removeSelector: #accept!PluggableTextModel removeSelector: #getTextSelector:setTextSelector:!PluggableTextModel removeSelector: #getTextSelector:setTextSelector:selectionGetter:!PluggableTextModel removeSelector: #textGetter!PluggableTextModel removeSelector: #textSetter!!classDefinition: #PluggableTextModel category: #'System-Text'!TextModel subclass: #PluggableTextModel	instanceVariableNames: 'textProvider textGetter textSetter selectionGetter'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!PluggableTextModel reorganize!('accessing' actualContents textGetter:textSetter:selectionGetter: textProvider textProvider:)('testing' is: refusesToAccept wantsFrameAdornments)('self-updating' updatePaneIfNeeded)('misc' autoSelectString getSelection refetch)('pane menu' editorClass)('updating' update:)('commands' acceptFrom:)('*Shout-Styling' shoutAboutToStyle:)!TextModel removeSelector: #contentsSelection!TextModel removeSelector: #okToChange!!TextModel reorganize!('initialize-release' initialize openAsMorphLabel: openInMorphicWindowLabeled:wrap: openLabel: openLabel:wrap:)('accessing' actualContents actualContents:)('pane menu' editorClass perform:orSendTo:)('user edits' clearUserEditFlag)('services')('self-updating' updatePaneIfNeeded)('misc' getSelection refetch)('testing' wantsFrameAdornments)('commands' acceptFrom:)!