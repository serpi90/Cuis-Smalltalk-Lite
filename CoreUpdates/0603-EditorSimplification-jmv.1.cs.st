'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 8 September 2010 at 10:51:59 am'!!classDefinition: #Editor category: #'System-Text'!Object subclass: #Editor	instanceVariableNames: 'morph selectionShowing '	classVariableNames: 'KeystrokeActions '	poolDictionaries: ''	category: 'System-Text'!!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/7/2010 18:08'!backspace: aKeyboardEvent	"Backspace over the last character."	| startIndex |	aKeyboardEvent shiftPressed ifTrue: [		"^ self backWord: aKeyboardEvent keyCharacter"		^self forwardDelete: aKeyboardEvent ].	startIndex _ self markIndex + (self hasCaret ifTrue: [0] ifFalse: [1]).	startIndex _ 1 max: startIndex - 1.	self backTo: startIndex.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/7/2010 17:01'!cr: aKeyboardEvent	"Append a carriage return character to the stream of characters."	self addString: Character cr asString.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/7/2010 17:03'!crWithIndent: aKeyboardEvent	"Only for SmalltalkEditor. Regular editors don't indent"	^ self cr: aKeyboardEvent! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/7/2010 17:37'!enter: aKeyboardEvent	"Enter / return key was pressed"	"Process the various Enter / Return keystrokes"		morph acceptOnCR ifTrue: [		self closeTypeIn.		^ true].	aKeyboardEvent controlKeyPressed ifTrue: [		^ self cr: aKeyboardEvent ].	aKeyboardEvent shiftPressed ifTrue: [		^ self lf: aKeyboardEvent ].	aKeyboardEvent commandAltKeyPressed ifTrue: [		^ self crlf: aKeyboardEvent ].	^ self crWithIndent: aKeyboardEvent! !!Editor methodsFor: 'private' stamp: 'jmv 9/7/2010 17:15'!moveCursor: directionBlock forward: forward specialBlock: specialBlock event: aKeyboardEvent	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| shift indices newPosition |	shift _ aKeyboardEvent shiftPressed.	indices _ self setIndices: shift forward: forward.	newPosition _ directionBlock value: (indices at: #moving).	(aKeyboardEvent commandAltKeyPressed or: [ aKeyboardEvent controlKeyPressed ])		ifTrue: [newPosition _ specialBlock value: newPosition].	shift		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!Editor class methodsFor: 'class initialization' stamp: 'jmv 9/7/2010 19:37'!initialize	"	Editor initialize	"	self initializeKeystrokeActions.	self allSubclassesDo: [ :c | c initialize ]! !!Editor class methodsFor: 'class initialization' stamp: 'jmv 9/7/2010 23:49'!initializeKeystrokeActions	"Initialize the table for regular (i.e. non-command) keystroke dispatch"	"	self initializeKeystrokeActions	"	| actions |	actions _ Array new: 256 withAll: #normalCharacter:.	0 to: 31 do: [ :i | actions at: i+1 put: #noop: ].	actions at: 1 + 1 put: #cursorHome:.				"home key"	actions at: 3 + 1 put: #enter:.						"enter / return key"	actions at: 4 + 1 put: #cursorEnd:.				"end key"	actions at: 5 + 1 put: #noop:.						"insert key"	actions at: 8 + 1 put: #backspace:.				"macDelete winBackspace key"	actions at: 9 + 1 put: #normalCharacter:.		"tab"	actions at: 11 + 1 put: #cursorPageUp:.			"page up key"	actions at: 12 + 1 put: #cursorPageDown:.		"page down key"	actions at: 13 + 1 put: #enter:.					"enter / return key"	actions at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"	actions at: 28 + 1 put: #cursorLeft:.				"left arrow key"	actions at: 29 + 1 put: #cursorRight:.				"right arrow key"	actions at: 30 + 1 put: #cursorUp:.				"up arrow key"	actions at: 31 + 1 put: #cursorDown:.			"down arrow key"	actions at: 127 + 1 put: #forwardDelete:.		"winDelete key"	KeystrokeActions _ actions! !!EntryField2LW methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:15'!keyStroke: aKeyboardEvent	"Handle a keystroke event."	| k |	aKeyboardEvent commandAltKeyPressed		ifTrue: [ ^super keyStroke: aKeyboardEvent ].		k _ aKeyboardEvent keyValue.	k = 13 ifTrue: [		crAction ifNotNil: [				self performActionWith: contents.			self updateView.			^target perform: crAction ].		^ aKeyboardEvent hand keyboardFocusNext ].	(k = 30 or: [ k = 31 ])		ifTrue: [ ^super keyStroke: aKeyboardEvent ].	(k = 28 and: [ editor isAtStart ])		ifTrue: [ ^super keyStroke: aKeyboardEvent ].	(k = 29 and: [ editor isAtEnd ])		ifTrue: [ ^super keyStroke: aKeyboardEvent ].	self handleInteraction: [ editor processKeyStroke: aKeyboardEvent ].	self updateFromContents! !!CustomNavigationEntryFieldLW methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:14'!keyStroke: aKeyboardEvent	"Handle a keystroke event."	| k |	aKeyboardEvent commandAltKeyPressed		ifTrue: [ ^super keyStroke: aKeyboardEvent ].		k _ aKeyboardEvent keyValue.	(k = 30 and: [ upLW notNil ]) ifTrue: [		^ aKeyboardEvent hand newKeyboardFocus: upLW ].	(k = 31 and: [ downLW notNil ]) ifTrue: [		^ aKeyboardEvent hand newKeyboardFocus: downLW ].	 ^super keyStroke: aKeyboardEvent! !!InputSensor methodsFor: 'keyboard' stamp: 'jmv 9/8/2010 10:51'!kbdTest	"	Sensor kbdTest	"	"This test routine will print the unmodified character, its keycode,	and the OR of all its modifier bits, until the character x is typedAlso useful:	| buf |	buf := OrderedCollection new.	[ buf size < 20 ] whileTrue: [ | evt |	  evt := Sensor nextEventFromQueue.	evt ifNotNil: [ buf add: evt ] ].	'' print.	buf do: [ :a | a first = 2 ifTrue: [ a print ]]	"	| char |	char _ nil.	[ char = $x ] whileFalse: [		[ self keyboardPressed ] whileFalse.		char _ self characterForKeycode: self keyboard.		Display fill: (5@5 extent: 400@20) fillColor: Color white.		(String streamContents: [ :s |			s				nextPut: $-;				nextPut: char;				nextPut: $-;				space;				print: char asciiValue;				space.			self blueButtonPressed ifTrue: [ s nextPutAll: ' blue/tertiary/halo ' ].			self yellowButtonPressed ifTrue: [ s nextPutAll: ' yellow/secondary/menu ' ].			self redButtonPressed ifTrue: [ s nextPutAll: ' red/primary ' ].			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])		displayAt: 10 @ 10 ].! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 9/7/2010 17:14'!commandAltKeyPressed	"Answer whether the command (Mac) / alt(Windows) key on the keyboard is being held down."	^ self primMouseButtons anyMask: 64! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 9/7/2010 17:12'!controlKeyPressed	"Answer whether the control/ctrl key on the keyboard is being held down."	^ self primMouseButtons anyMask: 16! !!Morph methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:15'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	(anEvent commandAltKeyPressed and: [ self focusKeyboardFor: anEvent ])		ifTrue: [ ^ self ].	self eventHandler ifNotNil:		[self eventHandler keyStroke: anEvent fromMorph: self].! !!HandMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2010 22:55'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type hadAny |	ActiveEvent ifNotNil: [		"Meaning that we were invoked from within an event response.		Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent].	hadAny := false.	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [		evt := nil.	"for unknown event types"		type := evtBuf first.		type = EventTypeMouse			ifTrue: [ evt := self generateMouseEvent: evtBuf ].		type = EventTypeKeyboard 			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].		"All other events are ignored"		evt			ifNil: [				^hadAny]			ifNotNil: [				"Finally, handle it"				self handleEvent: evt.				hadAny := true.				"For better user feedback, return immediately after a mouse event has been processed."				evt isMouse ifTrue: [ ^hadAny ]]].	"note: if we come here we didn't have any mouse events"	mouseClickState 		ifNotNil: [ 			"No mouse events during this cycle. Make sure click states time out accordingly"			mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	^hadAny! !!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 9/7/2010 17:15'!keyStroke: evt 	| matchString char asc selectable help |	help _ BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.	(self rootMenu hasProperty: #hasUsedKeyboard) 		ifFalse: 			[self rootMenu setProperty: #hasUsedKeyboard toValue: true.			self changed].	(evt commandAltKeyPressed and: [self commandKeyHandler notNil]) 		ifTrue: 			[self commandKeyHandler commandKeyTypedIntoMenu: evt.			^self deleteIfPopUp: evt].	char := evt keyCharacter.	asc := char asciiValue.	char = Character cr 		ifTrue: 			[selectedItem ifNotNil: 					[selectedItem hasSubMenu 						ifTrue: 							[evt hand newMouseFocus: selectedItem subMenu.							^evt hand newKeyboardFocus: selectedItem subMenu]						ifFalse: 							["self delete."							^selectedItem invokeWithEvent: evt]].			(selectable := self items) size = 1 				ifTrue: [^selectable first invokeWithEvent: evt].			^self].	asc = 27 		ifTrue: 			["escape key"			self valueOfProperty: #matchString				ifPresentDo: 					[:str | 					str isEmpty 						ifFalse: 							["If filtered, first ESC removes filter"							self setProperty: #matchString toValue: String new.							self selectItem: nil event: evt.							^self displayFiltered: evt]].			"If a stand-alone menu, just delete it"			popUpOwner ifNil: [^self delete].			"If a sub-menu, then deselect, and return focus to outer menu"			self selectItem: nil event: evt.			evt hand newMouseFocus: popUpOwner owner.			^evt hand newKeyboardFocus: popUpOwner owner].	(asc = 28 or: [asc = 29]) 		ifTrue: 			["left or right arrow key"			(selectedItem notNil and: [selectedItem hasSubMenu]) 				ifTrue: 					[evt hand newMouseFocus: selectedItem subMenu.					selectedItem subMenu moveSelectionDown: 1 event: evt.					^evt hand newKeyboardFocus: selectedItem subMenu]].	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: evt].	"up arrow key"	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: evt].	"down arrow key"	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: evt].	"page up key"	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: evt].	"page down key"	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].	matchString := char = Character backspace 				ifTrue: 					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]				ifFalse: [matchString copyWith: evt keyCharacter].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt.	help _ BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:15'!keyStroke: evt	"Handle a keystroke event."	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	"CR - check for special action	Note: Code below assumes that this was some	input field reacting on CR. Break the keyboard	focus so that the receiver can be safely deleted.	jmv - Currently not implemented"	"	evt keyValue = 13 ifTrue: [		action _ self crAction.		action ifNotNil: [			evt hand newKeyboardFocus: nil.			^action value ] ].	"	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromContents.	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:15'!keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	(self scrollByKeyboard: evt) ifTrue: [^self].	scroller submorphs last keyStroke: evt! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:15'!scrollByKeyboard: event 	"If event is ctrl+up/down then scroll and answer true"	(event controlKeyPressed or:[event commandAltKeyPressed]) ifFalse: [^ false].	event keyValue = 30		ifTrue: 			[scrollBar scrollUp: 3.			^ true].	event keyValue = 31		ifTrue: 			[scrollBar scrollDown: 3.			^ true].	^ false! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:15'!keyStroke: event 	"Process keys 	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"		| aChar aSpecialKey |	(event commandAltKeyPressed and: [ self focusKeyboardFor: event ])		ifTrue: [ ^ self ].	(self scrollByKeyboard: event) ifTrue: [^self].	aChar _ event keyCharacter.	aSpecialKey _ aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!PluggableTextMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:15'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	textMorph keyStroke: evt.	self eventHandler ifNotNil:		[self eventHandler keyStroke: evt fromMorph: self].! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 9/7/2010 19:38'!dispatchOn: aKeyboardEvent	"Carry out the action associated with this character, if any."	| asciiValue |	asciiValue _ aKeyboardEvent keyValue.	"We don't support multiple lines. Therefore, we don't process cr as a #normalCharacter:"	asciiValue = 13 ifTrue: [		self closeTypeIn.		^ true].	(Preferences cmdKeysInText and: [ aKeyboardEvent commandAltKeyPressed ]) ifTrue: [		^self perform: (self class cmdActions at: asciiValue + 1) with: aKeyboardEvent ].	^ self perform: (KeystrokeActions at: asciiValue + 1) with: aKeyboardEvent! !!SimpleEditor class methodsFor: 'class initialization' stamp: 'jmv 9/7/2010 19:40'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo."  	"SimpleEditor initialize"	self initializeCmdKeyShortcuts! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:16'!keyStroke: event 	"Process potential command keys"	| args aCharacter |	(event commandAltKeyPressed and: [ self focusKeyboardFor: event ])		ifTrue: [ ^ self ].	(self scrollByKeyboard: event) ifTrue: [^self].	aCharacter := event keyCharacter.	keystrokeActionSelector ifNil: [^self arrowKey: aCharacter].	(args := keystrokeActionSelector numArgs) = 1 		ifTrue: [^model perform: keystrokeActionSelector with: aCharacter].	args = 2 		ifTrue: [			^model 				perform: keystrokeActionSelector				with: aCharacter				with: self].	^self 		error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 9/7/2010 19:39'!presumedSentMessages   | sent |"Smalltalk presumedSentMessages"	"The following should be preserved for doIts, etc"	sent _ IdentitySet new.	#( rehashWithoutBecome compactSymbolTable		browseAllSelect:  lastRemoval		vScrollBarValue: hScrollBarValue: scrollBarMenuButtonPressed: 		to: removeClassNamed:		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib		newDepth: restoreAfter: forgetDoIts zapAllMethods obsoleteClasses		removeAllUnSentMessages abandonSources removeUnreferencedKeys		zapOrganization condenseChanges browseObsoleteReferences		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerEventLoop unusedClasses) do:		[:sel | sent add: sel].	"The following may be sent by perform: in dispatchOnChar..."	(TextEditor cmdActions) asSet do: [:sel | sent add: sel].	(SmalltalkEditor cmdActions) asSet do: [:sel | sent add: sel].		"methodsToKeep is never called, but any class can implement it to protect some methods from deletion.	For example, if no senders appear to exist because the symbols are built and later performed	Include the following comment when implementing it:"	"Send to self messages for all the methods that should be kept in Smalltalk image shrinking.	This method is not actually called, but will not be deleted and therefore messages sent here will not appear as unsent"	#(beReadOnlyBinding beReadWriteBinding changeSetCategoryClass belongsInAll: methodsToKeep) do:		[:sel | sent add: sel].	^ sent! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 9/7/2010 23:45'!offerColorMenu	"Present a menu of available colors, and if one is chosen, apply it to the current selection."	| attribute colors index thisSel |	thisSel _ self selection.	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).	index _ (PopUpMenu		labelArray: colors , #('choose color...' )		lines: (Array with: colors size + 1)) startUp.	index = 0 ifTrue: [ ^ true ].	index <= colors size		ifTrue: [ attribute _ TextColor color: (Color perform: (colors at: index)) ]		ifFalse: [			index _ index - colors size - 1.			"Re-number!!!!!!"			index = 0 ifTrue: [ attribute _ self chooseColor ].			thisSel ifNil: [ ^ true ]].	attribute ifNotNil: [ self applyAttribute: attribute ].	^ true.! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/7/2010 23:57'!changeEmphasis: aKeyboardEvent	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis."	"control 0..9 -> 0..9"	| keyCode attribute oldAttributes |	keyCode _ ('01234567'		indexOf: aKeyboardEvent keyCharacter		ifAbsent: [ 1 ]) - 1.	oldAttributes _ paragraph text attributesAt: self pointIndex.	keyCode = 0 ifTrue: [ attribute _ TextEmphasis normal ].	(keyCode between: 1 and: 5) ifTrue: [		attribute _ TextEmphasis perform: (#(#bold #italic #narrow #underlined #struckOut ) at: keyCode).		oldAttributes do: [ :att |			(att dominates: attribute) ifTrue: [ attribute turnOff ]]].	keyCode = 6 ifTrue: [ attribute _ TextKern kern: -1 ].	keyCode = 7 ifTrue: [ attribute _ TextKern kern: 1 ].	attribute ifNotNil: [ self applyAttribute: attribute ].	^ true.! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/7/2010 23:42'!offerColorMenu: aKeyboardEvent 	"The user typed the command key that requests a font change; Offer the color menu."	self closeTypeIn.	self offerColorMenu.	^ true! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 9/7/2010 19:38'!dispatchOn: aKeyboardEvent	"Carry out the action associated with this character, if any."	| asciiValue |	self clearParens.  	asciiValue _ aKeyboardEvent keyValue.	(Preferences cmdKeysInText and: [ aKeyboardEvent commandAltKeyPressed ]) ifTrue: [		^self perform: (self class cmdActions at: asciiValue + 1) with: aKeyboardEvent ].	(')]}' includes: aKeyboardEvent keyValue)		ifTrue: [ self blinkPrevParen: aKeyboardEvent ].	^ self perform: (KeystrokeActions at: asciiValue + 1) with: aKeyboardEvent! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/7/2010 23:24'!initializeBasicCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 13 + 1 put: #enter:.					"enter / return key"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmds _ #(		$a #selectAll: 		$c #copySelection: 		$e #exchange: 		$f #find: 		$g #findAgain: 		$h #setSearchString: 		$v #paste: 		$w #backWord: 		$x #cut: 		$y #swapChars: 		$z #undo:		$C	#compareToClipboard:		$D	#duplicate:		$H	#cursorTopHome:		$J	#doAgainMany:		$K	#changeStyle:		$L	#outdent:		$M	#selectCurrentTypeIn:		$R	#indent:		$S	#search:		$U	#changeLfToCr:		$X	#makeLowercase:		$Y	#makeUppercase:		$Z	#makeCapitalized:	).	1 to: cmds size		by: 2		do: [ :i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions _ cmdMap! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/7/2010 23:53'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"	Editor initialize	"	| cmds |	self initializeBasicCmdKeyShortcuts.				'01234567' 		do: [ :char | cmdActions at: char asciiValue + 1 put: #changeEmphasis:].		cmds := #(		$8	#offerColorMenu:		$k	#offerFontMenu:		$u	#align:		$K	#changeStyle:	).	1 to: cmds size		by: 2		do: [ :i | cmdActions at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)]! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/7/2010 14:35'!initializeYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"TextEditor initialize"	yellowButtonMenu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.	#setSearchString}.		#-.		{'do again (j)' translated.			#again}.		{'undo (z)' translated.				#undo}.		#-.		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.				#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.				#pasteRecent}.		#-.		{'set font... (k)' translated.			#offerFontMenu}.		{'set style... (K)' translated.			#changeStyle}.		{'set alignment...' translated.		#chooseAlignment}.		"		#-.		{'more...' translated.					#shiftedTextPaneMenuRequest}.		"	}! !!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 9/7/2010 19:40'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo."  	"TextEditor initialize"	UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeYellowButtonMenu.	self initializeShiftedYellowButtonMenu! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/7/2010 19:11'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"SmalltalkEditor initialize"	| cmds |	self initializeBasicCmdKeyShortcuts.		cmds := #(		$b	#browseIt: 		$d	#doIt: 		$i	#inspectIt: 		$j	#doAgainOnce: 		$l	#cancel: 		$m	#implementorsOfIt: 		$n	#sendersOfIt: 		$p	#printIt: 		$q	#querySymbol: 		$s	#save: 		$A	#argAdvance:		$B	#browseItHere:		$E	#methodStringsContainingIt:		$F	#displayIfFalse:		$G	#fileItIn:		$I	#exploreIt:		$N	#referencesToIt:		$T	#displayIfTrue:		$V	#pasteInitials:		$W	#methodNamesContainingIt:	).	1 to: cmds size		by: 2		do: [ :i | cmdActions at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)]! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/7/2010 14:35'!initializeYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	yellowButtonMenu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.	#setSearchString}.		#-.	     		{'do again (j)' translated.			#again}.		{'undo (z)' translated.				#undo}.		#-.	     		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.				#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.				#pasteRecent}.		#-.	     		{'do it (d)' translated.				#doIt}.		{'print it (p)' translated.				#printIt}.		{'inspect it (i)' translated.			#inspectIt}.		{'explore it (I)' translated.			#exploreIt}.		{'debug it' translated.				#debugIt}.		#-.	     		{'accept (s)' translated.				#accept}.		{'cancel (l)' translated.				#cancel}.		#-.	     		{'show bytecodes' translated.		#showBytecodes}.		#-.	     		{'more...' translated.				#shiftedTextPaneMenuRequest}.	}! !!TextMorph methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:16'!keyStroke: evt	"Handle a keystroke event."	| action |	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	self pauseBlinking.	evt keyValue = 13 ifTrue:["CR - check for special action"		action _ self crAction.		action ifNotNil:[			"Note: Code below assumes that this was some			input field reacting on CR. Break the keyboard			focus so that the receiver can be safely deleted."			evt hand newKeyboardFocus: nil.			^action value]].	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromParagraph.	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!StringMorphEditor methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:16'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor oldSel newSel |	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandAltKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandAltKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	oldSel _ self editor selectionInterval.	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	oldSel = newSel ifTrue:		["There is a bug that causes characters to be misplaced when the second		character typed is wider than the first.  This fixes it (ugh)."		self editor selectFrom: newSel first + 1 to: newSel last + 1].! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'jmv 9/7/2010 17:16'!keyStroke: evt	| view |	(evt commandAltKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	(editView scrollByKeyboard: evt) ifTrue: [^self].	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 9/7/2010 17:14'!commandAltKeyPressed	"Answer true if the command (Mac) / alt(Windows) key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 64! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 9/7/2010 17:13'!controlKeyPressed	"Answer true if the control/ctrl key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 16! !!UserInputEvent methodsFor: 'printing' stamp: 'jmv 9/7/2010 17:16'!modifierString	"Return a string identifying the currently pressed modifiers"	| string |	string _ ''.	self commandAltKeyPressed ifTrue:[string _ string,'CMD '].	self shiftPressed ifTrue:[string _ string,'SHIFT '].	self controlKeyPressed ifTrue:[string _ string,'CTRL '].	^string! !!KeyboardEvent methodsFor: 'printing' stamp: 'jmv 9/7/2010 17:15'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: type; nextPutAll: ' '''.	self controlKeyPressed ifTrue: [ aStream nextPutAll: 'Ctrl-' ].	self commandAltKeyPressed ifTrue: [ aStream nextPutAll: 'Cmd/Alt-' ].	(buttons anyMask: 32) ifTrue: [ aStream nextPutAll: 'Opt-' ].	self controlKeyPressed ifTrue: [		aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter.	] ifFalse: [		aStream nextPut: self keyCharacter.	].	aStream nextPut: $'.	aStream nextPut: $].! !UserInputEvent removeSelector: #commandKeyPressed!SmalltalkEditor class removeSelector: #initializeShiftCmdKeyShortcuts!TextEditor initialize!TextEditor class removeSelector: #initializeBasicShiftCmdKeyShortcuts!TextEditor class removeSelector: #initializeShiftCmdKeyShortcuts!TextEditor class removeSelector: #shiftCmdActions!TextEditor removeSelector: #crWithIndent:!TextEditor removeSelector: #shiftEnclose:!SimpleEditor initialize!SimpleEditor class removeSelector: #initializeShiftCmdKeyShortcuts!InputSensor removeSelector: #commandKeyPressed!Editor initialize!Editor class removeSelector: #specialShiftCmdKeys!!classDefinition: #Editor category: #'System-Text'!Object subclass: #Editor	instanceVariableNames: 'morph selectionShowing'	classVariableNames: 'KeystrokeActions'	poolDictionaries: ''	category: 'System-Text'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Editor initialize!