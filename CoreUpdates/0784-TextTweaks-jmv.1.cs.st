'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 26 January 2011 at 1:01:17 pm'!!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 1/26/2011 13:00'!displayBulletIfAppropriateFor: textLine offset: offset	| paragraphEnd count pattern |	paragraphStyle ifNotNil: [		(textLine isFirstLine and: [ paragraphStyle isListStyle ]) ifTrue: [			pattern _ paragraphStyle listBulletPattern.			"Count how many paragraphs before this one already used the pattern"			count _ 0.			paragraphEnd _ textLine first-1.			[			paragraphEnd > 0 and: [ ((text paragraphStyleOrNilAt: paragraphEnd) ifNotNil: [ :ps | ps listBulletPattern ]) = pattern ]] whileTrue: [				count _ count + 1.				paragraphEnd _ text string endOfParagraphBefore: paragraphEnd ].			"Our number in the list, is one more than the count of previous contiguous paragraphs with this pattern"			self				displayBulletOffset: offset				number: count + 1]]! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/26/2011 11:07'!paragraphStyleOrNilAt: characterIndex	| paragraphStyle |	self size = 0 ifTrue: [ ^ nil ].	paragraphStyle _ nil.	(runs at: characterIndex) do: [ :attribute | 		attribute forParagraphStyleReferenceDo: [ :s | paragraphStyle _ s ] ].	^paragraphStyle! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/26/2011 10:57'!paragraphStyleOrNilIfApplying: textAttributes	"Answer the ParagraphStyle for characters as specified by the argument."		self withAttributeValues: textAttributes do: [ :font :color :alignment :paragrapStyle :characterStyle :kern |		^paragrapStyle ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/26/2011 10:56'!withAttributeValues: attributes do: aBlock	"Evaluate aBlock with the values of various attributes applied in the correct order	The order is (each overwriting the previous one)	1) initialStyle	2) ParagraphStyleReferene	3) CharacterStyleReference	4) TextFontReference	5) TextEmphasis"	| paragraphStyle characterStyle font emphasis alignment color kern |	paragraphStyle _ nil.	characterStyle _ nil.	font _ StrikeFont default.	emphasis _ 0.	alignment _ 0.	color _ nil.	kern _ 0.		"ParagraphStyle is the first to set several values"	attributes do: [ :attribute |		attribute forParagraphStyleReferenceDo: [ :s | 			paragraphStyle _ s]].	paragraphStyle		ifNotNil: [			font _ paragraphStyle font.			alignment _ paragraphStyle alignment.			paragraphStyle color ifNotNil: [ :c | color _ c ]].	"CharacterStyle, if present, can override font and color"	attributes do: [ :attribute |		attribute forCharacterStyleReferenceDo: [ :s | 			characterStyle _ s.			font _ characterStyle font.			characterStyle color ifNotNil: [ :c | color _ c ]]].		"Hardcoded color for TextAction comes before TextColor"	attributes do: [ :attribute |		attribute forTextActionInfoDo: [ :info | color _ TextAction purple ]].	"These will not interfere with each other, and all of them take precedence over previous values"	attributes do: [ :attribute |		attribute forFontReferenceDo: [ :f | font _ f ].		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].		attribute forTextColorDo: [ :c | color _ c ].		attribute forTextAlignmentDo: [ :a | alignment _ a ].		attribute forTextKernDo: [ :k | kern _ kern + k ].	].	"Finally, the font must include any specified emphasis"	font _ font emphasized: emphasis.		"Done. Now evaluate the block."	aBlock valueWithArguments: {font. color. alignment. paragraphStyle. characterStyle. kern }! !!Text methodsFor: 'as yet unclassified' stamp: 'jmv 1/26/2011 11:11'!paragraphStyleChunksDo: aBlock	"Evaluate aBlock over each chunk (sequence of paragraphs) that have the same paragraphStyle"	| start nextStart style |	start _ 1.	nextStart _ 1.	[ start <= self size ] whileTrue: [		style _ self paragraphStyleOrNilAt: start.		[ nextStart <= self size and: [ (self paragraphStyleOrNilAt: nextStart) = style ]] whileTrue: [			nextStart _nextStart + 1 ].		aBlock value: (start to: nextStart-1) value: style.		start _ nextStart ]! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 1/26/2011 11:14'!addEmptyTrailingLine	"The line to add is always the first line of a new paragraph"	| ts f h bs r lm rm w a leftMarginForAlignment s |	s _ theText size+1.	f _ editor		ifNotNil: [ editor lastFont ]		ifNil: [ theText fontAt: s ].	ts _ editor		ifNotNil: [ editor lastParagraphStyleOrNil ]		ifNil: [ theText paragraphStyleOrNilAt: s].	h _ f height.	bs _ f ascent.	lm _ 0.	rm _ 0.	w _ theContainer width.	a _ 0.	ts ifNotNil: [		h _h + ts paragraphSpacingBefore + ts paragraphSpacingAfter.		bs _ bs + ts paragraphSpacingBefore.		lm _ (ts isListStyle not			ifTrue: [ts firstIndent]			ifFalse: [ts restIndent]).		rm _ ts rightIndent.		a _ ts alignment ].		leftMarginForAlignment _ a = CharacterScanner rightFlushCode		ifTrue: [ w - rm]		ifFalse: [			a = CharacterScanner centeredCode				ifTrue: [ (w - rm - lm) //2 + lm]				ifFalse: [ lm ]].	r _ theContainer left + leftMarginForAlignment @ currentY extent: 0@h.	lines addLast: (		EmptyLine new			firstIndex: s lastIndex: s - 1;			rectangle: r;			lineHeight: h baseline: bs;			paragraphStyle: ts)! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 1/26/2011 11:11'!currentParagraphStyle	"Answer the ParagraphStyle for the current selection or cursor location if any"		| i t |	i _ self startIndex.	t _ paragraph text.	^i > t size		ifTrue: [ t paragraphStyleOrNilIfApplying: emphasisHere ]		ifFalse: [ t paragraphStyleOrNilAt: i ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 1/26/2011 11:14'!lastParagraphStyleOrNil	"Answer the ParagraphStyle for to be used if positioned at the end of the text"		| t |	t _ paragraph text.	^self startIndex > t size		ifTrue: [ paragraph text paragraphStyleOrNilIfApplying: emphasisHere ]		ifFalse: [ paragraph text paragraphStyleOrNilAt: t size +1 ]! !TextEditor removeSelector: #lastParagraphStyle!Text removeSelector: #paragraphStyleAt:!Text removeSelector: #paragraphStyleIfApplying:!