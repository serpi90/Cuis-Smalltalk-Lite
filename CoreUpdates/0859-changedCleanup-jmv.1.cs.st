'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 14 March 2011 at 9:29:20 am'!!LightWidget methodsFor: 'debug and other' stamp: 'jmv 3/14/2011 09:17'!resumeAfterDrawError	self redrawNeeded.	self drawingFailsNot.	self redrawNeeded! !!LightWidget methodsFor: 'drawing' stamp: 'jmv 3/14/2011 09:17'!visible: aBoolean 	"set the 'visible' attribute of the receiver to aBoolean"	isVisible == aBoolean		ifTrue: [^ self].	isVisible _ aBoolean.	self redrawNeeded! !!LightWidget methodsFor: 'focus handling' stamp: 'jmv 3/14/2011 09:17'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes could change their appearance in some way when they are the current keyboard focus. This default implementation does nothing.		Only morphs that answer true to #handlesKeyboard will ever get keyboard focus!!"		self redrawNeeded! !!LightWidget methodsFor: 'geometry' stamp: 'jmv 3/14/2011 09:17'!extent: aPoint	bounds extent = aPoint ifTrue: [^ self].	self redrawNeeded.	bounds _ bounds topLeft extent: aPoint.	self layoutChanged.	self redrawNeeded! !!LightWidget methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:16'!arrangeToStartSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"	aWorld ifNotNil: [		aWorld startStepping: self.		self redrawNeeded ]! !!LightWidget methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:17'!startStepping: aSelector at: scheduledTime arguments: args stepTime: stepTime	"Start stepping the receiver"	| w |	w _ self world.	w ifNotNil: [		w startStepping: self at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.		self redrawNeeded]! !!LightWidget methodsFor: 'updating' stamp: 'jmv 3/14/2011 09:08'!redrawNeeded	"Report that the area occupied by this morph should be redrawn."	^self invalidRect: bounds! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 3/14/2011 09:13'!updateView	"The model or some Model Extension changed is some way.	We must update ourselves to reflect the new state.	This is the place to update secondary Model Extensions or any other state that must be updated	after model or Model Extension change.	This method is usually reimplemented in CompositeLWs, to update subviews.		The subviews should be sent one of the following messages:		modelChanged		target:		target:aspect:		target:aspect:aspectAdaptor:		target:aspect:aspectAdaptor:aspectChangeEvent:	to update their model and do a full update, as triggered by #modelChanged"		self redrawNeeded! !!CompositeLW methodsFor: 'change reporting' stamp: 'jmv 3/14/2011 09:11'!privateInvalidateMorph: aMorph	"Private. Invalidate the given morph after adding or removing.	This method is private because a) we're invalidating the morph 'remotely'	and b) it forces a fullBounds computation which should not be necessary	for a general morph c) the morph may or may not actually invalidate	anything (if it's not in the world nothing will happen) and d) the entire	mechanism should be rewritten."	aMorph redrawNeeded! !!EntryField2LW methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:12'!installEditorToReplace: priorEditor	"Install an editor for my contents.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [ stateArray _  priorEditor stateArray ].	editor _ self editorClass new morph: self.	editor changeString: contents.	stateArray ifNotNil: [editor stateArrayPut: stateArray].	self redrawNeeded.	^editor! !!EntryField2LW methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:13'!updateFromContents	| c |	c _ editor string.	c = contents ifFalse: [		contents _ c.		actionPending _ true.		self redrawNeeded ]! !!EntryField2LW methodsFor: 'editing' stamp: 'jmv 3/14/2011 09:12'!handleInteraction: interactionBlock	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple the editor to Morphic keyboard events"	| oldEditor oldContents |	oldEditor _ editor.	oldContents _ contents.	interactionBlock value.	oldContents == contents 		ifTrue: [ "this will not work if the paragraph changed"			editor _ oldEditor	"since it may have been changed while in block"].	self redrawNeeded! !!EntryField2LW methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:12'!keyboardFocusChange: aBoolean 	aBoolean ifTrue: [		"A hand is wanting to send us characters... Ensure editor."		self editor.		self redrawNeeded ]	ifFalse: [		actionPending ifTrue: [			self performActionWith: contents.			actionPending _ false ].		self updateView ]! !!EntryField2LW methodsFor: 'unaccepted edits' stamp: 'jmv 3/14/2011 09:12'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "		self flag: #jmv.	"Not used in this morph, as it doesn't do accept / cancel"	self redrawNeeded! !!CellStyleEntryFieldLW methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:11'!step	editor isInCellShiftMode ifFalse: [		self redrawNeeded.		self stopStepping ]! !!ImageLW methodsFor: 'layout' stamp: 'jmv 3/14/2011 09:13'!layoutChanged	"Update rotatedForm and compute new bounds."	self redrawNeeded.	self generateStretchedForm.	super layoutChanged.	self redrawNeeded! !!LabelLW methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:16'!font: aFont	font _ aFont.	self redrawNeeded! !!LabelLW methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:16'!fontColor: aColor	fontColor _ aColor.	self redrawNeeded! !!ListItemLW methodsFor: 'focus handling' stamp: 'jmv 3/14/2011 09:17'!keyboardFocusChange: aBoolean	aBoolean ifTrue: [		owner focused: self ].	self redrawNeeded! !!ListLW methodsFor: 'focus handling' stamp: 'jmv 3/14/2011 09:17'!focused: aSubmorph	"Default is to do nothing."		| delta |	delta _ aSubmorph displayBounds amountToTranslateWithin: bounds.	delta = (0@0) ifFalse: [		submorphs do: [ :m |			m privateFullMoveBy: delta ].		self redrawNeeded ]! !!ListOldLW methodsFor: 'focus handling' stamp: 'jmv 3/14/2011 09:17'!focused: aSubmorph	"Default is to do nothing."		| delta |	delta _ aSubmorph displayBounds amountToTranslateWithin: bounds.	delta = (0@0) ifFalse: [		submorphs do: [ :m |			m privateFullMoveBy: delta ].		self redrawNeeded ]! !!Morph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:19'!color: aColor	"Set the receiver's color.  Directly set the color if appropriate, else go by way of fillStyle"	((aColor is: #Color) or: [ aColor isKindOf: InfiniteForm ]) ifFalse: [		^ self fillStyle: aColor ].	color = aColor ifFalse: [		self removeProperty: #fillStyle.		color _ aColor.		self redrawNeeded ]! !!Morph methodsFor: 'change reporting' stamp: 'jmv 3/14/2011 09:11'!privateInvalidateMorph: aMorph	"Private. Invalidate the given morph after adding or removing.	This method is private because a) we're invalidating the morph 'remotely'	and b) it forces a fullBounds computation which should not be necessary	for a general morph c) the morph may or may not actually invalidate	anything (if it's not in the world nothing will happen) and d) the entire	mechanism should be rewritten."	aMorph doLayoutIfNeeded.	aMorph redrawNeeded! !!Morph methodsFor: 'debug and other' stamp: 'jmv 3/14/2011 09:20'!resumeAfterDrawError	self redrawNeeded.	self drawingFailsNot.	self redrawNeeded! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/14/2011 09:20'!highlightForMouseDown: aBoolean	aBoolean 		ifTrue: [ self setProperty: #highlightedForMouseDown toValue: aBoolean ]		ifFalse: [ self removeProperty: #highlightedForMouseDown. self resetExtension ].	self redrawNeeded! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/14/2011 09:20'!visible: aBoolean 	"set the 'visible' attribute of the receiver to aBoolean"	(self hasExtension not and:[aBoolean])		ifTrue: [^ self].	self visible == aBoolean		ifTrue: [^ self].	self assureExtension visible: aBoolean.	self redrawNeeded! !!Morph methodsFor: 'drop shadows' stamp: 'jmv 3/14/2011 09:20'!shadowColor: aColor	self shadowColor = aColor ifFalse: [ self redrawNeeded ].	self setProperty: #shadowColor toValue: aColor! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 3/14/2011 09:20'!highlightForDrop: aBoolean	self setProperty: #highlightedForDrop toValue: aBoolean.	self redrawNeeded! !!Morph methodsFor: 'geometry' stamp: 'jmv 3/14/2011 09:19'!basicExtent: aPoint	bounds extent = aPoint ifTrue: [^ self].	self redrawNeeded.	bounds _ bounds topLeft extent: aPoint.	self layoutChanged.	self redrawNeeded! !!Morph methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:19'!arrangeToStartSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"	aWorld ifNotNil: [		aWorld startStepping: self.		self redrawNeeded ]! !!Morph methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:20'!startStepping: aSelector at: scheduledTime arguments: args stepTime: stepTime	"Start stepping the receiver"	| w |	w _ self world.	w ifNotNil: [		w startStepping: self at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.		self redrawNeeded ]! !!Morph methodsFor: 'updating' stamp: 'jmv 3/14/2011 09:08'!redrawNeeded	"Report that the area occupied by this morph should be redrawn."	self invalidRect: (fullBounds ifNil: [ bounds ])! !!Morph methodsFor: 'visual properties' stamp: 'jmv 3/14/2011 09:19'!fillStyle: aFillStyle	"Set the current fillStyle of the receiver."	self setProperty: #fillStyle toValue: aFillStyle.	"Workaround for Morphs not yet converted"	color _ aFillStyle asColor.	self redrawNeeded! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:10'!textColor: aColor	color = aColor ifTrue: [^ self].	color _ aColor.	self redrawNeeded! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:10'!keyboardFocusChange: aBoolean		"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	paragraph ifNotNil: [ paragraph focused: aBoolean ].	aBoolean		ifTrue: [			"A hand is wanting to send us characters..."			editor ifNil: [ self editor ].	"Forces install"			self startBlinking ]		ifFalse: [ self stopBlinking ].	"Selection might be shown differently when focused"	"If (as usual) we are part of a TextModelMorph, invalidate it, to update the keyboard focus indicator"	owner ifNotNil: [ owner owner ifNotNil: [ :grandPa | ^ grandPa redrawNeeded ]].	self redrawNeeded! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 3/14/2011 09:10'!fit	"Adjust my bounds to fit the text.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para |	newExtent := (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).	newExtent ~= bounds extent 		ifTrue: [			para := paragraph.	"Save para (layoutChanged smashes it)"			self basicExtent: newExtent.			paragraph := para].	"These statements should be pushed back into senders"	self paragraph positionWhenComposed: self position.	self redrawNeeded.	"Too conservative: only paragraph composition							should cause invalidation."	editView innerHeight: newExtent y! !!BareTextMorph methodsFor: 'miscellaneous' stamp: 'jmv 3/14/2011 09:10'!selectAll	"Tell my editor to select all the text"	self editor selectAll.	self redrawNeeded! !!BorderedMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:11'!borderColor: colorOrSymbolOrNil	self doesBevels ifFalse: [		(colorOrSymbolOrNil is: #Color) ifFalse: [^self]].	borderColor = colorOrSymbolOrNil ifFalse: [		borderColor _ colorOrSymbolOrNil.		self redrawNeeded]! !!BorderedMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:11'!borderWidth: anInteger	borderWidth = anInteger ifFalse: [		borderColor ifNil: [borderColor _ Color black].		borderWidth _ anInteger max: 0.		self redrawNeeded ]! !!HaloMorph methodsFor: 'updating' stamp: 'jmv 3/14/2011 09:08'!redrawNeeded	"Quicker to invalidate handles individually if target is large (especially the world)"	self extent > (200@200)		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [					"Invalidate 4 outer strips first, thus subsuming separate damage."					(self fullDisplayBounds areasOutside: target bounds) do:						[ :r | self invalidRect: r ]].				self submorphsDo: [:m | m redrawNeeded]]		ifFalse: [ super redrawNeeded ]! !!HaloMorph methodsFor: 'private' stamp: 'jmv 3/14/2011 09:13'!addHandles	| box |	target isWorldMorph ifTrue: [ ^ self addHandlesForWorldHalos ].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target worldBoundsForHalo.  "update my size"	box _ self basicBox.	target addHandlesTo: self box: box.	self addName.	growingOrRotating _ false.	self layoutChanged.	self redrawNeeded! !!HaloMorph methodsFor: 'private' stamp: 'jmv 3/14/2011 09:14'!addHandlesForWorldHalos	"Add handles for world halos, like the man said"	| box w |	w _ self world ifNil:[target world].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ w bounds insetBy: 9.	target addWorldHandlesTo: self box: box.	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating _ false.	self layoutChanged.	self redrawNeeded! !!HandMorph methodsFor: 'cursor' stamp: 'jmv 3/14/2011 09:14'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset 	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self redrawNeeded.	temporaryCursorOffset 		ifNotNil: [ bounds _ bounds translateBy: temporaryCursorOffset negated ].	cursorOrNil		ifNil: [temporaryCursor _ temporaryCursorOffset _ nil]		ifNotNil: [			temporaryCursor _ (Preferences biggerCursors and: [ cursorOrNil is: #Cursor ])					ifTrue: [ cursorOrNil asBigCursor asCursorForm ]					ifFalse: [ cursorOrNil asCursorForm ].			temporaryCursorOffset _ temporaryCursor offset - hotSpotOffset ].	bounds _ self cursorBounds.	self		userInitials: userInitials andPicture: self userPicture;		layoutChanged;		redrawNeeded! !!HandMorph methodsFor: 'updating' stamp: 'jmv 3/14/2011 09:09'!redrawNeeded	hasChanged _ true! !!HandleMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 3/14/2011 09:14'!justDroppedInto: aMorph event: anEvent	"So that when the hand drops me (into the world) I go away"	lastPointBlock ifNotNil: [lastPointBlock value: self center].	self flag: #arNote. "Probably unnecessary"	anEvent hand releaseKeyboardFocus: self.	self redrawNeeded.	self delete! !!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:15'!color: aColor        super color: aColor.        (image depth = 1 and: [aColor is: #Color]) ifTrue: [                image colors: {Color transparent. aColor}.                self redrawNeeded]! !!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:15'!image: anImage 	self redrawNeeded.	image - anImage depth = 1 		ifTrue: [ ColorForm mappingWhiteToTransparentFrom: anImage ]		ifFalse: [ anImage ]. 	self basicExtent: image extent! !!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:15'!opaque: aBool	"Mark the receiver as being completely opaque or not"	opaque _ aBool.	self redrawNeeded! !!LazyListMorph methodsFor: 'list management' stamp: 'jmv 3/14/2011 09:16'!listChanged	"set newList to be the list of strings to display"	listItems _ Array new: self getListSize withAll: nil.	selectedRow _ nil.	selectedRows _ PluggableSet integerSet.	self adjustHeight.	self adjustWidth.	self redrawNeeded! !!LazyListMorph methodsFor: 'list management' stamp: 'jmv 3/14/2011 09:16'!selectRow: index	"select the index-th row"	selectedRows add: index.	self redrawNeeded! !!LazyListMorph methodsFor: 'list management' stamp: 'jmv 3/14/2011 09:16'!selectedRow: index	"select the index-th row.  if nil, remove the current selection"	selectedRow _ index.	self redrawNeeded! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 3/14/2011 09:16'!font: newFont	font _ (newFont ifNil: [ StrikeFont default ]).	self adjustHeight.	self redrawNeeded.! !!MagnifierMorph methodsFor: 'stepping' stamp: 'jmv 3/14/2011 09:18'!step	self redrawNeeded! !!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 3/14/2011 09:18'!chooseMagnification	| result |	result _ (SelectionMenu selections: #(1.5 2 4 8))		startUpWithCaption: 'Choose magnification(currently ', magnification printString, ')'.	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].	magnification _ result.	self extent: self extent. "round to new magnification"	self redrawNeeded. "redraw even if extent wasn't changed"! !!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 3/14/2011 09:18'!chooseMagnification: evt	| handle origin aHand currentMag |	currentMag _ magnification.	aHand _ evt ifNil: [self currentHand] ifNotNil: [evt hand].	origin _ aHand position y.	handle _ HandleMorph new forEachPointDo:		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].	aHand attachMorph: handle.	handle startStepping.	self redrawNeeded. "Magnify handle"! !!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 3/14/2011 09:19'!keyboardFocusChange: aBoolean	"Notify change due to green border for keyboard focus"	self redrawNeeded! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 3/14/2011 09:17'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| w titleString |	titleString _ titleMorph submorphs first.	self visible: false.	w _ ActiveWorld.	aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		titleString contents: string.		titleMorph width: titleString width + 8.		self setConstrainedPosition: Sensor cursorPoint hangOut: false.		self adjustSubmorphsLayout.		self redrawNeeded.		w displayWorld		 "show myself"	]. 	self delete.	w displayWorld! !!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:19'!fitContents	| newBounds boundsChanged |	newBounds _ self measureContents.	boundsChanged _ bounds extent ~= newBounds.	self extent: newBounds.		"default short-circuits if bounds not changed"	boundsChanged ifFalse: [ self redrawNeeded ]! !!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:20'!fitContents	| newBounds boundsChanged |	newBounds _ self measureContents.	boundsChanged _ bounds extent ~= newBounds.	self extent: newBounds.		"default short-circuits if bounds not changed"	boundsChanged ifFalse: [ self redrawNeeded ]! !!OneLineEditorMorph methodsFor: 'editing' stamp: 'jmv 3/14/2011 09:21'!handleInteraction: interactionBlock	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple the editor to Morphic keyboard events"	| oldEditor oldContents |	oldEditor _ editor.	oldContents _ contents.	interactionBlock value.	oldContents == contents 		ifTrue: [ "this will not work if the paragraph changed"			editor _ oldEditor	"since it may have been changed while in block"].	self redrawNeeded! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:21'!keyboardFocusChange: aBoolean 	aBoolean ifTrue: [		"A hand is wanting to send us characters... Ensure editor."		self editor ].	self redrawNeeded! !!OneLineEditorMorph methodsFor: 'unaccepted edits' stamp: 'jmv 3/14/2011 09:21'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "		self flag: #jmv.	"Not used in this morph, as it doesn't do accept / cancel"	self redrawNeeded! !!OneLineEditorMorph methodsFor: 'private' stamp: 'jmv 3/14/2011 09:21'!installEditorToReplace: priorEditor	"Install an editor for my contents.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [ stateArray _ priorEditor stateArray ].	editor _ SimpleEditor new morph: self.	editor changeString: contents.	stateArray ifNotNil: [ editor stateArrayPut: stateArray ].	self redrawNeeded.	^editor! !!OneLineEditorMorph methodsFor: 'private' stamp: 'jmv 3/14/2011 09:21'!updateFromContents	"O contents deberia ser un StringHolder????"	contents _ editor string.	self redrawNeeded! !!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 3/14/2011 09:22'!extent: aPoint	bounds extent = aPoint ifFalse: [		self redrawNeeded.		bounds _ bounds topLeft extent: aPoint.		self buildMagnifiedBackgroundImage.		self layoutChanged.		self redrawNeeded ].	worldState ifNotNil: [		worldState viewBox ifNotNil: [			worldState viewBox = bounds ifFalse: [				worldState canvas: nil.				worldState viewBox: bounds ]]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 3/14/2011 09:21'!buildMagnifiedBackgroundImage	| image old |	old _ backgroundImage.	backgroundImageData		ifNil: [ backgroundImage _ nil ]		ifNotNil: [ 			image _ Form fromBinaryStream: backgroundImageData readStream.			backgroundImage _ image magnifyTo: bounds extent ].	old == backgroundImage ifFalse: [		self redrawNeeded ]! !!PasteUpMorph methodsFor: 'errors on draw' stamp: 'jmv 3/14/2011 09:22'!removeAllKnownFailing	worldState removeAllKnownFailing.	self redrawNeeded! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:22'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	evt mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].	(self containsPoint: evt cursorPoint) ifTrue: [		isPressed _ true.		self redrawNeeded].	evt hand		waitForSimulatedMouseButton2: self		event: evt		dblClkSel: #doubleClick:! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:22'!mouseEnter: event	"The mouse entered the receiver"	mouseIsOver _ true.	self redrawNeeded.	^super mouseEnter: event! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:22'!mouseLeave: event	"The mouse has left the area of the receiver"	mouseIsOver _ false.	self redrawNeeded.	^super mouseLeave: event! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:22'!mouseUp: evt	isPressed _ false.	mouseIsOver _ false.	(self containsPoint: evt cursorPoint)		ifTrue: [ self performAction ].	self redrawNeeded! !!PluggableButtonMorph methodsFor: 'updating' stamp: 'jmv 3/14/2011 09:22'!update: aParameter "	getLabelSelector ifNotNil: [		aParameter == getLabelSelector ifTrue: [			self label: (model perform: getLabelSelector)]]."	self redrawNeeded! !!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 3/14/2011 09:22'!extent: aPoint	super extent: aPoint.	magnifiedIcon _ nil.	self redrawNeeded! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'jmv 3/14/2011 09:23'!resetPotentialDropRow	potentialDropRow ifNotNil: [	potentialDropRow ~= 0 ifTrue: [		potentialDropRow _ 0.		self redrawNeeded ] ]! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:22'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	"No. Selection might also be shown differently. Invalidate everything"	false		ifTrue: [ self invalidateBorderFeedback ]		ifFalse: [ self redrawNeeded ]! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 3/14/2011 09:23'!mouseEnterDragging: evt	(evt hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ "no d&d"		^ super mouseEnterDragging: evt ].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt )		ifTrue:[			potentialDropRow _ self rowAtLocation: evt position.			evt hand newMouseFocus: self.			self redrawNeeded.			"above is ugly but necessary for now"		]! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:23'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |	event position y < self top 		ifTrue: [			scrollBar scrollUp: 1.			row := self rowAtLocation: scroller topLeft + (1 @ 1)]		ifFalse: [			row _ event position y > self bottom 				ifTrue: [					scrollBar scrollDown: 1.					self rowAtLocation: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^self].	"No change if model is locked"	dragOnOrOff ifNil: [			"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff _ (self listSelectionAt: row) not].	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [ self changeModelSelection: row ]		ifFalse: [ self changeModelSelection: 0 ].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].		"Select all in between if drag was too fast"	"self listSelectionAt: row put: dragOnOrOff."	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |		self listSelectionAt: r put: dragOnOrOff].		row redrawNeeded! !!PluggableListMorphOfMany methodsFor: 'updating' stamp: 'jmv 3/14/2011 09:27'!update: aSymbol 	aSymbol == #allSelections ifTrue: [		self selectionIndex: self getCurrentSelectionIndex.		^ self redrawNeeded].	^ super update: aSymbol! !!PolygonMorph methodsFor: 'dashes' stamp: 'jmv 3/14/2011 09:25'!dashedBorder: dashSpec	"A dash spec is a 3- or 5-element array with		{ length of normal border color.		length of alternate border color.		alternate border color.		starting offset.		amount to add to offset at each step }	Starting offset is usually = 0, but changing it moves the dashes along the curve."	borderDashSpec _ dashSpec.	self redrawNeeded! !!PolygonMorph methodsFor: 'editing' stamp: 'jmv 3/14/2011 09:27'!addHandles	| handle newVert tri |	self removeHandles.	handles _ OrderedCollection new.	tri _ Array with: 0@-4 with: 4@3 with: -3@3.	vertices withIndexDo:		[ :vertPt :vertIndex |		handle _ EllipseMorph newBounds: (Rectangle center: vertPt extent: 8@8)				color: Color yellow.		handle on: #mouseMove send: #dragVertex:event:fromHandle:				to: self withValue: vertIndex.		handle on: #mouseUp send: #dropVertex:event:fromHandle:				to: self withValue: vertIndex.		self addMorph: handle.		handles addLast: handle.		(closed or: [vertIndex < vertices size]) ifTrue: [			newVert _ PolygonMorph					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])					color: Color green borderWidth: 1 borderColor: Color black.			newVert on: #mouseDown send: #newVertex:event:fromHandle:					to: self withValue: vertIndex.			self addMorph: newVert.			handles addLast: newVert]].	smoothCurve ifTrue: [self updateHandles; layoutChanged].	self redrawNeeded! !!PolygonMorph methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:25'!step	borderDashSpec ifNil: [^super step].	borderDashSpec size < 5 ifTrue: [^super step].	"Only for dashed lines with creep"	borderDashSpec at: 4 put: (borderDashSpec fourth) + borderDashSpec fifth.	self redrawNeeded.	^super step! !!PolygonMorph methodsFor: 'private' stamp: 'jmv 3/14/2011 09:25'!computeBounds	| oldBounds delta excludeHandles |	vertices ifNil: [^ self].	self redrawNeeded.	oldBounds _ bounds.	self releaseCachedState.	bounds _ self curveBounds truncated.	self arrowForms do:		[ :f | bounds _ bounds merge: (f offset extent: f extent)].	handles ifNotNil: [self updateHandles].	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [		excludeHandles _ IdentitySet new.		handles ifNotNil: [excludeHandles addAll: handles].		self submorphsDo: [ :each |			(excludeHandles includes: each) ifFalse: [				each position: each position + delta ] ] ].	self layoutChanged.	self redrawNeeded.! !!ProgressBarMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:25'!progressColor: aColor	progressColor = aColor		ifFalse: [			progressColor _ aColor.			self redrawNeeded ]! !!ProgressBarMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:25'!value: aValue	value _ aValue.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 3/14/2011 09:25'!updateDownButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #bottom size: self extent.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 3/14/2011 09:25'!updateLeftButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #left size: self extent.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 3/14/2011 09:25'!updateRightButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #right size: self extent.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 3/14/2011 09:25'!updateUpButtonImage	"update the receiver's as a upButton. put a new image inside"	image _ self class arrowOfDirection: #top size: self extent.	self redrawNeeded! !!ScrollingLabel2LW methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:25'!step	(hideTime notNil and: [		DateAndTime now > hideTime ])			ifTrue: [				^self hide ].	scrollPos _ scrollPos + 1.	scrollPos > contents size ifTrue: [		scrollPos _ 1 ].	self comeToFront.	self redrawNeeded! !!ScrollingLabel2LW methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:25'!label: aString	super label: aString.	scrollPos _ 1.	self redrawNeeded! !!ScrollingLabelLW methodsFor: 'stepping and presenter' stamp: 'jmv 3/14/2011 09:26'!step	(hideTime notNil and: [		DateAndTime now > hideTime ])			ifTrue: [				^self hide ].	scrollPos _ scrollPos + 1.	scrollPos > labelWidth ifTrue: [		self initializeScroll].	self comeToFront.	self redrawNeeded! !!ScrollingLabelLW methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:26'!label: aString	super label: aString.	self initializeScroll.	labelWidth _ self labelWidth.	self redrawNeeded! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2011 09:26'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	"No. Selection might also be shown differently. Invalidate everything"	false		ifTrue: [ self invalidateBorderFeedback ]		ifFalse: [ self redrawNeeded ]! !!SimpleHierarchicalListMorph methodsFor: 'private' stamp: 'jmv 3/14/2011 09:26'!adjustSubmorphPositions	| p h |	p _ 0@0.	scroller submorphsDo: [ :each |		h _ each height.		each privateBounds: (p extent: 9999@h).		p _ p + (0@h) ].	self 		redrawNeeded;		layoutChanged;		setScrollDeltas! !!SketchMorph methodsFor: 'layout' stamp: 'jmv 3/14/2011 09:13'!layoutChanged	"Update rotatedForm and compute new bounds."	self redrawNeeded.	bounds _ bounds origin extent: originalForm extent.	super layoutChanged.	self redrawNeeded! !!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 3/14/2011 09:11'!addToWorld: world near: box	| goodLocation |	goodLocation _ self bestPositionNear: box inWorld: world.	world allMorphsDo:		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:			[(p selector == selector and: [p argument == argument])				ifTrue: [^ p comeToFront  "uncover existing picker"]				ifFalse: ["place second picker relative to first"						goodLocation _ self bestPositionNear: p displayBounds inWorld: world]]]].	self position: goodLocation.	world addMorphFront: self.	self redrawNeeded! !!Sonogram methodsFor: 'all' stamp: 'jmv 3/14/2011 09:26'!scroll	image copy: (scrollDelta@0 extent: (image width-scrollDelta)@image height)			from: image to: 0@0 rule: Form over.	lastX _ lastX - scrollDelta.	self redrawNeeded! !!StarMorph methodsFor: 'handles' stamp: 'jmv 3/14/2011 09:26'!addHandles	| center | 	self removeHandles.	center _ vertices sum // vertices size.   "Average vertices to get the center"	handles _ {center. vertices second} with: {#center. #outside} collect:		[:p :which | (EllipseMorph newBounds: (Rectangle center: p extent: 8@8)							color: Color yellow)				on: #mouseDown send: #dragVertex:event:fromHandle:						to: self withValue: which;				on: #mouseMove send: #dragVertex:event:fromHandle:						to: self withValue: which].	self addAllMorphs: handles.	self redrawNeeded! !!StringMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:26'!contentsClipped: aString	"Change my text, but do not change my size as a result"	contents = aString ifTrue: [^ self].  "No substantive change"	contents _ aString.	self redrawNeeded! !!StringMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:26'!fitContents	| newBounds boundsChanged |	newBounds _ self measureContents.	boundsChanged _ bounds extent ~= newBounds.	self extent: newBounds.		"default short-circuits if bounds not changed"	boundsChanged ifFalse: [self redrawNeeded]! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 3/14/2011 09:16'!unhighlight	complexContents highlightingColor ifNotNil: [self color: Color black].	self redrawNeeded! !!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'jmv 3/14/2011 09:15'!highlight	complexContents highlightingColor ifNotNil: [ self color: complexContents highlightingColor ].	self redrawNeeded! !!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'jmv 3/14/2011 09:15'!openPath: anArray	anArray isEmpty ifTrue: [ ^container setSelectedMorph: nil ].	self withSiblingsDo: [ :each | 		(anArray first isNil or: [each complexContents asString = anArray first]) ifTrue: [			each isExpanded ifFalse: [				each toggleExpandedState.				container adjustSubmorphPositions.			].			each redrawNeeded.			anArray size = 1 ifTrue: [				^container setSelectedMorph: each			].			each firstChild ifNil: [^container setSelectedMorph: nil].			^each firstChild openPath: anArray allButFirst.		].	].	^container setSelectedMorph: nil! !!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'jmv 3/14/2011 09:16'!toggleExpandedState	| newChildren toDelete c |	isExpanded _ isExpanded not.	toDelete _ OrderedCollection new.	firstChild ifNotNil: [		firstChild withSiblingsDo: [ :aNode |			aNode recursiveAddTo: toDelete ]].	container noteRemovalOfAll: toDelete.	(isExpanded and: [ complexContents hasContents ]) ifFalse: [ ^ self redrawNeeded ].	(c _ complexContents contents) isEmpty ifTrue: [ ^ self redrawNeeded ].	newChildren _ container		addSubmorphsAfter: self		fromCollection: c		allowSorting: true.	firstChild _ newChildren first! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:19'!subMenu: aMenuMorph	subMenu _ aMenuMorph.	self redrawNeeded! !!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/14/2011 09:18'!isSelected: aBoolean	isSelected _ aBoolean.	self redrawNeeded! !!SystemWindow methodsFor: 'menu' stamp: 'jmv 3/14/2011 09:27'!setWindowColor: incomingColor	| existingColor aColor |	incomingColor ifNil: [^ self].  "it happens"	aColor _ incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor 		or: [aColor = Color black]) ifTrue: [^ self].	existingColor _ self widgetsColor.	existingColor ifNil: [^ Beeper beep].	self widgetsColor: aColor.	self redrawNeeded! !!SystemWindow methodsFor: 'top window' stamp: 'jmv 3/14/2011 09:27'!activateAndSendTopToBack: aBoolean	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop |	self owner 		ifNil: [^self	"avoid spurious activate when drop in trash"].	oldTop _TopWindow.	TopWindow _ self.	oldTop ifNotNil: [		oldTop passivate.		aBoolean ifTrue: [			oldTop owner addMorphBack: oldTop ]].	self owner firstSubmorph == self 		ifFalse: [			"Bring me (with any flex) to the top if not already"			self owner addMorphFront: self].	self redrawNeeded.	self isCollapsed 		ifFalse: [			model modelWakeUpIn: self]! !!SystemWindow methodsFor: 'top window' stamp: 'jmv 3/14/2011 09:27'!passivate	"Make me unable to respond to mouse and keyboard"	| focus |	focus _ ActiveHand keyboardFocus.	focus ifNotNil: [		(focus ownerThatIsA: SystemWindow) == self			ifTrue: [ ActiveHand releaseKeyboardFocus ]].	model modelSleep.		self world ifNotNil: [  "clean damage now, so dont merge this rect with new top window"		self world == World ifTrue: [self world displayWorld]].	self redrawNeeded! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 3/14/2011 09:27'!setSelection: sel	selectionInterval _ sel.	self editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [ scroller redrawNeeded ]! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 3/14/2011 09:27'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		self redrawNeeded].	aBoolean ifFalse: [hasEditingConflicts _ false].	"shout:  re-style the text iff aBoolean is true	Do not apply any formatting (i.e. changes to the characters in the text),	just styling (i.e. TextAttributes)"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess ]! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 3/14/2011 09:28'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents 		ifTrue: [			"Some day, it would be nice to keep objects and update them			instead of throwing them away all the time for no good reason..."			textMorph releaseParagraph.			self formatAndStyleIfNeeded.			^self].	aSymbol == #acceptedContents ifTrue: [		model refetch.		^self].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self].	aSymbol == #initialSelection 		ifTrue: [^self setSelection: model getSelection].	aSymbol == #autoSelect 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: model autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self redrawNeeded ].	aSymbol == #shoutStyle		ifTrue: [			self stylerStyled.			^self redrawNeeded ].! !!TransformMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:27'!offset: newOffset	| o |	o _ newOffset - self innerBounds topLeft.	txOffset = o ifFalse: [		txOffset _ o.		self redrawNeeded ]! !HandMorph removeSelector: #changed!HaloMorph removeSelector: #changed!Morph removeSelector: #changed!LightWidget removeSelector: #changed!