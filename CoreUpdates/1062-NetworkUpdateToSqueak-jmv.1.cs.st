'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 26 August 2011 at 6:54:45 pm'!!classDefinition: #Socket category: #'Network-Kernel'!Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle readSemaphore writeSemaphore primitiveOnlySupportsOneSemaphore '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry RegistryThreshold TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'Network-Kernel'!!Object methodsFor: 'error handling' stamp: 'ar 3/25/2010 15:23'!primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	self primitiveFailed: thisContext sender selector! !!Object methodsFor: 'error handling' stamp: 'ar 3/25/2010 15:23'!primitiveFailed: selector	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	self error: selector asString, ' failed'! !!NetNameResolver class methodsFor: 'lookups' stamp: 'nice 12/26/2009 18:45'!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	"NetNameResolver		nameForAddress: (NetNameResolver addressFromString: '128.111.92.2')		timeout: 30"	| deadline |	self initializeNetwork.	deadline := Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	^self resolverMutex		critical: [			(self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfAddress: hostAddress.					(self waitForCompletionUntil: deadline)						ifTrue: [self primAddressLookupResult]						ifFalse: [nil]]				ifFalse: [nil]].! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 4/20/2011 01:56'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle := self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle		ifNotNil: [ self register ]		ifNil: [  "socket creation failed"			Smalltalk unregisterExternalObject: semaphore.			Smalltalk unregisterExternalObject: readSemaphore.			Smalltalk unregisterExternalObject: writeSemaphore.			readSemaphore := writeSemaphore := semaphore := nil ]! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 4/20/2011 01:56'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle :=		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle 		ifNotNil: [ self register ]		ifNil: [  "socket creation failed"			Smalltalk unregisterExternalObject: semaphore.			Smalltalk unregisterExternalObject: readSemaphore.			Smalltalk unregisterExternalObject: writeSemaphore.			readSemaphore := writeSemaphore := semaphore := nil ]! !!Socket methodsFor: 'accessing' stamp: 'ul 4/20/2011 01:54'!readSemaphore		^readSemaphore! !!Socket methodsFor: 'accessing' stamp: 'ul 4/20/2011 01:56'!writeSemaphore		^writeSemaphore! !!Socket methodsFor: 'waiting' stamp: 'ul 6/17/2011 12:43'!waitForDataIfClosed: closedBlock	"Wait indefinitely for data to arrive.  This method will block until	data is available or the socket is closed."	[		(self primSocketReceiveDataAvailable: socketHandle)			ifTrue: [^self].		self isConnected			ifFalse: [^closedBlock value].		self readSemaphore wait ] repeat! !!Socket methodsFor: 'primitives' stamp: 'ul 4/20/2011 01:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"		<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ul 4/20/2011 01:56'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'mtf 3/14/2011 20:13'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'mtf 3/14/2011 19:59'!primitiveFailed: selector	SocketPrimitiveFailed signal: selector asString, ' failed'! !!Socket methodsFor: 'datagrams' stamp: 'ul 4/20/2011 01:55'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	[		datagram := self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]] repeat! !!Socket methodsFor: 'datagrams' stamp: 'ul 4/20/2011 01:53'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 16:17'!standardDeadline	"Return a default deadline time some seconds into the future."	^ self deadlineSecs: self standardTimeout! !!SocketStream methodsFor: 'stream out' stamp: 'cmm 1/28/2011 15:15'!nextPutAllFlush: aCollection 	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary		ifTrue: [ aCollection asByteArray ]		ifFalse: [ aCollection asString ].	self flush.	"first flush pending stuff, then directly send"	socket isOtherEndClosed ifFalse:		[ [ self			sendData: toPut			count: toPut size ]			on: ConnectionTimedOut			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ] ]! !!SocketStream methodsFor: 'control' stamp: 'cmm 1/28/2011 15:15'!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	(outNextToWrite > 1 and: [ socket isOtherEndClosed not ]) ifTrue:		[ [ self			sendData: outBuffer			count: outNextToWrite - 1 ]			on: ConnectionTimedOut			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ].		outNextToWrite := 1 ]! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:15'!receiveData	self waitForData.	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:09'!signalClosed	self shouldSignal ifFalse: [^ self]. 	ConnectionClosed signal: 'Connection closed while waiting for data.'! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:10'!signalTimeout	self shouldSignal ifFalse: [^ self]. 	ConnectionTimedOut signal: 'Data receive timed out.'! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:16'!waitForData	"Wait for data. If shouldTimeout, we will time out if nothing arrives, otherwise we wait indefinitely"	self shouldTimeout		ifTrue: [socket waitForDataFor: self timeout			ifClosed: [self signalClosed]			ifTimedOut: [self signalTimeout]]		ifFalse: [socket waitForDataIfClosed: [self signalClosed]]! !Socket removeSelector: #primitiveOnlySupportsOneSemaphore!!classDefinition: #Socket category: #'Network-Kernel'!Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle readSemaphore writeSemaphore'	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry RegistryThreshold TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection'	poolDictionaries: ''	category: 'Network-Kernel'!