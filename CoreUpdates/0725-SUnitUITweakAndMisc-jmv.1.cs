'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 21 December 2010 at 6:23:30 pm'!!Inspector commentStamp: '<historical>' prior: 0!I represent a query path into the internal representation of an object. As a TextProvider, the string I represent is the value of the currently selected variable of the observed object.!!ContextVariablesInspector commentStamp: '<historical>' prior: 0!I represent a query path into the internal representation of a ContextPart. Typically this is a context at a point in the query path of a Debugger. As a TextProvider, the string I represent is the value of the currently selected variable of the observed temporary variable of the context.!!MessageSet commentStamp: '<historical>' prior: 0!I represent a query path of the retrieval result of making a query about methods in the system. The result is a set of methods, denoted by a message selector and the class in which the method was found. As a TextProvider, the string I represent is the source code of the currently selected method. I am typically viewed in a Message Set Browser consisting of a MessageListView and a BrowserCodeView.!!OneLineEditorMorph commentStamp: '<historical>' prior: 0!A plain text editor for Morphic. Handles only one line. Does not handle fonts/styles, alignment, Smalltalk utilities and any other advanced stuff in TextModelMorph. Just a simple text editor.!!TextComposer commentStamp: '<historical>' prior: 0!Aux class for Paragraph. My instances are usually transient, and therefore don't need a TextModel, but just a Text with the current contents.!!SyntaxError commentStamp: '<historical>' prior: 0!I represent syntax error report for syntax errors encountered when filing in class descriptions from a non-interactive source such as an external file. As a TextProvider, the string to be viewed is the method code or expression containing the error.The user may fix the error and accept the method to continue the fileIn.!!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 12/21/2010 14:37'!model: aTextModel wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result.""Why was this ever needed?""	self newContents: ''."	wrapFlag _ true.	self basicExtent: width truncated@self height.	self model: aTextModel.	"update the paragraph cache"	self paragraph.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/21/2010 14:37'!assurePostscriptExists	"Make sure there is a TextModel holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript		ifNil: [			self postscriptString: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/21/2010 14:37'!assurePreambleExists	"Make sure there is a TextModel holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble actualContents isEmptyOrNil])		ifTrue: [preamble _ TextModel new actualContents: self preambleTemplate]! !!Editor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:46'!beginningOfLine: position	"Redefined in subclasses using Paragraph support"	^ self beginningOfParagraph: position! !!Editor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:46'!endOfLine: position	"Redefined in subclasses using Paragraph support"	^self endOfParagraph: position! !!Paragraph methodsFor: 'composition' stamp: 'jmv 12/21/2010 14:48'!recomposeFrom: start to: stop delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed."	| startLine newLines |	"Have to recompose line above in case a word-break was affected."	startLine _ (self lineIndexFor: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	newLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].	self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top! !!Paragraph methodsFor: 'editing' stamp: 'jmv 12/21/2010 14:42'!replaceFrom: start to: stop with: aText	"Edit the text, and then recompose the lines."	"jmv: I believe this should better be done in TextEditor.	For instance, someday, we might be applying recorded commands, without a GUI.	In such case we could have TextModel and TextEditor but no morphs or paragraph.	(Food for thought)"		| intervalToFix |	"in ANY case, this should be done at the model..."	self text replaceFrom: start to: stop with: aText.		"The interval actually modified in text can begin before start, because of paragraph attributes"	intervalToFix _ self text encompassParagraph: (start to: start + aText size - 1).	self		recomposeFrom: intervalToFix first		to: intervalToFix last		delta: aText size - (stop-start+1)! !!Paragraph methodsFor: 'selection' stamp: 'jmv 12/21/2010 14:47'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line t |	line _ lines at: (self lineIndexFor: index).	t _ self text.	^ (CharacterBlockScanner new text: t)		characterBlockAtPoint: nil index: ((index max: line first) min: t size+1)		in: line! !!Paragraph methodsFor: 'selection' stamp: 'jmv 12/21/2010 14:48'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ 6.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexFor: cb1 stringIndex.	line2 _ self lineIndexFor: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [ :i |		| line |		line _ lines at: i.		(line left = rects last left and: [ line right = rects last right ])			ifTrue: [ "new line has same margins as old one -- merge them, so that the caller gets as few rectangles as possible"					| lastRect |					lastRect _ rects removeLast.					rects add: (lastRect bottom: line bottom) ]			ifFalse: [ "differing margins; cannot merge"					rects add: line rectangle ] ].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!Paragraph methodsFor: 'private' stamp: 'jmv 12/21/2010 14:47'!lineIndexFor: characterIndex	"Answer the index of the line in which to select the character at index."	^ (self fastFindFirstLineSuchThat: [:line | line first > characterIndex]) - 1 max: 1! !!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 12/21/2010 16:44'!smallFonts	"Sets not only fonts but other GUI elements	to fit low resolution or small screens	Preferences smallFonts	"		Preferences setDefaultFonts: #(		(setSystemFontTo: 'DejaVu' 8)		(setListFontTo: 'DejaVu' 8)		(setMenuFontTo: 'DejaVu' 8)		(setWindowTitleFontTo: 'DejaVu' 11)		(setBalloonHelpFontTo: 'DejaVu' 8)		(setCodeFontTo: 'DejaVu' 8)		(setButtonFontTo: 'DejaVu' 8)).	Preferences disable: #biggerCursors! !!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 12/21/2010 16:44'!verySmallFonts	"Sets not only fonts but other GUI elements	to fit low resolution or small screens	Preferences verySmallFonts	"		Preferences setDefaultFonts: #(		(setSystemFontTo: 'DejaVu' 8)		(setListFontTo: 'DejaVu' 7)		(setMenuFontTo: 'DejaVu' 7)		(setWindowTitleFontTo: 'DejaVu' 9)		(setBalloonHelpFontTo: 'DejaVu' 7)		(setCodeFontTo: 'DejaVu' 7)		(setButtonFontTo: 'DejaVu' 7)).	Preferences disable: #biggerCursors! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 12/21/2010 16:53'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ self maximumUsableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ self maximumUsableArea insetBy: (			self scrollBarSetback @ self screenTopSetback extent: 0@0		).		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: 48@40 * Preferences standardCodeFont height ].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!TestRunner methodsFor: 'constants' stamp: 'jmv 12/21/2010 16:27'!runButtonLabel        ^ 'Run all selected'! !!TestRunner methodsFor: 'constants' stamp: 'jmv 12/21/2010 16:28'!runOneButtonLabel        ^ 'Run last selected'! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 12/21/2010 16:30'!buildUpperControls	| refreshButton filterButton stopButton runOneButton runButton row bWidth listsMorph bWidth2 |	row _ AlignmentMorph proportional.	refreshButton _ self buildRefreshButton.	filterButton _ self buildFilterButton.	stopButton _ self buildStopButton.	runOneButton _ self buildRunOneButton.	runButton _ self buildRunButton.	listsMorph _ self buildTestsList.	bWidth _ 80.	bWidth2 _ 120.	row		addMorph: refreshButton		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 0.33)				offsets: (0 @ 0 corner: bWidth @ 0)).	row		addMorph: filterButton		fullFrame: (LayoutFrame				fractions: (0 @ 0.33 corner: 0 @ 0.66)				offsets: (0 @ 0 corner: bWidth @ 0)).	row		addMorph: stopButton		fullFrame: (LayoutFrame				fractions: (0 @ 0.66 corner: 0 @ 1)				offsets: (0 @ 0 corner: bWidth @ 0)).	row		addMorph: listsMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (bWidth  @ 0 corner: bWidth2 negated @ 0)).	row		addMorph: runOneButton		fullFrame: (LayoutFrame				fractions: (1 @ 0 corner: 1 @ 0.5)				offsets: (bWidth2 negated @ 0 corner: 0 @ 0)).	row		addMorph: runButton		fullFrame: (LayoutFrame				fractions: (1 @ 0.5 corner: 1 @ 1)				offsets: (bWidth2 negated @ 0 corner: -0 @ 0)).	^ row! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/21/2010 14:48'!inOutdent: aKeyboardEvent delta: delta	"Add/remove a tab at the front of every line occupied by the selection. 	Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |	cr _ Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart _ self startIndex.	realStop _ self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and: [				realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue: [					morph flash]				ifFalse: [					self replaceSelectionWith: Character tab asSymbol.					self selectAt: realStart + 1].			^true].	lines _ paragraph lines.	startLine _ paragraph lineIndexFor: realStart.	stopLine _ paragraph lineIndexFor: (realStart max: realStop).	start _ (lines at: startLine) first.	stop _ (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart _ realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation _ (startLine to: stopLine) inject: 1000 into: [ :previousValue :each |		previousValue min: (paragraph indentationOfLineIndex: each ifBlank: [ :tabs | 1000 ])].				size _  stop + 1 - start.	numLines _ stopLine + 1 - startLine.	inStream _ ReadStream on: paragraph string from: start to: stop.	newString _ String new: size + ((numLines * delta) max: 0).	outStream _ ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].	realStop _ realStop + outStream position - size.	"Prepare for another iteration"	indentation _ indentation + delta.	size _ outStream position.	inStream _ outStream setFrom: 1 to: size.	outStream		ifNil: [ 	"tried to outdent but some line(s) were already left flush"			morph flash]		ifNotNil: [			self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString _ outStream contents].			self replaceSelectionWith: newString].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:48'!beginningOfLine: position	"Redefined in subclasses using Paragraph support"	^ (paragraph lines at:(paragraph lineIndexFor: position)) first! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:49'!endOfLine: position	"Redefined in subclasses using Paragraph support"	| targetLine |	targetLine _ paragraph lines at: (paragraph lineIndexFor: position).	^ targetLine = paragraph lastLine		ifFalse: [ targetLine last ]		ifTrue: [ targetLine last + 1 ]! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:48'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle _ Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines _ paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  _ paragraph lineIndexFor: start.			currentLine _ lines at: currentLineNumber]		ifFalse: [			lines _ self lines.			numberOfLines := lines size.			currentLine _ lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber _ currentLine second].	column _ start - currentLine first.	targetLineNumber _ ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine _ (lines at: targetLineNumber) first.	targetEOL _ (lines at: targetLineNumber) last + (targetLineNumber = numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber = currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 12/21/2010 14:43'!openLabel: aString 	"Create a standard system view of the model, me, and open it."	self openAsMorphLabel: aString! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 12/21/2010 14:44'!openLabel: aString wrap: aBoolean	"Create a standard system view of the model, me, and open it."	self openInMorphicWindowLabeled: aString wrap: aBoolean! !!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 12/21/2010 14:45'!vmStatisticsReportString	"	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'	"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := Smalltalk getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr			';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr			';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 12/21/2010 14:45'!vmStatisticsShortString	"Convenience item for access to recent statistics only"	"	(TextModel new contents: Utilities vmStatisticsShortString) openLabel: 'VM Recent Statistics'	"	^ (ReadStream on: self vmStatisticsReportString) upToAll: 'Since'; upTo: Character cr; upToEnd! !TextModel class removeSelector: #initialize!Paragraph removeSelector: #lineIndexForCharacter:!Paragraph removeSelector: #lineIndexOfCharacterIndex:!