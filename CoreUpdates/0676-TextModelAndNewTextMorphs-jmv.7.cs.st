'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 27 November 2010 at 1:12:01 am'!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model text wrapFlag paragraph editor pauseBlinking editView acceptOnCR '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!classDefinition: #PluggableTextModel category: #'System-Text'!TextModel subclass: #PluggableTextModel	instanceVariableNames: 'contentsProvider textProvider getTextSelector setTextSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!PluggableTextModel commentStamp: '<historical>' prior: 0!A TextModel whose contents are stored elsewhere (ivar contentsProvider)!!classDefinition: #TextModelMorph category: #'Morphic-Windows'!ScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph getTextSelector setTextSelector getSelectionSelector hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval hasEditingConflicts editorClass styler'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!TextModelMorph commentStamp: '<historical>' prior: 0!Comment about Shout specifics:Instances of me are usually created using my #on:text:accept:readSelection:menu: class method.In order to colour the text, I use an instance of SHTextStylerST80, which I store in my 'styler' instance variable.When my setText: method is called, I use my styler to ...	a) optionally set all assignments to ansi or leftArrow. 	b) Colour my text (immediately, if the text is less than 4096 chars in length, or in a backgroundProcess otherwise)	When my text is changed, my hasUnacceptedEdits: method is called with true, and I ask my styler to re-colour my text. This is performed in a background process so that typing remains responsive regardless of the length of the text.	Just before my styler is about to format/style the text, I send #stylerAboutToStyle:  to my model. This gives my model a chance to veto the styling (by answering false), or to initialize the styler with information it needs in order to parse the text correctly (e.g. the class to which a method belongs, or the workspace in which I am contained).	My styler informs me that it has finished styling by triggering the #stylerStyled: and #stylerStyledInBackground: events which I handle. I then update the textAttributes of my text and refresh the display. 	My 'unstyledAcceptText' instance variable is used in conjunction with my #acceptTextInModel and #correctFrom:to:with: methods to ensure that when my text is modified during a method compilation (removing unused vars etc), I do not lose those changes.	!!classDefinition: #TextProvider category: #'System-Text'!Model subclass: #TextProvider	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!TextProvider commentStamp: '<historical>' prior: 0!A superclass for text providing models. To be used together with a PluggableTextModel.!!classDefinition: #CodeProvider category: #'System-Text'!TextProvider subclass: #CodeProvider	instanceVariableNames: 'acceptedContentsCache currentCompiledMethod contentsSymbol '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #FileList category: #'Tools-FileList'!TextProvider subclass: #FileList	instanceVariableNames: 'acceptedContentsCache fileName directory volList volListIndex list listIndex pattern sortMode brevityState sortAscending '	classVariableNames: 'FileReaderRegistry RecentDirs '	poolDictionaries: ''	category: 'Tools-FileList'!!classDefinition: #Inspector category: #'Tools-Inspector'!TextProvider subclass: #Inspector	instanceVariableNames: 'acceptedContentsCache object selectionIndex timeOfLastListUpdate selectionUpdateTime context '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 23:48'!contentsAsIs: stringOrText	"Accept new text contents with line breaks only as in the text.	Fit my width and height to the result."	wrapFlag _ false.	model actualContents: stringOrText! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 19:05'!model: aTextModel	model _ aTextModel.	self releaseParagraph.	"So the model is properly set on the editor and the paragraph"! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 19:08'!model: aTextHolder wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result.""Why was this ever needed?""	self newContents: ''."	wrapFlag _ true.	self basicExtent: width truncated@self height.	self model: aTextHolder.	"update the paragraph cache"	self paragraph.! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 19:11'!text	^ model actualContents! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 18:40'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	"...Code here to recreate the paragraph..."	paragraph _ Paragraph new.	paragraph focused: self hasKeyboardFocus.	paragraph		model: model		in: self container.	wrapFlag ifFalse: [		"Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 21:25'!updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	"removed multiple lined paragraph support (predecessor and successor)"	| sel oldEditor |	paragraph ifNotNil: [		wrapFlag ifNil: [ wrapFlag := true ].		editor ifNotNil: [			oldEditor := editor.			sel := editor selectionInterval.			editor storeSelectionInParagraph].		self fit.		self layoutChanged.		sel ifNotNil: [			editor ifNil: [				"Reinstate selection after, eg, style change"				self installEditorToReplace: oldEditor]]].	editView setScrollDeltas! !!FillInTheBlankMorph methodsFor: 'TextModel compatibility' stamp: 'jmv 11/25/2010 23:00'!isCodeProvider	^false! !!NewParagraph methodsFor: 'composition' stamp: 'jmv 11/27/2010 00:53'!model: aTextModel in: textContainer	text _ aTextModel actualContents.	container _ textContainer.	self composeAll! !!ObjectExplorer methodsFor: 'misc' stamp: 'jmv 11/25/2010 23:09'!contentsProvider	^self! !!ObjectExplorer methodsFor: 'misc' stamp: 'jmv 11/25/2010 23:08'!isCodeProvider	^false! !!ObjectExplorer methodsFor: 'misc' stamp: 'jmv 11/27/2010 01:08'!textProvider	^self! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 18:59'!text	^ model actualContents! !!Paragraph methodsFor: 'composition' stamp: 'jmv 11/25/2010 18:40'!model: aTextModel in: textContainer	"Cambiar los senders, en realidad deben mandarnos un textHolder!!!!!!!!!!"	model _ aTextModel.	container _ textContainer.	self composeAll! !!Paragraph methodsFor: 'editing' stamp: 'jmv 11/25/2010 21:25'!replaceFrom: start to: stop with: aText	"Edit the text, and then recompose the lines."	"jmv: I believe this should better be done in TextEditor.	For instance, someday, we might be applying recorded commands, without a GUI.	In such case we could have TextHolder and TextEditor but no morphs or paragraph.	(Food for thought)"		| intervalToFix |	"in ANY case, this should be done at the model..."	self text replaceFrom: start to: stop with: aText.		"The interval actually modified in text can begin before start, because of paragraph attributes"	intervalToFix _ self text encompassParagraph: (start to: start + aText size - 1).	self		recomposeFrom: intervalToFix first		to: intervalToFix last		delta: aText size - (stop-start+1)! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'jmv 11/26/2010 23:54'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self hasUnacceptedEdits							ifTrue: [								model wantsDiffFeedback									ifTrue: [										bw _ 4.										bc _ Color green]									ifFalse: [										bc _ Color red]]							ifFalse: [								model wantsDiffFeedback									ifTrue: [										bc _ Color green]									ifFalse: []]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ ColorTheme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle width: bw color: bc ]! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'jmv 11/25/2010 22:55'!wantsFrameAdornments	"Answer whether the receiver wishes to have red borders, etc., used to show editing state"	"A 'long-term temporary workaround': a nonmodular, unsavory, but expedient way to get the desired effect, sorry.  Clean up someday."	model isCodeProvider ifFalse: [^false].	^ (#(annotation searchString infoViewContents) includes: getTextSelector) not! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'jmv 11/26/2010 23:56'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	textToAccept := textMorph text.	ok := setTextSelector isNil or: [					setTextSelector numArgs = 2 						ifTrue: [							model 								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [ model perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: [			self setText: self getText.			self hasUnacceptedEdits: false.			(model dependents				detect: [ :dep | 					(dep isKindOf: PluggableTextMorph) 						and: [ dep getTextSelector == #annotation ]]				ifNone: nil) ifNotNil: [ :aPane | model changed: #annotation ]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!PluggableTextMorph methodsFor: 'updating' stamp: 'jmv 11/25/2010 23:39'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: 			[self setText: self getText.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: 			[self handleEdit: 					[TextEditor abandonChangeText.	"no replacement!!"					(textMorph editor)						setSearch: model autoSelectString;						againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: 			[self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: 			[self handleEdit: [self appendEntry].			^self refreshWorld].	aSymbol == #clearText 		ifTrue: 			[self handleEdit: [self changeText: Text new].			^self refreshWorld].	aSymbol == #codeChangedElsewhere 		ifTrue: 			[self hasEditingConflicts: true.			^self changed]! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2010 01:11'!model: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	|styler answer |false ifTrue: [	answer _ TextModelMorph new].	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ anObject respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel		menuGetter: getMenuSel.	^answer! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2010 01:11'!noShoutModel: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	| answer |false ifTrue:[	answer _ TextModelMorph new ].	answer _ self new.	answer		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel		menuGetter: getMenuSel.	^answer! !!SmalltalkEditor methodsFor: 'private' stamp: 'jmv 11/27/2010 01:08'!codeProvider	^model textProvider! !!TextModel methodsFor: 'accessing' stamp: 'jmv 11/27/2010 00:17'!contentsProvider	^self! !!TextModel methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:08'!textProvider	^self! !!TextModel methodsFor: 'self-updating' stamp: 'jmv 11/26/2010 23:44'!updatePaneIfNeeded	"Nothing to do here"	"discutible!!"! !!TextModel methodsFor: 'misc' stamp: 'jmv 11/26/2010 23:43'!forceRefetch	"Nothing here"	"discutible!!"! !!TextModel methodsFor: 'misc' stamp: 'jmv 11/25/2010 22:55'!isCodeProvider	^false! !!PluggableTextModel methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:02'!actualContents	actualContents ifNil: [ self forceRefetch ].	^actualContents! !!PluggableTextModel methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:02'!getTextSelector: symbol1 setTextSelector: symbol2	"y por lo tanto, eliminarlos de los morphs!!"	getTextSelector _ symbol1.	setTextSelector _ symbol2! !!PluggableTextModel methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:06'!textProvider	^textProvider! !!PluggableTextModel methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:07'!textProvider: aTextProvider	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."	textProvider _ aTextProvider! !!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 11/27/2010 01:02'!refusesToAccept	^contentsProvider refusesToAccept! !!PluggableTextModel methodsFor: 'self-updating' stamp: 'jmv 11/27/2010 01:02'!updatePaneIfNeeded	"revisar estos delegadores..."	contentsProvider updatePaneIfNeeded! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 11/27/2010 01:02'!forceRefetch	contentsProvider setContentsToForceRefetch.	actualContents _ contentsProvider acceptedContents: getTextSelector! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 11/27/2010 01:02'!isCodeProvider	^contentsProvider isCodeProvider! !!PluggableTextModel class methodsFor: 'instance creation' stamp: 'jmv 11/27/2010 01:07'!on: aTextProvider	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."	^self basicNew textProvider: aTextProvider! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:10'!editor	^textMorph ifNotNil: [ textMorph editor ]! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:10'!editorClass	^editorClass! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:10'!getTextSelector	^getTextSelector! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:10'!textMorph	^ textMorph! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:10'!wrapFlag: aBoolean	textMorph wrapFlag: aBoolean! !!TextModelMorph methodsFor: 'dependents access' stamp: 'jmv 11/27/2010 01:10'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!TextModelMorph methodsFor: 'dependents access' stamp: 'jmv 11/27/2010 01:10'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ hasUnacceptedEdits! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 11/27/2010 01:10'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self hasUnacceptedEdits							ifTrue: [								model wantsDiffFeedback									ifTrue: [										bw _ 4.										bc _ Color green]									ifFalse: [										bc _ Color red]]							ifFalse: [								model wantsDiffFeedback									ifTrue: [										bc _ Color green]									ifFalse: []]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ ColorTheme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle width: bw color: bc ]! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 11/27/2010 01:10'!wantsFrameAdornments	"Answer whether the receiver wishes to have red borders, etc., used to show editing state"	"A 'long-term temporary workaround': a nonmodular, unsavory, but expedient way to get the desired effect, sorry.  Clean up someday."	model isCodeProvider ifFalse: [^false].	^ (#(annotation searchString infoViewContents) includes: getTextSelector) not! !!TextModelMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 11/27/2010 01:10'!wantsDroppedMorph: aMorph event: anEvent 	^false! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/27/2010 01:10'!handleEdit: editBlock	| result |	self editor		selectFrom: selectionInterval first to: selectionInterval last;		model: model.  "For, eg, evaluateSelection"		"mandar model: aca?????"	textMorph handleEdit: [ result _ editBlock value ].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/27/2010 01:10'!scrollSelectionIntoView	"Scroll my text into view if necessary and return true, else return false"	^ self scrollSelectionIntoView: nil! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/27/2010 01:10'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest cpHere |	selectionInterval _ self editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [event anyButtonPressed]) ifTrue: [  "Check for autoscroll"		cpHere _ scroller externalizePosition: event cursorPoint to: self.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ textMorph bounds: rectToTest in: self.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/27/2010 01:10'!selectAll	"Tell my textMorph's editor to select all"	textMorph selectAll! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/27/2010 01:10'!doubleClick: event	textMorph doubleClick: event! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/27/2010 01:10'!handlesKeyboard	self flag: #jmv.	"Not answering true helps not hitting pluggable texts twice during navigation. Only the internal text morph will receive it.	If some problem is found, introduce a new selector, that answers ^self handlesKeyboard in morph (and LW) 	and only in this class it will answer false""	^self visible" 	^ super handlesKeyboard! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/27/2010 01:10'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	textMorph keyStroke: evt.	self eventHandler ifNotNil: [		self eventHandler keyStroke: evt fromMorph: self ]! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/27/2010 01:10'!mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: textMorph ]! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/27/2010 01:10'!mouseLeave: event	"The mouse has left the area of the receiver"	self editor ifNotNil: [ :e | selectionInterval _ e selectionInterval ].	super mouseLeave: event! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/27/2010 01:10'!extent: newExtent 	super extent: newExtent.	textMorph ifNotNil: [ textMorph extent: self viewableWidth @ self height ].	self setScrollDeltas! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/27/2010 01:10'!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph ifNotNil: [		"the current selection gets munged by resetting the extent, so store it"		tempSelection _ self selectionInterval.		self extent: self extent.		self setSelection: tempSelection]! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/27/2010 01:10'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	scroller hasSubmorphs ifFalse: [ ^1].	^ scroller firstSubmorph defaultLineHeight! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/27/2010 01:10'!acceptOnCR: trueOrFalse	textMorph acceptOnCR: trueOrFalse! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/27/2010 01:10'!editString: aString 	"Jam some text in.  This is treated as clean text by default."	self changeText: aString asText! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/27/2010 01:10'!initialize	super initialize.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.	askBeforeDiscardingEdits _ true.	textMorph _ BareTextMorph new.	textMorph setEditView: self.	scroller addMorph: textMorph! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/27/2010 01:10'!model: o	"Set my model and make me me a dependent of the given object."	| anObject |	anObject _ o.	(anObject isKindOf: TextModel) ifFalse: [		anObject _ PluggableTextModel on: o.		anObject getTextSelector: getTextSelector setTextSelector: setTextSelector ].		super model: anObject.	textMorph		model: model wrappedTo: self viewableWidth.! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/27/2010 01:10'!model: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	editorClass _ anEditorClass.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	getMenuSelector _ getMenuSel.	self borderWidth: 1.	self model: anObject.	model forceRefetch.	self maybeStyle.		self setSelection: self getSelection.! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!correctFrom: start to: stop with: aString	^ self handleEdit: [ self editor correctFrom: start to: stop with: aString ]! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!correctSelectionWithString: aString	| result newPosition |	"I can't tell if this is a hack or if it's the right thing to do."	self setSelection: selectionInterval. 	result _ self correctFrom: selectionInterval first to: selectionInterval last with: aString.	newPosition _ selectionInterval first + aString size.	self setSelection: (newPosition to: newPosition - 1).	^ result! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!deselect	^ self editor deselect! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!nextTokenFrom: start direction: dir	^ self editor nextTokenFrom: start direction: dir! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!notify: aString at: anInteger in: aStream	^ self editor notify: aString at: anInteger in: aStream! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!selectFrom: start to: stop	^ self editor selectFrom: start to: stop! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!selectInvisiblyFrom: start to: stop	^ self editor selectInvisiblyFrom: start to: stop! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 11/27/2010 01:10'!selectionInterval	^ self editor selectionInterval! !!TextModelMorph methodsFor: 'layout' stamp: 'jmv 11/27/2010 01:10'!acceptDroppingMorph: aMorph event: evt 	"This message is sent when a morph is dropped onto a morph that has     	agreed to accept the dropped morph by responding 'true' to the     	wantsDroppedMorph:Event: message. The default implementation just     	adds the given morph to the receiver."	"Here we let the model do its work."	self model		acceptDroppingMorph: aMorph		event: evt		inMorph: self.! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	textToAccept := textMorph text.	ok := setTextSelector isNil or: [					setTextSelector numArgs = 2 						ifTrue: [							model textProvider								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [ model textProvider perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: [			model forceRefetch.			self maybeStyle.			self hasUnacceptedEdits: false.			(model dependents				detect: [ :dep | 					(dep isKindOf: PluggableTextMorph) 						and: [ dep getTextSelector == #annotation ]]				ifNone: nil) ifNotNil: [ :aPane | model changed: #annotation ]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!again	self handleEdit: [ self editor again ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!browseChangeSetsWithSelector	"Help the user track down which change sets mention a particular selector"	self handleEdit: [ self editor browseChangeSetsWithSelector ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!browseIt	self handleEdit: [ self editor browseIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!cancel	model forceRefetch.	self maybeStyle.	self setSelection: self getSelection.	getTextSelector == #annotation ifFalse: [		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [				dep getTextSelector == #annotation]] ifNone: nil)					ifNotNil: [:aPane | 						model changed: #annotation]]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!changeStyle	self handleEdit: [ self editor changeStyle ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!chooseAlignment	self handleEdit: [ self editor changeAlignment ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!classCommentsContainingIt	self handleEdit: [ self editor classCommentsContainingIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!classNamesContainingIt	self handleEdit: [ self editor classNamesContainingIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!copySelection	self handleEdit: [ self editor copySelection ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!cut	self handleEdit: [ self editor cut ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!debugIt	self handleEdit: [ self editor debugIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!doIt	self handleEdit: [ self editor evaluateSelection ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!explain	self handleEdit: [ self editor explain ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!exploreIt	| result |	self handleEdit: [		result _ self editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [ self flash ]			ifFalse:  [result explore ]]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!fileItIn	self handleEdit: [ self editor fileItIn ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!find	self handleEdit: [ self editor find ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!findAgain	self handleEdit: [ self editor findAgain ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!implementorsOfIt	self handleEdit: [ self editor implementorsOfIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!inspectIt	| result |	self handleEdit: [		result _ self editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [ self flash ]			ifFalse: [ result inspect ]]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!methodNamesContainingIt	self handleEdit: [ self editor methodNamesContainingIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!methodSourceContainingIt	self handleEdit: [ self editor methodSourceContainingIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!methodStringsContainingit	self handleEdit: [ self editor methodStringsContainingit ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!offerFontMenu	self handleEdit: [ self editor changeTextFont ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!paste	self handleEdit: [ self editor paste ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!pasteRecent	"Paste an item chosen from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self handleEdit: [ self editor paste ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!prettyPrint	self handleEdit: [ self editor prettyPrint ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!printIt	| result oldEditor |	self editor		selectFrom: selectionInterval first to: selectionInterval last;		model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result _ (oldEditor _ textMorph editor) evaluateSelection].	((result isKindOf: FakeClassPool) or: [result == #failedDoit]) ifTrue: [^self flash].	selectionInterval _ oldEditor selectionInterval.	textMorph installEditorToReplace: oldEditor.	textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	selectionInterval _ oldEditor selectionInterval.		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.	self scrollSelectionIntoView.! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!referencesToIt	self handleEdit: [ self editor referencesToIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!saveContentsInFile	self handleEdit: [ self editor saveContentsInFile ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!sendersOfIt	self handleEdit: [ self editor sendersOfIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!setSearchString	self handleEdit: [ self editor setSearchString ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!undo	self handleEdit: [ self editor undo ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 11/27/2010 01:10'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	^self yellowButtonActivity: false! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/27/2010 01:10'!getSelection	"Answer the model's selection interval."	getSelectionSelector ifNil: [^1 to: 0].	"null selection"	^model textProvider perform: getSelectionSelector! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/27/2010 01:10'!selectionInterval: sel	selectionInterval _ sel! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/27/2010 01:10'!setSelection: sel	selectionInterval _ sel.	self editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [ scroller changed ]! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/27/2010 01:10'!setTextColor: aColor	"Set the color of my text to the given color"	textMorph color: aColor! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/27/2010 01:10'!text	^ model actualContents! !!TextModelMorph methodsFor: 'scroll bar events' stamp: 'jmv 11/27/2010 01:10'!yellowButtonActivity: shiftKeyState	"Invoke the text-editing menu"	| menu |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu invokeModal]! !!TextModelMorph methodsFor: 'transcript' stamp: 'jmv 11/27/2010 01:10'!appendEntry	"Append the text in the model's writeStream to the editable text. "	textMorph text size > model characterLimit ifTrue: [		"Knock off first half of text"		self selectInvisiblyFrom: 1 to: textMorph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: textMorph text size + 1 to: textMorph text size.	self replaceSelectionWith: model contents asText.	"model IS a TranscriptStream"	self selectInvisiblyFrom: textMorph text size + 1 to: textMorph text size! !!TextModelMorph methodsFor: 'transcript' stamp: 'jmv 11/27/2010 01:10'!changeText: aText	"The paragraph to be edited is changed to aText."	model actualContents: aText! !!TextModelMorph methodsFor: 'transcript' stamp: 'jmv 11/27/2010 01:10'!replaceSelectionWith: aText	^ self editor replaceSelectionWith: aText! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/27/2010 01:10'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/27/2010 01:10'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/27/2010 01:10'!hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/27/2010 01:10'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		self changed].	aBoolean ifFalse: [hasEditingConflicts _ false].	"shout:  re-style the text iff aBoolean is true"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess: model actualContents ]! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 11/27/2010 01:10'!promptForCancel	"Ask if it is OK to cancel changes to text"	(self confirm:'Changes have not been saved.Is it OK to cancel those changes?' translated)		ifTrue: [ model textProvider clearUserEditFlag ].! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 11/27/2010 01:10'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: [			model forceRefetch.			self maybeStyle.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: model textProvider autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ]! !!TextModelMorph methodsFor: 'scrolling' stamp: 'jmv 11/27/2010 01:10'!hTotalScrollRange"Return the width of the widest item in the list"	textMorph ifNil: [ ^0 ].	textMorph isWrapped ifTrue:[ ^0 ].	^super hTotalScrollRange! !!TextModelMorph methodsFor: 'scrolling' stamp: 'jmv 11/27/2010 01:10'!mightNeedHorizontalScrollBar	textMorph ifNil: [ ^false ].	textMorph isWrapped ifTrue: [ ^false ].	^super mightNeedHorizontalScrollBar! !!TextModelMorph methodsFor: 'focus handling' stamp: 'jmv 11/27/2010 01:10'!focusText	self activeHand newKeyboardFocus: textMorph! !!TextModelMorph methodsFor: 'menu' stamp: 'jmv 11/27/2010 01:10'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key. The third argument, if required, is the editorClass."	| menu aMenu aTitle |	getMenuSelector		ifNil: [^ nil].	getMenuSelector numArgs = 3 ifFalse: [		^super getMenu: shiftKeyState ].		menu _ MenuMorph new defaultTarget: model textProvider.	aTitle _ getMenuTitleSelector ifNotNil: [model textProvider perform: getMenuTitleSelector].	aMenu _ model textProvider perform: getMenuSelector with: menu with: shiftKeyState with: editorClass.	aTitle ifNotNil:  [aMenu addTitle: aTitle].	^ aMenu! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/27/2010 01:10'!maybeStyle	| formattedText |	self okToStyle ifFalse: [ ^self ].	formattedText _ (styler format: self text).	model actualContents: formattedText.	formattedText size < 4096		ifTrue: [ styler style: formattedText ]		ifFalse: [ styler styleInBackgroundProcess: formattedText ]! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/27/2010 01:10'!okToStyle	styler ifNil: [ ^false ].	^model textProvider shoutAboutToStyle: styler! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/27/2010 01:10'!styler: anObject		styler := anObject! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/27/2010 01:10'!stylerStyled: styledCopyOfText	textMorph text privateSetRuns: styledCopyOfText runs.	"jmv - 11/2010 The next line used to be commented out but it is needed to fix lines whose	length might change due to font change (i.e., styled comments are shorter than unstyled)"	textMorph paragraph recomposeFrom: 1 to: textMorph text size delta: 0.	"older comment: caused chars to appear in wrong order esp. in demo mode. remove this line when sure it is fixed"		textMorph updateFromParagraph.	selectionInterval 		ifNotNil: [			self editor				selectInvisiblyFrom: selectionInterval first to: selectionInterval last;				storeSelectionInParagraph;				setEmphasisHereFromText].	self editor blinkParen.	self scrollSelectionIntoView! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 11/27/2010 01:10'!stylerStyledInBackground: styledCopyOfText 	"It is possible that the text string has changed since the styling began. Disregard the styles if styledCopyOfText's string differs with the current textMorph contents string"		textMorph text string = styledCopyOfText string		ifTrue: [ self stylerStyled: styledCopyOfText ]! !!TextModelMorph methodsFor: 'notifications' stamp: 'jmv 11/27/2010 01:10'!possiblyChanged	"A hook for notificating possible interested parties	Not used in base system"! !!TextModelMorph methodsFor: 'testing' stamp: 'jmv 11/27/2010 01:10'!is: aSymbol	^aSymbol = #HasTextSelector or: [ super is: aSymbol ]! !!TextModelMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2010 01:10'!model: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel	^ self		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil		menuGetter: nil! !!TextModelMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2010 01:10'!model: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	|styler answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ anObject respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel		menuGetter: getMenuSel.	^answer! !!TextModelMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2010 01:10'!noShoutModel: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel	^ self		noShoutModel: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil		menuGetter: nil! !!TextModelMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2010 01:10'!noShoutModel: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	| answer |	answer _ self new.	answer		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel		menuGetter: getMenuSel.	^answer! !!TextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 18:43'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	self setDefaultContentsIfNil.	"...Code here to recreate the paragraph..."	paragraph _ NewParagraph new.	paragraph focused: self hasKeyboardFocus.	paragraph		model: (TextModel new actualContents: text)		in: self container.	wrapFlag ifFalse: [		"Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!TextProvider methodsFor: 'misc' stamp: 'jmv 11/27/2010 00:21'!setContentsToForceRefetch! !!TextProvider methodsFor: 'self-updating' stamp: 'jmv 11/26/2010 23:55'!updatePaneIfNeeded	"Nothing to do"! !!TextProvider methodsFor: 'testing' stamp: 'jmv 11/27/2010 00:00'!isCodeProvider	^false! !!TextProvider methodsFor: 'accessing' stamp: 'jmv 11/27/2010 00:25'!acceptedContents: getTextSelector	^ Text		initialFont: Preferences standardCodeFont		stringOrText: (self perform: getTextSelector)! !!TextProvider methodsFor: 'accessing' stamp: 'jmv 11/27/2010 00:19'!contentsProvider	^self! !!TextProvider methodsFor: 'accessing' stamp: 'jmv 11/27/2010 01:08'!textProvider	^self! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 22:55'!isCodeProvider	^true! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 11/26/2010 23:55'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifTrue: [		aWindow updatablePanes do: [:aPane | aPane verifyContents]].	self updatePaneIfNeeded! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 11/26/2010 23:54'!updatePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue: [			self hasUnacceptedEdits				ifFalse: [					self setContentsToForceRefetch.					self acceptedContentsChanged]				ifTrue: [					self changed: #codeChangedElsewhere]]! !!CodeProvider methodsFor: 'testing' stamp: 'jmv 11/26/2010 23:59'!refusesToAccept	"Answer whether receiver, given its current contentsSymbol, could accept code happily if asked to"	^ (#(byteCodes documentation) includes: self contentsSymbol)! !!MessageNames methodsFor: 'initialization' stamp: 'jmv 11/25/2010 23:43'!inMorphicWindowWithInitialSearchString: initialString	"Answer a morphic window with the given initial search string, nil if none""MessageNames openMessageNames"	| window selectorListView firstDivider secondDivider horizDivider typeInPane searchButton plugTextMor |	window _ (SystemWindow labelled: 'Message Names') model: self.	firstDivider _ 0.07.	secondDivider _ 0.5.	horizDivider _ 0.5.	typeInPane _ AlignmentMorph proportional height: 14.	plugTextMor _ PluggableTextMorph 		model: self		editorClass: self editorClass		textGetter: #searchString 		textSetter: #searchString:notifying:		selectionGetter: nil 		menuGetter: nil.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor textMorph		on: #mouseEnter send: #selectAll to: plugTextMor textMorph.	searchButton _ SimpleButtonMorph new 		target: self;		beTransparent;		label: 'Search';		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.	typeInPane addInProportionalRow: { searchButton. plugTextMor. }.	initialString isEmptyOrNil ifFalse:		[plugTextMor changeText: initialString].	window addMorph: typeInPane frame: (0@0 corner: horizDivider @ firstDivider).	selectorListView _ PluggableListMorph 		model: self		listGetter: #selectorList		indexGetter: #selectorListIndex		indexSetter: #selectorListIndex:		menuGetter: #selectorListMenu:		keystrokeAction: #selectorListKey:from:.	selectorListView menuTitleSelector: #selectorListMenuTitle.	window addMorph: selectorListView frame: (0 @ firstDivider corner: horizDivider @ secondDivider).	window addMorph: self buildMorphicMessageList frame: (horizDivider @ 0 corner: 1@ secondDivider).	self 		addLowerPanesTo: window 		at: (0 @ secondDivider corner: 1@1) 		with: nil.	initialString isEmptyOrNil ifFalse:		[self searchString: initialString notifying: nil].	^ window! !!RecentMessageSet methodsFor: 'update' stamp: 'jmv 11/25/2010 22:50'!updateListsAndCodeIn: aWindow	| recentFromUtilities |	"RAA 20 june 2000 - a recent change to how messages were displayed in the list caused them not to match what was stored in Utilities. This caused the recent submissions to be continuously updated. The hack below fixed that problem"	self flag: #mref.	"in second pass, use simpler test"	self canDiscardEdits ifFalse: [^ self].	recentFromUtilities _ Utilities mostRecentlySubmittedMessage,' '.	(messageList first asStringOrText asString beginsWith: recentFromUtilities)		ifFalse: [			self reformulateList]		ifTrue: [			self updatePaneIfNeeded]! !!TranscriptStream methodsFor: 'TextModel compatibility' stamp: 'jmv 11/25/2010 23:06'!contentsProvider	^self! !!TranscriptStream methodsFor: 'TextModel compatibility' stamp: 'jmv 11/25/2010 23:00'!isCodeProvider	^false! !!TranscriptStream methodsFor: 'TextModel compatibility' stamp: 'jmv 11/27/2010 01:08'!textProvider	^self! !!Transcripter methodsFor: 'initialization' stamp: 'jmv 11/27/2010 00:51'!initInFrame: rect	frame _ rect insetBy: 2.  "Leave room for border"	para _ NewParagraph new.	para		model: (TextModel new actualContents: self contents asText)		in: ((frame insetBy: 4) withHeight: 9999)! !!Transcripter methodsFor: 'accessing' stamp: 'jmv 11/27/2010 00:51'!endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue: [		"Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para		model: (TextModel new actualContents: c asText)		in: ((frame insetBy: 4) withHeight: 9999).	para positionWhenComposed: 0@0.	d _ para extent y - frame height.	d > 0 ifTrue: [		"Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint:			para compositionRectangle topLeft + (0@(d+TextStyle default initialLineGrid)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	Display getCanvas		paragraph: para 		bounds: (0@0 extent: Display extent) 		color: Color black! !!Workspace methodsFor: '*Shout-Styling' stamp: 'jmv 11/25/2010 23:46'!toggleStyling	| codeTextMorph |	shouldStyle _ self shouldStyle not.	" Ugly hack, to restyle our contents. "	codeTextMorph _ self dependents		detect: [:dep | (dep isKindOf: PluggableTextMorph)				and: [dep getTextSelector == #contents]].	codeTextMorph changeText:		codeTextMorph textMorph text asString asText! !TranscriptStream removeSelector: #bs!!classDefinition: #Inspector category: #'Tools-Inspector'!TextProvider subclass: #Inspector	instanceVariableNames: 'acceptedContentsCache object selectionIndex timeOfLastListUpdate selectionUpdateTime context'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!classDefinition: #FileList category: #'Tools-FileList'!TextProvider subclass: #FileList	instanceVariableNames: 'acceptedContentsCache fileName directory volList volListIndex list listIndex pattern sortMode brevityState sortAscending'	classVariableNames: 'FileReaderRegistry RecentDirs'	poolDictionaries: ''	category: 'Tools-FileList'!CodeProvider removeSelector: #is:!CodeProvider removeSelector: #refusesToAcceptCode!CodeProvider removeSelector: #updateCodePaneIfNeeded!!classDefinition: #CodeProvider category: #'System-Text'!TextProvider subclass: #CodeProvider	instanceVariableNames: 'acceptedContentsCache currentCompiledMethod contentsSymbol'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!TextProvider removeSelector: #refusesToAccept!!TextProvider reorganize!('misc' setContentsToForceRefetch)('self-updating' updatePaneIfNeeded)('testing' isCodeProvider)('accessing' acceptedContents: contentsProvider textProvider)!PluggableTextModel removeSelector: #contentsProvider!PluggableTextModel removeSelector: #contentsProvider:!TextModel removeSelector: #refusesToAccept!PluggableTextMorph removeSelector: #bsText!Paragraph removeSelector: #compose:in:!Paragraph removeSelector: #deepCopy!Paragraph removeSelector: #lines:text:!Paragraph removeSelector: #model:!Paragraph removeSelector: #ztext!Paragraph removeSelector: #ztext:!NewParagraph removeSelector: #compose:in:!BareTextMorph removeSelector: #contents:wrappedTo:!BareTextMorph removeSelector: #copy!BareTextMorph removeSelector: #newContents:!BareTextMorph removeSelector: #text:wrap:color:!BareTextMorph removeSelector: #veryDeepInner:!BareTextMorph removeSelector: #ztext!BareTextMorph removeSelector: #ztext:!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!Smalltalk removeClassNamed: #PluggableTextMorph2!Smalltalk removeClassNamed: #TextModelWithProvider!