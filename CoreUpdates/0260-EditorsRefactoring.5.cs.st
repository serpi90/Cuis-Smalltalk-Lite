'From Cuis 1.0 of 6 August 2009 [latest update: #258] on 12 August 2009 at 11:08:08 pm'!!FileList methodsFor: 'file list menu' stamp: 'jmv 8/12/2009 22:38'!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| shiftMenu services maybeLine extraLines |	shifted ifTrue: [		shiftMenu _ self editorClass shiftedYellowButtonMenu.		^ aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: shiftMenu selections].	fileName ifNotNil: [		services _ OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		maybeLine _ services size.		(#('st' 'cs') includes: self suffixOfSelectedFile) ifTrue: [			services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines _ OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.				#find}.			{'find again (g)' translated.			#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.			#again}.			{'undo (z)' translated.				#undo}.			#-.			{'copy (c)' translated.				#copySelection}.			{'cut (x)' translated.					#cut}.			{'paste (v)' translated.				#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'do it (d)' translated.				#doIt}.			{'print it (p)' translated.				#printIt}.			{'inspect it (i)' translated.			#inspectIt}.			{'fileIn selection (G)' translated.		#fileItIn}.			#-.			{'accept (s)' translated.				#accept}.			{'cancel (l)' translated.				#cancel}.			#-.			{'more...' translated.					#shiftedYellowButtonActivity}}.	^ aMenu! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'jmv 8/12/2009 22:50'!debugIt	self handleEdit: [textMorph editor debugIt]! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 8/12/2009 22:37'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	"We don't support multiple lines. Therefore, we don't process cr as a #normalCharacter:"	((char == Character cr) "and: [morph acceptOnCR]")		ifTrue: [			sensor keyboard.  "Gobble cr -- probably unnecessary."			self closeTypeIn.			^ true].	char asciiValue = 13 ifTrue: [		sensor controlKeyPressed ifTrue: [			^ self normalCharacter: typeAheadStream ].		sensor leftShiftDown ifTrue: [			^ self lf: typeAheadStream ].		sensor commandKeyPressed ifTrue: [			^ self crlf: typeAheadStream ].		^ self crWithIndent: typeAheadStream ].	honorCommandKeys _ Preferences cmdKeysInText.	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue: [				self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [				self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	^ self normalCharacter: typeAheadStream! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 8/12/2009 22:37'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	((char == Character cr) and: [morph acceptOnCR])		ifTrue: [			sensor keyboard.  "Gobble cr -- probably unnecessary."			self closeTypeIn.			^ true].	self clearParens.  	char asciiValue = 13 ifTrue: [		sensor controlKeyPressed ifTrue: [			^ self normalCharacter: typeAheadStream ].		sensor leftShiftDown ifTrue: [			^ self lf: typeAheadStream ].		sensor commandKeyPressed ifTrue: [			^ self crlf: typeAheadStream ].		^ self crWithIndent: typeAheadStream ].	honorCommandKeys _ Preferences cmdKeysInText.	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue: [				self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [				self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue: [			^ self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	(')]}' includes: char)		ifTrue: [self blinkPrevParen].	^ self normalCharacter: typeAheadStream! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:49'!browseIt: characterStream 	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"	sensor keyboard.		"flush character"	self browseIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:52'!browseItHere: characterStream 	"Triggered by Cmd-shift-B; browse the thing represented by the current selection, if plausible, in the receiver's own window.  3/1/96 sw"	sensor keyboard.		"flush character"	self browseItHere.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:49'!doIt: characterStream 	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	sensor keyboard.		self doIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:54'!exploreIt: characterStream 	"Explore the selection -- invoked via cmd-shift-I.  If there is no current selection, use the current line."	sensor keyboard.		"flush character"	self exploreIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:53'!fileItIn: characterStream 	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."	sensor keyboard.		"flush character"	self fileItIn.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:48'!implementorsOfIt: characterStream 	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self implementorsOfIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:49'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	sensor keyboard.		"flush character"	self inspectIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:55'!methodNamesContainingIt: characterStream 	"Browse methods whose selectors containing the selection in their names"	sensor keyboard.		"flush character"	self methodNamesContainingIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:53'!methodStringsContainingIt: characterStream 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	sensor keyboard.		self methodStringsContainingit.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:54'!pasteInitials: characterStream 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:47'!printIt: characterStream 	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	sensor keyboard.		"flush character"	self printIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:54'!referencesToIt: characterStream 	"Triggered by Cmd-N; browse references to the current selection"	sensor keyboard.		"flush character"	self referencesToIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:33'!save: characterStream	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self accept.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:48'!sendersOfIt: characterStream 	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self sendersOfIt.	^ true! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 8/12/2009 22:48'!spawnIt: characterStream	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	sensor keyboard.	self spawn.	^ true! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:57'!compileSelectionFor: anObject in: evalContext	| methodNode method |	methodNode _ [Compiler new		compileNoPattern: self selectionAsStream		in: anObject class		context: evalContext		notifying: self		ifFail: [^nil]]			on: OutOfScopeNotification			do: [:ex | ex resume: true].	method _ methodNode generate: #(0 0 0 0).	^method copyWithTempNames: methodNode tempNames! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:57'!debug: aCompiledMethod receiver: anObject in: evalContext	| selector guineaPig debugger context |	selector _ evalContext isNil ifTrue: [#DoIt] ifFalse: [#DoItIn:].	anObject class addSelectorSilently: selector withMethod: aCompiledMethod.	guineaPig _ evalContext isNil		ifTrue: [[anObject DoIt] newProcess]		ifFalse: [[anObject DoItIn: evalContext] newProcess].	context _ guineaPig suspendedContext.	debugger _ Debugger new		process: guineaPig		controller: nil		context: context.	debugger openFullNoSuspendLabel: 'Debug it'.	[debugger interruptedContext method == aCompiledMethod]		whileFalse: [debugger send].	anObject class basicRemoveSelector: selector! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:31'!debugIt	| method receiver context |	(model respondsTo: #doItReceiver) 		ifTrue: 			[FakeClassPool adopt: model selectedClass.			receiver _ model doItReceiver.			context _ model doItContext]		ifFalse:			[receiver _ context _ nil].	self lineSelectAndEmptyCheck: [^self].	method _ self compileSelectionFor: receiver in: context.	method notNil ifTrue:		[self debug: method receiver: receiver in: context].	FakeClassPool adopt: nil! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:34'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelection! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:34'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr _ model doItReceiver.				ctxt _ model doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	^ result! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:39'!exploreIt	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [morph flash]			ifFalse: [result explore]! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:39'!inspectIt	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [morph flash]			ifFalse: [result inspect]! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/12/2009 22:39'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [morph flash]			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:42'!browseChangeSetsWithSelector	"Determine which, if any, change sets have at least one change for the selected selector, independent of class"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ morph flash].	ChangeSorter browseChangeSetsWithSelector: aSelector! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 23:02'!browseClassFromIt	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self lineSelectAndEmptyCheck: [^ self].	aClass _ Utilities classFromPattern: (self selection string copyWithout: Character cr) withCaption: 'choose a class to browse...'.	aClass ifNil: [^ morph flash].	Utilities spawnHierarchyForClass: aClass selector: nil! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:44'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ morph flash].	aSymbol first isUppercase		ifTrue:			[anEntry _ (Smalltalk				at: aSymbol				ifAbsent:					[ Smalltalk browseAllImplementorsOf: aSymbol.					^ nil]).			anEntry isNil ifTrue: [^ morph flash].			(anEntry isKindOf: Class)				ifFalse:	[anEntry _ anEntry class].			brow _ Preferences browseToolClass new.			brow setClass: anEntry selector: nil.			brow class				openBrowserView: (brow openEditString: nil)				label: 'System Browser']		ifFalse:			[Smalltalk browseAllImplementorsOf: aSymbol]! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:53'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ morph flash].	model okToChange ifFalse: [^ morph flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ morph flash].	foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).		foundClass isNil ifTrue: [^ morph flash].		(foundClass isKindOf: Class)			ifTrue:				[model systemCategoryListIndex: 					(model systemCategoryList indexOf: foundClass category).	model classListIndex: (model classList indexOf: foundClass name)]! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:42'!classCommentsContainingIt	"Open a browser class comments which contain the current selection somewhere in them."	self lineSelectAndEmptyCheck: [^ self].	Smalltalk browseClassCommentsWithString: self selection string! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:42'!classNamesContainingIt	"Open a browser on classes whose names contain the selected string"	self lineSelectAndEmptyCheck: [^self].	Smalltalk		browseClassesWithNamesContaining: self selection string		caseSensitive: Sensor leftShiftDown! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:55'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply symbol |Cursor execute showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry _ sorry , (morph canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: [string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are all letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol _ s])						ifTrue: [cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [										selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:44'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| selection |	selection _ self selection.	(ReadWriteStream on: selection string from: 1 to: selection size) fileIn! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:45'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ morph flash].	Smalltalk browseAllImplementorsOf: aSelector! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:41'!methodNamesContainingIt	"Open a browser on methods names containing the selected string"	self lineSelectAndEmptyCheck: [^ self].	Cursor wait showWhile:		[Smalltalk browseMethodsWhoseNamesContain: self selection string withBlanksTrimmed].	Cursor normal show! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:42'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"	self lineSelectAndEmptyCheck: [^ self].	(self confirm: 'This will take a few minutes.Shall I proceed?') ifFalse: [^ self].	Smalltalk browseMethodsWithSourceString: self selection string! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:41'!methodStringsContainingit	"Open a browser on methods which contain the current selection as part of a string constant."	self lineSelectAndEmptyCheck: [^ self].	Smalltalk browseMethodsWithString: self selection string! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:43'!prettyPrint	self prettyPrint: false! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 23:02'!prettyPrint: decorated	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageName ifNil: [^ morph flash].	selectedClass _ model selectedClassOrMetaClass.	newText _ selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:43'!prettyPrintWithColor	self prettyPrint: true! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:45'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectLine.	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ morph flash].	Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 23:03'!selectedSelector	"Try to make a selector out of the current text selection"	^self selection string findSelector! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 23:03'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString _ self selection string copyWithoutAll:		{Character space.  Character cr.  Character tab}.	aString size = 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:45'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ morph flash].	Smalltalk browseAllCallsOn: aSelector! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 8/12/2009 22:44'!spawn	"Create and schedule a message browser for the code of the model's 	selected message. Retain any edits that have not yet been accepted."	| code |	code _ paragraph text string.	self cancel.	model spawn: code.! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 8/12/2009 22:52'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start _ paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start _ paragraph text size + 1].	self selectAt: start + 2.	^true! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 8/12/2009 22:53'!displayIfFalse: characterStream 	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifFalse:'.	^false! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 8/12/2009 22:54'!displayIfTrue: characterStream 	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifTrue:'.	^false! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 8/12/2009 22:48'!doAgainOnce: characterStream 	"Do the previous thing again once. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self again.	^ true! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 8/12/2009 22:47'!querySymbol: characterStream	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	"keep typeahead"	self hasCaret		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[morph flash].	^true! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 22:59'!explainAnySel: symbol 	"Is this any message selector?"	| list reply |	list _ Smalltalk allClassesImplementing: symbol.	list size = 0 ifTrue: [^nil].	list size < 12		ifTrue: [reply _ ' is a message selector which is defined in these classes ' , list printString]		ifFalse: [reply _ ' is a message selector which is defined in many classes'].	^'"' , symbol , reply , '."' , '\' withCRs, 'Smalltalk browseAllImplementorsOf: #' , symbol! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:00'!explainChar: string	"Does string start with a special character?"	| char |	char _ string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = ${ or: [char = $}]) ifTrue: [^ '"A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array"'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	^nil! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:00'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class _ model selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class _ class soleInstance].	classes _ (Array with: class)				, class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames detect: [:name | symbol = name]					ifNone: [])					~~ nil]				ifNone: [].	reply == nil ifFalse: [^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol)					and: 						[reply _ pool.						true]]			ifNone: [])			~~ nil].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [^ '"is an undeclared variable.' , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes _ WriteStream on: Array new.			Smalltalk				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: [])						~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply) asString , ', which is used by the following classes ' , classes contents printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , (Smalltalk keyAtIdentityValue: reply) asString , ' bindingOf: #' , symbol , ').'].	^ nil! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:00'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls |	symbol = #nil ifTrue: [reply _ '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply _ '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply _ '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply _ '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes _ cls withAllSubclasses.			classes size > 12				ifTrue: [text _ cls printString , ' or a subclass']				ifFalse: 					[classes _ classes printString.					text _ 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply _ '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply _ '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:00'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes _ Set new.			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:01'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes _ (Array with: cls)				, cls allSuperclasses.	classes _ classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes _ classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:01'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	classes _ Smalltalk allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:01'!explainNumber: string 	"Is string a Number?"	| strm c |	(c _ string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])			ifFalse: [^nil]].	strm _ ReadStream on: string.	c _ Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 22:59'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits _ Array with: msg.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes _ Smalltalk allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:01'!explainScan: string 	"Remove beginning and trailing space, tab, cr.	 1/15/96 sw: copied intact from BrowserCodeController"	| c beg end |	beg _ 1.	end _ string size.		[beg = end ifTrue: [^string copyFrom: 1 to: 1].	"if all blank, tell about the first"	c _ string at: beg.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [beg _ beg + 1].		[c _ string at: end.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [end _ end - 1].	^string copyFrom: beg to: end	"Return purely visible characters"! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 8/12/2009 23:01'!explainTemp: string 	"Is string the name of a temporary variable (or block argument variable)?"	| selectedClass tempNames i reply methodNode method msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	selectedClass _ model selectedClassOrMetaClass.	tempNames _ selectedClass parserClass new 			parseArgsAndTemps: model selectedMessage notifying: nil.	method _ selectedClass compiledMethodAt: msg.	(i _ tempNames findFirst: [:each | each = string]) = 0 ifTrue: [		(method numTemps > tempNames size)			ifTrue: 				["It must be an undeclared block argument temporary"				methodNode _ selectedClass compilerClass new							parse: model selectedMessage							in: selectedClass							notifying: nil.				tempNames _ methodNode tempNames]			ifFalse: [^nil]].	(i _ tempNames findFirst: [:each | each = string]) > 0 ifTrue: [i > method numArgs			ifTrue: [reply _ '"is a temporary variable in this method"']			ifFalse: [reply _ '"is an argument to this method"']].	^reply! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 8/12/2009 23:04'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc _ start + dir.	str _ paragraph text string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc _ loc + dir].	^ loc! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 8/12/2009 23:04'!notify: aString at: anInteger in: aStream 	"The compilation of text failed. The syntax error is noted as the argument, 	aString. Insert it in the text at starting character position anInteger."	| pos |	pos _ self selectionInterval notEmpty		ifTrue: [			self startIndex + anInteger - 1 ]		ifFalse: [anInteger].	self insertAndSelect: aString at: (pos max: 1)! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 8/12/2009 23:06'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok _ false.	string _ paragraph text string.	stop _ self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop _ stop - 1].	sep _ stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok _ true. sep _ sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!SmalltalkEditor methodsFor: 'private' stamp: 'jmv 8/12/2009 23:05'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime _ self isRedoing		ifTrue: [prior _ sym _ selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret _ self startIndex.			self selectPrecedingIdentifier.			input _ self selection]		ifFalse: "Repeated Ctrl-q"			[caret _ UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input _ hintText.			prior _ selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym _ Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart _ self startIndex.			outStream _ WriteStream on: (String new: 2 * sym size).			1 to: (kwds _ sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret _ newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection _ input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection _ self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone _ true].			morph flash].	self selectAt: caret! !!SmalltalkEditor methodsFor: 'undoers' stamp: 'jmv 8/12/2009 23:05'!undoQuery: hintText lastOffering: selectorOrNil	"Undo ctrl-q.  selectorOrNil (if not nil) is the previously offered selector.	 hintText is the original hint.  Redoer: completeSymbol."	self zapSelectionWith: UndoSelection.	self undoMessage: (Message selector: #completeSymbol:lastOffering: arguments: UndoMessage arguments) forRedo: true.	self selectAt: self stopIndex! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 8/12/2009 22:50'!initializeYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"TextEditor initialize"	yellowButtonMenu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.	#setSearchString}.		#-.		{'do again (j)' translated.			#again}.		{'undo (z)' translated.				#undo}.		#-.		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.					#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.					#pasteRecent}.		#-.		{'set font... (k)' translated.			#offerFontMenu}.		{'set style... (K)' translated.			#changeStyle}.		{'set alignment...' translated.			#chooseAlignment}.		"		#-.		{'more...' translated.					#shiftedTextPaneMenuRequest}.		"	}! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 8/12/2009 22:41'!initializeShiftedYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	shiftedYellowButtonMenu _ SelectionMenu fromArray: {		{'set font... (k)' translated.				#offerFontMenu}.		{'set style... (K)' translated.				#changeStyle}.		{'set alignment...' translated.				#chooseAlignment}.		#-.		{'explain' translated.					#explain}.		{'pretty print' translated.				#prettyPrint}.		{'pretty print with color' translated.		#prettyPrintWithColor}.		{'file it in (G)' translated.					#fileItIn}.		{'spawn (o)' translated.					#spawn}.		#-.		{'browse it (b)' translated.				#browseIt}.		{'senders of it (n)' translated.			#sendersOfIt}.		{'implementors of it (m)' translated.		#implementorsOfIt}.		{'references to it (N)' translated.			#referencesToIt}.		#-.		{'selectors containing it (W)' translated.	#methodNamesContainingIt}.		{'method strings with it (E)' translated.	#methodStringsContainingit}.		{'method source with it' translated.		#methodSourceContainingIt}.		{'class names containing it' translated.	#classNamesContainingIt}.		{'class comments with it' translated.		#classCommentsContainingIt}.		{'change sets with it' translated.			#browseChangeSetsWithSelector}.		#-.		{'save contents to file...' translated.		#saveContentsInFile}.		#-.		{'more...' translated.						#yellowButtonActivity}.	}! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 8/12/2009 22:30'!initializeYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	yellowButtonMenu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.	#setSearchString}.		#-.	     		{'do again (j)' translated.			#again}.		{'undo (z)' translated.				#undo}.		#-.	     		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.					#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.					#pasteRecent}.		#-.	     		{'do it (d)' translated.				#doIt}.		{'print it (p)' translated.				#printIt}.		{'inspect it (i)' translated.			#inspectIt}.		{'explore it (I)' translated.			#exploreIt}.		{'debug it' translated.				#debugIt}.		#-.	     		{'accept (s)' translated.				#accept}.		{'cancel (l)' translated.				#cancel}.		#-.	     		{'show bytecodes' translated.		#showBytecodes}.		#-.	     		{'more...' translated.					#shiftedTextPaneMenuRequest}.	}! !!SmalltalkEditor reorganize!('editing keys' browseIt: browseItHere: changeEmphasis: doIt: exploreIt: fileItIn: implementorsOfIt: inspectIt: methodNamesContainingIt: methodStringsContainingIt: pasteInitials: printIt: referencesToIt: save: sendersOfIt: spawnIt:)('do-its' compileSelectionFor:in: debug:receiver:in: debugIt doIt evaluateSelection exploreIt inspectIt printIt)('menu messages' browseChangeSetsWithSelector browseClassFromIt browseIt browseItHere classCommentsContainingIt classNamesContainingIt explain fileItIn implementorsOfIt methodNamesContainingIt methodSourceContainingIt methodStringsContainingit prettyPrint prettyPrint: prettyPrintWithColor referencesToIt selectedSelector selectedSymbol sendersOfIt spawn)('typing/selecting keys' argAdvance: displayIfFalse: displayIfTrue: doAgainOnce: querySymbol:)('explain' explainAnySel: explainChar: explainClass: explainCtxt: explainGlobal: explainInst: explainMySel: explainNumber: explainPartSel: explainScan: explainTemp:)('new selection' nextTokenFrom:direction: notify:at:in: selectPrecedingIdentifier)('private' completeSymbol:lastOffering:)('undoers' undoQuery:lastOffering:)!TextEditor removeSelector: #argAdvance:!TextEditor removeSelector: #browseChangeSetsWithSelector!TextEditor removeSelector: #browseClassFromIt!TextEditor removeSelector: #browseIt!TextEditor removeSelector: #browseIt:!TextEditor removeSelector: #browseItHere!TextEditor removeSelector: #browseItHere:!TextEditor removeSelector: #classCommentsContainingIt!TextEditor removeSelector: #classNamesContainingIt!TextEditor removeSelector: #compileSelectionFor:in:!TextEditor removeSelector: #completeSymbol:lastOffering:!TextEditor removeSelector: #debug:receiver:in:!TextEditor removeSelector: #debugIt!TextEditor removeSelector: #dispatchOnEnterWith:!TextEditor removeSelector: #displayIfFalse:!TextEditor removeSelector: #displayIfTrue:!TextEditor removeSelector: #doAgainOnce:!TextEditor removeSelector: #doIt!TextEditor removeSelector: #doIt:!TextEditor removeSelector: #evaluateSelection!TextEditor removeSelector: #explain!TextEditor removeSelector: #explainAnySel:!TextEditor removeSelector: #explainChar:!TextEditor removeSelector: #explainClass:!TextEditor removeSelector: #explainCtxt:!TextEditor removeSelector: #explainGlobal:!TextEditor removeSelector: #explainInst:!TextEditor removeSelector: #explainMySel:!TextEditor removeSelector: #explainNumber:!TextEditor removeSelector: #explainPartSel:!TextEditor removeSelector: #explainScan:!TextEditor removeSelector: #explainTemp:!TextEditor removeSelector: #exploreIt!TextEditor removeSelector: #exploreIt:!TextEditor removeSelector: #fileItIn!TextEditor removeSelector: #fileItIn:!TextEditor removeSelector: #implementorsOfIt!TextEditor removeSelector: #implementorsOfIt:!TextEditor removeSelector: #inspectIt!TextEditor removeSelector: #inspectIt:!TextEditor removeSelector: #methodNamesContainingIt!TextEditor removeSelector: #methodNamesContainingIt:!TextEditor removeSelector: #methodSourceContainingIt!TextEditor removeSelector: #methodStringsContainingIt:!TextEditor removeSelector: #methodStringsContainingit!TextEditor removeSelector: #nextTokenFrom:direction:!TextEditor removeSelector: #notify:at:in:!TextEditor removeSelector: #pasteInitials:!TextEditor removeSelector: #prettyPrint!TextEditor removeSelector: #prettyPrint:!TextEditor removeSelector: #prettyPrintWithColor!TextEditor removeSelector: #printIt!TextEditor removeSelector: #printIt:!TextEditor removeSelector: #querySymbol:!TextEditor removeSelector: #referencesToIt!TextEditor removeSelector: #referencesToIt:!TextEditor removeSelector: #save:!TextEditor removeSelector: #selectPrecedingIdentifier!TextEditor removeSelector: #selectedSelector!TextEditor removeSelector: #selectedSymbol!TextEditor removeSelector: #sendersOfIt!TextEditor removeSelector: #sendersOfIt:!TextEditor removeSelector: #spawn!TextEditor removeSelector: #spawnIt:!TextEditor removeSelector: #undoQuery:lastOffering:!!TextEditor reorganize!('accessing' replace:with:and: replaceSelectionWith: setSearch: string text transformFrom:)('accessing-selection' hasCaret markBlock markBlock: markIndex markIndex: pointBlock pointBlock: pointIndex pointIndex: selection selectionAsStream startBlock startIndex stopBlock stopIndex unselect)('as yet unclassified' totalTextHeight visibleHeight)('attributes' changeEmphasisOrAlignment changeStyle changeTextFont offerFontMenu)('binding' bindingOf:)('current selection' recomputeInterval recomputeSelection reverseSelection selectAndScroll)('displaying' flash)('editing keys' align: cancel: changeEmphasis: changeLfToCr: chooseColor compareToClipboard: copyHiddenInfo duplicate: enclose: exchange: hiddenInfo inOutdent:delta: indent: makeCapitalized: makeLowercase: makeUppercase: offerFontMenu: outdent: setEmphasis: shiftEnclose: swapChars: undo:)('events' mouseDown: mouseMove: mouseUp:)('initialize-release' changeParagraph: resetState stateArray stateArrayPut:)('menu commands' offerMenuFromEsc:)('menu messages' accept again align cancel changeAlignment chooseAlignment compareToClipboard copySelection cut exchange find findAgain pasteRecent saveContentsInFile setAlignment: setSearchString undo yellowButtonActivity)('model access' model:)('mvc compatibility' storeSelectionInParagraph zapSelectionWith:)('new selection' afterSelectionInsertAndSelect: correctFrom:to:with: encompassLine: insertAndSelect:at: selectFrom:to: selectLine)('nonediting/nontyping keys' cursorDown: cursorEnd: cursorHome: raiseContextMenu: selectCurrentTypeIn: setSearchString:)('parenblinking' blinkParenAt: blinkPrevParen clearParens)('pluggable menus' pluggableYellowButtonActivity: shiftedTextPaneMenuRequest)('scrolling' scrollBy: updateMarker)('typing support' backTo: closeTypeIn dispatchOnCharacter:with: doneTyping insertTypeAhead: openTypeIn readKeyboard setEmphasisHere startOfTyping)('typing/selecting keys' changeStyle: crWithIndent: doAgainMany: find: findAgain: forwardDelete: search:)('undo support' isDoing isRedoing isUndoing noUndoer undoMessage:forRedo: undoer: undoer:with: undoer:with:with: undoer:with:with:with:)('undoers' undoAgain:andReselect:typedKey: undoAndReselect:redoAndReselect: undoCutCopy: undoReplace)('private' againOnce: againOrSame: againOrSame:many: exchangeWith: getPluggableYellowButtonMenu: indent:fromStream:toStream: isDisjointFrom: nullText pageHeight sameColumn:newLine:forward:)!