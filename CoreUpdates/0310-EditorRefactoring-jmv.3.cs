'From Cuis 1.0 of 4 September 2009 [latest update: #290] on 21 September 2009 at 3:31:31 pm'!!StringHolder methodsFor: 'services' stamp: 'jmv 9/21/2009 15:28'!offerDurableMenuFrom: menuRetriever shifted: aBoolean	"Pop up (morphic only) a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state; put a stay-up item at the top of the menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpIcons.	self perform: menuRetriever with: aMenu with: aBoolean.		aMenu popUpInWorld! !!StringHolder methodsFor: 'services' stamp: 'jmv 9/21/2009 15:28'!offerMenuFrom: menuRetriever shifted: aBoolean 	"Pop up, in morphic or mvc as the case may be, a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.			self 				perform: menuRetriever				with: aMenu				with: aBoolean.			aMenu popUpInWorld! !!CodeHolder methodsFor: 'self-updating' stamp: 'jmv 9/21/2009 15:02'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifTrue: [		aWindow updatablePanes do: [:aPane | aPane verifyContents]].	self updateCodePaneIfNeeded! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:06'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aClass aName method filteredList |	(aName _ self selectedMessageName) ifNotNil: [		method _ (aClass _ self selectedClassOrMetaClass) compiledMethodAt: aName.		filteredList _ method messages reject: 			[:each | #(new initialize = ) includes: each].		Smalltalk browseAllImplementorsOfList: filteredList asSortedCollection			 title: 'All messages sent in ', aClass name, '.', aName]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:06'!browseClass	"Open an class browser on this class and method"	self selectedClassOrMetaClass ifNotNil: [		Browser newOnClass: self selectedClassOrMetaClass 			selector: self selectedMessageName]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:08'!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		Smalltalk browseAllCallsOnClass: cls theNonMetaClass]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:08'!browseClassVarRefs	"1/17/96 sw: devolve responsibility to the class, so that the code that does the real work can be shared"	| cls |	cls _ self selectedClass.	cls ifNotNil: [cls browseClassVarRefs]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:09'!browseClassVariables	"Browse the class variables of the selected class. 2/5/96 sw"	| cls |	cls _ self selectedClass.	cls		ifNotNil: [cls classPool inspectWithLabel: 'Class Variables in ', cls name]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:09'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	^ self spawnFullProtocol! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:09'!browseInstVarDefs 	| cls |	(cls _ self selectedClassOrMetaClass) ifNotNil: [Smalltalk browseInstVarDefs: cls]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:10'!browseInstVarRefs	"1/26/96 sw: real work moved to class, so it can be shared"	| cls |	cls _ self selectedClassOrMetaClass.	cls		ifNotNil: [Smalltalk browseInstVarRefs: cls]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:11'!browseLocalImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:localTo:		to: Smalltalk		with: { self selectedClass }! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:11'!browseLocalSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all implementors	of the message chosen in or below the selected class"	self getSelectorAndSendQuery: #browseAllCallsOn:localTo:		to: Smalltalk		with: { self selectedClass }! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:11'!browseMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:12'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:18'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self getSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:18'!browseUnusedMethods	| classes unsent messageList cls |	(cls _ self selectedClass) ifNil: [^ self].	classes _ Array with: cls with: cls class.	unsent _ Set new.	classes do: [:c | unsent addAll: c selectors].	unsent _ Smalltalk allUnSentMessagesIn: unsent.	messageList _ OrderedCollection new.	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asSortedCollection					do: [:sel | messageList add: c name , ' ' , sel]].	Smalltalk browseMessageList: messageList name: 'Unsent Methods in ', cls name! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:18'!browseVersions	"Create and schedule a Versions Browser, showing all versions of the 	currently selected message. Answer the browser or nil."	| selector class | 	(selector _ self selectedMessageName)		ifNil:[ self inform: 'Sorry, only actual methods have retrievable versions.'. ^nil ]		ifNotNil: [(MessageSet isPseudoSelector: selector)				ifTrue: ["Eliminates Definition and Hierarchy"					^ self classCommentIndicated						ifTrue: [ ClassCommentVersionsBrowser browseCommentOf: self selectedClass. nil ]].			class _ self selectedClassOrMetaClass.			^VersionsBrowser				browseVersionsOf: (class compiledMethodAt: selector)				class: self selectedClass				meta: class isMeta				category: (class organization categoryOfElement: selector)				selector: selector]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:19'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	Utilities spawnHierarchyForClass: self selectedClassOrMetaClass "OK if nil"		selector: self selectedMessageName! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:27'!classListKey: aChar from: view 	"Respond to a Command key.  I am a model with a list of classes and a 	code pane, and I also have a listView that has a list of methods.  The 	view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findMethod].	aChar == $r ifTrue: [^ self recent].	aChar == $h ifTrue: [^ self spawnHierarchy].	aChar == $x ifTrue: [^ self removeClass].	^ self messageListKey: aChar from: view! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:20'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString asText]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:20'!copySelector	"Copy the selected selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:20'!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:20'!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName _ self selectedMessageName) ifNotNil: [		ChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:20'!inspectInstances	"Inspect all instances of the selected class."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[myClass theNonMetaClass inspectAllInstances]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:21'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil: [		aClass theNonMetaClass inspectSubInstances]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:21'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ self toggleDiffing].	sel _ self selectedMessageName.	aChar == $m ifTrue:  "These next two put up a type in if no message selected"		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].	aChar == $n ifTrue: 		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].	"The following require a class selection"	(class _ self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $c ifTrue: [^ self copySelector].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage]].	^ self arrowKey: aChar from: view! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:22'!messageListSelectorTitle	| aSize |	^(self selectedMessageName)		ifNil:[			aSize _ self messageList size.			(aSize = 0 ifTrue: ['no'] ifFalse: [aSize printString]), ' message', (aSize = 1 ifTrue: [''] ifFalse: ['s'])]		ifNotNil:			[nil]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:22'!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	Utilities methodHierarchyBrowserForClass: self selectedClassOrMetaClass 			selector: self selectedMessageName! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:23'!openSingleMessageBrowser	| msgName mr |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName _ self selectedMessageName) ifNil: [^ self].	mr _ MethodReference new		setStandardClass: self selectedClassOrMetaClass		methodSymbol: msgName.	Smalltalk 		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:24'!packageListKey: aChar from: view	"Respond to a Command key in the package pane in the PackageBrowser"	aChar == $f ifTrue: [^ self findClass].	^ self classListKey: aChar from: view! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:24'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotation! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:24'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self contentsChanged! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:25'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ Beeper beep].	changeRecords second fileIn.	self contentsChanged! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:25'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages |	(selector _ self selectedMessageName) ifNil: [^ self].	method _ (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages _ method messages) size = 0])		 ifTrue: [^ aBlock value: selector].	(messages size = 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	Smalltalk		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:25'!systemCatListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findClass].	aChar == $x ifTrue: [^ self removeSystemCategory].	^ self classListKey: aChar from: view! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:27'!timeStamp	"Answer the time stamp for the chosen class and method, if any, else an empty string"	|  selector  aMethod |	(selector _ self selectedMessageName) ifNotNil:		[self selectedClassOrMetaClass 			ifNil:				[^ String new]			ifNotNil:				[aMethod _ self selectedClassOrMetaClass compiledMethodAt: selector ifAbsent: [nil].				aMethod ifNotNil: [^ Utilities timeStampForMethod: aMethod]]].	^ String new! !!CodeHolder methodsFor: 'accessing' stamp: 'jmv 9/21/2009 14:45'!selectedClass	^ nil! !!CodeHolder methodsFor: 'accessing' stamp: 'jmv 9/21/2009 14:52'!selectedClassOrMetaClass	^ self selectedClass	"I don't know any better"! !!CodeHolder methodsFor: 'accessing' stamp: 'jmv 9/21/2009 14:53'!selectedMessageName	^ nil! !!CodeHolder methodsFor: 'optional panes' stamp: 'jmv 9/21/2009 14:57'!wantsAnnotationPane	"Answer whether the receiver, seen in some browser window, would like to have the so-called  annotationpane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences annotationPanes! !!CodeHolder methodsFor: 'optional panes' stamp: 'jmv 9/21/2009 14:58'!wantsOptionalButtons	"Answer whether the receiver, seen in some browser window, would like to have the so-called optional button pane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences optionalButtons! !!CodeHolder methodsFor: 'evaluation' stamp: 'jmv 9/21/2009 15:15'!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!Browser methodsFor: 'message list' stamp: 'jmv 9/21/2009 14:41'!reformulateList	"If the receiver has a way of reformulating its message list, here is a chance for it to do so"	self messageListIndex: 0! !!FileList methodsFor: 'optional panes' stamp: 'jmv 9/21/2009 14:58'!wantsOptionalButtons	"Answer whether the receiver, seen in some browser window, would like to have the so-called optional button pane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences optionalButtons! !!Inspector methodsFor: 'accessing' stamp: 'jmv 9/21/2009 15:16'!selectedClassOrMetaClass	^ self selectedClass	"I don't know any better"! !!Inspector methodsFor: 'code' stamp: 'jmv 9/21/2009 14:56'!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!Inspector methodsFor: 'updating' stamp: 'jmv 9/21/2009 15:01'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:29'!browseClass	"Open an class browser on this class and method"	self selectedClassOrMetaClass ifNotNil: [		Browser newOnClass: self selectedClassOrMetaClass 			selector: nil]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:08'!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		Smalltalk browseAllCallsOnClass: cls theNonMetaClass]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:08'!browseClassVarRefs	"1/17/96 sw: devolve responsibility to the class, so that the code that does the real work can be shared"	| cls |	cls _ self selectedClass.	cls ifNotNil: [cls browseClassVarRefs]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:09'!browseClassVariables	"Browse the class variables of the selected class. 2/5/96 sw"	| cls |	cls _ self selectedClass.	cls		ifNotNil: [cls classPool inspectWithLabel: 'Class Variables in ', cls name]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:09'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	^ self spawnFullProtocol! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:09'!browseInstVarDefs 	| cls |	(cls _ self selectedClassOrMetaClass) ifNotNil: [Smalltalk browseInstVarDefs: cls]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:10'!browseInstVarRefs	"1/26/96 sw: real work moved to class, so it can be shared"	| cls |	cls _ self selectedClassOrMetaClass.	cls		ifNotNil: [Smalltalk browseInstVarRefs: cls]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:30'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: nil]! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:30'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	Utilities spawnHierarchyForClass: self selectedClassOrMetaClass "OK if nil"		selector: nil! !!Inspector methodsFor: 'message list menu' stamp: 'jmv 9/21/2009 15:30'!copyName	"Copy the current selector to the clipboard"! !!MessageSet methodsFor: 'private' stamp: 'jmv 9/21/2009 14:37'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].	class ifNil: [^ false].	(oldSelector ~~ nil and: [oldSelector first isUppercase]) ifTrue:		[oldSelector = #Comment ifTrue:			[class comment: aString stamp: Utilities changeStamp.			self changed: #annotation. 			self clearUserEditFlag.			^ false].		oldSelector = #Definition ifTrue:			["self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self clearUserEditFlag. 			^ false].		oldSelector = #Hierarchy ifTrue:			[self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^ false].	selector == oldSelector ifFalse:		[self reformulateListNoting: selector].	contents _ aString copy.	self changed: #annotation.	^ true! !!MessageSet methodsFor: 'accessing' stamp: 'jmv 9/21/2009 14:39'!reformulateListNoting: newSelector	"A method has possibly been submitted for the receiver with newSelector as its selector; If the receiver has a way of reformulating its message list, here is a chance for it to do so"	^ self reformulateList! !!TextMorph methodsFor: 'notifications' stamp: 'jmv 9/21/2009 14:30'!possiblyChanged! !!TextMorphForEditView methodsFor: 'notifications' stamp: 'jmv 9/21/2009 14:29'!possiblyChanged	editView possiblyChanged! !!TextMorphForEditView reorganize!('accept/cancel' acceptOnCR:)('drawing' drawNullTextOn:)('edit view' editView setEditView:)('editing' acceptContents acceptOnCR cancelEdits handleInteraction: hasUnacceptedEdits:)('event handling' autoScrollView: keyStroke: keyboardFocusChange: mouseDown: mouseMove: mouseUp:)('initialization' initialize)('macpal' flash)('miscellaneous' selectAll)('private' editorClass updateFromParagraph yellowButtonActivity:)('notifications' possiblyChanged)!!TextMorph reorganize!('accessing' asText autoFit: backgroundColor backgroundColor: borderWidth: contents contents: contents:wrappedTo: contentsAsIs: contentsWrapped: crAction crAction: cursor editor isAutoFit isWrapped newContents: text textColor textColor: userString wrapFlag:)('anchors' adjustTextAnchor: anchorMorph:at:type:)('caching' releaseCachedState)('change reporting')('classification' isTextMorph)('containment')('copying' copy veryDeepInner:)('drawing' areasRemainingToFill: debugDrawLineRectsOn: drawNullTextOn: drawOn:)('editing' acceptContents acceptOnCR cancelEdits chooseAlignment chooseEmphasis chooseEmphasisOrAlignment chooseFont chooseStyle enterClickableRegion: handleEdit: handleInteraction: hasUnacceptedEdits:)('event handling' handlesKeyboard handlesMouseDown: keyStroke: keyboardFocusChange: mouseDown: mouseMove: mouseUp:)('events-processing' handleKeystroke: handleMouseMove:)('geometry' container defaultLineHeight extent: minimumExtent privateMoveBy: textBounds)('geometry testing')('initialization' defaultColor initialize)('layout' acceptDroppingMorph:event:)('menu' addCustomMenuItems:hand: autoFitOnOff autoFitString shiftedYellowButtonActivity wrapOnOff wrapString yellowButtonActivity)('printing' fullPrintOn:)('scripting access' insertCharacters:)('submorphs-add/remove' addMorphFront:fromWorldPosition:)('visual properties' fillStyle fillStyle:)('private' clippingRectangle composeToBounds editorClass fit installEditorToReplace: paragraph releaseParagraph removedMorph: selectionChanged setDefaultContentsIfNil text:wrap:color: updateFromParagraph)('notifications' possiblyChanged)!!MessageSet reorganize!('message list' addExtraShiftedItemsTo: addItem: growable messageList messageListIndex: selectedMessageName sortByDate)('message functions' deleteFromMessageList: methodCategoryChanged reformulateList removeMessage removeMessageFromBrowser)('class list' metaClassIndicated selectedClass selectedClassName selectedClassOrMetaClass selectedMessageCategoryName)('contents' selectedMessage setContentsToForceRefetch stringContents)('private' adjustWindowTitleAfterFiltering autoSelectString autoSelectString: buildMorphicMessageList contents:notifying: inMorphicWindowLabeled: initializeMessageList: openAsMorphNamed:inWorld: selection setClassAndSelectorIn: setFilteredList:)('filtering' augmentMessageList filterFrom: filterMessageList filterToAnyChangeSet filterToCommentedMethods filterToCurrentAuthor filterToCurrentChangeSet filterToImplementorsOf filterToMessagesInChangesFile filterToMessagesInSourcesFile filterToMessagesThat filterToMessagesWithPriorVersions filterToMessagesWithoutPriorVersions filterToNotAnyChangeSet filterToNotCurrentAuthor filterToNotCurrentChangeSet filterToNotImplementorsOf filterToNotSendersOf filterToSendersOf filterToUncommentedMethods filterToUnsentMessages)('message category functions' canShowMultipleMessageCategories)('metaclass' classCommentIndicated)('*Shout-Styling' shoutAboutToStyle:)('accessing' reformulateListNoting:)!Inspector removeSelector: #selectedMessageName!!Inspector reorganize!('accessing' baseFieldList fieldList i1 i2 initialExtent inspect: modelWakeUpIn: noteSelectionIndex:for: object selectedClass selectedClassOrMetaClass stepAt:in: stepTimeIn: timeOfLastListUpdate trash trash: update wantsSteps)('selecting' accept: contentsIsString replaceSelectionValue: selection selectionIndex selectionPrintString selectionUnmodifiable toggleIndex:)('code' doItContext doItReceiver)('menu commands' addCollectionItemsTo: chasePointers classOfSelection classVarRefs defsOfSelection explorePointers exploreSelection fieldListMenu: inspectBasic inspectElement inspectSelection inspectorKey:from: objectReferencesToSelection referencesToSelection spawnFullProtocol spawnProtocol)('nil' object: selectedSlotName)('code pane menu' editorClass)('updating' updateListsAndCodeIn:)('message list menu' browseClass browseClassRefs browseClassVarRefs browseClassVariables browseFullProtocol browseInstVarDefs browseInstVarRefs browseMethodFull classHierarchy copyName)!!FileList reorganize!('file list' fileList fileListIndex fileListIndex: fileName readOnlyStream)('file list menu' compressFile editorClass fileContentsMenu:shifted: fileListMenu: fileSelectedMenu: fullFileListMenu:shifted: itemsForAnyFile itemsForFile: itemsForNoFile myServicesForFile:suffix: noFileSelectedMenu: offerAllFileOptions suffixOfSelectedFile)('file menu action' addNew:byEvaluating: addNewDirectory addNewFile deleteFile get getHex renameFile sortByDate sortByName sortBySize spawn:)('initialization' buttonSelectorsToSuppress directory: dynamicButtonServices labelString modelSleep modelWakeUp optionalButtonRow optionalButtonSpecs setFileStream: universalButtonServices updateButtonRow updateButtonRow:)('menu messages' copyName)('own services' serviceAddNewDirectory serviceAddNewFile serviceAllFileOptions serviceBrowseCodeFiles serviceCompressFile serviceCopyName serviceDeleteFile serviceGet serviceGetHex serviceRenameFile serviceSortByDate serviceSortByName serviceSortBySize serviceViewContentsInWorkspace servicesFromSelectorSpecs: viewContentsInWorkspace)('to be transformed in registration' perform:orSendTo: volumeMenu:)('updating' update:)('volume list and pattern' deleteDirectory directory fileNameFormattedFrom:sizePad: pattern pattern: veryDeepFixupWith: volumeList volumeListIndex volumeListIndex:)('private' addPath: defaultContents entriesMatching: fileNameFromFormattedItem: folderString fullName isFileSelected listForPatterns: put: readContentsBrief: readContentsHex: readServerBrief recentDirs registeredFileReaderClasses resort: sortBlock sortingByDate sortingByName sortingBySize stringContents updateFileList)('optional panes' wantsOptionalButtons)!CodeHolder removeSelector: #offerDurableMenuFrom:shifted:!CodeHolder removeSelector: #selectedClassName!!CodeHolder reorganize!('annotation' addOptionalAnnotationsTo: addPriorVersionsCountForSelector:ofClass:to: annotation annotationForClassCommentFor: annotationForClassDefinitionFor: annotationForHierarchyFor: annotationForSelector:ofClass: annotationRequests annotationSeparator)('categories' categoryFromUserWithPrompt:for: categoryOfCurrentMethod changeCategory letUserReclassify:in: methodCategoryChanged selectedMessageCategoryName)('contents' commentContents contents contentsChanged contentsSymbol contentsSymbol: stringContents)('commands' abbreviatedWordingFor: adoptMessageInCurrentChangeset browseImplementors browseSenders copyUpOrCopyDown makeSampleInstance offerMenu offerShiftedClassListMenu offerUnshiftedClassListMenu removeClass shiftedYellowButtonActivity showUnreferencedClassVars showUnreferencedInstVars spawn: spawnFullProtocol spawnHierarchy spawnProtocol spawnToClass: spawnToCollidingClass: unshiftedYellowButtonActivity)('construction' buildClassBrowserEditString: buildMorphicCodePaneWith:)('controls' addOptionalButtonsTo:plus: buttonWithSelector: contentsSymbolQuints decorateButtons decorateForInheritance inheritanceButton optionalButtonRow optionalButtonTuples sourceAndDiffsQuintsOnly)('diffs' defaultDiffsSymbol diffFromPriorSourceFor: prettyDiffButton regularDiffButton showDiffs showDiffs: showPrettyDiffs: showRegularDiffs: showingAnyKindOfDiffs showingPrettyDiffs showingPrettyDiffsString showingRegularDiffs showingRegularDiffsString toggleDiffing togglePlainSource togglePrettyDiffing togglePrettyPrint toggleRegularDiffing wantsDiffFeedback)('misc' addLowerPanesTo:at:with: getSelectorAndSendQuery:to: getSelectorAndSendQuery:to:with: isThereAnOverride isThisAnOverride menuButton modelWakeUp modelWakeUpIn: okayToAccept priorSourceOrNil refreshAnnotation refusesToAcceptCode releaseCachedState sampleInstanceOfSelectedClass sendQuery:to: setClassAndSelectorIn: suggestCategoryToSpawnedBrowser: useSelector:orGetSelectorAndSendQuery:to:)('self-updating' didCodeChangeElsewhere stepIn: updateCodePaneIfNeeded updateListsAndCodeIn: wantsStepsIn:)('what to show' addContentsTogglesTo: addModelItemsToWindowMenu: offerWhatToShowMenu prettyPrintString setContentsToForceRefetch showByteCodes: showComment showDecompile: showDocumentation: showingByteCodes showingByteCodesString showingDecompile showingDecompileString showingDocumentation showingDocumentationString showingPlainSource showingPlainSourceString showingPrettyPrint showingSource toggleDecompile toggleShowDocumentation toggleShowingByteCodes)('categories & search pane')('message list' decompiledSourceIntoContentsWithTempNames: selectedBytecodes selectedMessage sourceStringPrettifiedAndDiffed validateMessageSource:forSelector:)('message list menu' browseAllMessages browseClass browseClassRefs browseClassVarRefs browseClassVariables browseFullProtocol browseInstVarDefs browseInstVarRefs browseLocalImplementors browseLocalSendersOfMessages browseMessages browseMethodFull browseSendersOfMessages browseUnusedMethods browseVersions classHierarchy classListKey:from: copyName copySelector fileOutMessage findMethodInChangeSets inspectInstances inspectSubInstances messageListKey:from: messageListSelectorTitle methodHierarchy openSingleMessageBrowser packageListKey:from: removeFromCurrentChanges revertAndForget revertToPreviousVersion selectMessageAndEvaluate: systemCatListKey:from: timeStamp)('message category functions' canShowMultipleMessageCategories)('testing' is:)('code pane menu' editorClass)('*Shout-Styling' shoutAboutToStyle: shoutIsModeStyleable)('accessing' selectedClass selectedClassOrMetaClass selectedMessageName)('optional panes' wantsAnnotationPane wantsOptionalButtons)('evaluation' doItContext)!StringHolder removeSelector: #browseAllMessages!StringHolder removeSelector: #browseClass!StringHolder removeSelector: #browseClassRefs!StringHolder removeSelector: #browseClassVarRefs!StringHolder removeSelector: #browseClassVariables!StringHolder removeSelector: #browseFullProtocol!StringHolder removeSelector: #browseInstVarDefs!StringHolder removeSelector: #browseInstVarRefs!StringHolder removeSelector: #browseLocalImplementors!StringHolder removeSelector: #browseLocalSendersOfMessages!StringHolder removeSelector: #browseMessages!StringHolder removeSelector: #browseMethodFull!StringHolder removeSelector: #browseSendersOfMessages!StringHolder removeSelector: #browseUnusedMethods!StringHolder removeSelector: #browseVersions!StringHolder removeSelector: #classHierarchy!StringHolder removeSelector: #classListKey:from:!StringHolder removeSelector: #copyName!StringHolder removeSelector: #copySelector!StringHolder removeSelector: #doItContext!StringHolder removeSelector: #doItReceiver!StringHolder removeSelector: #fileOutMessage!StringHolder removeSelector: #findMethodInChangeSets!StringHolder removeSelector: #inspectInstances!StringHolder removeSelector: #inspectSubInstances!StringHolder removeSelector: #messageListKey:from:!StringHolder removeSelector: #messageListSelectorTitle!StringHolder removeSelector: #methodHierarchy!StringHolder removeSelector: #noteAcceptanceOfCodeFor:!StringHolder removeSelector: #openSingleMessageBrowser!StringHolder removeSelector: #packageListKey:from:!StringHolder removeSelector: #reformulateList!StringHolder removeSelector: #reformulateListNoting:!StringHolder removeSelector: #removeFromCurrentChanges!StringHolder removeSelector: #revertAndForget!StringHolder removeSelector: #revertToPreviousVersion!StringHolder removeSelector: #selectMessageAndEvaluate:!StringHolder removeSelector: #selectedClassName!StringHolder removeSelector: #selectedClassOrMetaClass!StringHolder removeSelector: #selectedMessageName!StringHolder removeSelector: #showBytecodes!StringHolder removeSelector: #systemCatListKey:from:!StringHolder removeSelector: #timeStamp!StringHolder removeSelector: #updateListsAndCodeIn:!StringHolder removeSelector: #wantsAnnotationPane!StringHolder removeSelector: #wantsOptionalButtons!!StringHolder reorganize!('initialize-release' defaultContents embeddedInMorphicWindowLabeled: embeddedInMorphicWindowLabeled:wrap: initialize openAsMorphEditorClass:label:inWorld: openAsMorphLabel: openAsMorphLabel:inWorld: openLabel: openLabel:wrap:)('accessing' acceptContents: contents contents: contentsSelection stringContents textContents:)('code pane menu' editorClass paneMenu:shifted:editorClass: perform:orSendTo: spawn:)('user edits' clearUserEditFlag okToChange)('services' offerDurableMenuFrom:shifted: offerMenuFrom:shifted:)!Model removeSelector: #perform:orSendTo:!Model removeSelector: #selectedClass!Model removeSelector: #step!