'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 19 October 2011 at 11:00:29 pm'!!Fraction methodsFor: 'mathematical functions' stamp: 'nice 10/19/2011 21:40'!ln	"This function is defined because super ln might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self <= 0 ifTrue: [DomainError signal: 'ln is only defined for x > 0'].	self < 1 ifTrue: [^self reciprocal ln negated].	res := super ln.	res isFinite ifTrue: [^res].	int := self integerPart.	^int ln + (self / int) ln! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 10/19/2011 21:40'!log	"This function is defined because super log might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self <= 0 ifTrue: [DomainError signal: 'log is only defined for x > 0'].	self < 1 ifTrue: [^self reciprocal log negated].	res := super log.	res isFinite ifTrue: [^res].	int := self integerPart.	^int log + (self / int) log! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/19/2011 20:48'!testNthRoot	self assert: ((-2 raisedTo: 35) / (3 raisedTo: 20) raisedTo: 1/5) equals: (-2 raisedTo: 7) / (3 raisedTo: 4).	self assert: (1 / (1 << 2000) raisedTo: 1/100) equals: 1 / (1 << 20)! !!Integer methodsFor: 'mathematical functions' stamp: 'jmv 10/19/2011 22:39'!nthRoot: aPositiveInteger	"Answer the nth root of the receiver.	See #nthRootAlt: for an alternative implementation."	| selfAsFloat floatResult guess delta higher lower raised |	selfAsFloat _ self asFloat.	"If we can't do Float arithmetic because we are too big, then look for an exact answer in exact arithmetic"	selfAsFloat isInfinite ifTrue: [		guess _ self nthRootTruncated: aPositiveInteger.		(guess raisedToInteger: aPositiveInteger) = self			ifTrue: [ ^ guess ].		"Nothing else can be done. No exact answer means answer must be a Float.		Answer the best we have."		^guess asFloat ].	floatResult _ selfAsFloat nthRoot: aPositiveInteger.	guess _ floatResult rounded.	"If got an exact answer, answer it."	raised _ guess raisedToInteger: aPositiveInteger.	raised = self		ifTrue: [ ^ guess ].	"In this case, maybe it failed because we are such a big integer that the Float	method gets inexact, even if we are a whole square number.	Note 1(jmv): This algorithm is faster than #nthRootTruncated: for big n (aPositiveInteger)	but fails if self asFloat isInfinite.	Note 2(jmv): The algorithms I found for computing the nthRoot would havily use	very large fractions. I wrote this one, that doesn't create fractions."	selfAsFloat abs >= (Float maxExactInteger asFloat raisedToInteger: aPositiveInteger)		ifTrue: [			raised > self				ifTrue: [					higher _ guess.					delta _  floatResult predecessor - floatResult.					[						floatResult _ floatResult + delta.						lower _ floatResult rounded.						(lower raisedToInteger: aPositiveInteger) > self ] whileTrue: [							delta _ delta * 2.							higher _ lower ] ]				ifFalse: [					lower _ guess.					delta _  floatResult successor - floatResult.					[						floatResult _ floatResult + delta.						higher _ floatResult rounded.						(higher raisedToInteger: aPositiveInteger) < self ] whileTrue: [							delta _ delta * 2.							lower _ higher ]].			[ higher - lower > 1 ] whileTrue: [				guess _ lower + higher // 2.				raised _ guess raisedToInteger: aPositiveInteger.				raised = self					ifTrue: [						^ guess ].				raised > self					ifTrue: [ higher _ guess ]					ifFalse: [ lower _ guess ]]].	"We need an approximate result"	^floatResult! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/19/2011 22:59'!testBigReceiverInexactNthRoot	"	IntegerTest new testBigReceiverInexactNthRoot	"	"Inexact 3rd root (not a whole cube number), so a Float must be answered.	However, receiver is too big for Float arithmethic."	| bigNum result |	bigNum _ (100 factorial raisedTo: 3) + 1.		"Add 1 so it is not a whole cube"	self assert: bigNum asFloat isInfinite.			"Otherwise, we chose a bad sample"	result _ bigNum nthRoot: 3.	self assert: result class == Float.	self deny: result isInfinite.	self assert: result = 100 factorial asFloat.		"No other float is closer. See following line"	self assert: 100 factorial asFloat = (100 factorial+1) asFloat! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/19/2011 22:48'!testNthRoot	"	IntegerTest new testNthRoot	"	| i |	i _ 1234987687234509123.	#(3 5 7 9 11 13 15 17 19 21 23 25 27) do: [ :n |		self assert: ((i raisedTo: n) nthRoot: n) = i ].	self shouldnt: [ (1 << 2000 nthRoot: 100) ] raise: ArithmeticError.	self assert: (1 << 2000 nthRoot: 100) equals: 1 << 20! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/19/2011 21:03'!testNthRootTruncated	<timeout:  5 "seconds">	| tooBigToBeAFloat large |	tooBigToBeAFloat := 1 << 2000.	self assert: (tooBigToBeAFloat nthRootTruncated: 100) equals: 1 << 20.	self assert: (tooBigToBeAFloat + 1 nthRootTruncated: 100) equals: 1 << 20.	self assert: (tooBigToBeAFloat - 1 nthRootTruncated: 100) equals: 1 << 20 - 1.		large := -3 raisedTo: 255.	self assert: (large nthRootTruncated: 17) equals: (-3 raisedTo: 15).	self assert: (large + 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15) + 1.	self assert: (large - 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15).		2 to: 10 do: [:thePower |		1 to: 10000 do: [:n |			| theTruncatedRoot |			theTruncatedRoot := n nthRootTruncated: thePower.			self assert: (theTruncatedRoot raisedTo: thePower) <= n.			self assert: (theTruncatedRoot + 1 raisedTo: thePower) > n]]! !Integer removeSelector: #nthRootAlt:!