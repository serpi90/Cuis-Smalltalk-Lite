'From Cuis 1.0 of 21 August 2009 [latest update: #268] on 22 August 2009 at 11:41:31 pm'!!BitBlt methodsFor: 'copying' stamp: 'jmv 8/22/2009 23:41'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	"If required, do a second pass with new rule and colorMap"	| answer prevRule secondPassMap |	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.	If not, do it simply"	combinationRule = 37 "rgbMul" ifFalse: [		^self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta ].		"We need to do a second pass. The colormap set is for use in the second pass."	secondPassMap _ colorMap.	colorMap _ sourceForm depth ~= destForm depth		ifTrue: [ self cachedFontColormapFrom: sourceForm depth to: destForm depth ].	answer := self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta.	colorMap := secondPassMap.	secondPassMap ifNotNil: [		prevRule := combinationRule.		combinationRule := 20. "rgbAdd"		self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta.		combinationRule := prevRule ].	^answer! !!BitBlt methodsFor: 'private' stamp: 'jmv 8/22/2009 17:56'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor	| lastSourceDepth targetColor |	sourceForm notNil ifTrue: [ lastSourceDepth _ sourceForm depth ].	sourceForm _ aStrikeFont glyphs.	"Ignore any halftone pattern since we use a color map approach here"	halftoneForm _ nil.	sourceY _ 0.	height _ aStrikeFont height.	sourceForm depth = 1 ifTrue: [		self combinationRule: Form paint.		(colorMap isNil or: [ lastSourceDepth ~= sourceForm depth ]) ifTrue: [			"Set up color map for a different source depth (color font)"			"Uses caching for reasonable efficiency"			colorMap _ self cachedFontColormapFrom: sourceForm depth to: destForm depth.			colorMap at: 1 put: (destForm pixelValueFor: Color transparent)].		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]		ifFalse: [		(Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ Preferences subPixelRenderColorFonts ]]) ifTrue: [			destForm depth > 8 ifTrue: [				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"				self combinationRule: 37.		"rgbMul"				colorMap _ (Preferences properAlphaForBlackText or: [ (foregroundColor = Color black) not ]) ifTrue: [					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)					See #displayString:from:to:at:strikeFont:kern:"					self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]]			ifFalse: [				self combinationRule: 25.		"Paint"				targetColor _ foregroundColor = Color black ifFalse: [ foregroundColor ].				colorMap _ self colorConvertingMap: targetColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]]		ifFalse: [			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"			self combinationRule: (destForm depth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).			colorMap _ self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: false]].! !