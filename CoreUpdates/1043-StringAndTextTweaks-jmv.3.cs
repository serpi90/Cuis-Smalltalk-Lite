'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 28 June 2011 at 9:00:32 am'!!String methodsFor: 'comparing' stamp: 'jmv 6/23/2011 09:53'!commonPartWith: aString startAt: startIndex stopAt: stopIndexRequested applying: aBlock	"Return the size of the longest common subsequence with aString, only between startIndex and stopIndex.	Apply aBlock to each character before comparing.	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."	| stopIndex |	stopIndex _ stopIndexRequested min: aString size.	startIndex		to: stopIndex		do: [ :i |			(aBlock value: (self at: i)) = (aBlock value: (aString at: i)) ifFalse: [ ^ i - 1 ]].	^ stopIndex! !!String methodsFor: 'comparing' stamp: 'jmv 6/23/2011 09:54'!commonPrefixWith: aString	"Return the size of the longest common prefix with aString.	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly.	'this is a string' commonPrefixWith: 'this is another'	'this is a string' commonPrefixWith: ''	'' commonPrefixWith: 'this is another'	't' commonPrefixWith: 'this is another'	'txxxxxxxxx' commonPrefixWith: 'this is another'		"	^ self commonPartWith: aString startAt: 1 stopAt: self size applying: [ :c | c ]! !!String methodsFor: 'converting' stamp: 'jmv 6/17/2011 13:42'!asUnaccented	"	'Hello' asUnaccented	'αιξτσό' asUnaccented	"	^self hasAccents		ifFalse: [ self ]		ifTrue: [ self collect: [ :c | c asUnaccented ]]! !!String methodsFor: 'testing' stamp: 'jmv 6/17/2011 13:39'!hasAccents	"whether the receiver has any accented character"	self do: [ :c | c isAccented ifTrue: [^ true]].	^ true! !!String class methodsFor: 'initialization' stamp: 'jmv 6/22/2011 12:48'!initialize	"	String initialize	"	| order newOrder lowercase |	"Case insensitive compare sorts null, space, digits, letters, all the rest..."	newOrder _ Array new: 256.	order _ -1.	newOrder at: 0+1 put:  (order _ order+1).	32 to: 63 do: [ :c |		newOrder at: c + 1 put: (order _ order+1)].	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |		order _ order+1.		newOrder at: upperAndLowercase first asciiValue + 1 put: order.		upperAndLowercase size > 1 ifTrue: [			newOrder at: upperAndLowercase second asciiValue + 1 put: order ]].	1 to: newOrder size do: [ :i |		(newOrder at: i) ifNil: [			newOrder at: i put: (order _ order+1)]].	CaseInsensitiveOrder _ newOrder asByteArray.		"Case sensitive compare sorts null, space, digits, letters, all the rest..."	newOrder _ Array new: 256.	order _ -1.	newOrder at: 0+1 put:  (order _ order+1).	32 to: 63 do: [ :c |		newOrder at: c + 1 put: (order _ order+1)].	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |		upperAndLowercase size > 1 ifTrue: [			newOrder at: upperAndLowercase first asciiValue + 1 put: (order _ order+1) ]].	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |		lowercase _ upperAndLowercase size = 1			ifTrue: [ upperAndLowercase first ]			ifFalse: [ upperAndLowercase second ].		newOrder at: lowercase asciiValue + 1 put: (order _ order+1) ].	1 to: newOrder size do: [ :i |		(newOrder at: i) ifNil: [			newOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	CaseSensitiveOrder _ newOrder asByteArray.	"a table for translating to lower case"	LowercasingTable _ String withAll: (Character allCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable _ String withAll: (Character allCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish _ String withAll: (Character allCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement! !Text removeSelector: #howManyMatch:!String initialize!String removeSelector: #charactersExactlyMatching:!String removeSelector: #howManyMatch:!