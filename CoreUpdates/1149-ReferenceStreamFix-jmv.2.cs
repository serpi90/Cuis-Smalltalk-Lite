'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 25 November 2011 at 10:55:24 am'!!classDefinition: #ReferenceStreamTest category: #'System-Object Storage-Tests'!TestCase subclass: #ReferenceStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage-Tests'!!DiskProxy methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2011 09:48'!        storeDataOn: aReferenceStream	"Besides just storing, get me inserted into references, so structures will know about class DiskProxy."	super storeDataOn: aReferenceStream.	"just so instVarInfo: will find it and put it into structures""	aReferenceStream references at: self put: #none."	aReferenceStream addSpecialReference: self! !!ReferenceStream methodsFor: 'writing' stamp: 'jmv 11/25/2011 09:48'!      addSpecialReference: aDiskProxy	"See senders. Added to avoid breaking encapsulation (assuming that #references would answer the actual collection)"	references at: aDiskProxy put: #none! !!ReferenceStream methodsFor: 'writing' stamp: 'jmv 11/25/2011 10:48'!                           references	"Do not include provisory references created in #nextPutWeak that never became normal references,	because the referenced object was never added from a call to #nextPut:"	^ references select: [ :value | value isNumber ]! !!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 11/25/2011 10:54'!          statisticsOfRefs	"Analyze the information in references, the objects being written out"	| parents n kids nm ownerBags tallies owners objParent normalReferences |	normalReferences _ self references.	"Exclude unrealized weaks"	parents _ IdentityDictionary new: normalReferences size * 2.	n _ 0.	'Finding Owners...'	displayProgressAt: Sensor mousePoint	from: 0 to: normalReferences size	during: [:bar |	normalReferences keysDo:		[:parent | bar value: (n _ n+1).		kids _ parent class isFixed			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]			ifFalse: [parent class isBits ifTrue: [Array new]					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].		(kids select: [:x | normalReferences includesKey: x])			do: [:child | parents at: child put: parent]]].	ownerBags _ Dictionary new.	tallies _ Bag new.	n _ 0.	'Tallying Owners...'	displayProgressAt: Sensor mousePoint	from: 0 to: normalReferences size	during: [:bar |	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"		[:obj | bar value: (n _ n+1).		nm _ obj class name.		tallies add: nm.		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [			owners add: objParent class name]]].	^ String streamContents: [ :strm | 		tallies sortedCounts do: [ :assn |			n _ assn key.  nm _ assn value.			owners _ ownerBags at: nm.			strm cr; nextPutAll: nm; space; print: n.			owners size > 0 ifTrue: [				strm cr; tab; print: owners sortedCounts]]]! !!ReferenceStreamTest methodsFor: 'testing' stamp: 'jmv 11/25/2011 10:55'!             testWeakDumps	"Test that if we serialize a model with weak references to views, only the model is serialized and not the views.		Note: The bug became apparent only when dumping a model to a SmartRefStream, that calls #references, and the serialized stream	was later materialized in an image where the view classes had been deleted. In such rare cases, materialization would fail when trying to reference these	absent classes. If serializing to a ReferenceStream, the bug didn't become apparent (views were never serialized). If serializing to a SmartRefStream, but	view classes still existed, the bug didn't really become apparent (because views were not actually deserialized), the only effect was a larger file.		ReferenceStreamTest new testWeakDumps	"	| oldInstance window refStream |	oldInstance _TextModel withText: 'This is a text'.	window _ SystemWindow editText: oldInstance label: 'old instance' wrap: true.	refStream _ ReferenceStream on: (DummyStream on: nil).	refStream nextPut: oldInstance.	self deny: (refStream references keys anySatisfy: [ :dumpedObject | dumpedObject isKindOf: Morph ]).	window delete! !!ReferenceStreamTest reorganize!('testing' testWeakDumps)!Array removeSelector: #copyWithDependent:!Collection removeSelector: #copyWithDependent:!Smalltalk removeClassNamed: #DependentsArray!