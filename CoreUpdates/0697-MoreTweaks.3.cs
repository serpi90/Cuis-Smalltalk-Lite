'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 6 December 2010 at 9:58:05 am'!!CodeProvider methodsFor: 'controls' stamp: 'jmv 12/6/2010 09:50'!decorateForInheritance	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."	| aColor aButton flags buttonColor |	(aButton _ self inheritanceButton) ifNil: [^ self].	((currentCompiledMethod isKindOf: CompiledMethod) and: [Preferences decorateBrowserButtons])		ifFalse: [ ^aButton color: self class windowColor ].	"This table duplicates the old logic, but adds two new colors for the cases where there is a superclass definition, but this method doesn't call it."	flags _ 0.	self isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].	currentCompiledMethod sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].	self isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].	buttonColor _ Theme current buttonColorFrom: self class windowColor.	aColor _ {		"This is NOTan override. There is no super implementation."		buttonColor.							"no sends to super. there is not an override"		Color tan.							"no sends to super. there is an override"		Color red.							"sends to super. there is not an override. Error: no super to call"		Color red.							"sends to super. there is  an override. Error: no super to call"		"This is an override. There is some super implementation"		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"		Color green muchLighter.			"doesn't have sub; has super and callsl it"		Color blue muchLighter.			"has sub; has super and callsl it"	} at: flags + 1.	aButton color: aColor! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 12/6/2010 09:50'!optionalButtonRow	"Answer a row of control buttons"	| row buttons widths buttonColor |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	buttonColor _ Theme current buttonColorFrom: self class windowColor.	self optionalButtonTuples do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button color: buttonColor.		button label: tuple second asString.		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].		buttons add: button ].	row _ AlignmentMorph proportional.	row color: buttonColor.	row addInRow: buttons widthProportionalTo: widths.	^row! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 12/6/2010 09:50'!lineDiffButton	"Return a checkbox that lets the user decide whether regular diffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #toggleLineDiffing;		 getSelector: #showingLineDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'lineDiffs' color: Theme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	outerButton setBalloonText: 'Show code differences from the previous version, line by line.'.	^ outerButton! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 12/6/2010 09:50'!prettyLineDiffButton	"Return a checkbox that lets the user decide whether prettyDiffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #togglePrettyLineDiffing;		 getSelector: #showingPrettyLineDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'linePrettyDiffs' color: Theme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	(self isKindOf: VersionsBrowser)		ifTrue: [ outerButton setBalloonText: 'Show pretty-printed code differences from the previous version, line by line.' ]		ifFalse: [ outerButton setBalloonText: 'Show pretty-printed code differences between the file-based method and the in-memory version, line by line.' ].	^ outerButton.! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 12/6/2010 09:50'!prettyWordDiffButton	"Return a checkbox that lets the user decide whether prettyDiffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #togglePrettyWordDiffing;		 getSelector: #showingPrettyWordDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'wordPrettyDiffs' color: Theme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	(self isKindOf: VersionsBrowser)		ifTrue: [ outerButton setBalloonText: 'Show pretty-printed code differences from the previous version, word by word.' ]		ifFalse: [ outerButton setBalloonText: 'Show pretty-printed code differences between the file-based method and the in-memory version, word by word.' ].	^ outerButton.! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 12/6/2010 09:50'!wordDiffButton	"Return a checkbox that lets the user decide whether regular diffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #toggleWordDiffing;		 getSelector: #showingWordDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'wordDiffs' color: Theme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	outerButton setBalloonText: 'Show code differences (better algorithm) from the previous version.'.	^ outerButton.! !!Browser methodsFor: 'class functions' stamp: 'jmv 12/6/2010 09:49'!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row buttonColor |	instanceSwitch := PluggableButtonMorph 				model: self				stateGetter: #instanceMessagesIndicated				action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		borderWidth: 0.	commentSwitch := PluggableButtonMorph 				model: self				stateGetter: #classCommentIndicated				action: #plusButtonHit.	commentSwitch		label: '?' asText allBold;		setBalloonText: 'class comment';		borderWidth: 0.	classSwitch := PluggableButtonMorph 				model: self				stateGetter: #classMessagesIndicated				action: #indicateClassMessages.	classSwitch		label: 'class';		borderWidth: 0.	row _ AlignmentMorph proportional.	row		addMorph: instanceSwitch fullFrame: (LayoutFrame fractions: (0@0 corner: 0.5@1));		addMorph: commentSwitch fullFrame: (LayoutFrame fractions: (0.51@0 corner: 0.65@1));		addMorph: classSwitch fullFrame: (LayoutFrame fractions: (0.66@0 corner: 1@1)).	buttonColor _ Theme current buttonColorFrom: self class windowColor.	row color: buttonColor.	{ 		instanceSwitch.		commentSwitch.		classSwitch} do: [:m | 				m color: buttonColor ].	^row! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/6/2010 09:50'!optionalButtonRow	"Answer a row of buttons to occur in a tool pane"	| row buttons widths buttonColor |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	buttonColor _ Theme current buttonColorFrom: self class windowColor.	self buttonSpecs do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button color: buttonColor.		button label: tuple second asString.		buttons add: button.		button setBalloonText: tuple fourth].	buttons add: self lineDiffButton.	widths add: 14.	buttons add: self wordDiffButton.	widths add: 16.	self wantsPrettyDiffOption ifTrue: [		buttons add:  self prettyLineDiffButton.		widths add: 21.		buttons add:  self prettyWordDiffButton.		widths add: 23 ].	row _ AlignmentMorph proportional.	row color: buttonColor.	row addInRow: buttons widthProportionalTo: widths.	^row! !!EntryField2LW methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:51'!drawCaretOn: aCanvas	|  w caretColor leftX top bottom |	top _ bounds top + 4.	bottom _ top + font height + 1.	leftX _ (font widthOfString: contents from: 1 to: editor startIndex-1) + bounds left + 4.	w := 3.	caretColor := Theme current insertionPoint.		1 to: w do: [:i |		"Draw caret triangles at top and bottom"		aCanvas fillRectangle: ((leftX - w + i - 1) @ (top + i - 1) 				extent: ((w - i) * 2 + 4) @ 1)			color: caretColor.		aCanvas fillRectangle: ((leftX - w + i - 1) @ (bottom - i) 				extent: ((w - i) * 2 + 4) @ 1)			color: caretColor].	aCanvas fillRectangle: (leftX @ top corner: leftX+2 @ bottom)		color: caretColor! !!CellStyleEntryFieldLW methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:49'!drawCaretOn: aCanvas	| top bottom leftX rightX |	editor isInCellShiftMode not ifTrue: [		^super drawCaretOn: aCanvas ].		top _ bounds top + 4.	bottom _ top + font height + 1.	leftX _ (font widthOfString: contents from: 1 to: editor startIndex-2) + bounds left + 4.	rightX _ (font widthOfString: contents from: 1 to: editor stopIndex-1) + bounds left + 6.	aCanvas		fillRectangle: (leftX @ top corner: rightX @ bottom)		color: Theme current insertionPoint! !!FileList2 class methodsFor: '*smloader-extension' stamp: 'jmv 12/6/2010 09:51'!morphicViewOnDirectory: aFileDirectory	| aFileList window fileListBottom midLine fileListTopOffset buttonRow |	aFileList _ self new directory: aFileDirectory.	window _ (SystemWindow labelled: aFileDirectory pathName) model: aFileList.	fileListTopOffset _ (StrikeFont default pointSize * 2) + 14.	fileListBottom _ 0.4.	midLine _ 0.4.	buttonRow _ aFileList optionalButtonRow.	self addFullPanesTo: window from: {		{aFileList morphicPatternPane. 			0@0 corner: 0.3@0. 					0@0 corner: 0@fileListTopOffset}.		{buttonRow.				 			0.3 @ 0 corner: 1@0. 					0@0 corner: 0@fileListTopOffset}.		{aFileList morphicDirectoryTreePane. 	0@0 corner: midLine@fileListBottom. 	0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileListPane. 			midLine @ 0 corner: 1@fileListBottom. 	0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileContentsPane. 	0@fileListBottom corner: 1@1. 			nil}.	}.		buttonRow		color: (Theme current buttonColorFrom: self windowColor);	"not nice. was just turned transparent..."		borderColor: #simple.	aFileList postOpen.	^ window ! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:51'!colorForRow: row	^(selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Theme current listSelectedRowText ]		ifFalse: [ Theme current listUnselectedRowText ].! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:51'!drawBackgroundForMulti: row on: aCanvas	| selectionDrawBounds c |	"shade the background darker, if this row is selected"	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: bounds.	c _ (selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Theme current listHighlightFocused: listSource hasKeyboardFocus ]		ifFalse: [ Theme current listMultiHighlightFocused: listSource hasKeyboardFocus ].	aCanvas fillRectangle: selectionDrawBounds color: c! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:51'!drawSelectionOn: aCanvas	| selectionDrawBounds |	selectedRow ifNil: [ ^self ].	selectedRow = 0 ifTrue: [ ^self ].	selectionDrawBounds := self drawBoundsForRow: selectedRow.	selectionDrawBounds := selectionDrawBounds intersect: bounds.	aCanvas		fillRectangle: selectionDrawBounds		color: (Theme current listHighlightFocused: listSource hasKeyboardFocus)! !!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:51'!drawOn: aCanvas 	| stringColor stringBounds leftEdge |	stringColor := color.	isSelected & isEnabled		ifTrue: [			aCanvas fillRectangle: bounds color: Theme current menuHighlight].	leftEdge := 0.	self hasIcon		ifTrue: [| iconForm | 			iconForm := isEnabled ifTrue:[self icon] ifFalse:[self icon asGrayScale].			aCanvas paintImage: iconForm at: self left @ (self top + (self height - iconForm height // 2)).			leftEdge := iconForm width + 2].	self hasMarker		ifTrue: [ leftEdge := leftEdge + self submorphBounds width + 8 ].	stringBounds := bounds left: bounds left + leftEdge.	aCanvas		drawString: contents		in: stringBounds		font: self fontToUse		color: stringColor.	subMenu		ifNotNil: [aCanvas paintImage: SubMenuMarker at: self right - 8 @ (self top + self bottom - SubMenuMarker height // 2)]! !!NewParagraph methodsFor: 'display' stamp: 'jmv 12/6/2010 09:52'!displayClassicInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor e x1 x2 isBold isItalic x0 xtraWidth |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	xtraWidth _ isBold ifTrue: [ 1 ] ifFalse: [ 0 ].	isItalic ifTrue: [		x0 _ x - 2.		x1 _ x0 - 2.		x2 _ x0 - 6 ]	ifFalse: [		x0 _ x.		x1 _ x0 - 4.		x2 _ x1 ].	1 to: 2 do: [ :i | 		"Draw caret triangles at top and bottom"		e _ (2 - i) * 2 + 4+xtraWidth @ 1.		aCanvas fillRectangle: (x1 + i @ (top + i - 1) extent: e)			color: caretColor.		aCanvas fillRectangle: (x2 + i @ (bottom - i) extent: e)			color: caretColor].	aCanvas fillRectangle: (x0-1 @ top corner: x0+1+xtraWidth @ bottom)		color: caretColor! !!NewParagraph methodsFor: 'display' stamp: 'jmv 12/6/2010 09:52'!displayThinInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor x1 isBold isItalic x0 h w halfW r |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].	x0 < halfW ifTrue: [		x1 _ x1 - x0 + halfW.		x0 _ halfW ].	r _ container right-halfW-1.	r < x1 ifTrue: [		x0 _ x0 + r - x1.		x1 _ r.		].	caretRect _ x0-halfW@ top corner: x1+halfW+1 @ bottom.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:52'!drawCaretOn: aCanvas	"Essentially copied from #displayInsertionMarkAtX:top:bottom:emphasis:on:"	|  caretColor top bottom x isBold isItalic xtraWidth x0 x1 x2 e |	top _ bounds top.	bottom _ top + self baseFont height.	x _ (self fontToUse widthOfString: contents from: 1 to: editor startIndex-1) + bounds left.	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	xtraWidth _ isBold ifTrue: [ 1 ] ifFalse: [ 0 ].	isItalic ifTrue:		[x0 _ x - 2.		x1 _ x0 - 2.		x2 _ x0 - 6 ]	ifFalse:		[x0 _ x.		x1 _ x0 - 4.		x2 _ x1 ].	1 to: 2 do: [ :i | 		"Draw caret triangles at top and bottom"		e _ (2 - i) * 2 + 4+xtraWidth @ 1.		aCanvas fillRectangle: (x1 + i @ (top + i - 1) extent: e)			color: caretColor.		aCanvas fillRectangle: (x2 + i @ (bottom - i) extent: e)			color: caretColor].	aCanvas fillRectangle: (x0-1 @ top corner: x0+1+xtraWidth @ bottom)		color: caretColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 12/6/2010 09:52'!displayClassicInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor e x1 x2 isBold isItalic x0 xtraWidth |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	xtraWidth _ isBold ifTrue: [ 1 ] ifFalse: [ 0 ].	isItalic ifTrue: [		x0 _ x - 2.		x1 _ x0 - 2.		x2 _ x0 - 6 ]	ifFalse: [		x0 _ x.		x1 _ x0 - 4.		x2 _ x1 ].	1 to: 2 do: [ :i | 		"Draw caret triangles at top and bottom"		e _ (2 - i) * 2 + 4+xtraWidth @ 1.		aCanvas fillRectangle: (x1 + i @ (top + i - 1) extent: e)			color: caretColor.		aCanvas fillRectangle: (x2 + i @ (bottom - i) extent: e)			color: caretColor].	aCanvas fillRectangle: (x0-1 @ top corner: x0+1+xtraWidth @ bottom)		color: caretColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 12/6/2010 09:52'!displayThinInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor x1 isBold isItalic x0 h w halfW r |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].	x0 < halfW ifTrue: [		x1 _ x1 - x0 + halfW.		x0 _ halfW ].	r _ container right-halfW-1.	r < x1 ifTrue: [		x0 _ x0 + r - x1.		x1 _ r.		].	caretRect _ x0-halfW@ top corner: x1+halfW+1 @ bottom.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:49'!draw3DLookOn: aCanvas	| w f center x y borderStyleSymbol c availableW l labelMargin |	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].	c _ self fillStyle asColor.	self mouseIsOver ifTrue: [ c _ c  lighter ].	aCanvas		fillRectangle: bounds		fillStyle: c		borderWidth: 2		borderStyleSymbol: borderStyleSymbol.	f _ self fontToUse.	center _ bounds center.	label ifNotNil: [		labelMargin _ 4.		w _ f widthOfString: label.		availableW _ bounds width-labelMargin-labelMargin-1.		availableW >= w			ifTrue: [				x _ center x - (w // 2).				l _ label ]			ifFalse: [				x _ bounds left + labelMargin.				l _ label squeezedTo: (label size * availableW / w) rounded ].		y _ center y - (f height // 2).		self isPressed ifTrue: [			x _ x + 1.			y _ y + 1 ].		aCanvas			drawString: l			in: (x@y extent: bounds extent - (labelMargin*2-2@4))			font: f			color: Theme current buttonLabel ]! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:49'!drawOn: aCanvas	Theme current roundButtons		ifTrue: [ self drawRoundGradientLookOn: aCanvas ]		ifFalse: [ self draw3DLookOn: aCanvas ]! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:49'!drawRoundGradientLookOn: aCanvas	| w f center x y r c rect c2 lh height left top width bottomLeftForm bottomRightForm gradientForm topLeftForm topRightForm labelMargin l availableW targetSize |	aCanvas		fillRectangle: bounds		fillStyle: 			"(color adjustSaturation: -0.3 brightness: 0)"			(Color h: color hue s: color saturation * 0.3 v: color brightness "*0+ 0.8").	rect _ bounds insetBy: 2@3.	c _ self fillStyle asColor.	self isPressed		ifFalse: [			self mouseIsOver				ifTrue: [ c _ c adjustSaturation: 0.0 brightness: 0.0 ]				ifFalse: [					"c _ c adjustSaturation: -0.02 brightness: 0.03"					c _ Color h: c hue s: c saturation * 0.5 v: c brightness 					].			c2 _ c * Theme current buttonGradientBottomFactor.			gradientForm _ self class buttonGradient.			topLeftForm _ self class roundedCornerTL.			topRightForm _ self class roundedCornerTR.			bottomLeftForm _ self class roundedCornerBL.			bottomRightForm _ self class roundedCornerBR ]		ifTrue: ["			c _ c adjustSaturation: -0.15 brightness: 0.0."			c _ c adjustSaturation: 0.1 brightness: -0.1.			c2 _ c * Theme current buttonGradientTopFactor.			gradientForm _ self class buttonGradientPressed.			topLeftForm _ self class roundedCornerTLPressed.			topRightForm _ self class roundedCornerTRPressed.			bottomLeftForm _ self class roundedCornerBLPressed.			bottomRightForm _ self class roundedCornerBRPressed ].			lh _ gradientForm form height.	r _ topLeftForm width.	left _ rect left + r.	top _ rect top.	width _ rect width - r-r.	height _ rect height -r min: lh.	aCanvas fillRectangle: (left@top extent: width@height)  infiniteForm: gradientForm multipliedBy: c.	aCanvas image: topLeftForm multipliedBy: c in: (rect topLeft extent: r@height).	aCanvas image: topRightForm multipliedBy: c in: (rect topRight - (r@0)extent: r@height).	aCanvas fillRectangle: (rect origin + (0@height) extent: rect width@(rect height-height-r)) fillStyle: c2.	aCanvas image: bottomLeftForm multipliedBy: c at: rect bottomLeft - (0@r).	aCanvas image: bottomRightForm multipliedBy: c at: rect bottomRight - (r@r) .	aCanvas fillRectangle: (rect bottomLeft+(r@ r negated) corner:  rect bottomRight - (r@0) ) fillStyle: c2.				f _ self fontToUse.	center _ bounds center.	label ifNotNil: [		labelMargin _ 7.		w _ f widthOfString: label.		availableW _ bounds width-labelMargin-labelMargin.		availableW >= w			ifTrue: [				l _ label ]			ifFalse: [				x _ bounds left + labelMargin.				targetSize _ label size * availableW // w.				l _ label squeezedTo: targetSize.				(f widthOfString: l) > availableW ifTrue: [					targetSize _ targetSize - 1.					l _ label squeezedTo: targetSize ]].				w _ f widthOfString: l.		x _ center x - (w // 2).		y _ center y - (f height // 2).		aCanvas			drawStringEmbossed: l			in: (x@y extent: bounds extent - (labelMargin*2-2@4))			font: f			color: Theme current buttonLabel ]! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:52'!buttonGradient	"	ButtonGradient _ nil.	"	| h gradientBottomFactor gradientTopFactor |	h _ Theme current buttonGradientHeight.	(ButtonGradient isNil or: [ ButtonGradient form height ~= h ]) ifTrue: [		gradientTopFactor _ Theme current buttonGradientTopFactor.		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ].		ButtonGradient _ InfiniteForm 		verticalGradient: h		topColor: Color white * gradientTopFactor		bottomColor: Color white * gradientBottomFactor ].	^ ButtonGradient! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!buttonGradientPressed	"	ButtonGradientPressed _ nil.	"	| h gradientBottomFactor gradientTopFactor |	h _ Theme current buttonGradientHeight.	(ButtonGradientPressed isNil or: [ ButtonGradientPressed form height ~= h ]) ifTrue: [		gradientTopFactor _ Theme current buttonGradientBottomFactor.		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ].		ButtonGradientPressed _ InfiniteForm 		verticalGradient: h		topColor: Color white * gradientTopFactor		bottomColor: Color white * gradientBottomFactor ].	^ ButtonGradientPressed! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerBL	"	RoundedCornerBL _ nil.	Display getCanvas translucentImage: self roundedCornerBL at: 520@60	"	| f r gradientBottomFactor |	r _ Theme current roundedButtonRadius.	(RoundedCornerBL notNil and: [		RoundedCornerBL width = r and: [ RoundedCornerBL height = r ]]) ifFalse: [		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ].		f _ Form			bottomLeftCorner: r			height: r			gradientTop: gradientBottomFactor			gradientBottom: gradientBottomFactor.		RoundedCornerBL _ f ].	^ RoundedCornerBL! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerBLPressed	"	RoundedCornerBLPressed _ nil.	Display getCanvas translucentImage: self roundedCornerBLPressed at: 620@60	"	| f r gradientBottomFactor |	r _ Theme current roundedButtonRadius.	(RoundedCornerBLPressed notNil and: [		RoundedCornerBLPressed width = r and: [ RoundedCornerBLPressed height = r ]]) ifFalse: [		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ].		f _ Form			bottomLeftCorner: r			height: r			gradientTop: gradientBottomFactor			gradientBottom: gradientBottomFactor.		RoundedCornerBLPressed _ f ].	^ RoundedCornerBLPressed! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerBR	"	RoundedCornerBR _ nil.	Display getCanvas translucentImage: self roundedCornerBR at: 540@60	"	| f r gradientBottomFactor |	r _ Theme current roundedButtonRadius.	(RoundedCornerBR notNil and: [		RoundedCornerBR width = r and: [ RoundedCornerBR height = r ]]) ifFalse: [		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ].		f _ Form			bottomRightCorner: r			height: r			gradientTop: gradientBottomFactor			gradientBottom: gradientBottomFactor.		RoundedCornerBR _ f ].	^ RoundedCornerBR! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerBRPressed	"	RoundedCornerBRPressed _ nil.	Display getCanvas translucentImage: self roundedCornerBRPressed at: 640@60	"	| f r gradientBottomFactor |	r _ Theme current roundedButtonRadius.	(RoundedCornerBRPressed notNil and: [		RoundedCornerBRPressed width = r and: [ RoundedCornerBRPressed height = r ]]) ifFalse: [		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ].		f _ Form			bottomRightCorner: r			height: r			gradientTop: gradientBottomFactor			gradientBottom: gradientBottomFactor.		RoundedCornerBRPressed _ f ].	^ RoundedCornerBRPressed! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerTL	"	RoundedCornerTL _ nil.	Display getCanvas translucentImage: self roundedCornerTL at: 520@10	"	| height f r gradientBottomFactor gradientTopFactor |	height _ Theme current buttonGradientHeight.	r _ Theme current roundedButtonRadius.	(RoundedCornerTL notNil and: [		RoundedCornerTL width = r and: [ RoundedCornerTL height = height ]]) ifFalse: [		gradientTopFactor _ Theme current buttonGradientTopFactor.		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ].		f _ Form			topLeftCorner: r			height: height			gradientTop: gradientTopFactor			gradientBottom: gradientBottomFactor.		RoundedCornerTL _ f ].	^ RoundedCornerTL! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerTLPressed	"	RoundedCornerTLPressed _ nil.	Display getCanvas translucentImage: self roundedCornerTLPressed at: 620@10	"	| height f r gradientBottomFactor gradientTopFactor |	height _ Theme current buttonGradientHeight.	r _ Theme current roundedButtonRadius.	(RoundedCornerTLPressed notNil and: [		RoundedCornerTLPressed width = r and: [ RoundedCornerTLPressed height = height ]]) ifFalse: [		gradientTopFactor _ Theme current buttonGradientBottomFactor.		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ].		f _ Form			topLeftCorner: r			height: height			gradientTop: gradientTopFactor			gradientBottom: gradientBottomFactor.		RoundedCornerTLPressed _ f ].	^ RoundedCornerTLPressed! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerTR	"	RoundedCornerTR _ nil.	Display getCanvas translucentImage: self roundedCornerTR at: 540@10	"	| height f r gradientBottomFactor gradientTopFactor |	height _ Theme current buttonGradientHeight.	r _ Theme current roundedButtonRadius.	(RoundedCornerTR notNil and: [		RoundedCornerTR width = r and: [ RoundedCornerTR height = height ]]) ifFalse: [		gradientTopFactor _ Theme current buttonGradientTopFactor.		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ].		f _ Form			topRightCorner: r			height: height			gradientTop: gradientTopFactor			gradientBottom: gradientBottomFactor.		RoundedCornerTR _ f ].	^ RoundedCornerTR! !!PluggableButtonMorph class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:53'!roundedCornerTRPressed	"	RoundedCornerTR _ nil.	Display getCanvas translucentImage: self roundedCornerTRPressed at: 640@10	"	| height f r gradientBottomFactor gradientTopFactor |	height _ Theme current buttonGradientHeight.	r _ Theme current roundedButtonRadius.	(RoundedCornerTRPressed notNil and: [		RoundedCornerTRPressed width = r and: [ RoundedCornerTRPressed height = height ]]) ifFalse: [		gradientTopFactor _ Theme current buttonGradientBottomFactor.		Theme current useButtonGradient			ifTrue: [				gradientBottomFactor _ Theme current buttonGradientTopFactor ]			ifFalse: [				gradientBottomFactor _ Theme current buttonGradientBottomFactor ].		f _ Form			topRightCorner: r			height: height			gradientTop: gradientTopFactor			gradientBottom: gradientBottomFactor.		RoundedCornerTRPressed _ f ].	^ RoundedCornerTRPressed! !!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:53'!drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle			width: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:53'!drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle 			width: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].	selectedMorph  ifNotNil:		[aCanvas fillRectangle:			((selectedMorph bounds: selectedMorph bounds in: self)						intersect: scroller bounds)				color: (Theme current listHighlightFocused: self hasKeyboardFocus)].	Preferences showLinesInHierarchyViews ifTrue:[		self drawLinesOn: aCanvas.	].! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jmv 12/6/2010 09:53'!buttonToTriggerIn: aFileList 	"Answer a button that will trigger the receiver service in a file list"	| aButton |	aButton := PluggableButtonMorph 				model: self				stateGetter: nil				action: #performServiceFor:.	aButton arguments: { 				aFileList}.	aButton label: self buttonLabel.	aButton color: (Theme current buttonColorFrom: aFileList class windowColor).	aButton setBalloonText: self description.	^aButton! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:43'!drawClassicFrameOn: aCanvas titleColor: titleColor	"Window border encompasses title area. No round corners. No title gradient."	borderColor class == Symbol		ifTrue: [			" This would of course be much better...			""			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor			"			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor			]		ifFalse: [			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ].	aCanvas fillRectangle: self titleAreaInnerRect color: titleColor! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:54'!drawLabelOn: aCanvas	Theme current embossedTitles		ifFalse: [			aCanvas				drawString: labelString				in: self labelRectangle				font: Preferences windowTitleFont				color: Theme current windowLabel ]		ifTrue: [			aCanvas				drawStringEmbossed: labelString				in: self labelRectangleForEmbossed				font: Preferences windowTitleFont				color: Theme current windowLabel ]! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:54'!drawOn: aCanvas	| titleColor widgetsColorToUse roundCorners titleGradient |	widgetsColorToUse _ self widgetsColor.	titleColor _ self isTopWindow		ifTrue: [ widgetsColorToUse lighter ]		ifFalse: [ widgetsColorToUse ].	roundCorners _ Theme current roundWindowCorners.	titleGradient _ Theme current useWindowTitleGradient.	roundCorners | titleGradient		ifTrue: [			"Title area is not inside window borders"			self drawWindowBodyOn: aCanvas roundCorners: roundCorners widgetsColor: widgetsColorToUse.			self drawWindowTitleAreaOn: aCanvas roundCorners: roundCorners titleColor: titleColor useTitleGradient: titleGradient ]		ifFalse: [			"Window border encompasses title area. No round corners. No title gradient."			self drawClassicFrameOn: aCanvas titleColor: titleColor ].	self drawLabelOn: aCanvas! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:54'!drawWindowBodyOn: aCanvas roundCorners: doRoundCorners widgetsColor: widgetsColor	"Title area is not inside window borders"	| r bl tl tr he tw bw |	doRoundCorners		ifFalse: [			borderColor class == Symbol				ifTrue: [					" This would of course be much better...					aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor					"					aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor ]				ifFalse: [					aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ]]		ifTrue: [			r _ Theme current roundedWindowRadius.			aCanvas image: SystemWindow roundedCornerBL multipliedBy: widgetsColor at: bounds bottomLeft - (0@r).			aCanvas image: SystemWindow roundedCornerBR multipliedBy: widgetsColor at: bounds bottomRight - (r@r) .			aCanvas fillRectangle: self innerBounds fillStyle: self fillStyle.			tl _ bounds topLeft + (0@self labelHeight).			tr _ bounds topRight + (borderWidth negated@self labelHeight).			bl _ bounds bottomLeft + (r@borderWidth negated).			he _ borderWidth@(bounds height - self labelHeight - r).			tw _ bounds width@borderWidth.			bw _ bounds width - r - r@borderWidth.			aCanvas fillRectangle: (tl extent: he) fillStyle: widgetsColor.			aCanvas fillRectangle: (tr extent: he) fillStyle: widgetsColor.			aCanvas fillRectangle: (bl extent: bw) fillStyle: widgetsColor.			aCanvas fillRectangle: (tl extent: tw) fillStyle: widgetsColor ]! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:54'!drawWindowTitleAreaOn: aCanvas roundCorners: doRoundCorners titleColor: titleColor useTitleGradient: useTitleGradient	| r h c |	h _ self labelHeight.	c _ useTitleGradient ifTrue: [ titleColor * Theme current titleGradientExtraLightness ] ifFalse: [ titleColor ].	doRoundCorners		ifFalse: [			useTitleGradient				ifTrue: [ aCanvas fillRectangle: self titleAreaRect infiniteForm: (SystemWindow titleGradient: h) multipliedBy: c ]				ifFalse: [ aCanvas fillRectangle: self titleAreaRect color: c ]]		ifTrue: [			r _ Theme current roundedWindowRadius.			useTitleGradient				ifTrue: [					aCanvas fillRectangle: (self titleAreaRect insetBy: r@0) infiniteForm: (SystemWindow titleGradient: h) multipliedBy: c.					aCanvas image: (SystemWindow roundedCornerTL: h) multipliedBy: c at: bounds topLeft.					aCanvas image: (SystemWindow roundedCornerTR: h) multipliedBy: c at: bounds topRight - (r@0)				]				ifFalse: [					aCanvas fillRectangle: (self titleAreaRect insetBy: r@0) color: c.					aCanvas image: (SystemWindow roundedCornerTL: h) multipliedBy: c at: bounds topLeft.					aCanvas image: (SystemWindow roundedCornerTR: h) multipliedBy: c at: bounds topRight - (r@0) 				]		]! !!SystemWindow methodsFor: 'panes' stamp: 'jmv 12/6/2010 09:54'!widgetsColor: aColor	"aColor will be used for titles, borders, etc.	A variation of it, #paneColorFrom:, will be used for panes background"	widgetsColor _ aColor.	aColor		ifNotNil: [ self color: (Theme current paneBackgroundFrom: aColor) ].	self adoptWidgetsColor: aColor.! !!SystemWindow class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:54'!roundedCornerBL	"	RoundedCornerBL _ nil.	Display getCanvas translucentImage: self roundedCornerBL at: 10@60	"	| f r |	r _ Theme current roundedWindowRadius.	(RoundedCornerBL notNil and: [		RoundedCornerBL width = r and: [ RoundedCornerBL height = r ]]) ifFalse: [		f _ Form			bottomLeftCorner: r			height: r			gradientTop: 1.0			gradientBottom: 1.0.		RoundedCornerBL _ f ].	^ RoundedCornerBL! !!SystemWindow class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:54'!roundedCornerBR	"	RoundedCornerBR _ nil.	Display getCanvas translucentImage: self roundedCornerBR at: 10@60	"	| f r |	r _ Theme current roundedWindowRadius.	(RoundedCornerBR notNil and: [		RoundedCornerBR width = r and: [ RoundedCornerBR height = r ]]) ifFalse: [		f _ Form			bottomRightCorner: r			height: r			gradientTop: 1.0			gradientBottom: 1.0.		RoundedCornerBR _ f ].	^ RoundedCornerBR! !!SystemWindow class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:54'!roundedCornerTL: height	"	RoundedCornerTL _ nil.	Display getCanvas translucentImage: (self roundedCornerTL:20) at: 520@10	"	| f r gradientBottomFactor gradientTopFactor |	r _ Theme current roundedWindowRadius.	(RoundedCornerTL notNil and: [		RoundedCornerTL width = r and: [ RoundedCornerTL height = height ]]) ifFalse: [		Theme current useWindowTitleGradient			ifTrue: [				gradientTopFactor _ Theme current titleGradientTopFactor.				gradientBottomFactor _ Theme current titleGradientBottomFactor ]			ifFalse: [				gradientTopFactor _ 1.0.				gradientBottomFactor _ 1.0 ].		f _ Form			topLeftCorner: r			height: height			gradientTop: gradientTopFactor			gradientBottom: gradientBottomFactor.		RoundedCornerTL _ f ].	^ RoundedCornerTL! !!SystemWindow class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:54'!roundedCornerTR: height	"	RoundedCornerTR _ nil.	Display getCanvas translucentImage: self roundedCornerTR at: 10@60	"	| f r gradientBottomFactor gradientTopFactor |	r _ Theme current roundedWindowRadius.	(RoundedCornerTR notNil and: [		RoundedCornerTR width = r and: [ RoundedCornerTR height = height ]]) ifFalse: [		Theme current useWindowTitleGradient			ifTrue: [				gradientTopFactor _ Theme current titleGradientTopFactor.				gradientBottomFactor _ Theme current titleGradientBottomFactor ]			ifFalse: [				gradientTopFactor _ 1.0.				gradientBottomFactor _ 1.0 ].		f _ Form			topRightCorner: r			height: height			gradientTop: gradientTopFactor			gradientBottom: gradientBottomFactor.		RoundedCornerTR _ f ].	^ RoundedCornerTR! !!SystemWindow class methodsFor: 'accessing - forms' stamp: 'jmv 12/6/2010 09:55'!titleGradient: h	"	TitleGradient _ nil.	"	(TitleGradient isNil or: [ TitleGradient form height ~= h ]) ifTrue: [		TitleGradient _ InfiniteForm 		verticalGradient: h		topColor: Color white * Theme current titleGradientTopFactor		bottomColor: Color white * Theme current titleGradientBottomFactor ].	^ TitleGradient! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 12/6/2010 09:55'!optionalButtonRow	| row button buttons widths buttonColor |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	buttonColor _ Theme current buttonColorFrom: self class windowColor.	self optionalButtonTuples do: [ :tuple | 		widths add: tuple first.		button _ PluggableButtonMorph 			model: self			stateGetter: nil			action: tuple third.		button color: buttonColor.		button			label: tuple second.		buttons add: button].	row _ AlignmentMorph proportional.	row color: buttonColor.	row addInRow: buttons widthProportionalTo: widths.	^row! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 12/6/2010 09:55'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self hasUnacceptedEdits							ifTrue: [								model wantsDiffFeedback									ifTrue: [										bw _ 4.										bc _ Color green]									ifFalse: [										bc _ Color red]]							ifFalse: [								model wantsDiffFeedback									ifTrue: [										bc _ Color green]									ifFalse: []]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Theme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle width: bw color: bc ]! !