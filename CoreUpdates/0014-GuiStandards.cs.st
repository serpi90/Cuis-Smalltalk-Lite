'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 7 May 2008 at 12:48:54 am'!!classDefinition: #LightWidget category: #'LightWidgets-Kernel'!Object subclass: #LightWidget	instanceVariableNames: 'owner bounds model modelUpdateSelector isVisible actionAdaptor target aspect aspectAdaptor action '	classVariableNames: ''	poolDictionaries: ''	category: 'LightWidgets-Kernel'!!LightWidget commentStamp: 'jmv 5/1/2008 15:53' prior: 0!The base of the LightWidgets framework. LightWidgets is a small widgets set for Morphic in the Morphic3 image.LightWidgets are usually composed in views that exhibits some model to the user. They also allow acting on it. We call it "target" instead of "model" because it could be another view. This happens, for example, with buttons and menu items that open new views, close them, or act on them in some way that is not related to the real model.As a view my instances show some aspect of a model or target. For this, an aspectAdaptor symbol might be used, for example, to convert the the value of the aspect to a String.They can also act on the target, using some action. For this, an actionAdaptor symbol might be used, for example, to convert the value in the widget (usually a String) into a value suitable for the target (for example a Number).!!classDefinition: #ButtonLW category: #'LightWidgets-Kernel'!LightWidget subclass: #ButtonLW	instanceVariableNames: 'label font pressed contentsOrGetter '	classVariableNames: ''	poolDictionaries: ''	category: 'LightWidgets-Kernel'!!classDefinition: #LabelLW category: #'LightWidgets-Kernel'!LightWidget subclass: #LabelLW	instanceVariableNames: 'label font contents '	classVariableNames: ''	poolDictionaries: ''	category: 'LightWidgets-Kernel'!!Object methodsFor: 'testing' stamp: 'jmv 5/1/2008 23:08'!isSymbol	"Overridden to return true in Symbol"	^ false! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:29'!action	"The action is the message to send to the model (or target widget) 	when the user enters some value or invokes an action."		^action! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:29'!action: aSymbol	"The action is the message to send to the model (or target widget) 	when the user enters some value or invokes an action."		action _ aSymbol! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:29'!actionAdaptor	"The actionAdaptor is a message that is sent to the value that the user entered 	to adapt it to be sent to the model (or target widget), as an argument in the action."		^actionAdaptor! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:29'!actionAdaptor: aSymbol	"The actionAdaptor is a message that is sent to the value that the user entered 	to adapt it to be sent to the model (or target widget), as an argument in the action."		actionAdaptor _ aSymbol! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:29'!aspect	"The aspect is what part of the model (or target widget) we are concerned with. 	It is a message sent to the target to get the object to show to the user."		^aspect! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:29'!aspect: aSymbol	"The aspect is what part of the model (or target widget) we are concerned with. 	It is a message sent to the target to get the object to show to the user."		aspect _ aSymbol.	self modelChanged! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/1/2008 16:13'!aspectAdaptor	"The aspect adaptor is a message sent to the aspect to adapt it for viewing. 	For example, the aspect could be a numeric value, but it is shown as a String."		^aspectAdaptor! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:00'!aspectAdaptor: aSymbol	"The aspect adaptor is a message sent to the aspect to adapt it for viewing. 	For example, the aspect could be a numeric value, but it is shown as a String."		aspectAdaptor _ aSymbol.	self modelChanged! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:30'!beMainViewOn: aModel	"We are a main view on aModel.	This means:		- aModel is a real model, i.e. not a widget.		- no aspect or aspectAdaptor. We show the whole thing.		- no action or actionAdaptor. There is no main action.		- we must update ourselves on #selfChanged event"		self target: aModel aspect: nil aspectAdaptor: nil modelChangeEvent: #selfChanged! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/7/2008 00:24'!modelChanged	"The model changed is some way.	This is usually the pace to call #targetAspect to fetch the current value of the aspect from the		model, and to store it in some Model Extension.	We must update all Model Extension instance variables with values from the model (i.e. target)		or with appropriate defaults.	We must update ourselves and all subviews to reflect the model's new state"	self updateView! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:32'!target	"As a view I show some aspect of a model (or target widget) (may use aspectAdaptor).	I also can act on my model (or target widget), using some action (may use actionAdaptor)."		^target! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:32'!target: aModelOrView	"As a view I show some aspect of a model (or target widget) (may use aspectAdaptor).	I also can act on my model (or target widget), using some action (may use actionAdaptor)."		target _ aModelOrView.	self modelChanged! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 23:05'!target: aModelOrView action: aSymbol	"As a view I show some aspect of a model (or target widget) (may use aspectAdaptor).	I also can act on my model (or target widget), using some action (may use actionAdaptor)."		target _ aModelOrView.	self modelChanged.	action _ aSymbol! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:34'!target: aModelOrView aspect: aSymbol	"As a view I show some aspect of a model (or target widget) (may use aspectAdaptor).	I also can act on my model (or target widget), using some action (may use actionAdaptor)."		self target: aModelOrView aspect: aSymbol aspectAdaptor: nil! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:36'!target: aModelOrView aspect: aSymbol aspectAdaptor: anotherSymbol	"As a view I show some aspect of a model (or target widget) (may use aspectAdaptor).	I also can act on my model (or target widget), using some action (may use actionAdaptor)."		"The aspect is what part of the model (or target widget) we are concerned with. 	It is a message sent to the model (or target widget) to get the object to show to the user."		"The aspect adaptor is a message sent to the aspect to adapt it for viewing. 	For example, the aspect could be a numeric value, but it is shown as a String."		target _ aModelOrView.	aspect _ aSymbol.	aspectAdaptor _ anotherSymbol.	self modelChanged! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:43'!target: aModel aspect: aSymbol aspectAdaptor: anotherSymbol modelChangeEvent: eventSymbol	"Widgets are notified of model changes by being sent #modelChanged.	This happens when:		- The widget is given a new model (or target widget), aspect or aspect adaptor		- An owner view is updated			In addition, main views are updated from model events. See #beMainViewOn:			But other widgets might update on more specific events from the model. This is useful to 	update only a small subview, and not the whole main view.		This message is sent to such widgets, to set this specific event.		Warning:	When models change, they should trigger just one event.	It might be #selfChanged (the most general one) or a more specific one.	But it should not trigger more than one event for each change."			self target: aModel aspect: aSymbol aspectAdaptor: anotherSymbol.	target when: eventSymbol send: #modelChanged to: self! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/1/2008 23:21'!targetAspect	| answer |	aspect isNil ifTrue: [		^target].	answer _ target perform: aspect.	aspectAdaptor isNil ifTrue: [		^answer].	^answer perform: aspectAdaptor! !!LightWidget methodsFor: 'view of a model or target' stamp: 'jmv 5/6/2008 22:17'!updateView	"The model or some Model Extension changed is some way.	We must update ourselves to reflect the new state.	This is the place to update secondary Model Extensions or any other state that must be updated	after model or Model Extension change.	This method is usually reimplemented in CompositeLWs, to update subviews.		The subviews should be sent one of the following messages:		target:		target:aspect:		target:aspect:aspectAdaptor:		target:aspect:aspectAdaptor:aspectChangeEvent:	to update their model and do a full update, as triggered by #modelChanged"		self changed! !!ButtonLW methodsFor: 'accessing' stamp: 'jmv 5/6/2008 23:12'!label: aString	contentsOrGetter _ aString.	self modelChanged! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 5/6/2008 22:18'!keyDown: evt	"Handle a key down event."	(evt commandKeyPressed and: [evt keyValue = 13]) ifTrue: [		ActiveHand navigationFocus notNil ifTrue: [			ActiveHand navigationFocus: self].		pressed _ true.		self updateView].	super keyDown: evt! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 5/6/2008 22:12'!keyUp: evt	"Handle a key up event."		(evt commandKeyPressed and: [evt keyValue = 13]) ifTrue: [		(target notNil and: [action notNil])			ifTrue: [target perform: action].		pressed _ false.		self updateView].	super keyUp: evt! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 5/6/2008 22:18'!mouseDown: evt	ActiveHand navigationFocus notNil ifTrue: [		ActiveHand navigationFocus: self].	pressed _ true.	self updateView! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 5/6/2008 22:12'!mouseUp: evt	"Handle a mouse up event."	(target notNil and: [action notNil] and: [self containsPoint: evt cursorPoint])		ifTrue: [target perform: action].	pressed _ false.	self updateView! !!ButtonLW methodsFor: 'initialization' stamp: 'jmv 5/1/2008 23:45'!initialize	super initialize.	target _ 'I am the target'.	action _ #show.	bounds _ 10@10 extent: 60@30.	label _ 'button label'.	font _ (TextStyle named: 'Vera') fontNamed: 'Vera 16'.	pressed _ false! !!ButtonLW methodsFor: 'updating' stamp: 'jmv 5/7/2008 00:24'!modelChanged	"The model changed is some way.	This is usually the pace to call #targetAspect to fetch the current value of the aspect from the		model, and to store it in some Model Extension.	We must update all Model Extension instance variables with values from the model (i.e. target)		or with appropriate defaults.	We must update ourselves and all subviews to reflect the model's new state"	pressed _ self targetAspect == true.		contentsOrGetter notNil ifTrue: [		contentsOrGetter isSymbol ifTrue: [			label _ target perform: contentsOrGetter ]		ifFalse: [			label _ contentsOrGetter asString ]].		super modelChanged! !!CompositeLW methodsFor: 'updating' stamp: 'jmv 5/6/2008 23:46'!updateView	"The model or some Model Extension changed is some way.	We must update ourselves to reflect the new state.	This is the place to update secondary Model Extensions or any other state that must be updated	after model or Model Extension change.	This method is usually reimplemented in CompositeLWs, to update subviews.		The subviews should be sent one of the following messages:		target:		target:aspect:		target:aspect:aspectAdaptor:		target:aspect:aspectAdaptor:aspectChangeEvent:	to update their model and do a full update, as triggered by #modelChanged"		self subclassResponsibility! !!LabelLW methodsFor: 'accessing' stamp: 'jmv 5/6/2008 22:04'!label: aString	self target: aString aspect: nil aspectAdaptor: nil! !!LabelLW methodsFor: 'drawing' stamp: 'jmv 5/1/2008 23:30'!drawOn: aCanvas	aCanvas drawString: contents asString at: bounds topLeft font: font color: Color blue! !!LabelLW methodsFor: 'initialization' stamp: 'jmv 5/1/2008 22:39'!initialize	super initialize.	bounds _ 10@10 extent: 60@30.	font _ self defaultFont.	self label: 'label'! !!LabelLW methodsFor: 'updating' stamp: 'jmv 5/7/2008 00:24'!modelChanged	"The model changed is some way.	This is usually the pace to call #targetAspect to fetch the current value of the aspect from the		model, and to store it in some Model Extension.	We must update all Model Extension instance variables with values from the model (i.e. target)		or with appropriate defaults.	We must update ourselves and all subviews to reflect the model's new state"		contents _ self targetAspect.	super modelChanged! !!OldMorph methodsFor: 'menus' stamp: 'jmv 5/6/2008 23:19'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph
	"Add standard halo items to the menu"

	| unlockables |

	self isWorldMorph ifTrue:
		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].

	aMenu add: 'send to back' translated action: #goBehind.	aMenu add: 'bring to front' translated action: #comeToFront.	self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.	aMenu addLine.

	self addFillStyleMenuItems: aMenu hand: aHandMorph.
	self addBorderStyleMenuItems: aMenu hand: aHandMorph.
	self addLayoutMenuItems: aMenu hand: aHandMorph.
	self addHaloActionsTo: aMenu.
	owner isTextMorph ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].
	aMenu addLine.
	self addToggleItemsToHaloMenu: aMenu.
	aMenu addLine.
	self addCopyItemsTo: aMenu.
	self addExportMenuItems: aMenu hand: aHandMorph.
	Preferences noviceMode ifFalse:
		[self addDebuggingItemsTo: aMenu hand: aHandMorph].

	aMenu addLine.
	aMenu defaultTarget: self.

	aMenu addLine.

	unlockables _ self submorphs select:
		[:m | m isLocked].
	unlockables size == 1 ifTrue:
		[aMenu
			add: ('unlock "{1}"' translated format: unlockables first externalName)
			action: #unlockContents].
	unlockables size > 1 ifTrue:
		[aMenu add: 'unlock all contents' translated action: #unlockContents.
		aMenu add: 'unlock...' translated action: #unlockOneSubpart].

	aMenu defaultTarget: aHandMorph.
! !!OldMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 5/6/2008 23:18'!goBehind	owner addMorphBack: self.! !!OldSystemWindow methodsFor: 'menu' stamp: 'jmv 5/6/2008 23:18'!sendToBack	| aWorld nextWindow |	aWorld := self world.	nextWindow := aWorld submorphs 				detect: [:m | (m isSystemWindow) and: [m ~~ self]]				ifNone: [^self].	nextWindow activate.	aWorld addMorphBack: self! !!StackedPageSample1LW methodsFor: 'initialization' stamp: 'jmv 5/6/2008 23:06'!initialize	| title close menu |	super initialize.	level _ 1.	bounds _ 0 @ 0 extent: 400 @ 300.	title _ LabelLW new.	title		label: 'Application Start';		bounds: (110@30 corner: 300@60).	close _ ButtonLW new.	close		target: self action: #delete;		label: 'x';		bounds: (0@0 extent: 25@25).	menu _ CompositeLW new.	menu bounds: (20@150 extent: 340@120).	menu		addMorph: (MenuItemLW new			target: self action: #openChild;			label: 'Something to do 4';			bounds: (20@240 extent: 340@30));		addMorph: (MenuItemLW new			target: self action: #openChild;			label: 'Something to do 3';			bounds: (20@210 extent: 340@30));		addMorph:  (MenuItemLW new			target: self action: #openChild;			label: 'Something to do 2';			bounds: (20@180 extent: 340@30));		addMorph: (firstFocus _ MenuItemLW new			target: self action: #delete;			label: 'Go Back';			bounds: (20@150 extent: 340@30)).	self		addMorph: title;		addMorph: close;		addMorph: menu.	ActiveHand navigationFocus: firstFocus! !!Symbol methodsFor: 'testing' stamp: 'jmv 5/1/2008 23:09'!isSymbol	^ true! !OldMorph removeSelector: #addMorphNearBack:!OldMorph removeSelector: #mustBeBackmost!LabelLW removeSelector: #updateView!!classDefinition: #LabelLW category: #'LightWidgets-Kernel'!LightWidget subclass: #LabelLW	instanceVariableNames: 'font contents'	classVariableNames: ''	poolDictionaries: ''	category: 'LightWidgets-Kernel'!!LabelLW reorganize!('accessing' label:)('drawing' drawOn:)('initialization' initialize)('updating' modelChanged)!!CompositeLW reorganize!('change reporting' addedMorph: privateInvalidateMorph:)('drawing' drawSubmorphsOn: fullDrawOn:)('dropping/grabbing' acceptDroppingMorph:event: dropEnabled repelsMorph:event: wantsDroppedMorph:event:)('events-processing' handleDropMorph: rejectDropEvent:)('initialization' initialize)('submorphs-accessing' allMorphsDo: firstSubmorph hasSubmorphs morphsAt:behind:unlocked: submorphs submorphsDo:)('submorphs-add/remove' addMorph: addMorphBack: addMorphFront: removeMorph: removedMorph:)('private' privateAddMorph:atIndex: privateFullMoveBy: privateRemove:)('updating' updateView)!ButtonLW removeSelector: #keyStroke:!ButtonLW removeSelector: #updateView!!classDefinition: #ButtonLW category: #'LightWidgets-Kernel'!LightWidget subclass: #ButtonLW	instanceVariableNames: 'pressed contentsOrGetter font label'	classVariableNames: ''	poolDictionaries: ''	category: 'LightWidgets-Kernel'!!ButtonLW reorganize!('accessing' label:)('drawing' drawOn:)('event handling' keyDown: keyUp: mouseDown: mouseUp:)('events-processing' handlesKeyboard: handlesMouseDown: handlesMouseStillDown:)('initialization' initialize)('updating' modelChanged)!LightWidget removeSelector: #model:!LightWidget removeSelector: #modelUpdateSelector:!LightWidget removeSelector: #target:aspect:aspectAdaptor:aspectChangeEvent:!LightWidget removeSelector: #update!!classDefinition: #LightWidget category: #'LightWidgets-Kernel'!Object subclass: #LightWidget	instanceVariableNames: 'owner bounds isVisible target aspect aspectAdaptor action actionAdaptor'	classVariableNames: ''	poolDictionaries: ''	category: 'LightWidgets-Kernel'!!LightWidget reorganize!('DNU' doesNotUnderstand:)('accessing' eventHandler isLocked isSticky morphsAt:behind:unlocked: owner privateOwner: world)('accessing-properties' hasProperty:)('add/remove' delete dismissViaHalo privateDelete)('change reporting' invalidRect: invalidRect:from: ownerChanged)('classification' isHandMorph isWorldMorph isWorldOrHandMorph)('compatibility' allMorphsDo: isPlayfieldLike morphicLayerNumber morphicLayerNumberWithin: noteNewOwner: submorphs submorphsDo:)('copying' duplicate)('debug and other' buildDebugMenu:)('defaults' borderStyleFor: borderStyleWith: defaultFont pressedBorderStyleWith:)('drawing' areasRemainingToFill: drawErrorOn: drawHighlightOn: drawOn: drawingFails drawingFailsNot fullDrawOn: hide isKnownFailing shadowForm show visible visible:)('dropping/grabbing' aboutToBeGrabbedBy: formerOwner: formerPosition: justDroppedInto:event: justGrabbedFrom: rejectDropMorphEvent: wantsToBeDroppedInto:)('event handling' handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: handlesMouseStillDown: keyboardFocusChange: mouseMove: mouseStillDown: mouseStillDownStepRate mouseStillDownThreshold mouseUp: transformFrom: transformedFrom:)('events-processing' handleEvent: handleFocusEvent: handleKeyDown: handleKeyUp: handleKeystroke: handleMouseDown: handleMouseEnter: handleMouseLeave: handleMouseMove: handleMouseOver: handleMouseStillDown: handleMouseUp: handlerForMouseDown: handlesKeyboard: keyDown: keyStroke: keyUp: mouseDownPriority processEvent:using: rejectDropEvent: rejectsEvent:)('geometry' bounds bounds: extent: fullBounds fullBoundsInWorld point:from: point:in: pointInWorld: position position: referencePosition referencePosition: worldBoundsForHalo)('geometry testing' containsPoint: containsPoint:event: fullContainsPoint:)('halos and balloon help' addHalo: addHalo:from: addHandlesTo:box: addOptionalHandlesTo:box: balloonHelpTextForHandle: balloonText halo haloClass removeHalo setExtentFromHalo: transferHalo:from: wantsBalloon wantsHaloFromClick)('initialization' initialize intoWorld: openInWorld openInWorld:)('layout' layoutChanged)('menus' inspectInMorphic:)('meta actions' blueButtonDown: blueButtonUp: dismissMorph: duplicateMorph: handlerForBlueButtonDown:)('rotation scale and flex' rotationDegrees rotationDegrees:)('stepping and presenter' shouldGetStepsFrom: startStepping:at:arguments:stepTime: stopSteppingSelector:)('structure' activeHand allOwnersDo: firstOwnerSuchThat: hasOwner: isInWorld outermostWorldMorph ownerThatIsA: withAllOwnersDo:)('submorphs-add/remove' comeToFront goBehind)('testing' hasNavigationFocus isTextMorph resistsRemoval shouldDropOnMouseUp wantsSteps)('updating' changed)('view of a model or target' action action: actionAdaptor actionAdaptor: aspect aspect: aspectAdaptor aspectAdaptor: beMainViewOn: modelChanged target target: target:action: target:aspect: target:aspect:aspectAdaptor: target:aspect:aspectAdaptor:modelChangeEvent: targetAspect updateView)('private' privateFullMoveBy: privateMoveBy:)!!KeyboardEvent reorganize!('comparing' = hash)('dispatching' sentTo:)('initialize' type:readFrom:)('keyboard' keyCharacter keyValue)('printing' printOn: storeOn:)('testing' isKeyDown isKeyUp isKeyboard isKeystroke isMouseMove)('private' setType:buttons:position:keyValue:hand:stamp:)!!Object reorganize!('*VMMaker-translation support' asIf:var: asIf:var:asValue: asIf:var:put: asOop: asSmallIntegerObj asValue: cCode: cCode:inSmalltalk: cCoerce:to: debugCode: export: primitive:parameters:receiver: remapOop:in: returnTypeC: sharedCodeNamed:inCase: stAt: stAt:put: stSize static: suppressFailureGuards: var:type: var:type:array:)('*sunit-preload' sunitAddDependent: sunitChanged: sunitRemoveDependent:)('*tools-browser' browse browseHierarchy)('Breakpoint' break)('accessing' addInstanceVarNamed:withValue: at: at:modify: at:put: basicAt: basicAt:put: basicSize bindWithTemp: doIfNotNil: ifNotNilDo: in: readFromString: size yourself)('as yet unclassified' revisar)('associating' ->)('binding' bindingOf:)('casing' caseOf: caseOf:otherwise:)('class membership' class inheritsFromAnyIn: isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass)('comparing' = closeTo: hash hashMappedBy: identityHashMappedBy: identityHashPrintString literalEqual: ~=)('converting' adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: as: asActionSequence asActionSequenceTrappingErrors asOrderedCollection asString asStringOrText complexContents mustBeBoolean mustBeBooleanIn: printDirectlyToDisplay withoutListWrapper)('copying' clone copy copyAddedStateFrom: copyFrom: copySameFrom: copyTwoLevel deepCopy initialDeepCopierSize postCopy shallowCopy veryDeepCopy veryDeepCopySibling veryDeepCopyUsing: veryDeepCopyWith: veryDeepFixupWith: veryDeepInner:)('creation' asMorph openAsMorph)('dependents access' addDependent: breakDependents canDiscardEdits dependents hasUnacceptedEdits myDependents myDependents: release removeDependent:)('deprecated' beep: beepPrimitive)('drag and drop' acceptDroppingMorph:event:inMorph: dragAnimationFor:transferMorph: dragTransferType dragTransferTypeForMorph:)('error handling' assert: caseError confirm: confirm:orCancel: deprecated: deprecated:block: deprecated:explanation: deprecatedExplanation: doesNotUnderstand: error: halt halt: handles: notify: notify:at: notifyWithLabel: primitiveFailed shouldBeImplemented shouldNotImplement subclassResponsibility)('evaluating' value valueWithArguments:)('events-accessing' actionForEvent: actionForEvent:ifAbsent: actionMap actionSequenceForEvent: actionsDo: createActionMap hasActionForEvent: setActionSequence:forEvent: updateableActionMap)('events-registering' when:evaluate: when:send:to: when:send:to:with: when:send:to:withArguments:)('events-removing' releaseActionMap removeAction:forEvent: removeActionsForEvent: removeActionsSatisfying: removeActionsSatisfying:forEvent: removeActionsWithReceiver: removeActionsWithReceiver:forEvent:)('events-triggering' triggerEvent: triggerEvent:ifNotHandled: triggerEvent:with: triggerEvent:with:ifNotHandled: triggerEvent:withArguments: triggerEvent:withArguments:ifNotHandled:)('filter streaming' byteEncode: drawOnCanvas: elementSeparator flattenOnStream: printOnStream: putOn: storeOnStream: writeOnFilterStream:)('finalization' actAsExecutor executor finalizationRegistry finalize retryWithGC:until: toFinalizeSend:to:with:)('flagging' isThisEverCalled isThisEverCalled: logEntry logExecution logExit)('inspecting' basicInspect inspect inspectorClass)('macpal' contentsChanged currentEvent currentHand currentWorld flash ifKindOf:thenDo: instanceVariableValues playSoundNamed: refusesToAcceptCode)('message handling' perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: withArgs:executeMethod:)('objects from disk' comeFullyUpOnReload: convertToCurrentVersion:refStream: indexIfCompact objectForDataStream: readDataFrom:size: storeDataOn:)('printing' fullPrintString isLiteral longPrintOn: longPrintOn:limitedTo:indent: longPrintString nominallyUnsent: print printOn: printString printStringLimitedTo: storeOn: storeString stringForReadout stringRepresentation)('scripting' defaultFloatPrecisionFor:)('system primitives' asOop becomeForward: becomeForward:copyHash: className instVarAt: instVarAt:put: instVarNamed: instVarNamed:put: oopString primitiveChangeClassTo: rootStubInImageSegment: someObject)('testing' basicType haltIfNil isBehavior isBlock isBlockClosure isColor isColorForm isCompiledMethod isFloat isForm isFraction isHeap isInteger isInterval isMessageSend isMorph isMorphicEvent isMorphicModel isNumber isPoint isPseudoContext isStream isString isSymbol isSystemWindow isText isTransparent isVariableBinding isWebBrowser knownName name notNil renameTo: showDiffs stepAt:in: stepIn: stepTime stepTimeIn: wantsDiffFeedback wantsSteps wantsStepsIn:)('translation support' inline: var:declareC:)('updating' changed changed: changed:with: noteSelectionIndex:for: okToChange update: update:with: updateListsAndCodeIn: windowIsClosing)('user interface' addModelItemsToWindowMenu: addModelMenuItemsTo:forMorph:hand: asExplorerString beep defaultBackgroundColor defaultLabelForInspector explore fullScreenSize hasContentsInExplorer inform: initialExtent inspectWithLabel: launchPartVia:label: modelSleep modelWakeUp modelWakeUpIn: mouseUpBalk: notYetImplemented show windowActiveOnFirstClick windowReqNewLabel:)('viewer' externalName)('private' errorImproperStore errorNonIntegerIndex errorNotIndexable errorSubscriptBounds: primitiveError: species storeAt:inTempFrame:)!