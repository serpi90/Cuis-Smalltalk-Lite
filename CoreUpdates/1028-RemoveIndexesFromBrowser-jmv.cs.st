'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 8 June 2011 at 10:00:43 am'!!classDefinition: #Browser category: #'Tools-Browser'!CodeProvider subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer systemCategoryListIndex classListIndex messageCategoryListIndex messageListIndex editSelection metaClassIndicated selectedSystemCategory selectedMessage selectedClassName selectedMessageCategory '	classVariableNames: 'RecentClasses '	poolDictionaries: ''	category: 'Tools-Browser'!!classDefinition: #ChangeList category: #'Tools-Changes'!CodeProvider subclass: #ChangeList	instanceVariableNames: 'changeList list listIndex listSelections file lostMethodPointer '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #MessageNames category: #'Tools-Browser'!MessageSet subclass: #MessageNames	instanceVariableNames: 'searchString selectorList selectorListIndex selectedSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!!classDefinition: #ProcessBrowser category: #'Tools-Debugger'!ActiveModel subclass: #ProcessBrowser	instanceVariableNames: 'selectedProcess selectedContext methodText processList processListIndex stackList stackListIndex selectedClass selectedSelector searchString '	classVariableNames: 'SuspendedProcesses '	poolDictionaries: ''	category: 'Tools-Debugger'!!BareTextMorph methodsFor: 'private' stamp: 'jmv 6/8/2011 08:15'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	"release editor too"	editor ifNotNil: [		self selectionChanged.		editor _ nil].	paragraph ifNotNil: [		paragraph selectionStartBlocks: #() selectionStopBlocks: #().	"most likely not needed"		paragraph _ nil]! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 6/8/2011 09:00'!updateListsAndCodeIn: aWindow	"This is done because we are not the real model (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	aWindow canDiscardEdits ifTrue: [		aWindow updatablePanes do: [:aPane | aPane verifyContents]].	self updatePaneIfNeeded! !!Browser methodsFor: 'accessing' stamp: 'jmv 6/8/2011 08:14'!acceptedStringOrText	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClass)			ifNil: [				Class template: selectedSystemCategory]			ifNotNil: [				Class templateForSubclassOf: theClass category: selectedSystemCategory]].	editSelection == #editClass 		ifTrue: [			^ self classDefinitionText ].	editSelection == #editComment 		ifTrue: [			(theClass _ self selectedClass) ifNil: [^ ''].			comment _ theClass comment.			currentCompiledMethod _ theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [			^ (theClass _ self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue: [			self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'accessing' stamp: 'jmv 6/8/2011 08:43'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	(selectedMessageCategory notNil and: [selectedMessage isNil ])		ifTrue: [^ 1 to: 500]	"entire empty method template"		ifFalse: [^ 1 to: 0]  "null selection"! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/7/2011 22:37'!copyClass	| originalClass originalName copysName |	selectedClassName ifNil: [^ self].	originalClass := self selectedClass.	originalName := originalClass name.	copysName _ self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName _ copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk includesKey: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	Cursor wait 		showWhile: [			| newDefinition newMetaDefinition newClass |			newDefinition := originalClass definition				copyReplaceAll: originalName printString				with: copysName printString.			newClass _ Smalltalk actualCompilerClass evaluate: newDefinition logged: true.			newMetaDefinition := originalClass class definition				copyReplaceAll: originalClass class name				with: newClass class name.			Smalltalk actualCompilerClass evaluate: newMetaDefinition logged: true.			newClass copyAllCategoriesFrom: originalClass.			newClass class copyAllCategoriesFrom: originalClass class.			originalClass hasComment ifTrue: [				newClass comment: originalClass comment ] ].	self classListIndex: 0.	self changed: #classList! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/7/2011 22:35'!editClass	"Retrieve the description of the class definition."	selectedClassName ifNil: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #editClass.	self acceptedContentsChanged.	self changed: #classCommentText.! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/7/2011 22:41'!editComment	"Retrieve the description of the class comment."	selectedClassName ifNil: [ ^self ].	self messageCategoryListIndex: 0.	metaClassIndicated _ false.	self editSelection: #editComment.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self acceptedContentsChanged! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/7/2011 22:37'!fileOutClass	"Print a description of the selected class onto a file whose name is the 	category name followed by .st."Cursor write showWhile: [	selectedClassName ifNotNil: [ self selectedClass fileOut ]]! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/7/2011 22:34'!hierarchy	"Display the inheritance hierarchy of the receiver's selected class."	selectedClassName ifNil: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #hierarchy.	self changed: #editComment.	self acceptedContentsChanged.	^ self! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/7/2011 22:39'!plusButtonHit	"Cycle among definition, comment, and hierachy"	editSelection == #editComment		ifTrue: [			self hierarchy.			^ self].	editSelection == #hierarchy		ifTrue: [			self editSelection: #editClass.			selectedClassName ifNil: [ ^self ].			self changed: #editComment.			self acceptedContentsChanged.			^ self].	self editComment! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/8/2011 08:13'!renameClass	| oldName newName obs |	selectedClassName ifNil: [ ^self ].	oldName _ self selectedClass name.	newName _ self request: 'Please type new class name' initialAnswer: oldName.	newName = '' ifTrue: [^ self].  " Cancel returns '' "	newName _ newName asSymbol.	newName = oldName ifTrue: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	self selectedClass rename: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: selectedSystemCategory) indexOf: newName).	obs _ Smalltalk allCallsOn: (Smalltalk associationAt: newName).	obs isEmpty ifFalse: [		Smalltalk 			browseMessageList: obs			name: 'Obsolete References to ' , oldName			autoSelect: oldName	].! !!Browser methodsFor: 'class list' stamp: 'jmv 6/8/2011 08:13'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	^selectedSystemCategory		ifNil: [#()]		ifNotNil: [systemOrganizer listAtCategoryNumber: self systemCategoryListIndex]! !!Browser methodsFor: 'class list' stamp: 'jmv 6/7/2011 22:44'!classListIndex	"Answer the index of the current class selection."	selectedClassName ifNil: [ ^0 ].	^ self classList indexOf: selectedClassName! !!Browser methodsFor: 'class list' stamp: 'jmv 6/8/2011 08:47'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	selectedClassName _ anInteger = 0 ifFalse: [ self classList at: anInteger ].	self setClassOrganizer.	selectedMessageCategory _ nil.	selectedMessage _ nil.	self classCommentIndicated		ifFalse: [			self editSelection: (anInteger = 0				ifTrue: [					metaClassIndicated | selectedSystemCategory isNil						ifTrue: [#none]						ifFalse: [#newClass]]				ifFalse: [#editClass])].	self selectedClass		ifNotNil: [			className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self acceptedContentsChanged! !!Browser methodsFor: 'class list' stamp: 'jmv 6/7/2011 22:39'!selectedClassName	"Answer the name of the current class. Answer nil if no selection exists."	^selectedClassName ifNotNil: [		(self classList includes: selectedClassName)			ifTrue: [ selectedClassName ]]! !!Browser methodsFor: 'code pane' stamp: 'jmv 6/8/2011 08:46'!compileMessage: aText notifying: aController	"Compile the code that was accepted by the user, placing the compiled method into an appropriate message category.  Return true if the compilation succeeded, else false."	| fallBackCategory fallBackMessage originalSelectorName result |	self selectedMessageCategoryName ifNil: [		self selectOriginalCategoryForCurrentMethod 				ifFalse: [ "Select the '--all--' category"				self messageCategoryListIndex: 1]]. 	self selectedMessageCategoryName asSymbol = ClassOrganizer allCategory		ifTrue: [			"User tried to save a method while the ALL category was selected"			fallBackCategory _ selectedMessageCategory.			fallBackMessage _ selectedMessage.			editSelection == #newMessage				ifTrue: [					"Select the 'as yet unclassified' category"					selectedMessageCategory _ nil.					(result _ self defineMessageFrom: aText notifying: aController)						ifNil: [							"Compilation failure:  reselect the original category & method"							selectedMessageCategory _ fallBackCategory.							selectedMessage _ fallBackMessage ]						ifNotNil: [							self setSelector: result]]				ifFalse: [					originalSelectorName _ self selectedMessageName.					self setOriginalCategoryIndexForCurrentMethod.					selectedMessage _ fallBackMessage _ originalSelectorName.					(result _ self defineMessageFrom: aText notifying: aController)						ifNotNil: [							self setSelector: result]						ifNil: [							"Compilation failure:  reselect the original category & method"							selectedMessageCategory _ fallBackCategory.							selectedMessage _ fallBackMessage.							^ result notNil]].			self changed: #messageCategoryList.			^ result notNil]		ifFalse: [			"User tried to save a method while the ALL category was NOT selected"			^ (self defineMessageFrom: aText notifying: aController) notNil ]! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 6/8/2011 08:14'!setClass: aBehavior selector: aSymbol	"Set the state of a new, uninitialized Browser."	| isMeta aClass messageCatIndex |	aBehavior ifNil: [^ self].	(aBehavior isKindOf: Metaclass)		ifTrue: [			isMeta _ true.			aClass _ aBehavior soleInstance]		ifFalse: [			isMeta _ false.			aClass _ aBehavior].	self selectCategoryForClass: aClass.	self classListIndex: (		(SystemOrganization listAtCategoryNamed: selectedSystemCategory)			indexOf: aClass name).	self metaClassIndicated: isMeta.	aSymbol ifNil: [^ self].	messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.	self messageCategoryListIndex: (messageCatIndex > 0		ifTrue: [messageCatIndex + 1]		ifFalse: [0]).	messageCatIndex = 0 ifTrue: [^ self].	self messageListIndex: (		(aBehavior organization listAtCategoryNumber: messageCatIndex)			indexOf: aSymbol).! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 6/8/2011 08:47'!systemOrganizer: aSystemOrganizer	"Initialize the receiver as a perspective on the system organizer, 	aSystemOrganizer. Typically there is only one--the system variable 	SystemOrganization."	systemOrganizer _ aSystemOrganizer.	selectedSystemCategory _ nil.	selectedClassName _ nil.	selectedMessageCategory _ nil.	selectedMessage _ nil.	metaClassIndicated _ false.	self setClassOrganizer.	self editSelection: #none.! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/8/2011 08:20'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines menuIndex oldIndex newName |	selectedClassName ifNil: [ ^self ].	labels _ OrderedCollection with: 'new...'.	reject _ Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |		cls = Object ifFalse: [			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asArray sort.				reject addAll: cats]]].	newName _ (labels size = 1 or: [		menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: 'Add Category'.		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex _ self messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: selectedMessageCategory.	self changed: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [self classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/7/2011 22:44'!alphabetizeMessageCategories	selectedClassName ifNil: [^ false].	self classOrMetaClassOrganizer sortCategories.	self changed: #clearUserEdits.	self editClass.	self classListIndex: self classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/7/2011 22:44'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self changed: #clearUserEdits.	self editClass.	self classListIndex: self classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/7/2011 22:35'!editMessageCategories	"Indicate to the receiver and its dependents that the message categories of 	the selected class have been changed."	selectedClassName ifNotNil: [			self messageCategoryListIndex: 0.			self editSelection: #editMessageCategories.			self changed: #editMessageCategories.			self acceptedContentsChanged ]! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/8/2011 08:21'!fileOutMessageCategories	"Print a description of the selected message category of the selected class 	onto an external file."	Cursor write showWhile: [		selectedMessageCategory ifNotNil: [				self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName ]]! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/8/2011 08:21'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	selectedMessageCategory ifNil: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?'])		ifTrue: [			self selectedClassOrMetaClass removeCategory: messageCategoryName.			self messageCategoryListIndex: 0.			self changed: #classSelectionChanged].	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/8/2011 08:21'!renameCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	selectedClassName ifNil: [^ self].	selectedMessageCategory ifNil: [ ^self ].	oldIndex _ self messageCategoryListIndex.	oldName _ self selectedMessageCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	newName = oldName ifTrue: [^ self].	self classOrMetaClassOrganizer		renameCategory: oldName		toBe: newName.	self classListIndex: self classListIndex.	self messageCategoryListIndex: oldIndex.	self changed: #messageCategoryList! !!Browser methodsFor: 'message category list' stamp: 'jmv 6/7/2011 22:41'!messageCategoryList	"Answer the selected category of messages."	^selectedClassName		ifNil: [ #() ]		ifNotNil: [ (Array with: ClassOrganizer allCategory), self classOrMetaClassOrganizer categories ]! !!Browser methodsFor: 'message category list' stamp: 'jmv 6/8/2011 08:20'!messageCategoryListIndex	"Answer the index of the selected message category."	selectedMessageCategory ifNil: [ ^0 ].	selectedMessageCategory = ClassOrganizer allCategory ifTrue: [ ^1 ].	^(self classOrMetaClassOrganizer categories indexOf: selectedMessageCategory) + 1! !!Browser methodsFor: 'message category list' stamp: 'jmv 6/8/2011 08:47'!messageCategoryListIndex: anInteger	"Set the selected message category to be the one indexed by anInteger."	selectedMessageCategory _ anInteger = 0 ifFalse: [		anInteger = 1			ifTrue: [ ClassOrganizer allCategory ]			ifFalse: [ self classOrMetaClassOrganizer categories at: anInteger - 1 ]].	selectedMessage _ nil.	self changed: #messageCategorySelectionChanged.	self changed: #messageCategoryListIndex. "update my selection"	self changed: #messageList.	self editSelection: (anInteger > 0		ifTrue: [#newMessage]		ifFalse: [self classListIndex > 0			ifTrue: [#editClass]			ifFalse: [#newClass]]).	self acceptedContentsChanged.! !!Browser methodsFor: 'message category list' stamp: 'jmv 6/7/2011 22:36'!rawMessageCategoryList	^ 	selectedClassName			ifNil: [#()]			ifNotNil: [self classOrMetaClassOrganizer categories]! !!Browser methodsFor: 'message category list' stamp: 'jmv 6/8/2011 08:47'!selectOriginalCategoryForCurrentMethod	"private - Select the message category for the current method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected. 	 	 Returns: true on success, false on failure."	| aSymbol selectorName |	aSymbol _ self categoryOfCurrentMethod.	selectorName _ self selectedMessageName.	(aSymbol notNil and: [aSymbol ~= ClassOrganizer allCategory])		ifTrue: [			selectedMessageCategory _ aSymbol.			selectedMessage _ selectorName.			self changed: #messageCategorySelectionChanged.			self changed: #messageCategoryListIndex.	"update my selection"			self changed: #messageList.			self changed: #messageListIndex.			^ true].	^ false! !!Browser methodsFor: 'message category list' stamp: 'jmv 6/8/2011 08:21'!selectedMessageCategoryName	"Answer the name of the selected message category, if any. Answer nil 	otherwise."	^selectedMessageCategory! !!Browser methodsFor: 'message category list' stamp: 'jmv 6/8/2011 08:20'!setOriginalCategoryIndexForCurrentMethod	"private - Set the message category index for the currently selected method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected."	selectedMessageCategory _ self categoryOfCurrentMethod	! !!Browser methodsFor: 'message functions' stamp: 'jmv 6/8/2011 08:42'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	selectedMessage ifNil: [ ^self ].	messageName _ self selectedMessageName.	confirmation _ Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation = 2		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !!Browser methodsFor: 'message list' stamp: 'jmv 6/8/2011 08:20'!messageList	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!), it is reset to zero."	| sel |	(sel _ self messageCategoryListSelection) ifNil: [		^ self classOrMetaClassOrganizer			ifNil: [ #() ]			ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]].	^ sel = ClassOrganizer allCategory		ifTrue:  [			self classOrMetaClassOrganizer				ifNil: [ #() ]				ifNotNil:	[ self classOrMetaClassOrganizer allMethodSelectors ]]		ifFalse: [			selectedMessageCategory				ifNil: [ #()]				ifNotNil: [					(self classOrMetaClassOrganizer listAtCategoryNamed: selectedMessageCategory)						ifNil: [							selectedMessageCategory _ nil.							#() ]]]! !!Browser methodsFor: 'message list' stamp: 'jmv 6/8/2011 08:43'!messageListIndex	"Answer the index of the selected message selector into the currently 	selected message category."	selectedMessage ifNil: [ ^0 ].	^self messageList indexOf: selectedMessage! !!Browser methodsFor: 'message list' stamp: 'jmv 6/8/2011 08:46'!messageListIndex: anInteger	"Set the selected message selector to be the one indexed by anInteger."	selectedMessage _ anInteger = 0 ifFalse: [ self messageList at: anInteger ].	self editSelection: (anInteger > 0		ifTrue: [#editMessage]		ifFalse: [self messageCategoryListIndex > 0			ifTrue: [#newMessage]			ifFalse: [self classListIndex > 0				ifTrue: [#editClass]				ifFalse: [#newClass]]]).	self changed: #messageListIndex. "update my selection"	self acceptedContentsChanged! !!Browser methodsFor: 'message list' stamp: 'jmv 6/8/2011 08:44'!selectedMessageName	"Answer the message selector of the currently selected message, if any. 	Answer nil otherwise."	editSelection == #editComment ifTrue: [^ #Comment].	editSelection == #editClass ifTrue: [^ #Definition].	^selectedMessage! !!Browser methodsFor: 'metaclass' stamp: 'jmv 6/8/2011 08:47'!metaClassIndicated: trueOrFalse 	"Indicate whether browsing instance or class messages."	metaClassIndicated _ trueOrFalse.	self setClassOrganizer.	selectedSystemCategory ifNotNil: [		self editSelection: (selectedClassName			ifNil: [metaClassIndicated				ifTrue: [#none]				ifFalse: [#newClass]]			ifNotNil: [#editClass])].	selectedMessageCategory _ nil.	selectedMessage _ nil.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self acceptedContentsChanged! !!Browser methodsFor: 'metaclass' stamp: 'jmv 6/7/2011 22:36'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	selectedClassName ifNil: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass class organization.! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:13'!addSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex newName |	oldIndex _ self systemCategoryListIndex.	newName _ self		request: 'Please type new category name'		initialAnswer: 'Category-Name'.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	systemOrganizer		addCategory: newName		before: selectedSystemCategory.	self systemCategoryListIndex:		(oldIndex = 0			ifTrue: [self systemCategoryList size]			ifFalse: [oldIndex]).	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:19'!fileOutSystemCategory	"Print a description of each class in the selected category onto a file 	whose name is the category name followed by .st."	selectedSystemCategory		ifNotNil: [ systemOrganizer fileOutCategory: selectedSystemCategory ]! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:13'!moveSystemCategoryBottom	selectedSystemCategory ifNil: [^ self].	self systemCategoryListIndex:		(systemOrganizer moveCategoryBottom: selectedSystemCategory).	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:14'!moveSystemCategoryDown	selectedSystemCategory ifNil: [^ self].	self systemCategoryListIndex: 		(systemOrganizer moveCategoryDown: selectedSystemCategory).	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:13'!moveSystemCategoryTop	selectedSystemCategory ifNil: [^ self].	systemOrganizer moveCategoryTop: selectedSystemCategory.	self systemCategoryListIndex: 1.	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:13'!moveSystemCategoryUp	selectedSystemCategory ifNil: [^ self].	self systemCategoryListIndex: 		(systemOrganizer moveCategoryUp: selectedSystemCategory).	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:13'!removeSystemCategory	"If a class category is selected, create a Confirmer so the user can 	verify that the currently selected class category and all of its classes 	should be removed from the system. If so, remove it."	selectedSystemCategory ifNil: [^ self].	(self classList size = 0		or: [self confirm: 'Are you sure you want toremove this system category and all its classes?'])		ifTrue: [			systemOrganizer removeSystemCategory: selectedSystemCategory.			self systemCategoryListIndex: 0.			self changed: #systemCategoryList ]! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:19'!renameSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	selectedSystemCategory ifNil: [ ^ self].  "no selection"	oldIndex _ self systemCategoryListIndex.	oldName _ selectedSystemCategory.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	oldName = newName ifTrue: [^ self].	systemOrganizer		renameCategory: oldName		toBe: newName.	self systemCategoryListIndex: oldIndex.	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/8/2011 08:13'!systemCategoryBrowser	"Create a new system category browser with initial textual 	contents set to aString."	| newBrowser |	selectedSystemCategory		ifNotNil: [			newBrowser _ Browser new.			newBrowser systemCategoryListIndex: self systemCategoryListIndex.			newBrowser setClass: self selectedClassOrMetaClass selector: self selectedMessageName.			^newBrowser].	^nil! !!Browser methodsFor: 'system category list' stamp: 'jmv 6/8/2011 08:14'!selectedEnvironment	"Answer the name of the selected system category or nil."	^ selectedSystemCategory ifNotNil: [ Smalltalk environmentForCategory: selectedSystemCategory ]! !!Browser methodsFor: 'system category list' stamp: 'jmv 6/8/2011 08:14'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	^selectedSystemCategory! !!Browser methodsFor: 'system category list' stamp: 'jmv 6/8/2011 08:14'!systemCategoryListIndex	"Answer the index of the selected class category."	systemOrganizer ifNil: [ ^0 ].	selectedSystemCategory ifNil: [ ^0 ].	^systemOrganizer categories indexOf: selectedSystemCategory! !!Browser methodsFor: 'system category list' stamp: 'jmv 6/8/2011 08:46'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."	selectedSystemCategory _ anInteger = 0 ifFalse: [ systemOrganizer categories at: anInteger].	selectedClassName _ nil.	selectedMessageCategory _ nil.	selectedMessage _ nil.	self editSelection: ( anInteger = 0 ifTrue: [#none] ifFalse: [#newClass]).	metaClassIndicated _ false.	self setClassOrganizer.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self acceptedContentsChanged! !!Browser methodsFor: 'system category list' stamp: 'jmv 6/8/2011 08:15'!systemCategorySingleton	^ selectedSystemCategory		ifNil: [#()]		ifNotNil: [Array with: selectedSystemCategory]! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'jmv 6/8/2011 09:00'!updateListsAndCodeIn: aWindow	"This is done because we are not the real model (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	| aComment |	aComment _ classOfMethod organization commentRemoteStr.	aComment == currentCompiledMethod		ifFalse:			["Do not attempt to formulate if there is no source pointer.			It probably means it has been recompiled, but the source hasn't been written			(as during a display of the 'save text simply?' confirmation)."			aComment last ~= 0 ifTrue: [self reformulateList]].	^ true! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/7/2011 22:42'!removeClass	| class |	selectedClassName ifNil: [ ^self ].	class _ self selectedClass.	(self confirm:'Are you certain that youwant to delete the class ', class name, '?') ifFalse:[^self].	self selectedPackage removeClass: class.	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/8/2011 08:48'!removeMessage	| messageName |	selectedMessage ifNil: [ ^self ].	messageName _ self selectedMessageName.	(self selectedClass confirmRemovalOf: messageName)		ifFalse: [^ false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.	"In case organization not cached"	self changed: #messageList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/8/2011 08:21'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	selectedMessageCategory ifNil: [ ^self ].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'class list' stamp: 'jmv 6/8/2011 08:19'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	^(selectedSystemCategory isNil or: [ self selectedPackage isNil ])		ifTrue: [ #() ]		ifFalse: [ self selectedPackage classes keys sort ]! !!FileContentsBrowser methodsFor: 'class list' stamp: 'jmv 6/8/2011 08:19'!renameClass	| oldName newName |	selectedClassName ifNil: [ ^self ].	oldName _ self selectedClass name.	newName _ (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: selectedSystemCategory.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: selectedSystemCategory) indexOf: newName).! !!FileContentsBrowser methodsFor: 'metaclass' stamp: 'jmv 6/7/2011 22:42'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	selectedClassName ifNil: [ ^self ].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass metaClass organization.! !!FileContentsBrowser methodsFor: 'other' stamp: 'jmv 6/7/2011 22:44'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self unlock.	self editClass.	self classListIndex: self classListIndex.	^ true! !!FileContentsBrowser methodsFor: 'other' stamp: 'jmv 6/8/2011 08:19'!labelString	"Answer the string for the window title"	^ 'File Contents Browser ', (selectedSystemCategory ifNil: [''])! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'jmv 6/8/2011 08:19'!classListIndex: newIndex	"Cause system organization to reflect appropriate category"	| newClassName ind i |	newIndex ~= 0 ifTrue: [		newClassName _ (classList at: newIndex) copyWithout: $ .		i _ systemOrganizer numberOfCategoryOfElement: newClassName.		selectedSystemCategory _ i = 0 ifFalse: [ systemOrganizer categories at: i]].	ind _ super classListIndex: newIndex.	self changed: #systemCategorySingleton.	^ ind! !!HierarchyBrowser methodsFor: 'class list' stamp: 'jmv 6/8/2011 08:48'!assureSelectionsShow	"This is a workaround for the fact that a hierarchy browser, when launched, often does not show the selected class.	(jmv) Is this really needed?"	| saveCatIndex saveMsgIndex |	saveCatIndex _ self messageCategoryListIndex.	saveMsgIndex _ self messageListIndex.	self classListIndex: self classListIndex.	self messageCategoryListIndex: saveCatIndex.	self messageListIndex: saveMsgIndex! !!Inspector methodsFor: 'updating' stamp: 'jmv 6/8/2011 09:43'!updateListsAndCodeIn: aWindow	"This is done because we are not the real model (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	aWindow canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!Inspector methodsFor: 'private' stamp: 'jmv 6/8/2011 09:50'!printStringErrorText	| nm |	nm := self selectionIndex < 3					ifTrue: ['self']					ifFalse: [self selectedSlotName ifNil: ['??']].	^ ('<error in printString: evaluate "' , nm , ' printString" to debug>') asText.! !!Inspector methodsFor: 'stepping' stamp: 'jmv 6/8/2011 09:49'!stepAt: millisecondClockValue in: aWindow	| newText |	(Preferences smartUpdating and: [(millisecondClockValue - self timeOfLastListUpdate) > 2000]) "Not more often than once every 2 seconds"		ifTrue: [			self updateListsAndCodeIn: aWindow.			timeOfLastListUpdate := millisecondClockValue].	newText := self contentsIsString		ifTrue: [self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = acceptedContentsCache ifFalse: [		acceptedContentsCache _ newText.		self acceptedContentsChanged ]! !!MessageSet methodsFor: 'message list' stamp: 'jmv 6/8/2011 08:48'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	selectedMessage _ anInteger = 0 ifFalse: [ self messageList at: anInteger ].	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self acceptedContentsChanged.	(selectedMessage notNil and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect]! !!MessageSet methodsFor: 'message list' stamp: 'jmv 6/8/2011 08:39'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	selectedMessage ifNil: [ ^nil ].	^ self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'message functions' stamp: 'jmv 6/8/2011 08:41'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	selectedMessage ifNil: [ ^self ].	messageName _ self selectedMessageName.	confirmation _ Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self deleteFromMessageList: self selection.	self reformulateList.	confirmation = 2		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'message functions' stamp: 'jmv 6/8/2011 08:40'!removeMessageFromBrowser	"Remove the selected message from the browser."	selectedMessage ifNil: [ ^nil ].	self deleteFromMessageList: self selection.	self reformulateList.	self changed: #relabel! !!MessageSet methodsFor: 'class list' stamp: 'jmv 6/8/2011 08:39'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	selectedMessage ifNil: [ ^nil ].	self setClassAndSelectorIn: [:c :s | ^c]! !!MessageSet methodsFor: 'class list' stamp: 'jmv 6/8/2011 08:39'!selectedMessageCategoryName 	"Answer the name of the selected message category or nil."	"Ver si esta implementacion loca se usa. Si no se usa, eliminar todas (intentarlo!!)"	selectedMessage ifNil: [ ^nil ].	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !!MessageSet methodsFor: 'contents' stamp: 'jmv 6/8/2011 08:41'!acceptedStringOrText	"Answer the contents of the receiver"	^selectedMessage		ifNil: [			currentCompiledMethod _ nil.			'']		ifNotNil: [			self showingByteCodes				ifTrue: [ self selectedBytecodes ]				ifFalse: [ self selectedMessage ]]! !!MessageSet methodsFor: 'private' stamp: 'jmv 6/8/2011 08:48'!initializeMessageList: anArray	| s |	messageList _ OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil: [					s _ class name , ' ' , sel , ' {' , ((class organization categoryOfElement: sel) ifNil: ['']) , '}'.					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s) ]]].	selectedMessage _ messageList isEmpty ifFalse: [ messageList first ]! !!MessageSet methodsFor: 'private' stamp: 'jmv 6/8/2011 08:38'!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ selectedMessage! !!MessageNames methodsFor: 'selector list' stamp: 'jmv 6/8/2011 09:36'!messageList	"Answer the receiver's message list, computing it if necessary. The way 	to force a recomputation is to set the messageList to nil"	messageList		ifNil: [			messageList _ selectedSelector				ifNil: [#()]				ifNotNil: [					Smalltalk allImplementorsOf: selectedSelector].			self messageListIndex: (messageList size > 0				ifTrue: [1]				ifFalse: [0])].	^ messageList! !!MessageNames methodsFor: 'selector list' stamp: 'jmv 6/8/2011 09:34'!selectedMessageName	"Answer the name of the currently selected message."	^selectedSelector! !!MessageNames methodsFor: 'selector list' stamp: 'jmv 6/8/2011 09:37'!selectorList	"Answer the selectorList"	selectorList ifNil: [		self computeSelectorListFromSearchString.		selectedSelector _ selectorList isEmpty ifFalse: [ selectorList first ].		messageList _ nil ].	^ selectorList! !!MessageNames methodsFor: 'selector list' stamp: 'jmv 6/8/2011 09:37'!selectorListIndex	"Answer the selectorListIndex"	selectedSelector ifNil: [ ^ 0 ].	^self selectorList indexOf: selectedSelector! !!MessageNames methodsFor: 'selector list' stamp: 'jmv 6/8/2011 09:37'!selectorListIndex: anInteger 	"Set the selectorListIndex as specified, and propagate consequences"	selectedSelector _ anInteger = 0 ifFalse: [ self selectorList at: anInteger ].	anInteger = 0		ifTrue: [^ self].	messageList _ nil.	self changed: #selectorListIndex.	self changed: #messageList! !!Paragraph methodsFor: 'initialization' stamp: 'jmv 6/8/2011 08:15'!initialize	focused _ false.	showCaret _ false.	positionWhenComposed _ 0@0.	selectionStartBlocks _ #().	selectionStopBlocks _ #()! !!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 6/8/2011 09:43'!verifyContents	"Verify the contents of the receiver, reconstituting if necessary.  Called whenever window is reactivated, to react to possible structural changes.  Also called periodically in morphic if the smartUpdating preference is true"	"This is done because our model is not the real one (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	| newList oldList |	oldList _ list ifNil: [ #() ].	newList _ self getList.	((oldList == newList) "fastest" or: [ oldList = newList ]) ifTrue: [ ^ self ].	self updateList.! !!PluggableMessageCategoryListMorph methodsFor: 'updating' stamp: 'jmv 6/8/2011 09:00'!verifyContents	"This is done because our model is not the real one (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	| newList newRawList |	(model editSelection == #editComment) ifTrue: [^ self].	model classListIndex = 0 ifTrue: [^ self].	newRawList _ model perform: getRawListSelector.	newRawList == priorRawList ifTrue: [^ self].  "The usual case; very fast"	priorRawList _ newRawList.	newList _ (Array with: ClassOrganizer allCategory), priorRawList.	list = newList ifTrue: [^ self].	self updateList! !!ProcessBrowser methodsFor: 'accessing' stamp: 'jmv 6/7/2011 17:25'!context: aContext 	selectedContext := aContext.	selectedClass := nil.	selectedSelector := nil.	methodText := nil.	self changed: #stackListIndex.	self changed: #selectedMethod! !!ProcessBrowser methodsFor: 'accessing' stamp: 'jmv 6/7/2011 17:26'!processListIndex	processList ifNil: [ ^0 ].	selectedProcess ifNil: [ ^0 ].	^processList indexOf: selectedProcess! !!ProcessBrowser methodsFor: 'accessing' stamp: 'jmv 6/7/2011 22:49'!processListIndex: index 	self selectedProcess: 		(processList at: index ifAbsent: nil)! !!ProcessBrowser methodsFor: 'accessing' stamp: 'jmv 6/7/2011 22:08'!selectedProcess: aProcess	selectedProcess _ aProcess.	self updateStackList.	self changed: #processListIndex! !!ProcessBrowser methodsFor: 'accessing' stamp: 'jmv 6/7/2011 17:24'!stackListIndex	stackList ifNil: [ ^0 ].	selectedContext ifNil: [ ^0 ].	^stackList indexOf: selectedContext! !!ProcessBrowser methodsFor: 'accessing' stamp: 'jmv 6/7/2011 22:48'!stackListIndex: index 	self context: (		(stackList isNil or: [index = 0]) ifFalse: [			stackList at: index ifAbsent: nil ])! !!ProcessBrowser methodsFor: 'initialize-release' stamp: 'jmv 6/7/2011 17:24'!initialize	methodText _ ''.	selectedContext _ nil.	searchString _ ''.	self updateProcessList; processListIndex: 1! !!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 6/7/2011 22:12'!findContext: aString	| initialProcess initialContext found |	searchString _ aString.	searchString isEmpty		ifTrue: [^ false].	initialProcess _ selectedProcess.	initialContext _selectedContext.	self processListIndex: 1.	self stackListIndex: 1.	found _ self nextContext.	found ifFalse: [		self selectedProcess: initialProcess.		self context: initialContext].	^ found! !!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 6/7/2011 22:11'!updateProcessList	| oldSelectedProcess |	oldSelectedProcess _ selectedProcess.	processList _ selectedProcess _ selectedSelector _ nil.	Smalltalk garbageCollectMost.	"lose defunct processes"	processList _ Process allSubInstances reject: [:each | each isTerminated ].	processList _ processList sort: [ :a :b | a priority >= b priority ].	processList _ WeakArray withAll: processList.	self changed: #processNameList.	self selectedProcess: ((processList includes: oldSelectedProcess)		ifTrue: [processList])! !!ProcessBrowser methodsFor: 'stack list' stamp: 'jmv 6/7/2011 17:21'!changeStackListTo: aCollection         stackList _ aCollection.        self changed: #stackNameList.        self context: nil! !!ProcessBrowser methodsFor: 'stack list' stamp: 'jmv 6/7/2011 17:13'!pcRange	"Answer the indices in the source code for the method corresponding to  	the selected context's program counter value."	(selectedContext isNil or: [methodText isEmptyOrNil])		ifTrue: [^ 1 to: 0].	^selectedContext debuggerMap		rangeForPC: (selectedContext pc ifNotNil: [:pc| pc] ifNil: [selectedContext method endPC])		contextIsActiveContext: stackList first == selectedContext! !!ProcessBrowser methodsFor: 'stack list' stamp: 'jmv 6/7/2011 22:17'!updateStackList: depth 	| suspendedContext oldHighlight |	selectedProcess		ifNil: [ ^ self changeStackListTo: nil ].	oldHighlight _ selectedContext.	selectedProcess == Processor activeProcess		ifTrue: [			self changeStackListTo: (thisContext stackOfSize: depth)]		ifFalse: [			suspendedContext _ selectedProcess suspendedContext.			self changeStackListTo: (suspendedContext ifNotNil: [suspendedContext stackOfSize: depth])].	self context: ((stackList includes: oldHighlight) ifTrue: [oldHighlight])! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/8/2011 08:16'!allGlobalRefs	"Answer a set of symbols that may be refs to Global names.	Warning: Will not include references to a class from its own methods"	^ self allGlobalRefsWithout: #(#() #())! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/8/2011 08:16'!allGlobalRefsWithout: classesAndMessagesPair	"Answer a set of symbols that may be refs to Global names. 	This method computes its result in the absence of specified classes and messages.	Does not include references from a class to itself"	| globalRefs absentClasses absentSelectors |	globalRefs _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	Cursor execute showWhile: 		[self classNames do: 			[:cName | ((absentClasses includes: cName)						ifTrue: [#()]						ifFalse: [{(self at: cName). (self at: cName) class}]) do:				[:cl | (absentSelectors isEmpty						ifTrue: [cl selectors]						ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: 					[:sel | "Include all capitalized symbols for good measure"					self allSymbolsIn: (cl compiledMethodAt: sel) literals do: 						[:m | 						((m isMemberOf: Symbol) and: [ m size > 0] and: [m first isUppercase]) ifTrue:							[m = cl name ifFalse: [								globalRefs add: m]].						(m isVariableBinding) ifTrue:							[m key ifNotNil: [								m key = cl name ifFalse: [									globalRefs add: m key]]]]]]]].	^ globalRefs! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/8/2011 08:16'!allImplementedMessages	"Answer a Set of all the messages that are implemented in the system."	^ self allImplementedMessagesWithout:  #(#() #())! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/8/2011 08:16'!allImplementedMessagesWithout: classesAndMessagesPair	"Answer a Set of all the messages that are implemented in the system, computed in the absence of the supplied classes and messages.  Note this reports messages that are in the absent selectors set."	| messages absentClasses |	messages _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	Cursor execute showWhile: 		[self classNames do: 			[:cName | ((absentClasses includes: cName)						ifTrue: [#()]						ifFalse: [{(self at: cName). (self at: cName) class}]) do:				[:cl | messages addAll: cl selectors]]].	^ messages! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/8/2011 08:16'!allSentMessages	"Answer the set of selectors which are sent somewhere in the system."	^ self allSentMessagesWithout: #(#() #())! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/8/2011 08:16'!allSentMessagesWithout: classesAndMessagesPair	"Answer the set of selectors which are sent somewhere in the system, 	computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors |	sent _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	Cursor execute showWhile: 		[self classNames do: 			[:cName | ((absentClasses includes: cName)						ifTrue: [#()]						ifFalse: [{(self at: cName). (self at: cName) class}]) do:				[:cl | (absentSelectors isEmpty						ifTrue: [cl selectors]						ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: 					[:sel | "Include all sels, but not if sent by self"					self allSymbolsIn: (cl compiledMethodAt: sel) literals do: 						[ :m | m == sel ifFalse: [sent add: m] ].					]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			sent add: (self specialSelectorAt: index)]].	Smalltalk presumedSentMessages do: [:sel | sent add: sel].	^ sent! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 6/8/2011 08:17'!allUnSentMessages   "Smalltalk allUnSentMessages"	"Answer the set of selectors that are implemented by some object in the system but not sent by any."	^ self allUnSentMessagesWithout: #(#() #())! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 6/8/2011 08:17'!reportClassAndMethodRemovalsFor: collectionOfClassNames	| initialClassesAndMethods finalClassesAndMethods |	"Smalltalk reportClassAndMethodRemovalsFor: #(Celeste Scamper MailMessage)"	initialClassesAndMethods _ self unusedClassesAndMethodsWithout: #(#() #()).	finalClassesAndMethods _ self unusedClassesAndMethodsWithout: {collectionOfClassNames. #()}.	^ {finalClassesAndMethods first copyWithoutAll: initialClassesAndMethods first.		finalClassesAndMethods second copyWithoutAll: initialClassesAndMethods second}! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 6/8/2011 08:17'!unusedClasses	"Enumerates all classes in the system and returns a list of those that are apparently unused. A class is considered in use if it (a) has subclasses or (b) is referred to by some method or (c) has its name in use as a literal (but not in the same class) or (d) some instance is a global."	"Smalltalk unusedClasses asSortedCollection"	^ self allUnusedClassesWithout: #(#() #())! !!TextEditor methodsFor: 'events' stamp: 'jmv 6/8/2011 08:17'!mouseDown: evt 	| clickPoint b |	"Multiple selection of text.	Windows uses Control, Mac uses Command (i.e. commandAlt)	On the Mac, command-button1 is translated to command-button3 by the VM. do:		Preferences disable: #commandClickOpensHalo	to disable this behavior and make command-button1 work for multiple selection. "	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [		self selectionInterval size > 0 ifTrue: [			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]	ifFalse: [		selectionStartBlocks _ #().		selectionStopBlocks _ #() ]	.	clickPoint _ evt position.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint for: model) ifTrue: [		markBlock _ b.		pointBlock _ b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			self closeTypeIn.			markBlock _ b.			pointBlock _ b ]! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 6/8/2011 08:18'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	markBlock _ paragraph defaultCharacterBlock.	pointBlock _ markBlock.	beginTypeInIndex _ nil.	UndoInterval _ 1 to: 0.	self setEmphasisHereFromText.	selectionStartBlocks _ #().	selectionStopBlocks _ #()! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 6/8/2011 08:18'!selectAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	selectionStartBlocks _ #().	selectionStopBlocks _ #().	super selectAt: characterIndex! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 6/8/2011 08:18'!selectInterval: anInterval	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	selectionStartBlocks _ #().	selectionStopBlocks _ #().	super selectInterval: anInterval! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 6/8/2011 08:17'!clearSelection	selectionStartBlocks _ #().	selectionStopBlocks _ #().	super clearSelection! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 6/8/2011 08:18'!selectAll	selectionStartBlocks _ #().	selectionStopBlocks _ #().	super selectAll! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 6/8/2011 08:18'!selectAll: aKeyboardEvent 	"select everything, invoked by cmd-a.  1/17/96 sw"	selectionStartBlocks _ #().	selectionStopBlocks _ #().	^super selectAll: aKeyboardEvent! !!TextEditor methodsFor: 'private' stamp: 'jmv 6/8/2011 08:18'!zapMultiSelection	| delta intervals mi pi t start stop miAndPiUpdated |	miAndPiUpdated _ false.	mi _ self markIndex.	pi _ self pointIndex.	delta _ 0.	intervals _ (selectionStartBlocks with: selectionStopBlocks		collect: [ :strt :stp | strt stringIndex to: stp stringIndex ])			sorted: [ :a :b | a first < b first ].	t _ self text.	intervals do: [ :interval |		miAndPiUpdated not ifTrue: [			interval first > mi				ifTrue: [					miAndPiUpdated _ true.					mi _ mi + delta.					pi _ pi + delta ]				ifFalse: [					interval last > mi ifTrue: [						miAndPiUpdated _ true.						mi _ interval first + delta.						pi _ mi ]]].		start _  interval first+delta.		stop _ interval last - 1 + delta.		t replaceFrom: start to: stop with: ''.		delta _ delta - (interval size-1).		paragraph			recomposeFrom: start			to:  start - 1			delta: delta ].	miAndPiUpdated not ifTrue: [		mi _ mi + delta.		pi _ pi + delta ].	selectionStartBlocks _ #().	selectionStopBlocks _ #().	self markIndex: mi pointIndex: pi! !!TextEditor methodsFor: 'private' stamp: 'jmv 6/8/2011 08:18'!zapSelectionWith: replacement	| start stop rep |	start _ self startIndex.	stop _ self stopIndex.	(replacement isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (self text attributesAt: start) select: [:att | att mayBeExtended]].	(start = stop and: [ replacement isEmpty ]) ifFalse: [		(replacement is: #Text)			ifTrue: [				"If we are pasting a text that doesn't bring a ParagraphStyleReference in the past paragraph, and we need it,				but it won't be provided by our text, as we are at the end, then add any paragraph attribute from emphasisHere"				(replacement notEmpty and: [ (replacement last = Character cr) not and: [ stop > self text size ]])					ifTrue: [						rep _ (replacement, (Text string: String cr attributes: emphasisHere)) copyFrom: 1 to: replacement size ]					ifFalse: [ rep _ replacement ]]			ifFalse: [ rep _ Text string: replacement attributes: emphasisHere ].		self text replaceFrom: start to: stop - 1 with: rep.		paragraph			recomposeFrom: start			to:  start + rep size - 1			delta: rep size - (stop-start).		self markIndex: start pointIndex: start + rep size.		selectionStartBlocks _ #().		selectionStopBlocks _ #().		UndoInterval _ self selectionInterval.		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 6/8/2011 08:48'!initializeMessageList: anArray	messageList _ anArray.	selectedMessage _ messageList isEmpty ifFalse: [ messageList first ]! !!VersionsBrowserWindow class methodsFor: 'services' stamp: 'jmv 6/8/2011 09:13'!browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector lostMethodPointer: sourcePointer 	| changeList browser |	Cursor read showWhile: [		changeList _ (browser _ VersionsBrowser new)			scanVersionsOf: method class: class meta: meta			category: msgCategory selector: selector].	changeList ifNil: [ self inform: 'No versions available'. ^nil ].	VersionsBrowserWindow open: changeList label: 'Recent versions of ', selector.	^browser! !!classDefinition: #ProcessBrowser category: #'Tools-Debugger'!ActiveModel subclass: #ProcessBrowser	instanceVariableNames: 'selectedProcess selectedContext methodText processList stackList selectedClass selectedSelector searchString'	classVariableNames: 'SuspendedProcesses'	poolDictionaries: ''	category: 'Tools-Debugger'!PluggableListMorph removeSelector: #alertUserContentsChanged!MessageNames removeSelector: #selection!!classDefinition: #MessageNames category: #'Tools-Browser'!MessageSet subclass: #MessageNames	instanceVariableNames: 'searchString selectorList selectedSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser'!Inspector removeSelector: #noteSelectionIndex:for:!ChangeList removeSelector: #setLostMethodPointer:!!classDefinition: #ChangeList category: #'Tools-Changes'!CodeProvider subclass: #ChangeList	instanceVariableNames: 'changeList list listIndex listSelections file'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!Browser removeSelector: #noteSelectionIndex:for:!!classDefinition: #Browser category: #'Tools-Browser'!CodeProvider subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer selectedSystemCategory selectedClassName selectedMessageCategory selectedMessage editSelection metaClassIndicated'	classVariableNames: 'RecentClasses'	poolDictionaries: ''	category: 'Tools-Browser'!