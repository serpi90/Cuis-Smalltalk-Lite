'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 15 November 2011 at 10:25:49 pm'!!classDefinition: #InnerPluggableMorph category: #'Morphic-Views for Models'!Morph subclass: #InnerPluggableMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!InnerPluggableMorph commentStamp: '<historical>' prior: 0!      The morph that displays the list in a PluggableScrollPane!!classDefinition: #InnerHierarchicalListMorph category: #'Morphic-Views for Models'!InnerPluggableMorph subclass: #InnerHierarchicalListMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!InnerHierarchicalListMorph commentStamp: '<historical>' prior: 0! The morph that displays the list in a HierarchicalListMorph.!!classDefinition: #InnerListMorph category: #'Morphic-Views for Models'!InnerPluggableMorph subclass: #InnerListMorph	instanceVariableNames: 'listItems font selectedRow selectedRows listSource '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!InnerListMorph commentStamp: 'jmv 11/15/2011 17:47' prior: 0!       The morph that displays the list in a PluggableListMorph.!!classDefinition: #InnerTextMorph category: #'Morphic-Views for Models'!InnerPluggableMorph subclass: #InnerTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompleter '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!InnerTextMorph commentStamp: '<historical>' prior: 0!  InnerTextMorphs support display of text with emphasis.  They also support reasonable text-editing capabilities, as well as embedded hot links, and the ability to embed submorphs in the text. They are 'bare' in the sense that they can not clip contents to some window, or scroll it by themselves.Text display is clipped to the innerBounds of the rectangle, and text composition is normally performed within a rectangle which is innerBounds inset by the margins parameter.Comment about Shout specifics:-----------------------------------------Instances of me are usually created using my #on:text:accept:readSelection:menu: class method.In order to colour the text, I use an instance of SHTextStylerST80, which I store in my 'styler' instance variable.When my setText: method is called, I use my styler to ...	a) optionally set all assignments to ansi or leftArrow. 	b) Colour my text (immediately, if the text is less than 4096 chars in length, or in a backgroundProcess otherwise)	When my text is changed, my hasUnacceptedEdits: method is called with true, and I ask my styler to re-colour my text. This is performed in a background process so that typing remains responsive regardless of the length of the text.	Just before my styler is about to format/style the text, I send #stylerAboutToStyle:  to my model. This gives my model a chance to veto the styling (by answering false), or to initialize the styler with information it needs in order to parse the text correctly (e.g. the class to which a method belongs, or the workspace in which I am contained).	My styler informs me that it has finished styling by triggering the #stylerStyled: and #stylerStyledInBackground: events which I handle. I then update the textAttributes of my text and refresh the display. 	My 'unstyledAcceptText' instance variable is used in conjunction with my #acceptTextInModel and #correctFrom:to:with: methods to ensure that when my text is modified during a method compilation (removing unused vars etc), I do not lose those changes.!!Editor methodsFor: 'menu commands' stamp: 'jmv 11/15/2011 15:59'!    offerMenuFromEsc: aKeyboardEvent	"The escape key was hit while the receiver has the keyboard focus; take action"	^ aKeyboardEvent shiftPressed ifFalse: [		morph mouseButton2Activity ]! !!Morph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:20'!                            inATwoWayScrollPane	"Answer a two-way scroll pane that allows the user to scroll the receiver in either direction.  It will have permanent scroll bars unless you take some special action."	| widget |	widget _ PluggableScrollPane new.	widget addToScroller: self.	widget extent: (self width min: 300 max: 100) @ (self height min: 150 max: 100).	widget setScrollDeltas.	widget color: self color darker darker.	^widget! !!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'jmv 11/15/2011 19:21'!                   openPath: anArray	anArray isEmpty ifTrue: [ ^container setSelectedMorph: nil ].	self withSiblingsDo: [ :each | 		(anArray first isNil or: [each complexContents asString = anArray first]) ifTrue: [			each isExpanded ifFalse: [				each toggleExpandedState.				owner adjustExtent.				container setScrollDeltas			].			each redrawNeeded.			anArray size = 1 ifTrue: [				^container setSelectedMorph: each			].			each firstChild ifNil: [^container setSelectedMorph: nil].			^each firstChild openPath: anArray allButFirst.		].	].	^container setSelectedMorph: nil! !!InnerPluggableMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 22:11'!                    adjustExtent	self submorphBounds ifNotNil: [ :r |		self extent: r bottomRight - bounds topLeft ]! !!InnerPluggableMorph methodsFor: 'visual properties' stamp: 'jmv 11/15/2011 22:14'!    defaultColor	^Color transparent! !!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 19:02'!        adjustExtent	"And reposition submorphs"	| w p0 h y |	"make all items wide, so selection indicator is wide too"	w _ self desiredWidth.	p0 _ bounds topLeft..	y _ 0.	self submorphsDo: [ :m |		h _ m height.		m privateBounds: (p0 + (0@y) extent: w@h).		y _ y + h ].	self extent: w@y! !!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 19:02'!         desiredWidth	^submorphs inject: owner viewableWidth into: [ :previousValue :each |		previousValue max: each desiredWidth ]! !!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 19:09'!                  initialize	super initialize.	self color: Color black.	font _ Preferences standardListFont.	listItems _ #().	selectedRow _ nil.	selectedRows _ Set new! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/15/2011 19:39'!                   drawBoundsForRow: row	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"	| topLeft drawBounds |	topLeft _ bounds left @ (bounds top + ((row - 1) * (font height))).	drawBounds _ topLeft extent: bounds width @ font height.	^drawBounds! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/15/2011 19:11'!                           listChanged	"set newList to be the list of strings to display"	listItems _ Array new: self getListSize withAll: nil.	selectedRow _ nil.	selectedRows _ Set new.	self adjustExtent! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/15/2011 19:31'!draw: item atRow: row on: canvas	"display the given item at row row"	| drawBounds f |	drawBounds _ self drawBoundsForRow: row.	drawBounds _ drawBounds intersect: bounds.	f _ (item is: #Text) ifTrue: [ font emphasized: (item emphasisAt: 1) ] ifFalse: [ font ].	canvas drawString: item in: drawBounds font: f color: (self colorForRow: row)! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/15/2011 19:32'!                               drawBackgroundForMulti: row on: aCanvas	| selectionDrawBounds c |	"shade the background darker, if this row is selected"	selectionDrawBounds _ self drawBoundsForRow: row.	selectionDrawBounds _ selectionDrawBounds intersect: bounds.	c _ (selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].	aCanvas fillRectangle: selectionDrawBounds colorOrInfiniteForm: c! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/15/2011 19:32'!                          drawOn: aCanvas	listItems size = 0 ifTrue: [ ^self ]. 	self drawSelectionOn: aCanvas.	(self topVisibleRowForCanvas: aCanvas)		to: (self bottomVisibleRowForCanvas: aCanvas) 		do: [ :row |			(owner itemSelectedAmongMultiple:  row) ifTrue: [				self drawBackgroundForMulti: row on: aCanvas. ].			self draw: (self item: row) asStringOrText atRow: row on: aCanvas ]! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/15/2011 15:40'!   drawSelectionOn: aCanvas	| selectionDrawBounds |	selectedRow ifNil: [ ^self ].	selectedRow = 0 ifTrue: [ ^self ].	selectionDrawBounds _ self drawBoundsForRow: selectedRow.	selectionDrawBounds _ selectionDrawBounds intersect: bounds.	aCanvas		fillRectangle: selectionDrawBounds		colorOrInfiniteForm: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/15/2011 19:11'!       font: newFont	font _ newFont ifNil: [ StrikeFont default ].	self adjustExtent! !!InnerListMorph methodsFor: 'list access' stamp: 'jmv 11/15/2011 15:39'!   getListItem: index	"grab a list item directly from the model"	^owner getListItem: index! !!InnerListMorph methodsFor: 'list access' stamp: 'jmv 11/15/2011 15:39'!                         getListSize	"return the number of items in the list"	^owner getListSize! !!InnerListMorph methodsFor: 'scroll range' stamp: 'jmv 11/15/2011 19:09'!        desiredWidth"Ok, this is a bit messed up. We need to return the width of the widest item in the list. If we grab every item in the list, it defeats the purpose of LazyListMorph. If we don't, then we don't know the size. This is a compromise -- if the list is less then 30 items, we grab them all. If not, we grab currently visible ones, until we've checked itemsToCheck of them, then take the max width out of that 'sampling', then double it. If you know a better way, please chime in."	| maxW count itemsToCheck item |	itemsToCheck _ 30.	maxW _ owner viewableWidth.	count _ 0.	listItems do: [ :each |		each ifNotNil: [			maxW _ maxW max: (self widthToDisplayItem: each contents)]].	(count < itemsToCheck) ifTrue: [		1 to: listItems size do: [:i | 			(listItems at: i) ifNil: [ 				item _ self item: i.				maxW _ maxW max: (self widthToDisplayItem: item contents).				((count _ count + 1) > itemsToCheck) ifTrue: [ ^maxW * 2 ]]]].	^maxW ! !!InnerListMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 19:03'!                        adjustExtent	"Adjust our height to match the underlying list,	but make it wider if neccesary to fill the available width in our PluggableListMorph	(this is needed to make the selection indicator no narrower than the list)"	self extent:		self desiredWidth @ ((listItems size max: 1) * font height)! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/15/2011 15:57'!       acceptContents	"The message is sent when the user hits enter or Cmd-S.	Accept the current contents and end editing."	self updateFromParagraph.	owner accept! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/15/2011 16:01'!                       cancelEdits	"The message is sent when the user hits enter or Cmd-L.	Cancel the current contents and end editing."	self releaseParagraph.	owner cancel! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/15/2011 16:01'!                             hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		owner redrawNeeded].	aBoolean ifFalse: [ owner hasEditingConflicts: false].	"shout:  re-style the text iff aBoolean is true	Do not apply any formatting (i.e. changes to the characters in the text),	just styling (i.e. TextAttributes)"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess ]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 16:00'!              autoScrollView: evt	"This is kind of a hack because the PluggableTextMorph expects me to first expand the selection before auto scrolling will work."	super mouseMove: evt.	owner scrollSelectionIntoView: evt! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 16:00'!                             doubleClick: evt	self handleInteraction: [		editor doubleClick: (evt translatedBy: bounds topLeft negated) ].	owner scrollSelectionIntoView: evt! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 16:00'!                            keyStroke: evt	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].			"Maybe disable? Precludes the use of up and down arrows with control,	that are standard keystrokes in Windows to control the cursor.	Problem: At least Mac and Win VM generate ctrl-up and ctrl-down for	mouse wheel events.	I guess most people would prefer the mouse wheel to work properly..."	(owner scrollByKeyboard: evt)		ifTrue: [ ^self ].	autoCompleter 		ifNil: [ self processKeyStroke: evt ]		ifNotNil: [			autoCompleter				autoCompletionAround: [ self processKeyStroke: evt ]				keyStroke: evt ]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 16:02'!       mouseMove: evt	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].	(evt position y between: owner bounds top and: owner bounds bottom) ifFalse: [		"Start auto-scrolling"		self startStepping: #autoScrollView:			at: Time millisecondClockValue			arguments: (Array with: evt)			stepTime: 100. "fast enough"	] ifTrue: [		self stopSteppingSelector: #autoScrollView:.	]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 16:01'!                mouseUp: evt	super mouseUp: evt.	self pauseBlinking.	self handleInteraction: [editor mouseUp: (evt translatedBy: bounds topLeft negated)].	self stopSteppingSelector: #autoScrollView:.	owner scrollSelectionIntoView: evt! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 16:01'!                processKeyStroke: evt	| action |	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	self pauseBlinking.	evt keyValue = 13 ifTrue: ["CR - check for special action"		action _ self crAction.		action ifNotNil: [			^action value]].	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromParagraph.	self eventHandler ifNotNil: [		"like'super keyStroke: evt'"		self eventHandler keyStroke: evt fromMorph: self].	owner scrollSelectionIntoView! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 16:01'!                         tripleClick: evt	self handleInteraction: [		editor tripleClick: (evt translatedBy: bounds topLeft negated) ].	owner scrollSelectionIntoView: evt.! !!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 19:14'! adjustExtent	"This is just a suggestion. If we do wordwrap, the width will be honored.	But the height is whatever is appropriate for the contents!!"	self extent: owner viewableBounds extent! !!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 17:32'!                     extent: aPoint	| newExtent priorEditor |	priorEditor _ editor.	"Resist changing the extent if no wordwrap.. this should be checked."	wrapFlag ifFalse: [ ^ self ].	newExtent _ aPoint truncated max: self minimumExtent.		"No change of wrap width"	newExtent x = bounds extent x ifTrue: [ ^ self ].	"invalidate the paragraph cache"	self releaseParagraph.	super extent: newExtent.	priorEditor		ifNil: [			"since the width has changed..." 			self fit ]		ifNotNil: [ self installEditorToReplace: priorEditor ]! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/15/2011 16:00'!               fit	"Adjust my bounds to fit the text.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para |	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).	newExtent ~= bounds extent 		ifTrue: [			para _ paragraph.	"Save para (layoutChanged smashes it)"			self basicExtent: newExtent.			paragraph _ para].	"These statements should be pushed back into senders"	self redrawNeeded.	"Too conservative: only paragraph composition							should cause invalidation."	owner innerHeight: newExtent y! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/15/2011 15:59'!       mouseButton2Activity	^ owner mouseButton2Activity! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/15/2011 16:00'!    updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, and current typing emphasis."	| sel oldEditor |	paragraph ifNotNil: [		editor ifNotNil: [			oldEditor _ editor.			sel _ editor selectionInterval.			editor storeSelectionInParagraph].		self fit.		self layoutChanged.		sel ifNotNil: [			editor ifNil: [				"Reinstate selection after, eg, style change"				self installEditorToReplace: oldEditor ]]].	owner setScrollDeltas! !!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 11/15/2011 16:00'!                  possiblyChanged	owner possiblyChanged! !!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/15/2011 15:29'!        stopBlinking	"And do not show cursor anymore."	self stopSteppingSelector: #onBlinkCursor.	paragraph ifNotNil: [		paragraph showCaret: false ]! !!InnerTextMorph methodsFor: 'macpal' stamp: 'jmv 11/15/2011 16:01'!      flash	^ owner flash! !!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 11/15/2011 22:20'!                             addToScroller: aMorph	aMorph position: scroller position.	scroller addMorph: aMorph! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/15/2011 19:27'!                    keyStroke: evt	( self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	super keyStroke: evt.	(self scrollByKeyboard: evt)		ifTrue: [ ^self ].	scroller keyStroke: evt! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/15/2011 19:24'!   mouseDown: event	event mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	scroller mouseDown: event.	event hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: #tripleClick:! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/15/2011 19:25'!                            mouseUp: evt	super mouseUp: evt.	scroller mouseUp: evt! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 19:16'!                        extent: newExtent		| minH minW |	"Figure out the minimum width and height for this pane so that scrollbars will appear"	minH _ Preferences scrollbarThickness * 2.	minW _ minH.	super extent: (newExtent max: (minW@minH)).	"Now reset widget sizes"	scroller adjustExtent.	self setScrollDeltas! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 22:21'!      hLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	^ (self hTotalScrollRange - self viewableWidth) max: 0! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 22:22'!                             hSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta w |		delta _ self scrollDeltaWidth.	range _ self hLeftoverScrollRange.	range = 0 ifTrue: [		^hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0 ].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	w _ self viewableWidth.	hScrollBar scrollDelta: (delta / range) asFloat pageDelta: (w - delta / range) asFloat.	hScrollBar interval: (w / self hTotalScrollRange) asFloat.	hScrollBar setValue: hScrollBar value! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 17:26'!            hTotalScrollRange	"Return the width extent of the receiver's scrollable area"	^scroller width! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 17:44'!                 layoutChanged	| t topLeft |	super layoutChanged.		hideScrollBars ifTrue: [^self].	t _ Preferences scrollbarThickness.	topLeft _ bounds topRight + (0-t-borderWidth @ borderWidth).	scrollBar bounds: (topLeft extent: t @ self vScrollBarHeight).	topLeft _ bounds bottomLeft + (borderWidth @ (t + borderWidth) negated).	hScrollBar bounds: (topLeft extent: self hScrollBarWidth@ t)! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 21:54'!              scrollerOffset	^self viewableBounds topLeft - scroller position! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 21:54'!                scrollerOffset: newOffset	scroller position: self viewableBounds topLeft - newOffset! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 18:10'!                           setScrollDeltas	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."self flag: #jmvVer.	"Revisar senders. Que no se haga al dopelin"	self hideOrShowScrollBars.	self vIsScrollbarShowing ifTrue: [ self vSetScrollDelta ].	self hIsScrollbarShowing ifTrue: [ self hSetScrollDelta ]! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 22:23'!   vLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	^ (self vTotalScrollRange - self viewableHeight) max: 0! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 22:22'!                            vSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta h |		delta _ self scrollDeltaHeight.	range _ self vLeftoverScrollRange.	range = 0 ifTrue: [		^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0 ].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	h _ self viewableHeight.	scrollBar scrollDelta: (delta / range) asFloat pageDelta: (h - delta / range) asFloat.	scrollBar interval: (h / self vTotalScrollRange) asFloat.	scrollBar setValue: scrollBar value! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/15/2011 17:12'!              vTotalScrollRange	"Return the height extent of the receiver's scrollable area"	^scroller height! !!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 11/15/2011 21:59'!         initialize		"initialize the state of the receiver"	super initialize.	hideScrollBars _ false.	"initialize the receiver's scrollBars"	scrollBar _ ScrollBar new model: self setValueSelector: #vScrollBarValue:.	hScrollBar _ ScrollBar new model: self setValueSelector: #hScrollBarValue:.	drawKeyboardFocusIndicator _ true.	scroller _ self innerMorphClass new.	self addMorph: scroller.	self scrollerOffset: 0@ 0! !!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:09'!        innerMorphClass	^InnerPluggableMorph! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 19:16'!          hHideScrollBar	self hIsScrollbarShowing ifFalse: [		^self scrollerOffset: 0@self scrollerOffset y ].	self removeMorph: hScrollBar.	self scrollerOffset: 0@self scrollerOffset y.	scroller adjustExtent! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 22:21'!    hIsScrollbarNeeded: havingVerticalScrollbar	"Return whether the horz scrollbar is needed"	| w |	"Don't show it if we were told not to."	hideScrollBars ifTrue: [^false].	"If the contents of the pane are too small to scroll, return false."	w _ self innerBounds width - (2*self xtraBorder).	"Compute the need of the horizontal scrollbar honoring the havingVerticalScrollbar argument"	havingVerticalScrollbar ifTrue: [		w _ w - Preferences scrollbarThickness ].	^self hTotalScrollRange > w! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 19:16'!                              hShowScrollBar	self hIsScrollbarShowing ifTrue: [^self].	self privateAddMorph: hScrollBar atIndex: 1.	scroller adjustExtent! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 19:54'!                scrollToShow: aRectangle	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.	This means that 0@0 is scrolling all the way top and all the way left"	| y0 delta |	y0 _ self viewableBounds top.	((aRectangle top - y0) >= 0 and: [		(aRectangle bottom - y0) <= self viewableHeight ])		ifTrue: [			"already visible"			^self ].	"Scroll end of selection into view if necessary"	delta _ aRectangle amountToTranslateWithin: self viewableBounds.		delta y ~= 0 ifTrue: [		self scrollBy: 0@delta y ]! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 19:16'!      vHideScrollBar	self vIsScrollbarShowing ifFalse: [^self].	self removeMorph: scrollBar.	self scrollerOffset: self scrollerOffset x@ 0.	scroller adjustExtent! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 22:23'!                vIsScrollbarNeeded: havingHorizontalScrollbar	"Return whether the vertical scrollbar is needed"	| h |		"Don't show it if we were told not to."	hideScrollBars ifTrue: [^false].	"If the contents of the pane are too small to scroll, return false."	h _ self innerBounds height - (2*self xtraBorder).	"Compute the need of the vertical scrollbar honoring the havingHorizontalScrollbar argument"	havingHorizontalScrollbar ifTrue: [		h _ h - Preferences scrollbarThickness ].	^ self vTotalScrollRange > h! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 22:23'!                   vScrollBarValue: scrollValue	self scrollerOffset: (self scrollerOffset x @ (self vLeftoverScrollRange * scrollValue) rounded)! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/15/2011 19:16'!               vShowScrollBar	self vIsScrollbarShowing ifTrue: [^ self].	self privateAddMorph: scrollBar atIndex: 1.	scroller adjustExtent! !!PluggableScrollPane methodsFor: 'pane events' stamp: 'jmv 11/15/2011 19:25'!              mouseMove: evt	scroller  mouseMove: evt! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/15/2011 15:26'!      drawLinesOn: aCanvas 	| lColor |	lColor _ self lineColor.	scroller submorphs do: [ :submorph | 		(submorph isExpanded or: [			(aCanvas isVisible: submorph bounds) or: [				submorph nextSibling notNil and: [ aCanvas isVisible: submorph nextSibling bounds ] ] ]) ifTrue: [			submorph				drawLinesOn: aCanvas				lineColor: lColor ] ]! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/15/2011 19:29'!                     itemFromPoint: aPoint	"Return the list element (morph) at the given point or nil if outside"	| ptY b |	scroller hasSubmorphs ifFalse: [ ^nil ].	(scroller fullBounds containsPoint: aPoint) ifFalse: [ ^nil ].	ptY _ aPoint y.	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"	scroller firstSubmorph bounds top > ptY ifTrue: [ ^nil ].	scroller lastSubmorph bounds bottom < ptY ifTrue: [ ^nil ].	"now use binary search"	^scroller 		findSubmorphBinary: [ :m |			b _ m bounds.			(b top <= ptY and: [ b bottom >= ptY ])				ifTrue: [ 0 ] "found"				ifFalse: [ (b top + b bottom // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 11/15/2011 19:17'!                               expandAll	(selectedMorph isNil		or: [selectedMorph isExpanded])		ifTrue: [^self].	self expandAll: selectedMorph.	scroller adjustExtent.	self setScrollDeltas! !!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 11/15/2011 19:18'!              toggleExpandedState: aMorph event: event	| oldState |	"self setSelectedMorph: aMorph."	event mouseButton2Pressed ifTrue: [		oldState _ aMorph isExpanded.		scroller submorphs copy do: [ :each |			(each canExpand and: [each isExpanded = oldState]) ifTrue: [				each toggleExpandedState.			].		].	] ifFalse: [		aMorph toggleExpandedState.	].	scroller adjustExtent.	self setScrollDeltas! !!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 19:29'!  scrollDeltaHeight	scroller hasSubmorphs ifFalse: [ ^1].	^ scroller firstSubmorph height! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:00'!               initialize	super initialize.	self on: #mouseMove send: #mouseStillDown:onItem: to: self! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:00'!               innerMorphClass	^InnerHierarchicalListMorph! !!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 11/15/2011 19:18'!                       toggleExpandedState: aMorph	aMorph toggleExpandedState.	scroller adjustExtent.	self setScrollDeltas! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/15/2011 19:51'!       scrollSelectionIntoView	selectedMorph ifNotNil: [		self scrollToShow: selectedMorph bounds ]! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/15/2011 15:32'!               selectionIndex: idx	"Called internally to select the index-th item."	| theMorph index |	idx ifNil: [^ self].	index := idx min: scroller submorphs size max: 0.	theMorph _ index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index].	self selectedMorph: theMorph.	self scrollSelectionIntoView! !!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 11/15/2011 19:17'!   insertNewMorphs: morphList	scroller addAllMorphs: morphList.	scroller adjustExtent.	self setScrollDeltas.	self selection: self getCurrentSelectionItem! !!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 11/15/2011 15:32'!                    noteRemovalOfAll: aCollection	scroller removeAllMorphsIn: aCollection.	(aCollection includes: selectedMorph) ifTrue: [ self setSelectedMorph: nil ]! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:01'!                    initialize	super initialize.	scroller width: self width.	scroller color: self textColor.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:00'!                innerMorphClass	^InnerListMorph! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:25'!           model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	mainView _ aMainView.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self		updateList;		initForKeystrokes! !!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 11/15/2011 19:51'!             scrollSelectionIntoView	"make sure that the current selection is visible"	| row |	row _ self getCurrentSelectionIndex.	row = 0 ifTrue: [		^ scrollBar setValue: scrollBar value ].	self scrollToShow: (self listMorph drawBoundsForRow: row)! !!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 11/15/2011 18:53'!                               updateList	| index |	"the list has changed -- update from the model"	self listMorph listChanged.	self setScrollDeltas.	index _ self getCurrentSelectionIndex.	self selectionIndex: index! !!PolygonMorph methodsFor: 'visual properties' stamp: 'jmv 11/15/2011 22:12'!               color	^self isOpen		ifTrue: [ self borderColor  "easy access to line color from halo"]		ifFalse: [ super color]! !!ScrollBar methodsFor: 'other events' stamp: 'jmv 11/15/2011 18:09'!  mouseDownInSlider: event	slider borderColor == #raised		ifTrue: [ slider borderColor: #inset ].		sliderShadow color: self sliderShadowColor.	sliderShadow bounds: slider bounds.	sliderShadow show! !!TextEditorTest methodsFor: 'testing' stamp: 'jmv 11/15/2011 16:03'!            testUndoRedo	"	TextEditorTest new testUndoRedo	"	| editor model paragraph m text1 text0 text2 |	text0 _ ''.	model _ TextModel withText: text0 copy.	editor _ TextEditor new.	m _ InnerTextMorph new.	m privateOwner: TextModelMorph new.	editor morph: m.	editor instVarNamed: 'emphasisHere' put: Array new.	editor model: model.	paragraph _ Paragraph new.	paragraph setModel: model extentForComposing: 300@300.	editor changeParagraph: paragraph.	paragraph composeAll.	text1 _ 'some words' asText.	editor addString: text1.	self assert: model actualContents = text1.	editor undo.	self assert: model actualContents = text0.	editor redo.	self assert: model actualContents = text1.	text2 _ ' additional inserted stuff' asText.	editor addString: text2.	self assert: model actualContents = (text1, text2).	editor undo.	self assert: model actualContents = text1.	editor undo.	self assert: model actualContents = text0.	editor redo.	self assert: model actualContents = text1.	editor redo.	self assert: model actualContents = (text1, text2).! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 11/15/2011 15:53'!              textMorphself flag: #jmvVer."Podemos reemplazar los senders locales por accesos directos (el doble encapsulamiento es tonto) una vez que quede definido el shape de la clase!!Y la variable deberia ser innerMorph o algo asi..."	^ scroller! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/15/2011 19:58'!scrollSelectionIntoView	"Scroll my text into view if necessary and return true, else return false"	self scrollSelectionIntoView: nil! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/15/2011 20:01'!          scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects rectToTest cpHere |	selRects _ self textMorph selectionRects.	selRects isEmpty ifTrue: [ ^ self ].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [ event anyButtonPressed ]) ifTrue: [  "Check for autoscroll"		cpHere _ event position.		cpHere y <= bounds top			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]			ifFalse: [				cpHere y >= bounds bottom					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]					ifFalse: [ ^ self ]]].	^ self scrollToShow: rectToTest! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 11/15/2011 22:23'!                    scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	^ StrikeFont default height! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:01'!                          initialize	super initialize.	hasEditingConflicts _ false! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 11/15/2011 22:01'!                     innerMorphClass	^InnerTextMorph! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 11/15/2011 19:58'!                 setSelection: sel	self editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView! !TextModelMorph removeSelector: #bottom!TextModelMorph removeSelector: #hTotalScrollRange!TextModelMorph removeSelector: #resizeScroller!TextModelMorph removeSelector: #top!PluggableListMorph removeSelector: #hTotalScrollRange!PluggableListMorph removeSelector: #resizeScroller!PluggableListMorph removeSelector: #vTotalScrollRange!HierarchicalListMorph removeSelector: #adjustSubmorphPositions!HierarchicalListMorph removeSelector: #hTotalScrollRange!HierarchicalListMorph removeSelector: #resizeScroller!HierarchicalListMorph removeSelector: #vTotalScrollRange!PluggableScrollPane removeSelector: #resizeScroller!PluggableScrollPane removeSelector: #zscrollToShow:!InnerTextMorph removeSelector: #editView!InnerTextMorph removeSelector: #setEditView:!!classDefinition: #InnerTextMorph category: #'Morphic-Views for Models'!InnerPluggableMorph subclass: #InnerTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompleter'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!InnerListMorph removeSelector: #adjustHeight!InnerListMorph removeSelector: #adjustWidth!InnerListMorph removeSelector: #display:atRow:on:!InnerListMorph removeSelector: #drawBoundsForRowEspantoso:!InnerListMorph removeSelector: #hTotalScrollRange!InnerListMorph removeSelector: #listSource:!!classDefinition: #InnerListMorph category: #'Morphic-Views for Models'!InnerPluggableMorph subclass: #InnerListMorph	instanceVariableNames: 'listItems font selectedRow selectedRows'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!InnerListMorph reorganize!('initialization' initialize)('list management' drawBoundsForRow: listChanged rowAtLocation: selectedRow selectedRow:)('drawing' bottomVisibleRowForCanvas: colorForRow: draw:atRow:on: drawBackgroundForMulti:on: drawOn: drawSelectionOn: font font: topVisibleRowForCanvas:)('list access' getListItem: getListSize item:)('scroll range' desiredWidth widthToDisplayItem:)('private' noSelection)('geometry' adjustExtent)!InnerHierarchicalListMorph removeSelector: #defaultColor!InnerHierarchicalListMorph removeSelector: #desiredHeight!!InnerHierarchicalListMorph reorganize!('as yet unclassified')('geometry' adjustExtent desiredWidth)!!InnerPluggableMorph reorganize!('geometry' adjustExtent)('visual properties' defaultColor)!IndentingListItemMorph removeSelector: #bottom!IndentingListItemMorph removeSelector: #left!IndentingListItemMorph removeSelector: #right!IndentingListItemMorph removeSelector: #top!Editor removeSelector: #openMenu!