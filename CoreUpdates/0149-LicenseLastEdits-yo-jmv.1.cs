'From Cuis 1.0 of 6 March 2009 [latest update: #5989] on 23 March 2009 at 8:13:15 pm'!!BitBlt methodsFor: 'private' stamp: 'mir 9/25/2008 15:03'!cachedFontColormapFrom: sourceDepth to: destDepth	"Modified from computeColormapFrom:to:."	| srcIndex map |	CachedFontColorMaps class == Array 		ifFalse: [CachedFontColorMaps _ (1 to: 9) collect: [:i | Array new: 32]].	srcIndex _ sourceDepth.	sourceDepth > 8 ifTrue: [srcIndex _ 9].	(map _ (CachedFontColorMaps at: srcIndex) at: destDepth) ~~ nil ifTrue: [^ map].	map _ (Color cachedColormapFrom: sourceDepth to: destDepth) copy.	(CachedFontColorMaps at: srcIndex) at: destDepth put: map.	^ map! !!Browser methodsFor: 'accessing' stamp: 'tak 9/25/2008 14:58'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	messageCategoryListIndex > 0 & (messageListIndex = 0)		ifTrue: [^ 1 to: 500]	"entire empty method template"		ifFalse: [^ 1 to: 0]		"null selection"! !!Browser methodsFor: 'message list' stamp: 'tak 9/25/2008 15:00'!messageList	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!), it is reset to zero."	| sel |	(sel _ self messageCategoryListSelection) ifNil: [		^ self classOrMetaClassOrganizer			ifNil:		[Array new]			ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]	].	^ sel = ClassOrganizer allCategory ifTrue:  [		self classOrMetaClassOrganizer			ifNil:		[Array new]			ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]]		ifFalse:			[(self classOrMetaClassOrganizer listAtCategoryNumber: messageCategoryListIndex - 1)				ifNil: [messageCategoryListIndex _ 0.  Array new]]! !!Browser methodsFor: 'metaclass' stamp: 'mir 9/25/2008 14:56'!classMessagesIndicated	"Answer whether the messages to be presented should come from the metaclass."	^ self metaClassIndicated and: [self classCommentIndicated not]! !!Class methodsFor: 'initialize-release' stamp: 'mir 9/25/2008 15:05'!unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."	""! !!ChangeList class methodsFor: 'public access' stamp: 'tak 9/25/2008 16:25'!browseRecent: charCount 	"ChangeList browseRecent: 5000"	"Opens a changeList on the end of the changes log file"	"The core was moved to browserRecent:on:."	^ self browseRecent: charCount on: (SourceFiles at: 2) ! !!Debugger class methodsFor: 'class initialization' stamp: 'jmv 3/23/2009 20:06'!initialize	ErrorRecursion _ false.	ContextStackKeystrokes _ Dictionary new.	ContextStackKeystrokes		at: $e put: #send;		at: $t put: #doStep;		at: $T put: #stepIntoBlock;		at: $p put: #proceed;		at: $r put: #restart;		at: $f put: #fullStack;		at: $w put: #where.	"Debugger initialize"! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'tak 9/25/2008 15:15'!computeSignatureForMessageHash: hash privateKey: privateKey	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."	| p q g x r s k tmp |	p _ privateKey first.	q _ privateKey second.	g _ privateKey third.	x _ privateKey fourth.	r _ s _ 0.	[r = 0 or: [s = 0]] whileTrue: [		k _ self nextRandom160 \\ q.		r _ (g raisedTo: k modulo: p) \\ q.		tmp _ (hash + (x * r)) \\ q.		s _ ((self inverseOf: k mod: q) * tmp) \\ q].	^ Array with: r with: s.! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'tak 9/25/2008 15:16'!generateKeySet	"Generate and answer a key set for DSA. The result is a pair (<private key><public key>). Each key is an array of four large integers. The private key is (p, q, g, x); the public one is (p, q, g, y). The signer must be sure to record (p, q, g, x), and must keep x secret to prevent someone from forging their signature."	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"	| qAndPandS q p exp g h x y |	qAndPandS _ self generateQandP.	Transcript show: 'Computing g...'.	q _ qAndPandS first.	p _ qAndPandS second.	exp _ (p - 1) / q.	h _ 2.	[g _ h raisedTo: exp modulo: p. g = 1] whileTrue: [h _ h + 1].	Transcript show: 'done.'; cr.	Transcript show: 'Computing x and y...'.	x _ self nextRandom160.	y _ g raisedTo: x modulo: p.	Transcript show: 'done.'; cr.	Transcript show: 'Key generation complete!!'; cr.	^ Array		with: (Array with: p with: q with: g with: x)		with: (Array with: p with: q with: g with: y).! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'bf 9/25/2008 15:15'!verifySignature: aSignature ofMessageHash: hash publicKey: publicKey	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."	| p q g y r s w u1 u2 v0 v |	p _ publicKey first.	q _ publicKey second.	g _ publicKey third.	y _ publicKey fourth.	r _ aSignature first.	s _ aSignature last.	((r > 0) and: [r < q]) ifFalse: [^ false].  "reject"	((s > 0) and: [s < q]) ifFalse: [^ false].  "reject"	w _ self inverseOf: s mod: q.	u1 _ (hash * w) \\ q.	u2 _ (r * w) \\ q.	v0 _ (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).	v _ ( v0 \\ p) \\ q.	^ v = r.! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'bf 9/25/2008 15:15'!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations _ 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes _ Integer primesUpTo: 2000.		SmallPrimes _ SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor _ SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ p = factor].	pMinusOne _ p - 1.	b _ self logOfLargestPowerOfTwoDividing: pMinusOne.	m _ pMinusOne // (2 raisedTo: b).	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r _ Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a _ (r next * 16rFFFFFF) truncated.		j _ 0.		z _ (a raisedTo: m modulo: p) normalize.		couldBePrime _ z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime _ true]				ifFalse: [					(j _ j + 1) < b						ifTrue: [z _ (z * z) \\ p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime."! !!EndOfStream methodsFor: 'description' stamp: 'mir 9/25/2008 15:16'!isResumable	"EndOfStream is resumable, so ReadStream>>next can answer."	^ true! !!Integer methodsFor: 'arithmetic' stamp: 'bf 9/25/2008 15:13'!\\\ anInteger 	"a modulo method for use in DSA. Be careful if you try to use this elsewhere."	^self \\ anInteger! !!Integer methodsFor: 'mathematical functions' stamp: 'tak 9/25/2008 15:13'!raisedTo: y modulo: n	"Answer the modular exponential. Code by Jesse Welton."	| s t u |	s _ 1.	t _ self.	u _ y.	[u = 0] whileFalse: [		u odd ifTrue: [			s _ s * t.			s >= n ifTrue: [s _ s \\\ n]].		t _ t * t.		t >= n ifTrue: [t _ t \\\ n].		u _ u bitShift: -1].	^ s.! !!Integer methodsFor: 'bit manipulation' stamp: 'tak 9/25/2008 15:17'!bitInvert	"Answer an Integer whose bits are the logical negation of the receiver's bits.	Numbers are interpreted as having 2's-complement representation."	^ -1 - self.! !!MacFileDirectory class methodsFor: 'platform specific' stamp: 'bf 9/25/2008 15:06'!maxFileNameLength	^ 32-1! !!OldSystemWindow methodsFor: 'events' stamp: 'jmv 3/23/2009 20:12'!doFastFrameDrag: grabPoint	"Do fast frame dragging from the given point"	"modified from doFastFrameDrag."	| offset newBounds outerWorldBounds |	outerWorldBounds _ self boundsIn: nil.	offset _ outerWorldBounds origin - grabPoint.	newBounds _ outerWorldBounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: outerWorldBounds extent].	self position: (self globalPointToLocal: newBounds topLeft); comeToFront! !!PackagePaneBrowser methodsFor: 'class list' stamp: 'bf 9/25/2008 14:56'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection exists."	| name envt |	(name _ self selectedClassName) ifNil: [^ nil].	"(envt _ self selectedEnvironment) ifNil: [^ nil]."	envt_(Smalltalk environmentForCategory: self selectedSystemCategoryName).	^ envt at: name! !!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'mir 9/25/2008 15:04'!fileOutDefinitionOn: aStream	self hasDefinition ifFalse:[^self].	aStream nextChunkPut: self definition; cr.	self hasComment ifTrue: [		aStream cr.		self organization commentRemoteStr fileOutOn: aStream]! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'tak 9/25/2008 16:09'!label	^label! !!SimpleServiceEntry methodsFor: 'services menu' stamp: 'tak 9/25/2008 15:10'!useLineAfter	^ useLineAfter == true! !!SimpleServiceEntry methodsFor: 'services menu' stamp: 'tak 9/25/2008 15:10'!useLineAfter: aBoolean	useLineAfter := aBoolean! !!SmallInteger methodsFor: 'arithmetic' stamp: 'tak 9/25/2008 15:14'!/ aNumber 	"Primitive. This primitive (for /) divides the receiver by the argument	and returns the result if the division is exact. Fail if the result is not a	whole integer. Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 10>	aNumber isZero ifTrue: [^(ZeroDivide dividend: self) signal].	^(aNumber isMemberOf: SmallInteger)		ifTrue: [(Fraction numerator: self denominator: aNumber) reduced]		ifFalse: [super / aNumber]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'bf 9/25/2008 15:18'!bitAnd: arg 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 14>	self >= 0 ifTrue: [^ arg bitAnd: self].	^ (self bitInvert bitOr: arg bitInvert) bitInvert.! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'mir 9/25/2008 15:18'!bitShift: arg 	"Primitive. Answer an Integer whose value is the receiver's value shifted	left by the number of bits indicated by the argument. Negative arguments	shift right. The receiver is interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 17>	self >= 0 ifTrue: [^ super bitShift: arg].	^ arg >= 0		ifTrue: [(self negated bitShift: arg) negated]		ifFalse: [(self bitInvert bitShift: arg) bitInvert].! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'mir 9/25/2008 15:18'!bitXor: arg 	"Primitive. Answer an Integer whose bits are the logical XOR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 16>	self >= 0 ifTrue: [^ arg bitXor: self].	^ arg < 0		ifTrue: [self bitInvert bitXor: arg bitInvert]		ifFalse: [(self bitInvert bitXor: arg) bitInvert].! !Debugger initialize!