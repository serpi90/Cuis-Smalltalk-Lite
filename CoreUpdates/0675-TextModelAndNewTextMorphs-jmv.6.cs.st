'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 25 November 2010 at 6:37:47 pm'!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model text wrapFlag paragraph editor pauseBlinking editView acceptOnCR'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!BareTextMorph commentStamp: 'jmv 11/25/2010 13:00' prior: 0!BareTextMorphs support display of text with emphasis.  They also support reasonable text-editing capabilities, as well as embedded hot links, and the ability to embed submorphs in the text. They are 'bare' in the sense that they can not clip contents to some window, or scroll it by themselves.Text display is clipped to the innerBounds of the rectangle, and text composition is normally performed within a rectangle which is innerBounds inset by the margins parameter.If text has been embedded in another object, one can elect to fill the owner's shape, in which case the text will be laid out in the shape of the owner's shadow image (including any submorphs other than the text).  One can also elect to have the text avoid occlusions, in which case it will avoid the bounds of any sibling morphs that appear in front of it.  It may be necessary to update bounds in order for the text runaround to notice the presence of a new occluding shape.The optional autoFitContents property enables the following feature:  if the text contents changes, then the bounds of the morph will be adjusted to fit the minimum rectangle that encloses the text (plus any margins specified).  Similarly, any attempt to change the size of the morph will be resisted if this parameter is set.  Except...If the wrapFlag parameter is true, then text will be wrapped at word boundaries based on the composition width (innerBounds insetBy: margins) width.  Thus an attempt to resize the morph in autofit mode, if it changes the width, will cause the text to be recomposed with the new width, and then the bounds will be reset to the minimum enclosing rectangle.  Similarly, if the text contents are changed with the wrapFlag set to true, word wrap will be performed based on the current compostion width, after which the bounds will be set (or not), based on the autoFitcontents property.Note that fonts can only be applied to the TextMorph as a whole.  While you can change the size, color, and emphasis of a subsection of the text and have it apply to only that subsection, changing the font changes the font for the entire contents of the TextMorph. Yet to do:Make a comprehensive control for the eyedropper, with border width and color, inner color and text color, and margin widths.!!classDefinition: #Paragraph category: #'System-Text'!Object subclass: #Paragraph	instanceVariableNames: 'model container lines positionWhenComposed maxRightX selectionStart selectionStop focused editor showCaret caretRect'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!Paragraph commentStamp: '<historical>' prior: 0!A Paragraph represents text that has been laid out, or composed, in some container.	text 		A Text with encoded per-character emphasis.	container	A Rectangle or TextContainer that determines where text can go.	lines		An Array of TextLines comprising the final layout of the text				after it has been composed within its container.	positionWhenComposed   As its name implies.  Allows display at new locations				without the need to recompose the text.Lines are ordered vertically.  However, for a given y, there may be several lines in left to right order.  Lines must never be empty, even if text is empty.!!classDefinition: #PluggableTextMorph2 category: #'Morphic-Windows'!ScrollPane subclass: #PluggableTextMorph2	instanceVariableNames: 'textMorph getTextSelector setTextSelector getSelectionSelector hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval hasEditingConflicts editorClass styler'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableTextMorph2 commentStamp: '<historical>' prior: 0!Comment about Shout specifics:Instances of me are usually created using my #on:text:accept:readSelection:menu: class method.In order to colour the text, I use an instance of SHTextStylerST80, which I store in my 'styler' instance variable.When my setText: method is called, I use my styler to ...	a) optionally set all assignments to ansi or leftArrow. 	b) Colour my text (immediately, if the text is less than 4096 chars in length, or in a backgroundProcess otherwise)	When my text is changed, my hasUnacceptedEdits: method is called with true, and I ask my styler to re-colour my text. This is performed in a background process so that typing remains responsive regardless of the length of the text.	Just before my styler is about to format/style the text, I send #stylerAboutToStyle:  to my model. This gives my model a chance to veto the styling (by answering false), or to initialize the styler with information it needs in order to parse the text correctly (e.g. the class to which a method belongs, or the workspace in which I am contained).	My styler informs me that it has finished styling by triggering the #stylerStyled: and #stylerStyledInBackground: events which I handle. I then update the textAttributes of my text and refresh the display. 	My 'unstyledAcceptText' instance variable is used in conjunction with my #acceptTextInModel and #correctFrom:to:with: methods to ensure that when my text is modified during a method compilation (removing unused vars etc), I do not lose those changes.	!!classDefinition: #TextModel category: #'System-Text'!Model subclass: #TextModel	instanceVariableNames: 'actualContents'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!TextModel commentStamp: '<historical>' prior: 0!I am a kind of Model that includes a piece of text.Category 'pane menu' and 'message list menu' are messages that may be called by my menus.See also CodeProvider.!!classDefinition: #FillInTheBlank category: #'Tools-Menus'!TextModel subclass: #FillInTheBlank	instanceVariableNames: 'acceptOnCR done responseUponCancel '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!classDefinition: #SyntaxError category: #'Tools-Debugger'!TextModel subclass: #SyntaxError	instanceVariableNames: 'class selector category debugger doitFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!classDefinition: #TextModelWithProvider category: #'System-Text'!TextModel subclass: #TextModelWithProvider	instanceVariableNames: 'contentsProvider'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #Workspace category: #'System-Text'!TextModel subclass: #Workspace	instanceVariableNames: 'bindings mustDeclareVariables shouldStyle '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!autoFit: trueOrFalse	self isAutoFit = trueOrFalse ifTrue: [^ self].	self autoFitOnOff! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!contents: stringOrText	^ self contentsAsIs: stringOrText! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!contents: stringOrText wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result.""Why was this ever needed?""	self newContents: ''."	wrapFlag _ true.	self basicExtent: width truncated@self height.	self newContents: stringOrText! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!contentsAsIs: stringOrText	"Accept new text contents with line breaks only as in the text.	Fit my width and height to the result."	wrapFlag _ false.	self newContents: stringOrText! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!crAction	"Return the action to perform when encountering a CR in the input"	^self valueOfProperty: #crAction! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!editor	"Return my current editor, or install a new one."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!isAutoFit	^ self valueOfProperty: #autoFitContents ifAbsent: [true]! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!isWrapped		^wrapFlag! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 18:37'!model: aTextModel	model _ aTextModel! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 15:24'!model: aTextHolder wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result.""Why was this ever needed?""	self newContents: ''."	wrapFlag _ true.	self basicExtent: width truncated@self height.	self model: aTextHolder.	"En realidad, se podria reusar el paragraph... Por que no?"	self releaseParagraph.	"update the paragraph cache"	self paragraph.! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!newContents: stringOrText	"Accept new text contents."	"If my text is all the same font, use the font for my new contents"	| newText oldEmbeddedMorphs |	newText _ stringOrText isString		ifTrue: [ | textSize |			(text notNil and: [				(textSize _ text size) > 0 and: [ (text runLengthFor: 1) = textSize ]])				ifTrue: [ | attribs |					attribs _ text attributesAt: 1.					Text						initialStyle: text initialStyleOrNil						string: stringOrText copy						attributes: attribs ]				ifFalse: [ Text fromString: stringOrText copy ]]		ifFalse: [ stringOrText copy asText ].	"should be veryDeepCopy?"	(text = newText and: [ text runs = newText runs ]) ifTrue: [ ^ self ].	text ifNotNil: [		oldEmbeddedMorphs _ text embeddedMorphs.		self removeAllMorphsIn: oldEmbeddedMorphs.		oldEmbeddedMorphs do: [ :m |			m delete ]].	"REPENSAR completamente. Deberian mandarme un TextHolder"	self ztext: newText.	"add all morphs off the visible region; they'll be moved into the right 	place when they become visible. (this can make the scrollable area too 	large, though)"	newText embeddedMorphs do: [ :m |		self addMorph: m.		m position: -1000 @ 0 ].	self releaseParagraph.	"update the paragraph cache"	self paragraph.	"re-instantiate to set bounds"	self world ifNotNil: [ self world startSteppingSubmorphsOf: self ].! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!text	^ self ztext! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!textColor	^ color! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!textColor: aColor	color = aColor ifTrue: [^ self].	color _ aColor.	self changed.! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!wrapFlag: aBoolean	"Change whether contents are wrapped to the container."	aBoolean == wrapFlag ifTrue: [^ self].	wrapFlag _ aBoolean.	self composeToBounds! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!ztext	"hay que ver si los senders quieren pedir un text o un TextHolder"	^text! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 11/25/2010 12:58'!ztext: popo	"hay que ver si los senders quieren mandar un text o un TextHolder"	^text _ popo! !!BareTextMorph methodsFor: 'anchors' stamp: 'jmv 11/25/2010 12:58'!anchorMorph: aMorph at: aPoint type: anchorType	| relPt index newText block |	aMorph owner == self ifTrue:[self removeMorph: aMorph].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	self addMorphFront: aMorph.	aMorph textAnchorType: anchorType.	aMorph relativeTextAnchorPosition: nil.	anchorType == #document ifTrue:[^self].	relPt _ self internalizePosition: aPoint from: self world.	index _ (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ Text string: (String value: 1) attribute: (TextAnchor new anchoredMorph: aMorph).	anchorType == #inline ifTrue:[		self paragraph replaceFrom: index to: index-1 with: newText.	] ifFalse:[		index _ index min: paragraph text size.		index _ paragraph text string lastIndexOf: Character cr startingAt: index ifAbsent:[0].		block _ paragraph characterBlockForIndex: index+1.		aMorph relativeTextAnchorPosition: (relPt x - bounds left) @ (relPt y - block top ).		self paragraph replaceFrom: index+1 to: index with: newText.	].	self fit.! !!BareTextMorph methodsFor: 'caching' stamp: 'jmv 11/25/2010 12:58'!releaseCachedState	super releaseCachedState.	self releaseParagraph.! !!BareTextMorph methodsFor: 'classification' stamp: 'jmv 11/25/2010 12:58'!is: aSymbol	^ aSymbol = #TextMorph or: [ super is: aSymbol ]! !!BareTextMorph methodsFor: 'copying' stamp: 'jmv 11/25/2010 12:58'!copy	"jmv note We don't copy TextStyles anymore. We want to preserve their identity."	^ super copy		text: text copy		wrap: wrapFlag 		color: color! !!BareTextMorph methodsFor: 'copying' stamp: 'jmv 11/25/2010 13:04'!veryDeepInner: deepCopier 	"Copy all of my instance variables. Some need to be not copied at all, but shared.	Warning!!!! Every instance variable defined in this class must be handled.	We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	"Otra vez los deepTongo..."	self ztext: (self ztext veryDeepCopyWith: deepCopier).	wrapFlag _ wrapFlag veryDeepCopyWith: deepCopier.	paragraph _ paragraph veryDeepCopyWith: deepCopier.	editor _ editor veryDeepCopyWith: deepCopier.! !!BareTextMorph methodsFor: 'drawing' stamp: 'jmv 11/25/2010 12:58'!debugDrawLineRectsOn: aCanvas	"Shows where text line rectangles are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!BareTextMorph methodsFor: 'drawing' stamp: 'jmv 11/25/2010 16:51'!drawOn: aCanvas	"Draw the receiver on a canvas"	| fauxBounds |	false ifTrue: [self debugDrawLineRectsOn: aCanvas].  "show line rects for debugging"	"Hack here:  The canvas expects bounds to carry the location of the text, but we also need to communicate clipping."	fauxBounds _ bounds topLeft corner: self innerBounds bottomRight.	aCanvas paragraph: self paragraph bounds: fauxBounds color: color! !!BareTextMorph methodsFor: 'editing' stamp: 'di 4/22/1998 10:57'!acceptContents	"The message is sent when the user hits enter or Cmd-S.	Accept the current contents and end editing."	self updateFromParagraph.	editView accept.! !!BareTextMorph methodsFor: 'editing' stamp: 'sw 8/12/2002 00:02'!acceptOnCR	"Answer whether the receiver wants to accept when the Return key is hit"	^ acceptOnCR == true! !!BareTextMorph methodsFor: 'editing' stamp: 'di 4/22/1998 11:03'!cancelEdits	"The message is sent when the user hits enter or Cmd-L.	Cancel the current contents and end editing."	self releaseParagraph.	editView cancel! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 11/25/2010 12:58'!chooseAlignment	self editor changeAlignment.	self updateFromParagraph! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 11/25/2010 12:58'!chooseEmphasisOrAlignment	self editor changeEmphasisOrAlignment.	self updateFromParagraph! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 11/25/2010 12:58'!chooseFont	self editor changeTextFont.	self updateFromParagraph.! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 11/25/2010 12:58'!chooseStyle	self editor changeStyle.	self updateFromParagraph! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 11/25/2010 12:58'!enterClickableRegion: evt	| index isLink |	evt hand hasSubmorphs ifTrue:[^self].	evt hand temporaryCursor ifNotNil:[^self].	paragraph ifNotNil:[		index _ (paragraph characterBlockAtPoint: evt position) stringIndex.		isLink _ (paragraph text attributesAt: index) 					anySatisfy:[:attr| attr mayActOnClick].		isLink ifTrue:[Cursor webLink show] ifFalse:[Cursor normal show].	].! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 11/25/2010 12:58'!handleEdit: editBlock	"Ensure that changed areas get suitably redrawn"	self selectionChanged.  "Note old selection"		editBlock value.	self selectionChanged.  "Note new selection"	self updateFromParagraph  "Propagate changes as necessary"! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 11/25/2010 15:04'!handleInteraction: interactionBlock	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple ParagraphEditor to Morphic keyboard events"	| oldEditor oldParagraph oldSize |	oldEditor _ editor.	oldParagraph _ paragraph.	oldSize _ oldParagraph text size.	self selectionChanged.  "Note old selection"		interactionBlock value.	(oldParagraph == paragraph) ifTrue: [		"this will not work if the paragraph changed"		editor _ oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	(oldSize = paragraph text size)		ifFalse: [ self updateFromParagraph ]! !!BareTextMorph methodsFor: 'editing' stamp: 'di 4/21/1998 13:23'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag in my view."	editView hasUnacceptedEdits: aBoolean! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 10/9/2009 12:50'!autoScrollView: evt	"This is kind of a hack because the PluggableTextMorph expects me to first expand the selection before auto scrolling will work."	| localEvt |	localEvt _ evt internalizedToOwnerOf: self from: editView.	super mouseMove: localEvt.	editView scrollSelectionIntoView: localEvt.! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:12'!doubleClick: evt	self handleInteraction: [ editor doubleClick: evt ].	editView scrollSelectionIntoView: evt.! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 12:58'!handlesKeyboard	^self visible! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 12:58'!handlesMouseDown: evt	^ self innerBounds containsPoint: evt cursorPoint! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 15:05'!keyStroke: evt	| action |	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].			"Maybe disable? Precludes the use of up and down arrows with control,	that are standard keystrokes in Windows to control the cursor.	Problem: At least Mac and Win VM generate ctrl-up and ctrl-down for	mouse wheel events.	I guess most people would prefer the mouse wheel to work properly..."	(editView scrollByKeyboard: evt)		ifTrue: [ ^self ].	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	self pauseBlinking.	evt keyValue = 13 ifTrue: ["CR - check for special action"		action _ self crAction.		action ifNotNil: [			^action value]].	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromParagraph.	super keyStroke: evt.  "sends to keyStroke event handler, if any"	editView scrollSelectionIntoView! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 12:58'!keyboardFocusChange: aBoolean		"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	paragraph ifNotNil: [ paragraph focused: aBoolean ].	aBoolean		ifTrue: [			"A hand is wanting to send us characters..."			editor ifNil: [ self editor ].	"Forces install"			self startBlinking ]		ifFalse: [ self stopBlinking ].	"Selection might be shown differently when focused"	self changed! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 14:24'!mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		editor ifNotNil: [ editor disregardNextMouseUp ].		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: event].	event hand		waitForSimulatedYellow: self 		event: event		dblClkSel: #doubleClick:! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:20'!mouseMove: evt	| editEvt |	evt redButtonPressed ifFalse: [^ self enterClickableRegion: evt].	self handleInteraction: [editor mouseMove: evt].	editEvt _ evt externalizedFromOwnerOf: self to: editView.	(editEvt position y between: editView top and: editView bottom) ifFalse: [		"Start auto-scrolling"		self startStepping: #autoScrollView:			at: Time millisecondClockValue			arguments: (Array with: editEvt)			stepTime: 100. "fast enough"	] ifTrue: [		self stopSteppingSelector: #autoScrollView:.	]! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:20'!mouseUp: evt	super mouseUp: evt.	self pauseBlinking.	self handleInteraction: [editor mouseUp: evt].	self stopSteppingSelector: #autoScrollView:.	editView scrollSelectionIntoView: evt.! !!BareTextMorph methodsFor: 'events-processing' stamp: 'jmv 11/25/2010 12:58'!handleKeystroke: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:	[^ self].	anEvent wasHandled: true.	self keyStroke: anEvent! !!BareTextMorph methodsFor: 'events-processing' stamp: 'jmv 11/25/2010 12:58'!handleMouseMove: anEvent	"Re-implemented to allow for mouse-up move events"	anEvent wasHandled ifTrue:[^self]. "not interested"	(anEvent hand hasSubmorphs) ifTrue:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2010 12:58'!container	"Return the container for composing this text.  There are 2 cases:	1.  container is nil, and wrap is true -- grow downward as necessary,	2.  container is nil, and wrap is false -- grow in 2D as necessary."	wrapFlag ifTrue: [		^ self innerBounds withHeight: 9999999].	^ self innerBounds topLeft extent: 9999999@9999999! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2010 12:58'!defaultLineHeight	^ self text initialStyle initialLineGrid! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2010 12:58'!extent: aPoint 	| newExtent priorEditor |	priorEditor _ editor.	self isAutoFit		ifTrue: [wrapFlag ifFalse: [^ self].  "full autofit can't change"				newExtent _ aPoint truncated max: self minimumExtent.				newExtent x = self extent x ifTrue: [^ self].  "No change of wrap width"				self releaseParagraph.  "invalidate the paragraph cache"				super extent: newExtent.				priorEditor					ifNil: [self fit]  "since the width has changed..."					ifNotNil: [self installEditorToReplace: priorEditor]]		ifFalse: [super extent: (aPoint truncated max: self minimumExtent).				wrapFlag ifFalse: [^ self].  "no effect on composition"				self composeToBounds]! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2010 13:01'!minimumExtent	^(9@(self text initialStyle initialLineGrid+2))! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2010 12:58'!privateMoveBy: delta 	super privateMoveBy: delta.	editor 		ifNil: [ paragraph ifNotNil: [paragraph moveBy: delta]]		ifNotNil: [ 			"When moving text with an active editor, save and restore all state."			paragraph moveBy: delta.			self installEditorToReplace: editor]! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2010 12:58'!textBounds	^ bounds! !!BareTextMorph methodsFor: 'initialization' stamp: 'jmv 11/25/2010 12:58'!defaultColor	"Return the default fill style for the receiver"	^ ColorTheme current text! !!BareTextMorph methodsFor: 'initialization' stamp: 'jmv 11/25/2010 13:21'!initialize	"jmv note: We don't copy TextStyles all over the place anymore. We want to preserve their identity."	super initialize.	wrapFlag _ true.	acceptOnCR _ false! !!BareTextMorph methodsFor: 'layout' stamp: 'jmv 11/25/2010 12:58'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !!BareTextMorph methodsFor: 'menu' stamp: 'jmv 11/25/2010 12:58'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	"Add text-related menu items to the menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu 		addUpdating: #autoFitString		target: self		action: #autoFitOnOff.	aCustomMenu 		addUpdating: #wrapString		target: self		action: #wrapOnOff! !!BareTextMorph methodsFor: 'menu' stamp: 'jmv 11/25/2010 12:58'!autoFitOnOff	self setProperty: #autoFitContents toValue: self isAutoFit not.	self isAutoFit ifTrue: [self fit]! !!BareTextMorph methodsFor: 'menu' stamp: 'jmv 11/25/2010 12:58'!autoFitString	"Answer the string to put in a menu that will invite the user to 	switch autoFit mode"	^ (self isAutoFit		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text auto fit' translated! !!BareTextMorph methodsFor: 'menu' stamp: 'jmv 11/25/2010 12:58'!wrapOnOff	self wrapFlag: wrapFlag not! !!BareTextMorph methodsFor: 'menu' stamp: 'jmv 11/25/2010 12:58'!wrapString	"Answer the string to put in a menu that will invite the user to 	switch autoFit mode"	^ (wrapFlag		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text wrap to bounds' translated! !!BareTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/25/2010 12:58'!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	aMorph textAnchorType == #document 		ifFalse:[^self anchorMorph: aMorph at: wp type: aMorph textAnchorType].	self addMorphFront: aMorph.! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 18:29'!composeToBounds	"Compose my text to fit my bounds.	If any text lies outside my bounds, it will be clipped,."	self releaseParagraph.	self paragraph positionWhenComposed: self position! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 14:24'!editorClass	^editView ifNotNil: [ editView editorClass ] ifNil: [ TextEditor ]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 13:01'!fit	"Adjust my bounds to fit the text.  Should be a no-op if autoFit is not specified.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para |	self isAutoFit 		ifTrue: [			newExtent := (self paragraph extent max: 9 @ self text initialStyle initialLineGrid) + (0 @ 2).			newExtent ~= bounds extent 				ifTrue: [					para := paragraph.	"Save para (layoutChanged smashes it)"					self basicExtent: newExtent.					paragraph := para].			].	"These statements should be pushed back into senders"	self paragraph positionWhenComposed: self position.	self changed	"Too conservative: only paragraph composition					should cause invalidation."! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 18:34'!installEditorToReplace: priorEditor 	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	"Revisar senders. Por que #printIt?"	| stateArray |	priorEditor ifNotNil: [ stateArray _ priorEditor stateArray] .	editor := self editorClass new morph: self.	editor model: model.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [ editor stateArrayPut: stateArray ].	self selectionChanged.	^editor! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 16:51'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	"...Code here to recreate the paragraph..."	paragraph _ Paragraph new.	paragraph model: model.	paragraph focused: self hasKeyboardFocus.	paragraph		compose: self ztext	"Mandar el TextHolder!!"		in: self container.	wrapFlag ifFalse: [		"Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 12:58'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	"release editor too"	editor ifNotNil: [		self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.	"most likely not needed"		editor _ nil].	paragraph ifNotNil: [		paragraph _ nil]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 12:58'!removedMorph: aMorph	| range |	range _ self text find: (TextAnchor new anchoredMorph: aMorph).	range ifNotNil: [		self paragraph replaceFrom: range first to: range last with: Text new.		self fit ].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	super removedMorph: aMorph! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 12:58'!selectionChanged	self paragraph selectionRects do: [:r | self invalidRect: r]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 12:58'!text: t wrap: wrap color: c	"Private -- for use only in morphic duplication"	self ztext: t.		"Pasar modelo, no texto..."	wrapFlag _ wrap.	color _ c.	paragraph _ editor _ nil! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 11/25/2010 13:22'!updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	"removed multiple lined paragraph support (predecessor and successor)"	| sel oldEditor |	paragraph ifNotNil: [		wrapFlag ifNil: [ wrapFlag := true ].		editor ifNotNil: [			oldEditor := editor.			sel := editor selectionInterval.			editor storeSelectionInParagraph].			"NO deberia hacer falta si el modelo es el mismo y esta actualizado!!!!!!"		self ztext: paragraph text.		self fit.		self layoutChanged.		sel ifNotNil: [			editor ifNil: [				"Reinstate selection after, eg, style change"				self installEditorToReplace: oldEditor]]].	editView setScrollDeltas! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 5/8/2009 19:00'!yellowButtonActivity: shiftKeyState	^ editView yellowButtonActivity: shiftKeyState! !!BareTextMorph methodsFor: 'notifications' stamp: 'jmv 11/25/2010 14:25'!possiblyChanged	editView ifNotNil: [ editView possiblyChanged ]! !!BareTextMorph methodsFor: 'testing' stamp: 'jmv 11/25/2010 13:04'!isOpaqueMorph	^false! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/25/2010 12:58'!onBlinkCursor	"Blink the cursor"	paragraph ifNil: [ ^nil ].	paragraph showCaret: paragraph showCaret not | pauseBlinking.	pauseBlinking _ false.	paragraph caretRect ifNotNil: [ :r | self invalidRect: r].! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/25/2010 12:58'!pauseBlinking	"Show a solid cursor (non blinking) for a short while"	pauseBlinking _ true.	paragraph ifNotNil: [		"Show cursor right now if needed"		paragraph showCaret ifFalse: [			paragraph showCaret: true.			paragraph caretRect ifNotNil: [ :r | self invalidRect: r ]]]! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/25/2010 12:58'!startBlinking	"And show the cursor"	pauseBlinking _ true.	"Start blinking in a short while"	paragraph ifNotNil: [ paragraph showCaret: true ].	self		startStepping: #onBlinkCursor		at: Time millisecondClockValue		arguments: nil		stepTime: 500.! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/25/2010 12:58'!stopBlinking	"And do not show cursor anymore."	self stopSteppingSelector: #onBlinkCursor.	paragraph ifNotNil: [		"Hide cursor right now if needed"		paragraph showCaret ifTrue: [			paragraph showCaret: false.			paragraph caretRect ifNotNil: [ :r | self invalidRect: r ]]]! !!BareTextMorph methodsFor: 'accept/cancel' stamp: 'di 9/11/1998 15:42'!acceptOnCR: trueOrFalse	acceptOnCR _ trueOrFalse! !!BareTextMorph methodsFor: 'edit view' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !!BareTextMorph methodsFor: 'edit view' stamp: 'di 4/21/1998 13:09'!setEditView: editPane	editView _ editPane! !!BareTextMorph methodsFor: 'macpal' stamp: 'di 11/10/1998 10:13'!flash	^ editView flash! !!BareTextMorph methodsFor: 'miscellaneous' stamp: 'jmv 9/10/2010 09:12'!selectAll	"Tell my editor to select all the text"	self editor selectAll.	self changed! !!BareTextMorph class methodsFor: 'new-morph participation' stamp: 'jmv 11/25/2010 12:58'!includeInNewMorphMenu	^ true! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 14:51'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents isEmptyOrNil])		ifTrue: [preamble _ TextModel new actualContents: self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 14:52'!postscriptString: aString	postscript _ TextModel new actualContents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 14:52'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	preamble _ TextModel new actualContents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 14:52'!setPreambleToSay: aString	"Make aString become the preamble of this change set"	preamble _ TextModel new actualContents: aString! !!CodeProvider methodsFor: 'code pane menu' stamp: 'jmv 11/25/2010 15:12'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu _ shifted		ifTrue: [			anEditorClass shiftedYellowButtonMenu]		ifFalse: [			anEditorClass yellowButtonMenu].	aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections.	aMenu addTitle: 'Text Editor'; addStayUpIcons.	^aMenu! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/25/2010 14:51'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change class s1 s2 differDesc diffWords |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])		ifTrue: [			s1 _ (class sourceCodeAt: change methodSelector) asString.			s2 _ change string.			s1 = s2				ifTrue: [^ self inform: 'Exact Match'].			diffWords _ self shouldDiffWords.			differDesc _ diffWords				ifTrue: [ 'Words']				ifFalse: [ 'Lines'].			(TextModel new				actualContents: (					(DifferenceFinder						displayPatchFrom: s1 to: s2						tryWords: diffWords						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))							initialFont: Preferences standardCodeFont))				openLabel: 'Comparison to Current Version: ', differDesc, 					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]		ifFalse: [self flash]! !!FillInTheBlankMorph methodsFor: 'menu' stamp: 'jmv 11/25/2010 14:53'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	^ TextModel new paneMenu: aMenu shifted: shifted editorClass: anEditorClass! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 14:53'!spyAllOn: aBlock	"Spy on all the processes in the system		[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]		"	| node result |	node _ self new.	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.	(TextModel new actualContents: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 14:53'!spyOn: aBlock reportOtherProcesses: aBoolean	"	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true	"	| node result |	node _ self new.	node reportOtherProcesses: aBoolean.	result _ node spyEvery: self defaultPollPeriod on: aBlock.	(TextModel new actualContents: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 14:53'!spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean	"	Spy on aProcess for a certain amount of time	| p1 p2 |  	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.	p1 resume.	p2 resume.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true	"	| node |	node _ self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	(TextModel new actualContents: (String				streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 14:52'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [ :current |			current == prev ifFalse: [ "call or return"				prev sender ifNotNil: [ "call only"					(receiver == nil or: [ current receiver == receiver ])						ifTrue: [ tallies tally: current by: 1 ]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(TextModel new actualContents:		(String streamContents: [ :s |			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ]]))		openLabel: 'Spy Results' wrap: false! !!ObjectExplorer methodsFor: 'menus' stamp: 'jmv 11/25/2010 14:52'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ TextModel basicNew paneMenu: aMenu shifted: shifted editorClass: anEditorClass! !!ObjectExplorer class methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 14:53'!about	TextModel new contents: self comment; openLabel: 'about ',self asString! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!caretRect	^caretRect! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!editor: anEditor	"Can be nil.	But if not nil, must be the same editor used in any TextMorph"	editor _ anEditor! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!extent	^ container width @ (lines last bottom - lines first top)! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!focused	^ focused! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!focused: aBoolean	focused _ aBoolean! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:29'!model: aTextModel	model _ aTextModel! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!numberOfLines	^lines size! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!showCaret	^showCaret! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!showCaret: aBool	showCaret _ aBool! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!string	^ self text string! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!text	^ self ztext! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!ztext	"hay que ver si los senders quieren pedir un text o un TextHolder"	^model! !!Paragraph methodsFor: 'access' stamp: 'jmv 11/25/2010 15:28'!ztext: popo	"hay que ver si los senders quieren mandar un text o un TextHolder"	^model _ popo! !!Paragraph methodsFor: 'composition' stamp: 'jmv 11/25/2010 15:28'!compose: t in: textContainer	"Cambiar los senders, en realidad deben mandarnos un textHolder!!!!!!!!!!"	self ztext: t.	container _ textContainer.	self composeAll! !!Paragraph methodsFor: 'composition' stamp: 'jmv 11/25/2010 15:28'!composeAll	self composeLinesFrom: 1 to: self text size delta: 0		into: OrderedCollection new priorLines: Array new atY: container top! !!Paragraph methodsFor: 'composition' stamp: 'jmv 11/25/2010 15:28'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY 	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult composer |	composer _ TextComposer new.	editor ifNotNil: [		composer editor: editor ].	newResult := composer				composeLinesFrom: start				to: stop				delta: delta				into: lineColl				priorLines: priorLines				atY: startingY				text: self text				container: container.	lines := newResult first asArray.	maxRightX := newResult second.	^maxRightX! !!Paragraph methodsFor: 'composition' stamp: 'jmv 11/25/2010 15:28'!compositionRectangle	^ container! !!Paragraph methodsFor: 'composition' stamp: 'jmv 11/25/2010 15:28'!recomposeFrom: start to: stop delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed."	| startLine newLines |	"Have to recompose line above in case a word-break was affected."	startLine _ (self lineIndexForCharacter: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	newLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].	self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top! !!Paragraph methodsFor: 'copying' stamp: 'jmv 11/25/2010 15:28'!deepCopy	"Don't want to copy the container (etc) or fonts in the TextStyle."	"jmv note We don't copy TextStyles anymore. We want to preserve their identity."	| new |	new _ self copy.	new		lines: lines copy		text: self ztext deepCopy.	^ new! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/25/2010 15:28'!displayClassicInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor e x1 x2 isBold isItalic x0 xtraWidth |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ ColorTheme current insertionPoint.	xtraWidth _ isBold ifTrue: [ 1 ] ifFalse: [ 0 ].	isItalic ifTrue: [		x0 _ x - 2.		x1 _ x0 - 2.		x2 _ x0 - 6 ]	ifFalse: [		x0 _ x.		x1 _ x0 - 4.		x2 _ x1 ].	1 to: 2 do: [ :i | 		"Draw caret triangles at top and bottom"		e _ (2 - i) * 2 + 4+xtraWidth @ 1.		aCanvas fillRectangle: (x1 + i @ (top + i - 1) extent: e)			color: caretColor.		aCanvas fillRectangle: (x2 + i @ (bottom - i) extent: e)			color: caretColor].	aCanvas fillRectangle: (x0-1 @ top corner: x0+1+xtraWidth @ bottom)		color: caretColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/25/2010 15:28'!displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	self displayThinInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/25/2010 15:28'!displaySelectionInLine: line on: aCanvas	| leftX rightX idx caretFont t b caretAttributes |	selectionStart ifNil: [^self].	"No selection"	selectionStart = selectionStop 		ifTrue: [			"Only show caret on line where clicked"			selectionStart textLine ~= line ifTrue: [ ^self ]]		ifFalse: [			"Test entire selection before or after here"			(selectionStop stringIndex < line first 				or: [selectionStart stringIndex > (line last + 1)])					ifTrue: [^self].	"No selection on this line"			(selectionStop stringIndex = line first 				and: [selectionStop textLine ~= line])					ifTrue: [^self].	"Selection ends on line above"			(selectionStart stringIndex = (line last + 1) 				and: [selectionStop textLine ~= line])					ifTrue: [^self]].	"Selection begins on line below"	selectionStart = selectionStop 		ifTrue: [			leftX _ selectionStart left.			idx _ selectionStart stringIndex.			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].			caretFont _ caretAttributes				ifNil: [ self text fontAt: idx ]				ifNotNil: [ self text fontIfApplying: caretAttributes ].			b _ line top + line baseline + caretFont descent.			t _ line top + line baseline - caretFont ascent.			self showCaret ifTrue: [				self					displayInsertionMarkAtX: leftX					top: t					bottom: b					emphasis: caretFont emphasis					on: aCanvas ]]		ifFalse: [			caretRect _ nil.			leftX _ (selectionStart stringIndex < line first 				ifTrue: [ line ]				ifFalse: [ selectionStart ]) left.			rightX _ (selectionStop stringIndex > (line last + 1) or: [					selectionStop stringIndex = (line last + 1) 						and: [selectionStop textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [selectionStop left].			aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom)				color: self selectionColor]! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/25/2010 15:28'!displayThinInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor x1 isBold isItalic x0 h w halfW r |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ ColorTheme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].	x0 < halfW ifTrue: [		x1 _ x1 - x0 + halfW.		x0 _ halfW ].	r _ container right-halfW-1.	r < x1 ifTrue: [		x0 _ x0 + r - x1.		x1 _ r.		].	caretRect _ x0-halfW@ top corner: x1+halfW+1 @ bottom.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/25/2010 15:28'!selectionColor	^ColorTheme current textHighlightFocused: self focused! !!Paragraph methodsFor: 'editing' stamp: 'jmv 11/25/2010 15:28'!clickAt: clickPoint for: model	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action target range boxes box t |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	t _ self text.	(t attributesAt: startBlock stringIndex) do: [ :att | 		att mayActOnClick ifTrue:				[(target _ model) ifNil: [ target _ editor morph].				range _ t rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint] ifNone: nil.				box ifNotNil: [					box _ editor morph displayBounds.					editor morph allOwnersDo: [ :m | box _ box intersect: (m displayBounds) ].					Utilities						awaitMouseUpIn: box						repeating: nil						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action _ true]].					Cursor currentCursor == Cursor webLink ifTrue:[Cursor normal show].				]]].	^ action! !!Paragraph methodsFor: 'editing' stamp: 'jmv 11/25/2010 15:28'!replaceFrom: start to: stop with: aText	"Edit the text, and then recompose the lines."	"jmv: I believe this should better be done in TextEditor.	For instance, someday, we might be applying recorded commands, without a GUI.	In such case we could have TextHolder and TextEditor but no morphs or paragraph.	(Food for thought)"		| intervalToFix |	"in ANY case, this should be done at the model..."	self ztext replaceFrom: start to: stop with: aText.		"The interval actually modified in text can begin before start, because of paragraph attributes"	intervalToFix _ self text encompassParagraph: (start to: start + aText size - 1).	self		recomposeFrom: intervalToFix first		to: intervalToFix last		delta: aText size - (stop-start+1)! !!Paragraph methodsFor: 'fonts-display' stamp: 'jmv 11/25/2010 15:28'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle _ aCanvas clipRect.	offset _ (somePosition - positionWhenComposed) truncated.	leftInRun _ 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [ :i |			line _ lines at: i.			self displaySelectionInLine: line on: aCanvas.			leftInRun _ displayScanner displayLine: line offset: offset leftInRun: leftInRun ]! !!Paragraph methodsFor: 'selection' stamp: 'jmv 11/25/2010 15:28'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: self text)		characterBlockAtPoint: aPoint index: nil		in: line! !!Paragraph methodsFor: 'selection' stamp: 'jmv 11/25/2010 15:28'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line t |	line _ lines at: (self lineIndexForCharacter: index).	t _ self text.	^ (CharacterBlockScanner new text: t)		characterBlockAtPoint: nil index: ((index max: line first) min: t size+1)		in: line! !!Paragraph methodsFor: 'selection' stamp: 'jmv 11/25/2010 15:28'!containsPoint: aPoint	^ (lines at: (self lineIndexForPoint: aPoint)) rectangle		containsPoint: aPoint! !!Paragraph methodsFor: 'selection' stamp: 'jmv 11/25/2010 15:28'!defaultCharacterBlock	^ (CharacterBlock new stringIndex: 1 text: self text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!Paragraph methodsFor: 'selection' stamp: 'jmv 11/25/2010 15:28'!selectionRects	"Return an array of rectangles representing the selection region."	selectionStart ifNil: [^ Array new].	^ self selectionRectsFrom: selectionStart to: selectionStop! !!Paragraph methodsFor: 'selection' stamp: 'jmv 11/25/2010 15:28'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ 6.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [ :i |		| line |		line _ lines at: i.		(line left = rects last left and: [ line right = rects last right ])			ifTrue: [ "new line has same margins as old one -- merge them, so that the caller gets as few rectangles as possible"					| lastRect |					lastRect _ rects removeLast.					rects add: (lastRect bottom: line bottom) ]			ifFalse: [ "differing margins; cannot merge"					rects add: line rectangle ] ].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!Paragraph methodsFor: 'selection' stamp: 'jmv 11/25/2010 15:28'!selectionStart: startBlock selectionStop: stopBlock	selectionStart _ startBlock.	selectionStop _ stopBlock.! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!adjustRightX	| shrink |	shrink _ container right - maxRightX.	lines do: [:line | line paddingWidth: (line paddingWidth - shrink)].	container _ container withRight: maxRightX! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!fastFindFirstLineSuchThat: lineBlock	"Perform a binary search of the lines array and return the index	of the first element for which lineBlock evaluates as true.	This assumes the condition is one that goes from false to true for	increasing line numbers (as, eg, yval > somey or start char > somex).	If lineBlock is not true for any element, return size+1."	| index low high |	low _ 1.	high _ lines size.	[index _ high + low // 2.	low > high]		whileFalse: 			[(lineBlock value: (lines at: index))				ifTrue: [high _ index - 1]				ifFalse: [low _ index + 1]].	^ low! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last cr s |	s _ self string.	cr _ Character cr.	arrayIndex _ lineIndex.	[		first _ (lines at: arrayIndex) first.		 first > 1 and: [(s at: first - 1) ~~ cr] ] whileTrue: [ "word wrap"			arrayIndex _ arrayIndex - 1].	last _ (lines at: arrayIndex) last.		^(s copyFrom: first to: last) indentationIfBlank: aBlock.! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!lastLine	^lines last! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!lineIndexForCharacter: index	"Answer the index of the line in which to select the character at index."	^ (self fastFindFirstLineSuchThat: [:line | line first > index]) - 1 max: 1! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!lineIndexForPoint: aPoint	"Answer the index of the line in which to select the character nearest to aPoint."	| i py |	py _ aPoint y truncated.	"Find the first line at this y-value"	i _ (self fastFindFirstLineSuchThat: [:line | line bottom > py]) min: lines size.	"Now find the first line at this x-value"	[i < lines size and: [(lines at: i+1) top = (lines at: i) top				and: [aPoint x >= (lines at: i+1) left]]]		whileTrue: [i _ i + 1].	^ i! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	"apparently the selector changed with NewParagraph"	^self lineIndexForCharacter: characterIndex ! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!lines	^ lines! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!lines: l text: t	"Private -- just a service for deepCopy"	"POR LO TANTO, tomar las ivars, i.e. el TextHolder!!!!!!!!!!	En realidad, quien corno quiere hacer deepCopy de estos bichos???	interceptar? entender?"	lines _ l.	self ztext: t.! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!moveBy: delta	lines do: [:line | line moveBy: delta].	positionWhenComposed _ (positionWhenComposed ifNil: [ container origin ]) + delta.	container _ container translateBy: delta! !!Paragraph methodsFor: 'private' stamp: 'jmv 11/25/2010 15:28'!positionWhenComposed: pos	positionWhenComposed _ pos! !!Paragraph methodsFor: 'initialization' stamp: 'jmv 11/25/2010 15:28'!initialize	focused _ false.	showCaret _ false.! !!PluggableTextMorph2 methodsFor: 'accessing' stamp: 'jmv 11/25/2010 13:27'!editor	^textMorph ifNotNil: [ textMorph editor ]! !!PluggableTextMorph2 methodsFor: 'accessing' stamp: 'jmv 11/25/2010 13:27'!editorClass	^editorClass! !!PluggableTextMorph2 methodsFor: 'accessing' stamp: 'jmv 11/25/2010 13:27'!getTextSelector	^getTextSelector! !!PluggableTextMorph2 methodsFor: 'accessing' stamp: 'jmv 11/25/2010 13:27'!textMorph	^ textMorph! !!PluggableTextMorph2 methodsFor: 'accessing' stamp: 'jmv 11/25/2010 13:27'!wrapFlag: aBoolean	textMorph wrapFlag: aBoolean! !!PluggableTextMorph2 methodsFor: 'dependents access' stamp: 'jmv 11/25/2010 13:27'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!PluggableTextMorph2 methodsFor: 'dependents access' stamp: 'jmv 11/25/2010 13:27'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ hasUnacceptedEdits! !!PluggableTextMorph2 methodsFor: 'drawing' stamp: 'jmv 11/25/2010 13:27'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		((model is: #CodeProvider) and: [model refusesToAcceptCode])			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self hasUnacceptedEdits							ifTrue: [								model wantsDiffFeedback									ifTrue: [										bw _ 4.										bc _ Color green]									ifFalse: [										bc _ Color red]]							ifFalse: [								model wantsDiffFeedback									ifTrue: [										bc _ Color green]									ifFalse: []]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ ColorTheme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle width: bw color: bc ]! !!PluggableTextMorph2 methodsFor: 'drawing' stamp: 'jmv 11/25/2010 13:27'!wantsFrameAdornments	"Answer whether the receiver wishes to have red borders, etc., used to show editing state"	"A 'long-term temporary workaround': a nonmodular, unsavory, but expedient way to get the desired effect, sorry.  Clean up someday."	(model is: #CodeProvider) ifFalse: [^false].	^ (#(annotation searchString infoViewContents) includes: getTextSelector) not! !!PluggableTextMorph2 methodsFor: 'dropping/grabbing' stamp: 'jmv 11/25/2010 13:27'!wantsDroppedMorph: aMorph event: anEvent 	^false! !!PluggableTextMorph2 methodsFor: 'editor access' stamp: 'jmv 11/25/2010 13:27'!handleEdit: editBlock	| result |	self editor		selectFrom: selectionInterval first to: selectionInterval last;		model: model.  "For, eg, evaluateSelection"		"mandar model: aca?????"	textMorph handleEdit: [ result _ editBlock value ].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PluggableTextMorph2 methodsFor: 'editor access' stamp: 'jmv 11/25/2010 13:27'!scrollSelectionIntoView	"Scroll my text into view if necessary and return true, else return false"	^ self scrollSelectionIntoView: nil! !!PluggableTextMorph2 methodsFor: 'editor access' stamp: 'jmv 11/25/2010 13:27'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest cpHere |	selectionInterval _ self editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [event anyButtonPressed]) ifTrue: [  "Check for autoscroll"		cpHere _ scroller externalizePosition: event cursorPoint to: self.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ textMorph bounds: rectToTest in: self.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph2 methodsFor: 'editor access' stamp: 'jmv 11/25/2010 13:27'!selectAll	"Tell my textMorph's editor to select all"	textMorph selectAll! !!PluggableTextMorph2 methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:27'!doubleClick: event	textMorph doubleClick: event! !!PluggableTextMorph2 methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:27'!handlesKeyboard	self flag: #jmv.	"Not answering true helps not hitting pluggable texts twice during navigation. Only the internal text morph will receive it.	If some problem is found, introduce a new selector, that answers ^self handlesKeyboard in morph (and LW) 	and only in this class it will answer false""	^self visible" 	^ super handlesKeyboard! !!PluggableTextMorph2 methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:27'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	textMorph keyStroke: evt.	self eventHandler ifNotNil: [		self eventHandler keyStroke: evt fromMorph: self ]! !!PluggableTextMorph2 methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:27'!mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: textMorph ]! !!PluggableTextMorph2 methodsFor: 'event handling' stamp: 'jmv 11/25/2010 13:27'!mouseLeave: event	"The mouse has left the area of the receiver"	self editor ifNotNil: [ :e | selectionInterval _ e selectionInterval ].	super mouseLeave: event! !!PluggableTextMorph2 methodsFor: 'geometry' stamp: 'jmv 11/25/2010 13:27'!extent: newExtent 	super extent: newExtent.	textMorph ifNotNil: [ textMorph extent: self viewableWidth @ self height ].	self setScrollDeltas! !!PluggableTextMorph2 methodsFor: 'geometry' stamp: 'jmv 11/25/2010 13:27'!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph ifNotNil: [		"the current selection gets munged by resetting the extent, so store it"		tempSelection _ self selectionInterval.		self extent: self extent.		self setSelection: tempSelection]! !!PluggableTextMorph2 methodsFor: 'geometry' stamp: 'jmv 11/25/2010 13:27'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	scroller hasSubmorphs ifFalse: [ ^1].	^ scroller firstSubmorph defaultLineHeight! !!PluggableTextMorph2 methodsFor: 'initialization' stamp: 'jmv 11/25/2010 13:27'!acceptOnCR: trueOrFalse	textMorph acceptOnCR: trueOrFalse! !!PluggableTextMorph2 methodsFor: 'initialization' stamp: 'jmv 11/25/2010 13:27'!editString: aString 	"Jam some text in.  This is treated as clean text by default."	self setText: aString asText! !!PluggableTextMorph2 methodsFor: 'initialization' stamp: 'jmv 11/25/2010 18:23'!initialize	super initialize.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.	askBeforeDiscardingEdits _ true.	textMorph _ BareTextMorph new		model: model wrappedTo: self viewableWidth.	textMorph setEditView: self.	scroller addMorph: textMorph! !!PluggableTextMorph2 methodsFor: 'initialization' stamp: 'jmv 11/25/2010 18:14'!model: anObject	"Set my model and make me me a dependent of the given object."		(anObject isKindOf: TextModel) ifFalse: [ self halt: 'wrong model' ].		^super model: anObject! !!PluggableTextMorph2 methodsFor: 'initialization' stamp: 'jmv 11/25/2010 15:26'!model: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	editorClass _ anEditorClass.	self model: anObject.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	getMenuSelector _ getMenuSel.	self borderWidth: 1.	false ifTrue: [self setText: self getText. ].		self setSelection: self getSelection.! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!correctFrom: start to: stop with: aString	^ self handleEdit: [ self editor correctFrom: start to: stop with: aString ]! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!correctSelectionWithString: aString	| result newPosition |	"I can't tell if this is a hack or if it's the right thing to do."	self setSelection: selectionInterval. 	result _ self correctFrom: selectionInterval first to: selectionInterval last with: aString.	newPosition _ selectionInterval first + aString size.	self setSelection: (newPosition to: newPosition - 1).	^ result! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!deselect	^ self editor deselect! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!nextTokenFrom: start direction: dir	^ self editor nextTokenFrom: start direction: dir! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!notify: aString at: anInteger in: aStream	^ self editor notify: aString at: anInteger in: aStream! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!selectFrom: start to: stop	^ self editor selectFrom: start to: stop! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!selectInvisiblyFrom: start to: stop	^ self editor selectInvisiblyFrom: start to: stop! !!PluggableTextMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/25/2010 13:27'!selectionInterval	^ self editor selectionInterval! !!PluggableTextMorph2 methodsFor: 'layout' stamp: 'jmv 11/25/2010 13:27'!acceptDroppingMorph: aMorph event: evt 	"This message is sent when a morph is dropped onto a morph that has     	agreed to accept the dropped morph by responding 'true' to the     	wantsDroppedMorph:Event: message. The default implementation just     	adds the given morph to the receiver."	"Here we let the model do its work."	self model		acceptDroppingMorph: aMorph		event: evt		inMorph: self.! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	textToAccept := textMorph text.	ok := setTextSelector isNil or: [					setTextSelector numArgs = 2 						ifTrue: [							model 								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [ model perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: [			self setText: self getText.			self hasUnacceptedEdits: false.			(model dependents				detect: [ :dep | 					(dep isKindOf: PluggableTextMorph) 						and: [ dep getTextSelector == #annotation ]]				ifNone: nil) ifNotNil: [ :aPane | model changed: #annotation ]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			(model is: #CodeProvider) ifTrue: [model updateCodePaneIfNeeded].			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!again	self handleEdit: [ self editor again ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!browseChangeSetsWithSelector	"Help the user track down which change sets mention a particular selector"	self handleEdit: [ self editor browseChangeSetsWithSelector ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!browseIt	self handleEdit: [ self editor browseIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!cancel	self setText: self getText.	self setSelection: self getSelection.	getTextSelector == #annotation ifFalse: [		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [				dep getTextSelector == #annotation]] ifNone: nil)					ifNotNil: [:aPane | 						model changed: #annotation]]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!changeStyle	self handleEdit: [ self editor changeStyle ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!chooseAlignment	self handleEdit: [ self editor changeAlignment ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!classCommentsContainingIt	self handleEdit: [ self editor classCommentsContainingIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!classNamesContainingIt	self handleEdit: [ self editor classNamesContainingIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!copySelection	self handleEdit: [ self editor copySelection ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!cut	self handleEdit: [ self editor cut ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!debugIt	self handleEdit: [ self editor debugIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!doIt	self handleEdit: [ self editor evaluateSelection ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!explain	self handleEdit: [ self editor explain ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!exploreIt	| result |	self handleEdit: [		result _ self editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [ self flash ]			ifFalse:  [result explore ]]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!fileItIn	self handleEdit: [ self editor fileItIn ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!find	self handleEdit: [ self editor find ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!findAgain	self handleEdit: [ self editor findAgain ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!implementorsOfIt	self handleEdit: [ self editor implementorsOfIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!inspectIt	| result |	self handleEdit: [		result _ self editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [ self flash ]			ifFalse: [ result inspect ]]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!methodNamesContainingIt	self handleEdit: [ self editor methodNamesContainingIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!methodSourceContainingIt	self handleEdit: [ self editor methodSourceContainingIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!methodStringsContainingit	self handleEdit: [ self editor methodStringsContainingit ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!offerFontMenu	self handleEdit: [ self editor changeTextFont ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!paste	self handleEdit: [ self editor paste ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!pasteRecent	"Paste an item chosen from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self handleEdit: [ self editor paste ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!prettyPrint	self handleEdit: [ self editor prettyPrint ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!printIt	| result oldEditor |	self editor		selectFrom: selectionInterval first to: selectionInterval last;		model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result _ (oldEditor _ textMorph editor) evaluateSelection].	((result isKindOf: FakeClassPool) or: [result == #failedDoit]) ifTrue: [^self flash].	selectionInterval _ oldEditor selectionInterval.	textMorph installEditorToReplace: oldEditor.	textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	selectionInterval _ oldEditor selectionInterval.		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.	self scrollSelectionIntoView.! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!referencesToIt	self handleEdit: [ self editor referencesToIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!saveContentsInFile	self handleEdit: [ self editor saveContentsInFile ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!sendersOfIt	self handleEdit: [ self editor sendersOfIt ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!setSearchString	self handleEdit: [ self editor setSearchString ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!undo	self handleEdit: [ self editor undo ]! !!PluggableTextMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 13:27'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	^self yellowButtonActivity: false! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 18:23'!basicSetText: aText"NO deberia existir"	scrollBar setValue: 0.0.	textMorph newContents: aText.	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 13:27'!getSelection	"Answer the model's selection interval."	getSelectionSelector ifNil: [^1 to: 0].	"null selection"	^model perform: getSelectionSelector! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 13:27'!getText	"Retrieve the current model text"	| newText |	getTextSelector ifNil: [^Text new].	newText := model perform: getTextSelector.	newText ifNil: [^Text new].	^newText shallowCopy! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 13:27'!selectionInterval: sel	selectionInterval _ sel! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 13:27'!setSelection: sel	selectionInterval _ sel.	self editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [ scroller changed ]! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 13:27'!setText: aText	self okToStyle ifFalse: [ ^self basicSetText: aText ].	self basicSetText: (styler format: aText asText).	aText size < 4096		ifTrue: [ styler style: textMorph text ]		ifFalse: [ styler styleInBackgroundProcess:  textMorph text ]! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 13:27'!setTextColor: aColor	"Set the color of my text to the given color"	textMorph color: aColor! !!PluggableTextMorph2 methodsFor: 'model access' stamp: 'jmv 11/25/2010 13:27'!text	"En realidad, habria que pedirselo al modelo!!!!!!!!!!"	^ textMorph ztext! !!PluggableTextMorph2 methodsFor: 'scroll bar events' stamp: 'jmv 11/25/2010 13:27'!yellowButtonActivity: shiftKeyState	"Invoke the text-editing menu"	| menu |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu invokeModal]! !!PluggableTextMorph2 methodsFor: 'transcript' stamp: 'jmv 11/25/2010 13:27'!appendEntry	"Append the text in the model's writeStream to the editable text. "	textMorph text size > model characterLimit ifTrue: [		"Knock off first half of text"		self selectInvisiblyFrom: 1 to: textMorph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: textMorph text size + 1 to: textMorph text size.	self replaceSelectionWith: model contents asText.	"model IS a TranscriptStream"	self selectInvisiblyFrom: textMorph text size + 1 to: textMorph text size! !!PluggableTextMorph2 methodsFor: 'transcript' stamp: 'jmv 11/25/2010 13:27'!bsText	self changeText: (self text copyFrom: 1 to: (self text size - 1 max: 0))! !!PluggableTextMorph2 methodsFor: 'transcript' stamp: 'jmv 11/25/2010 13:27'!changeText: aText	"The paragraph to be edited is changed to aText."	self setText: aText! !!PluggableTextMorph2 methodsFor: 'transcript' stamp: 'jmv 11/25/2010 13:27'!replaceSelectionWith: aText	^ self editor replaceSelectionWith: aText! !!PluggableTextMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/25/2010 13:27'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean! !!PluggableTextMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/25/2010 13:27'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!PluggableTextMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/25/2010 13:27'!hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!PluggableTextMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/25/2010 13:27'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		self changed].	aBoolean ifFalse: [hasEditingConflicts _ false].	"shout:  re-style the text iff aBoolean is true"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess: textMorph ztext ]	"al modelo!!"! !!PluggableTextMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/25/2010 13:27'!promptForCancel	"Ask if it is OK to cancel changes to text"	(self confirm:'Changes have not been saved.Is it OK to cancel those changes?' translated)		ifTrue: [model clearUserEditFlag].! !!PluggableTextMorph2 methodsFor: 'updating' stamp: 'jmv 11/25/2010 13:27'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: [			self setText: self getText.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: model autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			^self refreshWorld ].	aSymbol == #bs 		ifTrue: [			self handleEdit: [self bsText].			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ]! !!PluggableTextMorph2 methodsFor: 'scrolling' stamp: 'jmv 11/25/2010 13:27'!hTotalScrollRange"Return the width of the widest item in the list"	textMorph ifNil: [ ^0 ].	textMorph isWrapped ifTrue:[ ^0 ].	^super hTotalScrollRange! !!PluggableTextMorph2 methodsFor: 'scrolling' stamp: 'jmv 11/25/2010 13:27'!mightNeedHorizontalScrollBar	textMorph ifNil: [ ^false ].	textMorph isWrapped ifTrue: [ ^false ].	^super mightNeedHorizontalScrollBar! !!PluggableTextMorph2 methodsFor: 'focus handling' stamp: 'jmv 11/25/2010 13:27'!focusText	self activeHand newKeyboardFocus: textMorph! !!PluggableTextMorph2 methodsFor: 'menu' stamp: 'jmv 11/25/2010 13:27'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key. The third argument, if required, is the editorClass."	| menu aMenu aTitle |	getMenuSelector		ifNil: [^ nil].	getMenuSelector numArgs = 3 ifFalse: [		^super getMenu: shiftKeyState ].		menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	aMenu _ model perform: getMenuSelector with: menu with: shiftKeyState with: editorClass.	aTitle ifNotNil:  [aMenu addTitle: aTitle].	^ aMenu! !!PluggableTextMorph2 methodsFor: 'shout' stamp: 'jmv 11/25/2010 13:27'!okToStyle	styler ifNil: [ ^false ].	^model shoutAboutToStyle: styler! !!PluggableTextMorph2 methodsFor: 'shout' stamp: 'jmv 11/25/2010 13:27'!styler: anObject		styler := anObject! !!PluggableTextMorph2 methodsFor: 'shout' stamp: 'jmv 11/25/2010 13:27'!stylerStyled: styledCopyOfText	textMorph text privateSetRuns: styledCopyOfText runs.	"jmv - 11/2010 The next line used to be commented out but it is needed to fix lines whose	length might change due to font change (i.e., styled comments are shorter than unstyled)"	textMorph paragraph recomposeFrom: 1 to: textMorph text size delta: 0.	"older comment: caused chars to appear in wrong order esp. in demo mode. remove this line when sure it is fixed"		textMorph updateFromParagraph.	selectionInterval 		ifNotNil: [			self editor				selectInvisiblyFrom: selectionInterval first to: selectionInterval last;				storeSelectionInParagraph;				setEmphasisHereFromText].	self editor blinkParen.	self scrollSelectionIntoView! !!PluggableTextMorph2 methodsFor: 'shout' stamp: 'jmv 11/25/2010 13:27'!stylerStyledInBackground: styledCopyOfText 	"It is possible that the text string has changed since the styling began. Disregard the styles if styledCopyOfText's string differs with the current textMorph contents string"		textMorph text string = styledCopyOfText string		ifTrue: [ self stylerStyled: styledCopyOfText ]! !!PluggableTextMorph2 methodsFor: 'notifications' stamp: 'jmv 11/25/2010 13:27'!possiblyChanged	"A hook for notificating possible interested parties	Not used in base system"! !!PluggableTextMorph2 methodsFor: 'testing' stamp: 'jmv 11/25/2010 13:27'!is: aSymbol	^aSymbol = #HasTextSelector or: [ super is: aSymbol ]! !!PluggableTextMorph2 class methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 13:27'!model: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel	^ self		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil		menuGetter: nil! !!PluggableTextMorph2 class methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 13:27'!model: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	|styler answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ anObject respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel		menuGetter: getMenuSel.	^answer! !!PluggableTextMorph2 class methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 13:27'!noShoutModel: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel	^ self		noShoutModel: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil		menuGetter: nil! !!PluggableTextMorph2 class methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 13:27'!noShoutModel: anObject editorClass: anEditorClass textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel menuGetter: getMenuSel"on: anObject editorClass: anEditorClass text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel"	| answer |	answer _ self new.	answer		model: anObject		editorClass: anEditorClass		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel		menuGetter: getMenuSel.	^answer! !!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 14:52'!statsOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats in the form:	ScriptEditorMorph 51		SortedCollection (21->LayoutMorph 15->SimpleButtonMorph 9->Array 4->CompoundTileMorph 2->StringMorph )"	| dummy printOut |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	"(dummy references) is the raw data"	printOut _ dummy statisticsOfRefs.	(TextModel new contents: printOut) 		openLabel: 'ReferenceStream statistics'.! !!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 14:53'!tallyOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats are simply the number of instances of each class:	1450->Point   835->Rectangle   549->Array   300->String"	| dummy bag |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	bag _ Bag new.	dummy references keysDo: [:key | bag add: key class name].	"(bag sortedCounts) is the SortedCollection"	(TextModel new contents: bag sortedCounts printString) 		openLabel: 'ReferenceStream statistics'.! !!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 11/25/2010 14:52'!compareTallyIn: beforeFileName to: afterFileName	"SpaceTally new compareTallyIn: 'tally' to: 'tally2'"	| answer s beforeDict a afterDict allKeys before after diff |	beforeDict _ Dictionary new.	s _ FileDirectory default fileNamed: beforeFileName.	 [s atEnd ] whileFalse: [		a _ Array readFrom: s nextLine.		beforeDict at: a first put: a allButFirst.	].	s close.	afterDict _ Dictionary new.	s _ FileDirectory default fileNamed: afterFileName.	[ s atEnd ] whileFalse: [		a _ Array readFrom: s nextLine.		afterDict at: a first put: a allButFirst.	].	s close.	answer _ WriteStream on: String new.	allKeys _ (Set new addAll: beforeDict keys; addAll: afterDict keys; yourself) asArray sort.	allKeys do: [ :each |		before _ beforeDict at: each ifAbsent: [#(0 0 0)].		after _ afterDict at: each ifAbsent: [#(0 0 0)].		diff _ before with: after collect: [ :vBefore :vAfter | vAfter - vBefore].		diff = #(0 0 0) ifFalse: [			answer nextPutAll: each, '  ', diff printString; cr.		].	].	TextModel new contents: answer contents; openLabel: 'space diffs'! !!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 11/25/2010 14:52'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream readOnlyFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream readOnlyFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(TextModel new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!String methodsFor: 'user interface' stamp: 'jmv 11/25/2010 14:52'!edit	TextModel new contents: self; openLabel: 'Text Editor'! !!Text methodsFor: 'user interface' stamp: 'jmv 11/25/2010 14:52'!edit	TextModel new contents: self; openLabel: 'Text Editor'! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/25/2010 14:52'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(TextModel new contents:		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))			openLabel: 'Comparison to Clipboard Text'! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/25/2010 14:33'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave suggestedName |	stringToSave := paragraph string.	stringToSave size = 0 ifTrue: [^self inform: 'nothing to save.'].	suggestedName := 'unnamed.txt'.	fileName := FillInTheBlank request: 'File name?'				initialAnswer: suggestedName.	fileName isEmptyOrNil 		ifFalse: [			(FileStream newFileNamed: fileName)				nextPutAll: stringToSave;				close]! !!TextEditor methodsFor: 'model access' stamp: 'jmv 11/25/2010 15:02'!model: aModel	model _ aModel! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 11/25/2010 14:40'!debugIt	| provider method receiver context |	provider _ self codeProvider.	(provider respondsTo: #doItReceiver) 		ifTrue: [			FakeClassPool adopt: provider selectedClass.			receiver _ provider doItReceiver.			context _ provider doItContext]		ifFalse: [			receiver _ context _ nil].	self lineSelectAndEmptyCheck: [^self].	method _ self compileSelectionFor: receiver in: context.	method ifNotNil: [		self debug: method receiver: receiver in: context].	FakeClassPool adopt: nil! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 11/25/2010 14:37'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| provider result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	provider _ self codeProvider.	(provider respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: provider selectedClass.  "Include model pool vars if any"				rcvr _ provider doItReceiver.				ctxt _ provider doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new			sourceStreamGetter: #selectionAsStream;		"Cuis specific. Do not remove!!"			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	^ result! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/25/2010 14:38'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b provider |	provider _ self codeProvider.	(((b _ provider) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ morph flash].	provider okToChange ifFalse: [^ morph flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) ifNil: [^ morph flash].	foundClass _ (Smalltalk at: aSymbol ifAbsent: nil).		foundClass ifNil: [^ morph flash].		(foundClass isKindOf: Class)			ifTrue: [				provider systemCategoryListIndex: 					(provider systemCategoryList indexOf: foundClass category).	provider classListIndex: (provider classList indexOf: foundClass name)]! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/25/2010 14:39'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply symbol provider |Cursor execute showWhile: [			sorry _ '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry _ sorry , (morph canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: [					string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are all letters"					(string detect: [:char | char isGenerallyValidInIdentifiers not]						ifNone: nil) ifNil: [							tiVars _ (self explainTemp: string)								ifNil: [self explainInst: string]].										provider _ self codeProvider.					(tiVars == nil and: [provider respondsTo: #explainSpecial:])						ifTrue: [tiVars _ provider explainSpecial: string].					tiVars _ tiVars						ifNil: [ '']						ifNotNil: [ tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol _ s])						ifTrue: [							cgVars _ (self explainCtxt: symbol) 								ifNil: [ (self explainClass: symbol)									ifNil: [ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ (self explainMySel: symbol)								ifNil: [(self explainPartSel: string)									ifNil: [ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars _ cgVars						ifNil: [ '']						ifNotNil: [cgVars , '\' withCRs].					selectors _ selectors						ifNil: [ '']						ifNotNil: [ selectors , '\' withCRs].					delimitors _ string size = 1						ifTrue: ["single special characters"							self explainChar: string]						ifFalse: ["matched delimitors"							self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers ifNil: [numbers _ ''].					delimitors ifNil: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/25/2010 14:37'!prettyPrint	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText provider |	provider _ self codeProvider.	provider selectedMessageName ifNil: [^ morph flash].	selectedClass _ provider selectedClassOrMetaClass.	newText _ selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/25/2010 14:40'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| provider class reply classes |	provider _ self codeProvider.	(provider respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class _ provider selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class _ class soleInstance].	classes _ (Array with: class)				, class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames detect: [:name | symbol = name]					ifNone: nil)					notNil]				ifNone: nil.	reply ifNotNil: [		^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 		'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol)					and: 						[reply _ pool.						true]]			ifNone: nil)			notNil].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [					^ '"is an undeclared variable.' , '"\' withCRs , 					'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes _ WriteStream on: Array new.			Smalltalk				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: nil)						notNil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply) asString , 			', which is used by the following classes ' , classes contents printString , '"\' withCRs , 			'SystemNavigation new browseAllCallsOn: (' , (Smalltalk keyAtIdentityValue: reply) asString , 			' bindingOf: #' , symbol , ').'].	^ nil! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/25/2010 14:39'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls provider |	symbol = #nil ifTrue: [reply _ '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply _ '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply _ '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply _ '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	provider _ self codeProvider.	(provider respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ provider selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes _ cls withAllSubclasses.			classes size > 12				ifTrue: [text _ cls printString , ' or a subclass']				ifFalse: 					[classes _ classes printString.					text _ 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply _ '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply _ '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/25/2010 14:39'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls provider |	provider _ self codeProvider.	(provider respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ provider selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes _ (Array with: cls)				, cls allSuperclasses.	classes _ classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: nil)			notNil] ifNone: [^nil].	classes _ classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/25/2010 14:41'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| provider lits classes msg |	provider _ self codeProvider.	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ provider selectedMessageName) ifNil: [^nil].	"not in a message"	classes _ Smalltalk allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	msg = symbol		ifTrue: [			^ '"' , symbol , ' is the selector of this very method!!  It is defined in ', classes , 			'.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: [			lits _ (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.			(lits detect: [:each | each == symbol]				ifNone: nil)					ifNil: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , 			'.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/25/2010 14:41'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg provider |	provider _ self codeProvider.	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ provider selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits _ Array with: msg.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: nil) notNil]				ifNone: nil)		ifNotNil: [			reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifNil: [ 			"Selectors called from this method"			lits _ (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.			(whole _ lits detect: [:each | (each keywords detect: [ :frag | frag = string ]							ifNone: nil) notNil]						ifNone: nil) notNil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes _ Smalltalk allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/25/2010 14:40'!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| provider selectedClass methodNode tempNode |	provider _ self codeProvider.	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].	provider selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := provider selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: provider selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [ :n | n name = string ] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !!SmalltalkEditor methodsFor: 'private' stamp: 'jmv 11/25/2010 16:46'!codeProvider	"Para nada elegante. Arreglar despues"	self flag: #ztext.	^model class == TextModelWithProvider		ifTrue: [ model contentsProvider ]		ifFalse: [ model ]! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 14:51'!initialize	"Initialize the state of the receiver with its default contents."	actualContents _ '' asText! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 14:51'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	self openInMorphicWindowLabeled: labelString wrap: true! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 14:51'!openInMorphicWindowLabeled: labelString wrap: aBoolean	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: ((PluggableTextMorph 		model: self 		editorClass: self editorClass		textGetter: #actualContents 		textSetter: nil		selectionGetter: nil 		menuGetter: #paneMenu:shifted:editorClass:)			wrapFlag: aBoolean)				frame: (0@0 corner: 1@1).	^ window openInWorld! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 14:51'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	self openAsMorphLabel: aString! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 14:51'!openLabel: aString wrap: aBoolean	"Create a standard system view of the model, me, a StringHolder and open it."	self openInMorphicWindowLabeled: aString wrap: aBoolean! !!TextModel methodsFor: 'accessing' stamp: 'jmv 11/25/2010 14:51'!actualContents	^actualContents! !!TextModel methodsFor: 'accessing' stamp: 'jmv 11/25/2010 14:51'!actualContents: aTextOrString	actualContents _ aTextOrString ifNotNil: [ aTextOrString asText ]! !!TextModel methodsFor: 'accessing' stamp: 'jmv 11/25/2010 14:51'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!TextModel methodsFor: 'pane menu' stamp: 'jmv 11/25/2010 14:51'!editorClass	^TextEditor! !!TextModel methodsFor: 'pane menu' stamp: 'jmv 11/25/2010 14:51'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu _ shifted		ifTrue: [			anEditorClass shiftedYellowButtonMenu]		ifFalse: [			anEditorClass yellowButtonMenu].	aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections.	aMenu addTitle: 'Text Editor'; addStayUpIcons.	^aMenu! !!TextModel methodsFor: 'pane menu' stamp: 'jmv 11/25/2010 14:51'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	^(self respondsTo: selector)		ifTrue: [ self perform: selector]		ifFalse: [ otherTarget perform: selector]! !!TextModel methodsFor: 'user edits' stamp: 'jmv 11/25/2010 14:51'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!TextModel methodsFor: 'user edits' stamp: 'jmv 11/25/2010 14:51'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!TextModel methodsFor: 'services' stamp: 'jmv 11/25/2010 14:51'!offerMenuFrom: menuRetriever shifted: aBoolean 	"Pop up, in morphic or mvc as the case may be, a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.			self 				perform: menuRetriever				with: aMenu				with: aBoolean.			aMenu popUpInWorld! !!TextModel class methodsFor: 'class initialization' stamp: 'jmv 11/25/2010 14:51'!initialize	"The class variables were initialized once, and subsequently filled with	information. Re-executing this method is therefore dangerous." 	 	"workSpace _ StringHolder new"	"StringHolder initialize"! !!TextModel class methodsFor: 'instance creation' stamp: 'jmv 11/25/2010 14:51'!normal	| model |	model _ self new.	model contents: (Text initialStyle: (TextStyle named: 'Normal') string: '').	^model! !!TextModel class methodsFor: 'instance creation' stamp: 'jmv 11/25/2010 14:51'!open	self new openLabel: 'Text Editor'! !!TextModel class methodsFor: 'instance creation' stamp: 'jmv 11/25/2010 14:51'!openLabel: aString	self new openLabel: aString! !!TextModel class methodsFor: 'window color' stamp: 'jmv 11/25/2010 14:51'!windowColor	^ ColorTheme current workspace! !!TextModelWithProvider methodsFor: 'accessing' stamp: 'jmv 11/25/2010 15:10'!contentsProvider	^contentsProvider! !!TextModelWithProvider methodsFor: 'accessing' stamp: 'jmv 11/25/2010 14:55'!contentsProvider: aContentsProvider	"aContentsProvider can be a kind of CodeProvider, a kind of FileList or an Inspector"	contentsProvider _ aContentsProvider! !!TextModelWithProvider methodsFor: 'testing' stamp: 'jmv 11/25/2010 16:47'!is: aSymbol	"NO deberia hacer falta.	Esta clase es solo para todo lo nuevo..."	"Para nada elegante. Arreglar despues"	self flag: #ztext.	^ aSymbol = #CodeProvider or: [ super is: aSymbol ]! !!TextModelWithProvider class methodsFor: 'instance creation' stamp: 'jmv 11/25/2010 14:56'!on: aContentsProvider	"aContentsProvider can be a kind of CodeProvider, a kind of FileList or an Inspector"	^self basicNew contentsProvider: aContentsProvider! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 11/25/2010 14:52'!openTextEditor	TextModel new openInMorphicWindowLabeled: 'Text Editor' wrap: true! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 11/25/2010 14:52'!vmStatistics	"Open a string view on a report of vm statistics"	(TextModel new contents: Utilities vmStatisticsReportString)		openLabel: 'VM Statistics'! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 11/25/2010 14:52'!worldMenuHelp	| aList aMenu cnts explanation |	"self currentWorld primaryHand worldMenuHelp"	aList _ OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu windowsMenu appearanceMenu) 		with:	#('help' 'changes' 'open' 'debug' 'windows' 'appearance' ) do:		[:sel :title | aMenu _ self perform: sel.			aMenu items do:				[:it | (((cnts _ it contents) = 'keep this menu up') or: [cnts isEmpty])					ifFalse: [aList add: (cnts, ' - ', title translated)]]].	aList _ aList asArray sort: [:a :b | a asLowercase < b asLowercase].	explanation _ String streamContents: [:aStream | aList do:		[:anItem | aStream nextPutAll: anItem; cr]].	(TextModel new contents: explanation)		openLabel: 'Where in the world menu is...' translated! !!TranscriptStream methodsFor: 'model protocol' stamp: 'jmv 11/25/2010 14:52'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ TextModel basicNew paneMenu: aMenu shifted: shifted editorClass: anEditorClass! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 11/25/2010 14:52'!commonRequestStrings: aString	"Initialize the common request strings from aString.  "	CommonRequestStrings _ TextModel new contents: aString! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 11/25/2010 14:52'!initializeCommonRequestStrings	"Initialize the common request strings, a directly-editable list of expressions that can be evaluated from the 'do...' menu."	CommonRequestStrings _ TextModel new actualContents: 'Utilities saveScreenshot.Utilities saveDisplay.Cursor normal show.Transcript clear.-Undeclared inspect.Undeclared removeUnreferencedKeys; inspect.-ChangeSorter removeEmptyUnnamedChangeSets.ChangeSorter reorderChangeSets.'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jmv 11/25/2010 14:52'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: nil.			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(TextModel new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'support windows' stamp: 'jmv 11/25/2010 14:52'!openCommandKeyHelp	"Open a window giving command key help."	"Utilities openCommandKeyHelp"	(TextModel new contents: self commandKeyMappings)		openLabel: 'Command Key Actions'! !!Utilities class methodsFor: 'support windows' stamp: 'jmv 11/25/2010 14:52'!openStandardWorkspace 	"Open up a throwaway workspace with useful expressions in it.  1/22/96 sw"	"Utilities openStandardWorkspace"	(TextModel new contents: self standardWorkspaceContents)		openLabel: 'Useful Expressions ', Date today printString! !!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/25/2010 14:52'!compareToOtherVersion	"Prompt the user for a reference version, then spawn a window 	showing the diffs between the older and the newer of the current 	version and the reference version as text."	| change1 change2 s1 s2 differDesc diffWords |	change1 := changeList at: listIndex ifAbsent: [ ^self ].	change2 := ((SelectionMenu				labels: (list copyWithoutIndex: listIndex)				selections: (changeList copyWithoutIndex: listIndex)) startUp) ifNil: [ ^self ].		"compare earlier -> later"	"change1 timeStamp < change2 timeStamp		ifFalse: [ | temp | temp _ change1. change1 _ change2. change2 _ temp ]."	s1 := change1 string.	s2 := change2 string.	s1 = s2		ifTrue: [^ self inform: 'Exact Match' translated].	diffWords _ self shouldDiffWords.	differDesc _ diffWords		ifTrue: [ 'Words']		ifFalse: [ 'Lines'].	(TextModel new		contents: (DifferenceFinder			displayPatchFrom: s1 to: s2			tryWords: diffWords			prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [classOfMethod])))		openLabel: 			(('Comparison from {1} to {2}: ', differDesc, 				(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])) 					format: { change1 stamp. change2 stamp })! !!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/25/2010 14:52'!offerVersionsHelp	(TextModel new contents: self versionsHelpString)		openLabel: 'Versions Browsers'! !!ClassCommentVersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/25/2010 14:52'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change s1 s2 differDesc diffWords |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	s1 _ classOfMethod organization classComment.	s2 _ change string.	s1 = s2		ifTrue: [^ self inform: 'Exact Match'].	diffWords _ self shouldDiffWords.	differDesc _ diffWords		ifTrue: [ 'Words']		ifFalse: [ 'Lines'].	(TextModel new		contents: (DifferenceFinder			displayPatchFrom: s1 to: s2			tryWords: diffWords))				openLabel: 'Comparison to Current Version: ', differDesc! !!ClassCommentVersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/25/2010 14:53'!offerVersionsHelp	(TextModel new contents: self versionsHelpString)		openLabel: 'Class Comment Versions Browsers'! !!classDefinition: #Workspace category: #'System-Text'!TextModel subclass: #Workspace	instanceVariableNames: 'bindings mustDeclareVariables shouldStyle'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!TextModel initialize!!classDefinition: #SyntaxError category: #'Tools-Debugger'!TextModel subclass: #SyntaxError	instanceVariableNames: 'class selector category debugger doitFlag'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!classDefinition: #FillInTheBlank category: #'Tools-Menus'!TextModel subclass: #FillInTheBlank	instanceVariableNames: 'acceptOnCR done responseUponCancel'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!TextEditor removeSelector: #bindingOf:!BareTextMorph removeSelector: #asText!BareTextMorph removeSelector: #contents!BareTextMorph removeSelector: #setDefaultContentsIfNil!Smalltalk removeClassNamed: #TextHolder!