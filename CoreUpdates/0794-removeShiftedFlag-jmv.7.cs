'From Cuis 3.0 of 31 January 2011 [latest update: #790] on 16 February 2011 at 10:11:28 am'!!classDefinition: 'TextEditor class' category: nil!TextEditor class	instanceVariableNames: 'cmdActions yellowButtonMenu shiftedYellowButtonMenu menu '!!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 2/6/2011 15:05'!mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		editor ifNotNil: [ editor disregardNextMouseUp ].		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: event].	event hand		waitForSimulatedYellow: self 		event: event		dblClkSel: #doubleClick:! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 2/6/2011 15:14'!yellowButtonActivity	^ editView yellowButtonActivity! !!Compiler methodsFor: 'public access' stamp: 'jmv 2/6/2011 14:49'!format: textOrStream in: aClass notifying: aRequestor	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode := self format: sourceStream noPattern: false ifFail: [^ nil].	^aNode decompileString! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 2/6/2011 15:05'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag distance |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt internalizedToOwnerOf: clickClient from: aHand owner.	distance _ (localEvt position - firstClickDown position) r.	isDrag _ distance > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag or sendYellowButtonActivity if requested"			clickState _ #firstClickTimedOut.			(sendYellowButtonActivity not and: [ dragSelector isNil ]) ifTrue: [				aHand resetClickState.				self doubleClickTimeout; click "***"].			^true].		localEvt isMouseUp ifTrue:[			(timedOut or: [ dblClickSelector isNil ]) ifTrue:[				self click.				aHand resetClickState.				^true ].			"Otherwise transfer to #firstClickUp"			firstClickUp _ evt copy.			clickState _ #firstClickUp.			"If timedOut or the client's not interested in dbl clicks get outta here"			self click.			aHand handleEvent: firstClickUp.			^false ].		isDrag ifTrue: [ "drag start"			self doubleClickTimeout. "***"			aHand resetClickState.			dragSelector "If no drag selector send #click instead"				ifNil: [ self click ]				ifNotNil: [ self drag: firstClickDown ].			^true ].		^false ].	clickState == #firstClickTimedOut ifTrue: [		localEvt isMouseUp ifTrue:[ "neither drag nor double click"			aHand resetClickState.			self doubleClickTimeout; click. "***"			^true ].		isDrag ifTrue: [ "drag start"			aHand resetClickState.			self doubleClickTimeout; drag: firstClickDown. "***"			^true ].		"Neither drag nor double click. Simulate yellow button click. This is useful, for example, for pen computers"		(sendYellowButtonActivity and: [ distance = 0 ]) ifTrue: [			aHand resetClickState.			clickClient yellowButtonActivity.			^true ].		^false ].	clickState = #firstClickUp ifTrue:[		timedOut ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			aHand resetClickState.			self doubleClickTimeout. "***"			^true ].		localEvt isMouseDown ifTrue:[ "double click"			clickState _ #secondClickDown.			^false ]].	clickState == #secondClickDown ifTrue: [		localEvt isMouseUp ifTrue: ["double click"			aHand resetClickState.			self doubleClick.			^false ]	].	^true! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 2/6/2011 15:05'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	evt yellowButtonPressed ifTrue: [^ self yellowButtonActivity].	(self containsPoint: evt cursorPoint) ifTrue: [		isPressed _ true.		self changed].	evt hand		waitForSimulatedYellow: self		event: evt		dblClkSel: #doubleClick:! !!PointerFinder methodsFor: 'morphic ui' stamp: 'jmv 2/6/2011 16:02'!getMenu: aMenu	^ MenuMorph new		defaultTarget: self;		add: 'Inspect (i)' action: #inspectObject;		balloonTextForLastItem: 'Live long and prosper!!';		addLine;		add: 'Search again' action: #searchAgain;		balloonTextForLastItem: 'Search again\for the same object' withCRs;		yourself! !!PointerFinder methodsFor: 'morphic ui' stamp: 'jmv 2/6/2011 16:02'!open	| window list |	window _ (SystemWindow labelled: 'Pointer Finder')		model: self.	list _ PluggableListMorph new		doubleClickSelector: #inspectObject;		model: self		listGetter: #pointerList		indexGetter: #pointerListIndex		indexSetter: #pointerListIndex:		menuGetter: #getMenu:		keystrokeAction: #arrowKey:from:.	"For doubleClick to work best disable autoDeselect"	list autoDeselect: false.	window addMorph: list frame: (0@0 extent: 1@1).	list color: Color lightMagenta.	window openInWorld! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 2/6/2011 15:06'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue: [		scroller submorphs last mouseDown:			(evt internalizedTo: scroller from: self)].	evt hand 		waitForSimulatedYellow: self 		event: evt		dblClkSel: #doubleClick:! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'jmv 2/6/2011 15:04'!yellowButtonActivity	"Invoke the text-editing menu"	self getMenu ifNotNil: [ :menu |		menu setInvokingView: self.		menu invokeModal]! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 2/6/2011 15:05'!mouseDown: evt	| row |	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedYellow: self		event: evt		clkSel: #click:		dblClkSel: (doubleClickSelector ifNotNil:[#doubleClick:])		dblClkTimeoutSel: nil		dragSel: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil])! !!PluggableListMorph methodsFor: 'menu' stamp: 'jmv 2/6/2011 16:09'!getMenu	"Answer the menu for this view, supplying an empty menu to be filled in"	| menu aMenu |	menuGetter ifNil: [^ nil].	menu _ MenuMorph new defaultTarget: model.	menuGetter numArgs = 1 ifTrue: [		aMenu _ model perform: menuGetter with: menu.		aMenu ifNotNil: [aMenu commandKeyHandler: self ].		^ aMenu ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 2/6/2011 15:06'!specialKeyPressed: asciiValue	"A special key with the given ascii-value was pressed; dispatch it"	| oldSelection nextSelection max howManyItemsShowing |	asciiValue = 27 ifTrue: 		[" escape key"		^ ActiveEvent shiftPressed			ifFalse:				[self yellowButtonActivity]].	max _ self maximumSelection.	max > 0 ifFalse: [^ self].	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	asciiValue = 31 ifTrue: 		[" down arrow"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].	asciiValue = 30 ifTrue: 		[" up arrow"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].	asciiValue = 1 ifTrue:		[" home"		nextSelection _ 1].	asciiValue = 4 ifTrue:		[" end"		nextSelection _ max].	howManyItemsShowing _ self numSelectionsInView.	asciiValue = 11 ifTrue:		[" page up"		nextSelection _ 1 max: oldSelection - howManyItemsShowing].	asciiValue = 12 ifTrue:		[" page down"		nextSelection _ oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection = nextSelection ifTrue: [^ self "flash"	"ugly"].	^ self changeModelSelection: nextSelection! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 2/6/2011 15:06'!mouseDown: event	| oldIndex oldVal row |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row := self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifTrue: ["No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForSimulatedYellow: self		event: event		dblClkSel: #doubleClick:! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 2/6/2011 15:07'!mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph internalizePositionToOwner: evt position from: self)])		ifTrue:[^self toggleExpandedState: aMorph event: evt]. 	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedYellow: self 		event: evt 		clkSel: #click:		dblClkSel: nil		dblClkTimeoutSel: nil		dragSel:  (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil])! !!SimpleHierarchicalListMorph methodsFor: 'menu' stamp: 'jmv 2/6/2011 16:09'!getMenu	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key.NOOOOO"	| menu |	menuGetter ifNil: [^ nil].	menu _ MenuMorph new defaultTarget: model.	menuGetter numArgs = 1 ifTrue: [		^ model perform: menuGetter with: menu ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 2/6/2011 16:06'!buildTestsList	| column buttonRow bh |	column _ AlignmentMorph proportional.	testsList _ PluggableListMorphOfMany				model: self				listGetter: #tests				primarySelectionGetter: #selectedSuite				primarySelectionSetter: #selectedSuite:				listSelectionGetter: #listSelectionAt:				listSelectionSetter: #listSelectionAt:put:				menuGetter: #listMenu:.	testsList autoDeselect: false.	testsList color: Color veryVeryLightGray.	bh _ self defaultButtonPaneHeight.	column		addMorph: testsList		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0@0 corner: 1 @ bh negated)).	buttonRow _ self optionalButtonRow.	column		addMorph: buttonRow		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0@bh negated corner: 0@0)).	^ column! !!TestRunner methodsFor: 'menus' stamp: 'jmv 2/6/2011 16:05'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	self listMenu: aMenu.	aMenu addLine.	aMenu add: 'log to Transcript' target: self selector: #showResult.	^aMenu.! !!TestRunner methodsFor: 'menus' stamp: 'jmv 2/6/2011 16:05'!listMenu: aMenu	aMenu title: 'Test Cases'.	aMenu add: 'select all' target: self selector: #selectAll.	aMenu add: 'deselect all' target: self selector: #deselectAll.	aMenu add: 'toggle selections' target: self selector: #toggleSelections.	aMenu add: 'filter' target: self selector: #setFilter.	running ifNotNil: [		aMenu add: 'stop' target: self selector: #terminateRun		].	selectedSuite > 0 ifTrue: [ | cls |		cls _ (tests at: selectedSuite ifAbsent: ['']) copyUpTo: Character space.		cls _ cls asSymbol.		cls _ (Smalltalk at: cls ifAbsent: nil).		cls ifNotNil: [ | mtc |			aMenu addLine.			aMenu add: 'browse' target: self selector: #browse: argument: cls.		].	].	^aMenu! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 2/6/2011 15:07'!raiseContextMenu: aKeyboardEvent	(morph respondsTo: #editView)		ifTrue: [morph editView yellowButtonActivity].	^ true! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 2/6/2011 16:11'!initializeMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"TextEditor initialize"	menu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.		#setSearchString}.		#-.		{'do again (j)' translated.				#again}.		{'undo (z)' translated.				#undo}.		#-.		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.				#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.				#pasteRecent}.		#-.		{'set font... (k)' translated.			#offerFontMenu}.		{'set alignment...' translated.			#chooseAlignment}.	}! !!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 2/6/2011 16:12'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo."  	"TextEditor initialize"	UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeMenu! !!TextEditor class methodsFor: 'menu' stamp: 'jmv 2/6/2011 16:14'!paneMenu:  aMenu	aMenu labels: menu labelString lines: menu lineArray selections: menu selections.	aMenu addTitle: 'Text Editor'; addStayUpIcons.	^ aMenu! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 2/6/2011 16:12'!initializeMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	menu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.	#setSearchString}.		#-.		{'do again (j)' translated.			#again}.		{'undo (z)' translated.				#undo}.		#-.		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.				#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.				#pasteRecent}.		#-.		{'do it (d)' translated.				#doIt}.		{'print it (p)' translated.				#printIt}.		{'inspect it (i)' translated.			#inspectIt}.		{'explore it (I)' translated.			#exploreIt}.		{'debug it' translated.				#debugIt}.		#-.		{'explain' translated.					#explain}.		{'browse it (b)' translated.				#browseIt}.		{'senders of it (n)' translated.				#sendersOfIt}.		{'implementors of it (m)' translated.		#implementorsOfIt}.		{'references to it (N)' translated.			#referencesToIt}.		#-.		{'accept (s)' translated.				#accept}.		{'cancel (l)' translated.				#cancel}.		#-.		{'method strings with it (E)' translated.		#methodStringsContainingit}.		{'method source with it' translated.		#methodSourceContainingIt}.		{'class comments with it' translated.		#classCommentsContainingIt}.		{'change sets with it' translated.			#browseChangeSetsWithSelector}.	}! !!FileContentsEditor class methodsFor: 'menu' stamp: 'jmv 2/6/2011 14:58'!paneMenu:  aMenu	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| services maybeLine extraLines brevityState fileName theModel |	theModel _ aMenu defaultTarget textProvider.	fileName _ theModel fileName.	fileName ifNotNil: [		brevityState _ theModel brevityState.		services _ OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue: [			services add: theModel serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse: [			services add: theModel serviceGetHex].		maybeLine _ services size.		(#('st' 'cs') includes: theModel suffixOfSelectedFile) ifTrue: [			services addAll:				(theModel servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines _ OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: theModel fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.				#find}.			{'find again (g)' translated.			#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.			#again}.			{'undo (z)' translated.				#undo}.			#-.			{'copy (c)' translated.				#copySelection}.			{'cut (x)' translated.				#cut}.			{'paste (v)' translated.				#paste}.			{'paste...' translated.				#pasteRecent}.			#-.			{'do it (d)' translated.				#doIt}.			{'print it (p)' translated.				#printIt}.			{'inspect it (i)' translated.			#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.				#accept}.			{'cancel (l)' translated.				#cancel}}.	^ aMenu! !!TextModelMorph methodsFor: 'menu' stamp: 'jmv 2/6/2011 15:01'!getMenu	| menu |	menu _ MenuMorph new defaultTarget: model.	^editorClass paneMenu: menu! !!TextProvider methodsFor: 'services' stamp: 'jmv 2/6/2011 15:22'!offerMenuFrom:  menuRetriever	"Pop upa menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	self 		perform: menuRetriever		with: aMenu.	aMenu popUpInWorld! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 2/6/2011 15:31'!offerShiftedClassListMenu	"Offer the shifted class-list menu."	^ self offerMenuFrom: #shiftedClassListMenu:! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 2/6/2011 15:31'!offerUnshiftedClassListMenu	"Offer the shifted class-list menu."	^ self offerMenuFrom: #classListMenu:! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 2/6/2011 15:57'!shiftedYellowButtonActivity	"Offer the shifted selector-list menu"	^ self offerMenuFrom: #shiftedMessageListMenu:! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 2/6/2011 15:57'!unshiftedYellowButtonActivity	"Offer the unshifted shifted selector-list menu"	^ self offerMenuFrom: #messageListMenu:! !!Browser methodsFor: 'class functions' stamp: 'jmv 2/6/2011 15:27'!classListMenu: aMenu	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class...'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 2/6/2011 15:30'!buildMorphicClassList	| myClassList |	(myClassList := PluggableListMorph new)		model: self		listGetter: #classList		indexGetter: #classListIndex		indexSetter: #classListIndex:		menuGetter: #classListMenu:		keystrokeAction: #classListKey:from:.	myClassList borderWidth: 0.	myClassList enableDragNDrop: false.	myClassList doubleClickSelector: #browseSelectionInPlace.	^myClassList! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 2/6/2011 15:56'!buildMorphicMessageList	"Build a morphic message list, with #messageList as its list-getter"	| aListMorph |	(aListMorph := PluggableListMorph new)		model: self		listGetter: #messageList		indexGetter: #messageListIndex		indexSetter: #messageListIndex:		menuGetter: #messageListMenu:		keystrokeAction: #messageListKey:from:.	aListMorph enableDragNDrop: false.	^aListMorph! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 2/6/2011 15:30'!openAsMorphClassEditing: editString 	"Create a pluggable version a Browser on just a single class."	| window dragNDropFlag hSepFrac switchHeight mySingletonClassList switches c |	window := SystemWindow new model: self.	dragNDropFlag := false.	hSepFrac := 0.3.	switchHeight _ StrikeFont default height + 10.	mySingletonClassList := PluggableListMorph 				model: self				listGetter: #classListSingleton				indexGetter: #indexIsOne				indexSetter: #indexIsOne:				menuGetter: #classListMenu:				keystrokeAction: #classListKey:from:.	mySingletonClassList enableDragNDrop: dragNDropFlag.	self 		addLowerPanesTo: window		at: (0 @ hSepFrac corner: 1 @ 1)		with: editString.	window addMorph: mySingletonClassList		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 0.5 @ 0)				offsets: (0 @ 0 corner: 0 @ switchHeight)).	switches _ self buildMorphicSwitches.	c _ switches color.	window addMorph: switches		fullFrame: (LayoutFrame fractions: (0.5 @ 0 corner: 1.0 @ 0)				offsets: (0 @ 0 corner: 0 @ switchHeight)).	switches color: c.	window addMorph: self buildMorphicMessageCatList		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 0.5 @ hSepFrac)				offsets: (0 @ switchHeight corner: 0 @ 0)).	window addMorph: self buildMorphicMessageList		fullFrame: (LayoutFrame fractions: (0.5 @ 0 corner: 1.0 @ hSepFrac)				offsets: (0 @ switchHeight corner: 0 @ 0)).	window setUpdatablePanesFrom: #(#messageCategoryList #messageList).	^window! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 2/6/2011 15:57'!openAsMorphMessageEditing: editString	"Create a pluggable version a Browser that shows just one message"	| window mySingletonMessageList verticalOffset nominalFractions |	window := SystemWindow new model: self.	mySingletonMessageList := PluggableListMorph 				model: self				listGetter: #messageListSingleton				indexGetter: #indexIsOne				indexSetter: #indexIsOne:				menuGetter: #messageListMenu:				keystrokeAction: #messageListKey:from:.	mySingletonMessageList enableDragNDrop: false.	verticalOffset := 25.	nominalFractions := 0 @ 0 corner: 1 @ 0.	window addMorph: mySingletonMessageList		fullFrame: (LayoutFrame fractions: nominalFractions				offsets: (0 @ 0 corner: 0 @ verticalOffset)).	verticalOffset := self 				addOptionalAnnotationsTo: window				at: nominalFractions				plus: verticalOffset.	verticalOffset := self 				addOptionalButtonsTo: window				at: nominalFractions				plus: verticalOffset.	window addMorph: (self buildMorphicCodePaneWith: editString)		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ verticalOffset corner: 0 @ 0)).	^window! !!Browser methodsFor: 'message functions' stamp: 'jmv 2/6/2011 15:52'!messageListMenu: aMenu	"Answer the message-list menu"	"Changed by emm to include menu-item for breakpoints"	aMenu addList:#(			('what to show...'				offerWhatToShowMenu)                	('toggle break on entry'		toggleBreakOnEntry)            		-			('browse full (b)' 				browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'						fileOutMessage)			-			('senders of... (n)'				browseSendersOfMessages)			('implementors of... (m)'			browseMessages)			('inheritance (i)'					methodHierarchy)			('versions (v)'					browseVersions)			-			('inst var refs...'					browseInstVarRefs)			('inst var defs...'				browseInstVarDefs)			('class var refs...'				browseClassVarRefs)			('class variables'				browseClassVariables)			('class refs (N)'					browseClassRefs)			-			('remove method (x)'			removeMessage)			-			('more...'						shiftedYellowButtonActivity)).	^ aMenu! !!ChangeSorter methodsFor: 'creation' stamp: 'jmv 2/6/2011 15:55'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| csListHeight msgListHeight csMsgListHeight |	csListHeight _ 0.25.	msgListHeight _ 0.25.	csMsgListHeight _ csListHeight + msgListHeight.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: ((PluggableListMorphByItem 				model: self				listGetter: #changeSetList				indexGetter: #currentCngSet				indexSetter: #showChangeSetNamed:				menuGetter: #changeSetMenu:				keystrokeAction: #changeSetListKey:from:)			autoDeselect: false)		frame: (((0@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:				keystrokeAction: #classListKey:from:)		frame: (((0.5@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:				keystrokeAction: #messageListKey:from:)		frame: (((0@csListHeight extent: 1@msgListHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@csMsgListHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 2/6/2011 15:23'!changeSetMenu: aMenu	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"	aMenu title: 'Change Set'.	aMenu addStayUpIcons.	aMenu add: 'make changes go to me (m)' action: #newCurrent.	aMenu addLine.	aMenu add: 'new change set... (n)' action: #newSet.	aMenu add: 'find...(f)' action: #findCngSet.	aMenu add: 'select change set...' action: #chooseCngSet.	aMenu addLine.	aMenu add: 'rename change set (r)' action: #rename.	aMenu add: 'file out (o)' action: #fileOut.	aMenu add: 'browse methods (b)' action: #browseChangeSet.	aMenu add: 'browse change set (B)' action: #openChangeSetBrowser.	aMenu addLine.	parent		ifNotNil: 			[aMenu add: 'copy all to other side (c)' action: #copyAllToOther.			aMenu add: 'submerge into other side' action: #submergeIntoOtherSide.			aMenu add: 'subtract other side (-)' action: #subtractOtherSide.			aMenu addLine].	myChangeSet hasPreamble		ifTrue: 			[aMenu add: 'edit preamble (p)' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse: [aMenu add: 'add preamble (p)' action: #addPreamble].	myChangeSet hasPostscript		ifTrue: 			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse: [aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.	aMenu add: 'destroy change set (x)' action: #remove.	aMenu addLine.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 2/6/2011 15:22'!offerShiftedChangeSetMenu	"Offer the shifted version of the change set menu"	self offerMenuFrom: #shiftedChangeSetMenu:! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 2/6/2011 15:23'!offerUnshiftedChangeSetMenu	"Offer the unshifted version of the change set menu"	self offerMenuFrom: #changeSetMenu:! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 2/6/2011 15:29'!classListMenu: aMenu	"Fill aMenu with items appropriate for the class list"	aMenu title: 'class list'.	aMenu addStayUpIcons.	parent notNil		ifTrue: [aMenu addList: #( "These two only apply to dual change sorters"			('copy class chgs to other side'			copyClassToOther)				('move class chgs to other side'			moveClassToOther))].	aMenu addList: #(			-			('delete class from change set (d)'		forgetClass)			('remove class from system (x)'			removeClass)			-			('browse full (b)'						browseMethodFull)			('browse hierarchy (h)'					spawnHierarchy)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut'								fileOutClass)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class vars'								browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('more...'								offerShiftedClassListMenu)).	^ aMenu! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 2/6/2011 15:26'!shiftedClassListMenu: aMenu	"Fill aMenu with items appropriate for the class list"	aMenu title: 'class list'.	aMenu addStayUpIcons.	aMenu addList: #(			-			('unsent methods'						browseUnusedMethods)			('unreferenced inst vars'				showUnreferencedInstVars)			('unreferenced class vars'				showUnreferencedClassVars)			-			('sample instance'						makeSampleInstance)			('inspect instances'						inspectInstances)			('inspect subinstances'					inspectSubInstances)			-			('more...'								offerUnshiftedClassListMenu )).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 2/6/2011 15:53'!messageListMenu: aMenu	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	^ self messageMenu: aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 2/6/2011 15:53'!messageMenu: aMenu	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	aMenu title: 'message list'.	aMenu addStayUpIcons.	parent ifNotNil:		[aMenu addList: #(			('copy method to other side'			copyMethodToOther)			('move method to other side'			moveMethodToOther))].	aMenu addList: #(			('delete method from changeSet (d)'	forget)			-			('remove method from system (x)'	removeMessage)				-			('browse full (b)'					browseMethodFull)			('browse hierarchy (h)'				spawnHierarchy)			('browse method (O)'				openSingleMessageBrowser)			('browse protocol (p)'				browseFullProtocol)			-			('fileOut'							fileOutMessage)			-			('senders of... (n)'					browseSendersOfMessages)			('implementors of... (m)'				browseMessages)			('inheritance (i)'					methodHierarchy)			('versions (v)'						browseVersions)			-			('more...'							shiftedYellowButtonActivity)).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 2/7/2011 14:58'!shiftedMessageListMenu: aMenu	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	^ self shiftedMessageMenu: aMenu! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'jmv 2/6/2011 15:54'!openAsMorphIn: window rect: rect	"Add a set of changeSetBrowser views to the given top view offset by the given amount"	| aHeight |	aHeight _ 0.25.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:				keystrokeAction: #classListKey:from:)		frame: (((0.0@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:				keystrokeAction: #messageListKey:from:)		frame: (((0.5@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@aHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil! !!Debugger methodsFor: 'initialize' stamp: 'jmv 2/6/2011 15:50'!openFullMorphicLabel: aLabelString	"Open a full morphic debugger with the given label"	| window aListMorph oldContextStackIndex |	oldContextStackIndex _ contextStackIndex.	self expandStack. "Sets contextStackIndex to zero."	window _ (SystemWindow labelled: aLabelString) model: self.	aListMorph _ PluggableListMorph		model: self 		listGetter: #contextStackList		indexGetter: #contextStackIndex		indexSetter: #toggleContextStackIndex:		menuGetter: #contextStackMenu:		keystrokeAction: #contextStackKey:from:.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.25).	self addLowerPanesTo: window at: (0@0.25 corner: 1@0.8) with: nil.	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: self receiverInspector			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu: 			keystrokeAction: #inspectorKey:from:)		frame: (0@0.8 corner: 0.2@1).	window addMorph: (TextModelMorph 			textProvider: self receiverInspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection)		frame: (0.2@0.8 corner: 0.5@1).	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: self contextVariablesInspector 			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu: 			keystrokeAction: #inspectorKey:from:)		frame: (0.5@0.8 corner: 0.7@1).	window addMorph: (TextModelMorph 			textProvider: self contextVariablesInspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection)		frame: (0.7@0.8 corner: 1@1).	window openInWorld.	self toggleContextStackIndex: oldContextStackIndex.	^ window ! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 2/6/2011 15:49'!contextStackMenu: aMenu	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"	^		aMenu addList: {			{'fullStack (f)'.		#fullStack}.			{'restart (r)'.		#restart}.			{'proceed (p)'.		#proceed}.			{'step (t)'.			#doStep}.			{'step through (T)'.	#stepIntoBlock}.			{'send (e)'.			#send}.			{'where (w)'.		#where}.			{'peel to first like this'.		#peelToFirst}.			#-.			{'return entered value'.		#returnValue}.			#-.			{'toggle break on entry'.	#toggleBreakOnEntry}.			{'senders of... (n)'.			#browseSendersOfMessages}.			{'implementors of... (m)'.	#browseMessages}.			{'inheritance (i)'.	#methodHierarchy}.			#-.			{'versions (v)'.		#browseVersions}.			{'inst var refs...'.		#browseInstVarRefs}.			#-.			{'inst var defs...'.	#browseInstVarDefs}.			{'class var refs...'.	#browseClassVarRefs}.			{'class variables'.	#browseClassVariables}.			#-.			{'class refs (N)'.		#browseClassRefs}.			{'browse full (b)'.	#browseMethodFull}.			{'file out '.			#fileOutMessage}.			#-.			{'more...'.		#shiftedYellowButtonActivity}.		}! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 2/6/2011 15:50'!messageListMenu: aMenu	"The context-stack menu takes the place of the message-list menu in the debugger, so pass it on"	^ self contextStackMenu: aMenu! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 2/6/2011 15:49'!shiftedContextStackMenu: aMenu	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"	^		aMenu addList: {			{'browse class hierarchy'.	#classHierarchy}.			{'browse class'.				#browseClass}.			{'browse method (O)'.		#openSingleMessageBrowser}.			{'implementors of sent messages'.		#browseAllMessages}.			{'change sets with this method'.		#findMethodInChangeSets}.			#-.			{'inspect instances'.		#inspectInstances}.			{'inspect subinstances'.		#inspectSubInstances}.			#-.			{'revert to previous version'.			#revertToPreviousVersion}.			{'remove from current change set'.		#removeFromCurrentChanges}.			{'revert & remove from changes'.		#revertAndForget}.			#-.			{'more...'.					#unshiftedYellowButtonActivity}. 		}! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 2/6/2011 15:51'!shiftedMessageListMenu: aMenu	"The context-stack menu takes the place of the message-list menu in the debugger, so pass it on"	^ self shiftedContextStackMenu: aMenu! !!FileContentsBrowser methodsFor: 'menus' stamp: 'jmv 2/6/2011 15:26'!shiftedClassListMenu: aMenu	"Answer the class list menu, ignoring the state of the shift key in this case"	^ self classListMenu: aMenu! !!FileList methodsFor: 'file list menu' stamp: 'jmv 2/6/2011 15:44'!fullFileListMenu: aMenu	"Fill the menu with all possible items for the file list pane, regardless of selection."	| lastProvider |	aMenu title: 'all possible file operations'.	aMenu addStayUpIcons.	lastProvider _ nil.	(self itemsForFile: 'a.*') do: [ :svc |		(lastProvider notNil and: [svc provider ~~ lastProvider])			ifTrue: [ aMenu addLine ].		svc addServiceFor: self toMenu: aMenu.		aMenu submorphs last setBalloonText: svc description.		lastProvider _ svc provider.		svc addDependent: self.	].	^aMenu! !!FileList methodsFor: 'file list menu' stamp: 'jmv 2/6/2011 15:44'!offerAllFileOptions	"Put up a menu offering all possible file options, whatever the suffix of the current selection may be.  Specially useful if you're wanting to keep the menu up"	self offerMenuFrom: #fullFileListMenu:! !!MessageSet methodsFor: 'private' stamp: 'jmv 2/6/2011 15:57'!buildMorphicMessageList	"Build my message-list object in morphic"	| aListMorph |	aListMorph := PluggableListMorph new.	aListMorph 		model: self		listGetter: #messageList		indexGetter: #messageListIndex		indexSetter: #messageListIndex:		menuGetter: #messageListMenu:		keystrokeAction: #messageListKey:from:.	aListMorph enableDragNDrop: false.	^aListMorph! !!RecentMessageSet methodsFor: 'message functions' stamp: 'jmv 2/6/2011 15:56'!messageListMenu: aMenu	"Answer the message-list menu"	aMenu addList:#(			('what to show...'						offerWhatToShowMenu)			-			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('copy selector (c)'						copySelector)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			('remove from RecentSubmissions'		removeFromRecentSubmissions)			-			('more...'								shiftedYellowButtonActivity)).	^ aMenu! !TimeProfileBrowser removeSelector: #messageListMenu:shifted:!RecentMessageSet removeSelector: #messageListMenu:shifted:!FileList removeSelector: #fullFileListMenu:shifted:!FileContentsBrowser removeSelector: #classListMenu:shifted:!Debugger removeSelector: #contextStackMenu:shifted:!Debugger removeSelector: #messageListMenu:shifted:!ChangeSorter removeSelector: #changeSetMenu:shifted:!ChangeSorter removeSelector: #classListMenu:shifted:!ChangeSorter removeSelector: #messageListMenu:shifted:!ChangeSorter removeSelector: #messageMenu:shifted:!Browser removeSelector: #classListMenu:shifted:!Browser removeSelector: #messageListMenu:shifted:!Browser removeSelector: #showBytecodes!TextProvider removeSelector: #offerMenuFrom:shifted:!TextModelMorph removeSelector: #getMenu:!TextModelMorph removeSelector: #prettyPrint!TextModelMorph removeSelector: #yellowButtonActivity!TextModelMorph removeSelector: #yellowButtonActivity:!FileContentsEditor class removeSelector: #paneMenu:shifted:!SmalltalkEditor class removeSelector: #initializeShiftedYellowButtonMenu!SmalltalkEditor class removeSelector: #initializeYellowButtonMenu!TextEditor initialize!TextEditor class removeSelector: #initializeShiftedYellowButtonMenu!TextEditor class removeSelector: #initializeYellowButtonMenu!TextEditor class removeSelector: #paneMenu:shifted:!TextEditor class removeSelector: #shiftedYellowButtonMenu!TextEditor class removeSelector: #yellowButtonMenu!!classDefinition: 'TextEditor class' category: nil!TextEditor class	instanceVariableNames: 'cmdActions menu'!SmalltalkEditor removeSelector: #prettyPrint!TestRunner removeSelector: #listMenu:shifted:!SimpleHierarchicalListMorph removeSelector: #getMenu:!PluggableListMorph removeSelector: #getMenu:!ScrollPane removeSelector: #shiftedTextPaneMenuRequest!ScrollPane removeSelector: #unshiftedYellowButtonActivity!ScrollPane removeSelector: #yellowButtonActivity:!PointerFinder removeSelector: #menu:shifted:!PluggableButtonMorph removeSelector: #yellowButtonActivity:!BareTextMorph removeSelector: #yellowButtonActivity:!