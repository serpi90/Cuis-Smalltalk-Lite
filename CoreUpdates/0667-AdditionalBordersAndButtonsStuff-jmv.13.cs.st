'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 30 November 2010 at 8:42:58 am'!!BorderedMorph commentStamp: 'jmv 11/29/2010 18:25' prior: 0!BorderedMorph introduce borders to morph. Borders have the instanceVariables borderWidth and borderColor. BorderedMorph new borderColor: Color red; borderWidth: 10; openInWorld.BorderedMorph also have a varaity of border styles: simple, inset, raised, complexAltFramed, complexAltInset, complexAltRaised, complexFramed, complexInset, complexRaised.These styles are set using the classes BorderStyle, SimpleBorder, RaisedBorder, InsetBorder and ComplexBorder.BorderedMorph new borderColor: Color white; openInWorld.BorderedMorph new borderColor: #inset; borderWidth: 2; openInWorld!!classDefinition: #BorderedSubpaneDividerMorph category: #'Morphic-Windows'!Morph subclass: #BorderedSubpaneDividerMorph	instanceVariableNames: 'resizingEdge '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!EllipseMorph commentStamp: '<historical>' prior: 0!A round BorderedMorph. Supports borderWidth and borderColor. Only simple borderStyle is implemented.EllipseMorph new borderWidth:10; borderColor: Color green; openInWorld.!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector getLabelSelector getMenuSelector offColor onColor arguments argumentsProvider argumentsSelector isPressed mouseIsOver '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableButtonMorph commentStamp: 'jmv 11/30/2010 07:59' prior: 0!A PluggableButtonMorph is a combination of an indicator for a boolean value stored in its model and an action button. The action of a button is often, but not always, to toggle the boolean value that it shows. Its pluggable selectors are:		getStateSelector		fetch a boolean value from the model		actionSelector		invoke this button's action on the model		getLabelSelector		fetch this button's lable from the model		getMenuSelector		fetch a pop-up menu for this button from the modelAny of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if getStateSelector is nil, then this button shows the state of a read-only boolean that is always false.The model informs its view(s) of changes by sending #changed: to itself with getStateSelector as a parameter. The view tells the model when the button is pressed by sending actionSelector.If the actionSelector takes one or more arguments, then the following are relevant:		arguments			A list of arguments to provide when the actionSelector is called.		argumentsProvider	The object that is sent the argumentSelector to obtain arguments, if dynamic		argumentsSelector	The message sent to the argumentProvider to obtain the arguments.!!CodeHolder methodsFor: 'annotation' stamp: 'jmv 11/29/2010 18:10'!addOptionalAnnotationsTo: window at: fractions plus: verticalOffset	"Add an annotation pane to the window if preferences indicate a desire for it, and return the incoming verticalOffset plus the height of the added pane, if any"	| aTextMorph divider delta |	self wantsAnnotationPane ifFalse: [^ verticalOffset].	aTextMorph _ PluggableTextMorph 		model: self		editorClass: self editorClass		textGetter: #annotation 		textSetter: nil.	aTextMorph		askBeforeDiscardingEdits: false;		borderWidth: 0;		hideScrollBarsIndefinitely.	divider _ BorderedSubpaneDividerMorph forBottomEdge.	delta _ self defaultAnnotationPaneHeight.	window 		addMorph: aTextMorph 		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!CodeHolder methodsFor: 'controls' stamp: 'jmv 11/30/2010 08:31'!addOptionalButtonsTo: window at: fractions plus: verticalOffset	"If the receiver wishes it, add a button pane to the window, and answer the verticalOffset plus the height added"	| delta buttons divider |	self wantsOptionalButtons ifFalse: [^verticalOffset].	delta _ self defaultButtonPaneHeight.	buttons _ self optionalButtonRow.	divider _ BorderedSubpaneDividerMorph forBottomEdge.	window 		addMorph: buttons		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!CodeHolder methodsFor: 'controls' stamp: 'jmv 11/30/2010 08:38'!decorateForInheritance	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."	| aColor aButton flags buttonColor |	(aButton _ self inheritanceButton) ifNil: [^ self].	((currentCompiledMethod isKindOf: CompiledMethod) and: [Preferences decorateBrowserButtons])		ifFalse: [ ^aButton color: self class windowColor ].	"This table duplicates the old logic, but adds two new colors for the cases where there is a superclass definition, but this method doesn't call it."	flags _ 0.	self isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].	currentCompiledMethod sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].	self isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	aColor _ {		"This is NOTan override. There is no super implementation."		buttonColor.							"no sends to super. there is not an override"		Color tan.							"no sends to super. there is an override"		Color red.							"sends to super. there is not an override. Error: no super to call"		Color red.							"sends to super. there is  an override. Error: no super to call"		"This is an override. There is some super implementation"		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"		Color green muchLighter.			"doesn't have sub; has super and callsl it"		Color blue muchLighter.			"has sub; has super and callsl it"	} at: flags + 1.	aButton color: aColor! !!CodeHolder methodsFor: 'controls' stamp: 'jmv 11/30/2010 08:28'!optionalButtonRow	"Answer a row of control buttons"	| row buttons widths buttonColor |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	self optionalButtonTuples do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button color: buttonColor.		button label: tuple second asString.		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].		buttons add: button ].	row _ AlignmentMorph proportional.	row color: buttonColor.	row addInRow: buttons widthProportionalTo: widths.	^row! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/30/2010 08:38'!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row buttonColor |	instanceSwitch := PluggableButtonMorph 				model: self				stateGetter: #instanceMessagesIndicated				action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		borderWidth: 0.	commentSwitch := PluggableButtonMorph 				model: self				stateGetter: #classCommentIndicated				action: #plusButtonHit.	commentSwitch		label: '?' asText allBold;		setBalloonText: 'class comment';		borderWidth: 0.	classSwitch := PluggableButtonMorph 				model: self				stateGetter: #classMessagesIndicated				action: #indicateClassMessages.	classSwitch		label: 'class';		borderWidth: 0.	row _ AlignmentMorph proportional.	row		addMorph: instanceSwitch fullFrame: (LayoutFrame fractions: (0@0 corner: 0.5@1));		addMorph: commentSwitch fullFrame: (LayoutFrame fractions: (0.51@0 corner: 0.65@1));		addMorph: classSwitch fullFrame: (LayoutFrame fractions: (0.66@0 corner: 1@1)).	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	row color: buttonColor.	{ 		instanceSwitch.		commentSwitch.		classSwitch} do: [:m | 				m color: buttonColor ].	^row! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 11/29/2010 18:10'!morphicClassColumn	| column switchHeight divider |	column _ AlignmentMorph proportional.	switchHeight _ StrikeFont default height + 4.	column 		addMorph: self buildMorphicSwitches		fullFrame: (LayoutFrame fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ (1 - switchHeight) corner: 0 @ 0)).	divider _ BorderedSubpaneDividerMorph forTopEdge.	column addMorph: divider		fullFrame: (LayoutFrame fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ switchHeight negated corner: 0 @ (1 - switchHeight))).	column addMorph: self buildMorphicClassList 		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ switchHeight negated)).	^column! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/30/2010 08:25'!optionalButtonRow	"Answer a row of buttons to occur in a tool pane"	| row buttons widths buttonColor |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	self buttonSpecs do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button color: buttonColor.		button label: tuple second asString.		buttons add: button.		button setBalloonText: tuple fourth].	buttons add: self lineDiffButton.	widths add: 14.	buttons add: self wordDiffButton.	widths add: 16.	self wantsPrettyDiffOption ifTrue: [		buttons add:  self prettyLineDiffButton.		widths add: 21.		buttons add:  self prettyWordDiffButton.		widths add: 23 ].	row _ AlignmentMorph proportional.	row color: buttonColor.	row addInRow: buttons widthProportionalTo: widths.	^row! !!Debugger methodsFor: 'initialize' stamp: 'jmv 11/30/2010 08:35'!customButtonRow	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"	| button buttons row buttonColor |		buttons _ OrderedCollection new.	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	self customButtonSpecs do: [ :tuple | 		button := PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple second.		button color: buttonColor.		button label: tuple first asString.		tuple size > 2 ifTrue: [button setBalloonText: tuple third].		buttons add: button].			row _ AlignmentMorph proportional.	row color: buttonColor.	row addInProportionalRow: buttons.	^row! !!Debugger methodsFor: 'controls' stamp: 'jmv 11/30/2010 08:32'!addOptionalButtonsTo: window at: fractions plus: verticalOffset	"Add button panes to the window.  A row of custom debugger-specific buttons (Proceed, Restart, etc.) is always added, and if optionalButtons is in force, then the standard code-tool buttons are also added.  Answer the verticalOffset plus the height added."	| delta buttons divider anOffset |	anOffset _ (Preferences optionalButtons and: [Preferences extraDebuggerButtons | true])		ifTrue:			[super addOptionalButtonsTo: window at: fractions plus: verticalOffset]		ifFalse:			[verticalOffset].	delta _ self defaultButtonPaneHeight.	buttons _ self customButtonRow.	divider _ BorderedSubpaneDividerMorph forBottomEdge.	window 		addMorph: buttons		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@anOffset corner: 0@(anOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(anOffset + delta - 1) corner: 0@(anOffset + delta))).	^ anOffset + delta! !!FileContentsBrowser methodsFor: 'creation' stamp: 'jmv 11/29/2010 18:10'!addLowerPanesTo: window at: nominalFractions with: editString	| verticalOffset column codePane infoPane infoHeight divider |	column _ AlignmentMorph proportional.	codePane _ PluggableTextMorph 		model: self 		editorClass: self editorClass		textGetter: #contents 		textSetter: #contents:notifying:		selectionGetter: #contentsSelection 		menuGetter: #paneMenu:shifted:editorClass:.	infoPane _ PluggableTextMorph 		model: self 		editorClass: self editorClass		textGetter: #infoViewContents 		textSetter: nil		selectionGetter: nil 		menuGetter: nil.	infoPane askBeforeDiscardingEdits: false.	verticalOffset _ 0.	infoHeight _ 20.	column 		addMorph: (codePane borderWidth: 0)		fullFrame: (			LayoutFrame 				fractions: (0@0 corner: 1@1) 				offsets: (0@verticalOffset corner: 0@infoHeight negated)		).	divider _ BorderedSubpaneDividerMorph forTopEdge.	column 		addMorph: divider		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@infoHeight negated corner: 0@(1-infoHeight))		).	column 		addMorph: (infoPane borderWidth: 0; hideScrollBarsIndefinitely)		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@(1-infoHeight) corner: 0@0)		).	window 		addMorph: column		frame: nominalFractions.	column on: #mouseEnter send: #paneTransition: to: window.	column on: #mouseLeave send: #paneTransition: to: window! !!FileList methodsFor: 'initialization' stamp: 'jmv 11/30/2010 08:29'!optionalButtonRow	"Answer the button row associated with a file list"	| row buttonColor |	row _ AlignmentMorph proportional.	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	row setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"	row color: buttonColor.	self updateButtonRow: row.	^row! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 11/30/2010 08:33'!addButtonsAndFileListPanesTo: window at: upperFraction plus: offset forFileList: aFileList 	| fileListMorph column buttonHeight fileListTop divider dividerDelta buttons |	fileListMorph _ PluggableListMorph				model: aFileList				listGetter: #fileList				indexGetter: #fileListIndex				indexSetter: #fileListIndex:				menuGetter: #fileListMenu:.	fileListMorph enableDrag: true; enableDrop: false.	aFileList wantsOptionalButtons		ifTrue: [			buttons _ aFileList optionalButtonRow.			divider _ BorderedSubpaneDividerMorph forBottomEdge.			dividerDelta _ 0.			fileListMorph borderColor: Color transparent.			dividerDelta _ 3.			column _ AlignmentMorph proportional.			buttonHeight _ self defaultButtonPaneHeight.			column				addMorph: buttons				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 0)						offsets: (0 @ 0 corner: 0 @ buttonHeight)).			column				addMorph: divider				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 0)						offsets: (0 @ buttonHeight corner: 0 @ buttonHeight + dividerDelta)).			column				addMorph: fileListMorph				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 1)						offsets: (0 @ buttonHeight + dividerDelta corner: 0 @ 0)).			window				addMorph: column				fullFrame: (LayoutFrame						fractions: upperFraction						offsets: (0 @ offset corner: 0 @ 0)).			column borderWidth: 2]		ifFalse: [			fileListTop _ 0.			window				addMorph: fileListMorph				frame: (0.3 @ fileListTop corner: 1 @ 0.3)].! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 11/29/2010 18:11'!addVolumesAndPatternPanesTo: window at: upperFraction plus: offset forFileList: aFileList 	| column patternHeight volumeListMorph patternMorph divider dividerDelta |	column _ AlignmentMorph proportional.	patternHeight _ 25.	volumeListMorph _ (PluggableListMorph				model: aFileList				listGetter: #volumeList				indexGetter: #volumeListIndex				indexSetter: #volumeListIndex:				menuGetter: #volumeMenu:)				autoDeselect: false.	volumeListMorph enableDrag: false; enableDrop: true.	patternMorph _ PluggableTextMorph				model: aFileList				editorClass: aFileList editorClass				textGetter: #pattern				textSetter: #pattern:.	patternMorph acceptOnCR: true.	patternMorph hideScrollBarsIndefinitely.	divider _ BorderedSubpaneDividerMorph new.	dividerDelta _ 0.	volumeListMorph borderColor: Color transparent.	patternMorph borderColor: Color transparent.	dividerDelta _ 3.	column		addMorph: (volumeListMorph autoDeselect: false)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ patternHeight negated - dividerDelta)).	column		addMorph: divider		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ patternHeight negated - dividerDelta corner: 0 @ patternHeight negated)).	column		addMorph: patternMorph		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ patternHeight negated corner: 0 @ 0)).	window		addMorph: column		fullFrame: (LayoutFrame				fractions: upperFraction				offsets: (0 @ offset corner: 0 @ 0)).	column borderWidth: 2! !!FileList2 class methodsFor: '*smloader-extension' stamp: 'jmv 11/30/2010 08:33'!morphicViewOnDirectory: aFileDirectory	| aFileList window fileListBottom midLine fileListTopOffset buttonRow |	aFileList _ self new directory: aFileDirectory.	window _ (SystemWindow labelled: aFileDirectory pathName) model: aFileList.	fileListTopOffset _ (StrikeFont default pointSize * 2) + 14.	fileListBottom _ 0.4.	midLine _ 0.4.	buttonRow _ aFileList optionalButtonRow.	self addFullPanesTo: window from: {		{aFileList morphicPatternPane. 			0@0 corner: 0.3@0. 					0@0 corner: 0@fileListTopOffset}.		{buttonRow.				 			0.3 @ 0 corner: 1@0. 					0@0 corner: 0@fileListTopOffset}.		{aFileList morphicDirectoryTreePane. 	0@0 corner: midLine@fileListBottom. 	0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileListPane. 			midLine @ 0 corner: 1@fileListBottom. 	0@fileListTopOffset corner: 0@0}.		{aFileList morphicFileContentsPane. 	0@fileListBottom corner: 1@1. 			nil}.	}.		buttonRow		color: (ColorTheme current buttonColorFrom: self windowColor);	"not nice. was just turned transparent..."		borderColor: #simple.	aFileList postOpen.	^ window ! !!Morph methodsFor: 'accessing' stamp: 'jmv 11/23/2010 11:40'!adoptWidgetsColor: paneColor	self submorphsDo:[:m| m adoptWidgetsColor: paneColor].! !!BorderedMorph methodsFor: 'drawing' stamp: 'jmv 11/29/2010 18:41'!drawOn: aCanvas	borderColor class == Symbol		ifTrue: [			"This would be better."			"aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor."			"But, for instance, pluggable lists and text in browsers are shown with an inset border, their color is white, and the baseColorForBorder must match the window..."			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor			]		ifFalse: [			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ]! !!BorderedSubpaneDividerMorph methodsFor: 'drawing' stamp: 'jmv 11/29/2010 18:06'!drawOn: aCanvas	aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: 2 borderStyleSymbol: #raised! !!BorderedSubpaneDividerMorph methodsFor: 'accessing' stamp: 'jmv 11/29/2010 18:07'!adoptWidgetsColor: paneColor	super adoptWidgetsColor: paneColor.	paneColor ifNotNil: [ self color: paneColor ]! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 11/30/2010 08:26'!adoptWidgetsColor: paneColor	super adoptWidgetsColor: paneColor.	paneColor ifNotNil: [ self color: (ColorTheme current buttonColorFrom: paneColor) ]! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'jmv 11/29/2010 19:56'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model _ model.		Weakly copied""getStateSelector _ getStateSelector.		a Symbol""actionSelector _ actionSelector.		a Symbol""getLabelSelector _ getLabelSelector.		a Symbol""getMenuSelector _ getMenuSelector.		a Symbol"arguments _ arguments veryDeepCopyWith: deepCopier.argumentsProvider _ argumentsProvider veryDeepCopyWith: deepCopier.argumentsSelector _ argumentsSelector.  " a Symbol" isPressed _ isPressed.mouseIsOver _ mouseIsOver! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 11/30/2010 08:10'!drawOn: aCanvas 	| w f center x y borderStyleSymbol c |	"This paves the road for configurable button look..."	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].	c _ self fillStyle asColor.	self mouseIsOver ifTrue: [ c _ c  lighter ].	aCanvas		fillRectangle: (bounds insetBy: 0)		fillStyle: c		borderWidth: 2		borderStyleSymbol: borderStyleSymbol."	aCanvas		fillRectangle: (bounds insetBy: 4)		fillStyle: self fillStyle		borderWidth: borderWidth		borderStyleSymbol: borderStyleSymbol."	f _ self fontToUse.	center _ bounds center.	label ifNotNil: [		w _ f widthOfString: label.		x _ bounds width > w			ifTrue: [ center x - (w // 2) ]			ifFalse: [ bounds left +4].		y _ center y - (f height // 2).		self isPressed ifTrue: [			x _ x + 1.			y _ y + 1 ].		aCanvas drawString: label at: x@y font: f color: ColorTheme current buttonLabel ]! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/29/2010 19:42'!handlesMouseOver: evt	^ true! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/29/2010 18:53'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	evt yellowButtonPressed ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	(self containsPoint: evt cursorPoint) ifTrue: [		isPressed _ true.		self changed].	evt hand		waitForSimulatedYellow: self		event: evt		dblClkSel: #doubleClick:! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/29/2010 19:54'!mouseEnter: event	"The mouse entered the receiver"	mouseIsOver _ true.	self changed.	^super mouseEnter: event! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/29/2010 19:54'!mouseLeave: event	"The mouse has left the area of the receiver"	mouseIsOver _ false.	self changed.	^super mouseLeave: event! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/29/2010 18:53'!mouseUp: evt	isPressed _ false.	self changed.	(self containsPoint: evt cursorPoint) ifTrue: [self performAction]! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 11/29/2010 19:45'!initialize	"initialize the state of the receiver"	super initialize.	model _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	argumentsProvider _ nil.	argumentsSelector _ nil.	isPressed _ false.	mouseIsOver _ false.	self extent: 20 @ 15! !!PluggableButtonMorph methodsFor: 'updating' stamp: 'jmv 11/30/2010 08:10'!update: aParameter 	getLabelSelector ifNotNil: [		aParameter == getLabelSelector ifTrue: [			self label: (model perform: getLabelSelector)]].	self changed! !!PluggableButtonMorph methodsFor: 'testing' stamp: 'jmv 11/29/2010 19:57'!isPressed	^isPressed == true | self getModelState! !!PluggableButtonMorph methodsFor: 'testing' stamp: 'jmv 11/29/2010 19:46'!mouseIsOver	^mouseIsOver == true! !!ScrollPane methodsFor: 'event handling' stamp: 'jmv 11/29/2010 19:41'!handlesMouseOver: evt	^true! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jmv 11/30/2010 08:34'!buttonToTriggerIn: aFileList 	"Answer a button that will trigger the receiver service in a file list"	| aButton |	aButton := PluggableButtonMorph 				model: self				stateGetter: nil				action: #performServiceFor:.	aButton arguments: { 				aFileList}.	aButton label: self buttonLabel.	aButton color: (ColorTheme current buttonColorFrom: aFileList class windowColor).	aButton setBalloonText: self description.	^aButton! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 11/29/2010 18:26'!drawClassicFrameOn: aCanvas titleColor: titleColor	"Window border encompasses title area. No round corners. No title gradient."	borderColor class == Symbol		ifTrue: [			" This would of course be much better...			"			^aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor			"			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor 			"			]		ifFalse: [			aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ].	aCanvas fillRectangle: self titleAreaInnerRect color: titleColor! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 11/29/2010 18:26'!drawWindowBodyOn: aCanvas roundCorners: doRoundCorners widgetsColor: widgetsColor	"Title area is not inside window borders"	| r bl tl tr he tw bw |	doRoundCorners		ifFalse: [			borderColor class == Symbol				ifTrue: [					" This would of course be much better...					^aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor					"					aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor ]				ifFalse: [					aCanvas fillRectangle: bounds fillStyle: self fillStyle borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ]]		ifTrue: [			r _ ColorTheme current roundedCornerRadius.			aCanvas image: SystemWindow roundedCornerBL multipliedBy: widgetsColor at: bounds bottomLeft - (0@r).			aCanvas image: SystemWindow roundedCornerBR multipliedBy: widgetsColor at: bounds bottomRight - (r@r) .			aCanvas fillRectangle: self innerBounds fillStyle: self fillStyle.			tl _ bounds topLeft + (0@self labelHeight).			tr _ bounds topRight + (borderWidth negated@self labelHeight).			bl _ bounds bottomLeft + (r@borderWidth negated).			he _ borderWidth@(bounds height - self labelHeight - r).			tw _ bounds width@borderWidth.			bw _ bounds width - r - r@borderWidth.			aCanvas fillRectangle: (tl extent: he) fillStyle: widgetsColor.			aCanvas fillRectangle: (tr extent: he) fillStyle: widgetsColor.			aCanvas fillRectangle: (bl extent: bw) fillStyle: widgetsColor.			aCanvas fillRectangle: (tl extent: tw) fillStyle: widgetsColor ]! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/29/2010 17:29'!buildFilterButton	| filterButton |	filterButton := PluggableButtonMorph 				model: self				stateGetter: nil				action: #setFilter				labelOrGetter: #filterButtonLabel.	filterButton color: self runButtonColor.	^filterButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/29/2010 18:12'!buildLowerPanes	| failuresList errorsList column tHeight divider |	column _ AlignmentMorph proportional.	self buildPassFailText.	self buildDetailsText.	self buildTestsList.	failuresList _ self buildFailuresList.	errorsList _ self buildErrorsList.	tHeight _ 26.	divider _ Array new: 3.	1		to: divider size		do: [:index | 			divider at: index put: BorderedSubpaneDividerMorph forBottomEdge ].	column		addMorph: (passFailText borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ 0 corner: 0 @ tHeight - 1)).	column		addMorph: (divider at: 1)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ (tHeight - 1) corner: 0 @ tHeight)).	column		addMorph: (detailsText borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ tHeight corner: 0 @ (2 * tHeight - 1))).	column		addMorph: (divider at: 2)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0)				offsets: (0 @ (2 * tHeight - 1) corner: 0 @ (2 * tHeight))).	column		addMorph: (failuresList borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 0.6)				offsets: (0 @ (2 * tHeight) corner: 0 @ -1)).	column		addMorph: (divider at: 3)		fullFrame: (LayoutFrame				fractions: (0 @ 0.6 corner: 1 @ 0.6)				offsets: (0 @ - 1 corner: 0 @ 0)).	column		addMorph: (errorsList borderWidth: 0)		fullFrame: (LayoutFrame				fractions: (0 @ 0.6 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ 0)).	^ column! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/29/2010 17:29'!buildRefreshButton	| refreshButton |	refreshButton := PluggableButtonMorph 				model: self				stateGetter: #refreshButtonState				action: #refreshTests				labelOrGetter: #refreshButtonLabel.	refreshButton		color: self runButtonColor.	^refreshButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/29/2010 17:29'!buildRunButton	| runButton |	runButton := PluggableButtonMorph 				model: self				stateGetter: #runButtonState				action: #runTests				labelOrGetter: #runButtonLabel.	runButton		color: self runButtonColor.	^runButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/29/2010 17:29'!buildRunOneButton	| runOneButton |	runOneButton := PluggableButtonMorph 				model: self				stateGetter: #runButtonState				action: #runOneTest				labelOrGetter: #runOneButtonLabel.	runOneButton		color: self runButtonColor.	^runOneButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/29/2010 17:29'!buildStopButton	| stopButton |	stopButton := PluggableButtonMorph 				model: self				stateGetter: #stopButtonState				action: #terminateRun				labelOrGetter: #stopButtonLabel.	stopButton		color: self runButtonColor.	^stopButton! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/29/2010 18:12'!morphicWindow	"TestRunner new openAsMorph"	| upperRow lowerPanes fracYRatio divider window |	window _ SystemWindow labelled: self windowLabel.	window model: self.	upperRow _ self buildUpperControls.	lowerPanes _ self buildLowerPanes.	fracYRatio _ 0.25.	window		addMorph: upperRow		fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 1 @ fracYRatio)).	divider _ BorderedSubpaneDividerMorph forBottomEdge.	window		addMorph: divider		fullFrame: (LayoutFrame				fractions: (0 @ fracYRatio corner: 1 @ fracYRatio)				offsets: (0 @ 0 corner: 0 @ 2)).	window		addMorph: lowerPanes		fullFrame: (LayoutFrame fractions: (0 @ fracYRatio extent: 1 @ (1 - fracYRatio))).	self refreshWindow.	window extent: 460 @ 400.	^window! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 11/30/2010 08:29'!optionalButtonRow	| row button buttons widths buttonColor |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	self optionalButtonTuples do: [ :tuple | 		widths add: tuple first.		button _ PluggableButtonMorph 			model: self			stateGetter: nil			action: tuple third.		button color: buttonColor.		button			label: tuple second.		buttons add: button].	row _ AlignmentMorph proportional.	row color: buttonColor.	row addInRow: buttons widthProportionalTo: widths.	^row! !Uniformity removeSelector: #buttonOff!Uniformity removeSelector: #buttonOn!Uniformity removeSelector: #switchOff!Uniformity removeSelector: #switchOn!PluggableButtonMorph removeSelector: #offColor:!PluggableButtonMorph removeSelector: #onColor:offColor:!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector getLabelSelector getMenuSelector arguments argumentsProvider argumentsSelector isPressed mouseIsOver'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!BorderedSubpaneDividerMorph removeSelector: #defaultColor!!classDefinition: #BorderedSubpaneDividerMorph category: #'Morphic-Windows'!Morph subclass: #BorderedSubpaneDividerMorph	instanceVariableNames: 'resizingEdge'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!DarkColorTheme removeSelector: #switchOff!DarkColorTheme removeSelector: #switchOn!DarkBluesPalette removeSelector: #switchOff!DarkBluesPalette removeSelector: #switchOn!Conformist removeSelector: #buttonOff!Conformist removeSelector: #buttonOn!Conformist removeSelector: #switchOff!Conformist removeSelector: #switchOn!ColorTheme removeSelector: #buttonOff!ColorTheme removeSelector: #buttonOn!ColorTheme removeSelector: #switchOff!ColorTheme removeSelector: #switchOn!