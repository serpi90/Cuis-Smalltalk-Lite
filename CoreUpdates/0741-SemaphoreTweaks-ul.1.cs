'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 28 December 2010 at 12:30:03 pm'!!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 11/7/2010 05:29'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical: [ mutuallyExcludedBlock ifCurtailed: terminationBlock ]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 11/7/2010 15:00'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	blockValue := self critical:[		mutuallyExcludedBlock ifError: [ :msg :rcvr |			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'jmv 12/28/2010 12:29'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, then evaluate 	alternativeBlock and return."	"See the comment of #critical: for the explanation how this pattern works	before changing the code."	| caught |	caught := false.	^[		"Note: The following is tricky and depends on the fact that the VM will not switch between processes while executing byte codes (process switches happen only in real sends). The following test is written carefully so that it will result in bytecodes only.	Do not change the following #== for #=, as #== is not a real message send, just a bytecode."		excessSignals == 0			ifTrue: [				"If we come here, then the semaphore was locked when the test executed. 				Evaluate the alternative block and answer its result."				alternativeBlock value ]			ifFalse: [				excessSignals := excessSignals - 1.				caught := true.				mutuallyExcludedBlock value ] ]		ensure: [ caught ifTrue: [ self signal ] ]! !