'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 9 March 2011 at 2:01:16 pm'!!Morph commentStamp: 'jmv 3/9/2011 14:00' prior: 0!A Morph (from the Greek "shape" or "form") is an interactive graphical object. General information on the Morphic system can be found at http://minnow.cc.gatech.edu/squeak/30. Morphs exist in a tree, rooted at a World (generally a PasteUpMorph). The morphs owned by a morph are its submorphs. Morphs are drawn recursively; if a Morph has no owner it never gets drawn. To hide a Morph and its submorphs, set its #visible property to false using the #visible: method. The World (screen) coordinate system is used for most coordinates, but can be changed if there is a TransformMorph somewhere in the owner chain. My instance variables have accessor methods (e.g., #bounds, #bounds:). Most users should use the accessor methods instead of using the instance variables directly.Structure:instance var 	Type 			Description bounds 		Rectangle 		A Rectangle indicating my position and a size that will enclose me. owner 			Morph		 	My parent Morph, or nil for the top-level Morph, which is a 				or nil			world, typically a PasteUpMorph.submorphs 	Array 			My child Morphs. fullBounds 		Rectangle 		A Rectangle minimally enclosing me and my submorphs. color 			Color 			My primary color. Subclasses can use this in different ways. extension 		MorphExtension Allows extra properties to be stored without adding a				or nil  				storage burden to all morphs. By default, Morphs do not position their submorphs. Morphs may position their submorphs directly or use a LayoutPolicy to automatically control their submorph positioning.Although Morph has some support for BorderStyle, most users should use BorderedMorph if they want borders.!!Debugger methodsFor: 'notifier menu' stamp: 'jmv 3/9/2011 12:29'!storeLog	| logFileName |	logFileName _ Preferences debugLogTimestamp		ifTrue: ['CuisDebug-' , Time totalSeconds printString , '.log']		ifFalse: ['CuisDebug.log'].	Smalltalk logError: labelString printString inContext: contextStackTop to: logFileName! !!Debugger methodsFor: 'private' stamp: 'jmv 3/9/2011 12:29'!lowSpaceChoices	"Return a notifier message string to be presented when space is running low."	^ 'Warning!! Cuis is almost out of memory!!Low space detection is now disabled. It will be restored when you close or proceed from this error notifier. Don''t panic, but do proceed with caution.Here are some suggestions:- If you suspect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem.- If you want this computation to finish, then make more space available (read on) and choose "proceed" in this debugger. Here are some ways to make more space available...   > Close any windows that are not needed.   > Get rid of some large objects (e.g., images).   > Leave this window on the screen, choose "save as..." from the screen menu, quit, restart the Squeak VM with a larger memory allocation, then restart the image you just saved, and choose "proceed" in this window.- If you want to investigate further, choose "debug" in this window.  Do not use the debugger "fullStack" command unless you are certain that the stack is not very deep. (Trying to show the full stack will definitely use up all remaining memory if the low-space problem is caused by an infinite recursion!!).'! !!Debugger class methodsFor: 'class initialization' stamp: 'jmv 3/9/2011 12:30'!openContext: aContext label: aString contents: contentsStringOrNil	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		self primitiveError: aString].	ErrorRecursion _ true.	self informExistingDebugger: aContext label: aString.	(Debugger context: aContext)		openNotifierContents: contentsStringOrNil		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'jmv 3/9/2011 12:30'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| errorWasInUIProcess |	errorWasInUIProcess _ ProjectX newProcessIfUIX: process.	WorldState addDeferredUIMessage: [ 		[	| debugger |			debugger := self new process: process controller: nil context: context.			"schedule debugger in deferred UI message to address redraw			problems after opening a debugger e.g. from the testrunner."			"WorldState addDeferredUIMessage: ["			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			debugger errorWasInUIProcess: errorWasInUIProcess.			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'CuisDebug.log'].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	process suspend! !!FileDirectory class methodsFor: 'system start up' stamp: 'jmv 3/9/2011 12:33'!openSources: sourcesName andChanges: changesName forImage: imageName 	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or CR/CRLF mixups."	"Note: SourcesName and imageName are full paths; changesName is a  	local name."	| sources changes msg wmsg |	msg _ 'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.'.	wmsg _ 'Squeak cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.	"Do not open source files if internalized (i.e. notNil)"	sources _ (SourceFiles at: 1) ifNil: [ self openSources: sourcesName forImage: imageName ].	changes _ (SourceFiles at: 2) ifNil: [ self openChanges: changesName forImage: imageName ].	(sources isNil and: [ Preferences valueOfFlag: #warnIfNoSourcesFile ])		ifTrue: [			Smalltalk platformName = 'Mac OS'				ifTrue: [					msg _ msg , String cr, 'Make sure the sources file is not an Alias.'].			self inform: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName)].	(changes isNil and: [ Preferences valueOfFlag: #warnIfNoChangesFile ])		ifTrue: [self inform: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	((Preferences valueOfFlag: #warnIfNoChangesFile) and: [changes notNil])		ifTrue: [			changes isReadOnly				ifTrue: [					self inform: (wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].			((changes next: 200)					includesSubString: String crlf)				ifTrue: [					self inform: 'The changes file named ' , changesName , 'has been injured by an unpacking utility.  Crs were changed to CrLfs.Please set the preferences in your decompressing program to "do not convert text files" and unpack the system again.']].	SourceFiles _ Array with: sources with: changes! !!DisplayScreen methodsFor: 'private' stamp: 'jmv 3/9/2011 12:31'!findAnyDisplayDepth	"Return any display depth that is supported on this system."	^self findAnyDisplayDepthIfNone:[		"Ugh .... now this is a biggie - a system that does not support		any of the Squeak display depths at all."		Smalltalk			logError:'Fatal error: This system has no support for any display depth at all.'			inContext: thisContext			to: 'CuisDebug.log'.		Smalltalk quitPrimitive. "There is no way to continue from here"	].! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'jmv 3/9/2011 12:49'!inform: aString	"PopUpMenu inform: 'I like Cuis'"	(PopUpMenu labels: ' OK ') startUpWithCaption: aString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 3/9/2011 12:55'!systemInformationString	"Identify software version"	^ SystemVersion current version, String cr, self lastUpdateString, String cr, self currentChangeSetString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 3/9/2011 12:55'!writeRecentToFile	| numChars aDirectory aFileName |	"Smalltalk writeRecentToFile"	aDirectory _ FileDirectory default.	aFileName _ Utilities keyLike: 'cuis-recent.01' withTrailing: '.log' satisfying:		[:aKey | (aDirectory includesKey: aKey) not].	numChars _ ChangeList getRecentLocatorWithPrompt: 'copy logged source as far back as...'.	numChars ifNotNil:		[Smalltalk writeRecentCharacters: numChars toFileNamed: aFileName]! !!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 3/9/2011 12:56'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu := MenuMorph new defaultTarget: self.	menu commandKeyHandler: self.	self colorForDebugging: menu.	menu addStayUpIcons.	self fillIn: menu		from: { 				{ 					'restore display (r)'.					{ 						World.						#restoreMorphicDisplay}.					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.				nil}.	Preferences simpleMenus 		ifFalse: 			[self fillIn: menu				from: { 						{ 							'open...'.							{ 								self.								#openWindow}}.						{ 							'windows...'.							{ 								self.								#windowsDo}}.						{ 							'changes...'.							{ 								self.								#changesDo}}}].	self fillIn: menu		from: { 				{ 					'help...'.					{ 						self.						#helpDo}.					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.				{ 					'appearance...'.					{ 						self.						#appearanceDo}.					'put up a menu offering many controls over appearance.'}}.	Preferences simpleMenus 		ifFalse: 			[self fillIn: menu				from: { 						{ 							'do...'.							{ 								Utilities.								#offerCommonRequestsInMorphic}.							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].	self fillIn: menu		from: { 				nil.				{ 					'new morph...'.					{ 						self.						#newMorph}.					'Offers a variety of ways to create new objects'}.				}.	Preferences simpleMenus 		ifFalse: 			[self fillIn: menu				from: { 						{ 							'debug...'.							{ 								self.								#debugDo}.							'a menu of debugging items'}}].	self fillIn: menu		from: { 				nil.				{ 					'save'.					{ 						Smalltalk .						#saveSession}.					'save the current version of the image on disk'}.				{ 					'save as...'.					{ 						Smalltalk .						#saveAs}.					'save the current version of the image on disk under a new name.'}.				{ 					'save as new version'.					{ 						Smalltalk .						#saveAsNewVersion}.					'give the current image a new version-stamped name and save it under that name on disk.'}.				{ 					'save and quit'.					{ 						self.						#saveAndQuit}.					'save the current image on disk, and quit out of Cuis.'}.				{ 					'quit'.					{ 						self.						#quitSession}.					'quit out of Cuis.'}}.	^menu! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 3/9/2011 12:58'!saveDisplay	"Save Display to a file"	"SampledSound playSoundNamed: 'camera'."	PNGReadWriter		putForm: Display		onFileNamed:			(FileDirectory default				nextNameFor: 'CuisDisplay'				extension: 'png')! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 3/9/2011 12:58'!saveScreenshot	"Make a screenshot of the world and save it to a file"	"SampledSound playSoundNamed: 'camera'."	PNGReadWriter		putForm: World imageForm		onFileNamed:			(FileDirectory default				nextNameFor: 'CuisScreen'				extension: 'png')! !DisplayScreen removeSelector: #isDisplayScreen!Form removeSelector: #displayScreen!Form removeSelector: #isDisplayScreen!Form removeSelector: #isExternalForm!