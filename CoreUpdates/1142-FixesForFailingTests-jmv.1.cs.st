'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 16 November 2011 at 8:40:46 am'!!Debugger methodsFor: 'accessing' stamp: 'jmv 11/16/2011 08:32'!     contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		(result := self contents: aText notifying: aController) ifTrue: [			self acceptedContentsChanged].		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	^true! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 11/16/2011 08:37'!            doStep	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext newContext |	self checkContextSelection.	currentContext _ self selectedContext.	newContext _ interruptedProcess completeStep: currentContext.	newContext == currentContext ifTrue: [		newContext _ interruptedProcess stepToSendOrReturn].	self contextStackIndex > 1		ifTrue: [self resetContext: newContext]		ifFalse: [newContext == currentContext				ifTrue: [self changed: #initialSelection.						self updateInspectors]				ifFalse: [self resetContext: newContext]].! !!Editor methodsFor: 'menu commands' stamp: 'jmv 11/16/2011 08:39'!                       offerMenuFromEsc: aKeyboardEvent	"The escape key was hit while the receiver has the keyboard focus; take action"	^ aKeyboardEvent shiftPressed ifFalse: [		morph mouseButton2Activity ]; not! !!OneLineEditorMorph methodsFor: 'private' stamp: 'jmv 11/16/2011 08:23'!                 mouseButton2Activity	"Nothing to do right now..."! !!TextEditorTest methodsFor: 'as yet unclassified' stamp: 'jmv 11/16/2011 08:40'!                       testSimpleEditor	"	TextEditorTest new testSimpleEditor	"	| m |	self shouldnt: [		m _ OneLineEditorMorph new.		m editor offerMenuFromEsc:			(KeyboardEvent new				setType: #keystroke				buttons: 0				position: 0@0				keyValue: 65				hand: ActiveHand				stamp: 0)	] raise: Exception! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 11/16/2011 08:37'!              update: aSymbol	super update: aSymbol.	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents ifTrue: [		"Some day, it would be nice to keep objects and update them		instead of throwing them away all the time for no good reason..."		self textMorph releaseParagraph.		self textMorph formatAndStyleIfNeeded.		^self ].	aSymbol == #acceptedContents ifTrue: [		self textMorph hasUnacceptedEdits ifTrue: [			self hasEditingConflicts: true.			^self redrawNeeded ].		model refetch.		^self ].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self ].	aSymbol == #initialSelection ifTrue: [		^self setSelection: model getSelection; redrawNeeded ].	aSymbol == #autoSelect ifTrue: [		self handleEdit: [			TextEditor abandonChangeText.	"no replacement!!"			self editor				setSearch: model autoSelectString;				findAndReplaceMany: true ]].	"Quite ugly"	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #shoutStyle ifTrue: [		self stylerStyled.		^self redrawNeeded ].! !