'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 2 March 2011 at 5:01:01 pm'!!BlockClosure methodsFor: 'private' stamp: 'jmv 3/2/2011 16:59'!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^(MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc;		privRefresh! !!CompiledMethod methodsFor: 'initialize-release' stamp: 'jmv 3/2/2011 16:56'!needsFrameSize: newFrameSize	"Set the largeFrameBit to accomodate the newFrameSize"	| largeFrameBit header |	largeFrameBit _ 16r20000.	(self numTemps + newFrameSize) > LargeFrame ifTrue:		[^ self error: 'Cannot compile -- stack including temps is too deep'].	header _ self objectAt: 1.	(header bitAnd: largeFrameBit) ~= 0		ifTrue: [header _ header - largeFrameBit].	self objectAt: 1 put: header 			+ ( ((self numTemps + newFrameSize) > SmallFrame or: [ self primitive = 84 "perform:withArguments:"])					ifTrue: [largeFrameBit]					ifFalse: [0])! !!Fraction methodsFor: 'comparing' stamp: 'jmv 3/2/2011 16:58'!hash	"Hash is reimplemented because = is implemented.	Care is taken that a Fraction equal to a Float also have an equal hash"	| tmp |	denominator isPowerOfTwo ifTrue: [		"If denominator is a power of two, I can be exactly equal to a Float"		tmp := self asFloat.		tmp isFinite ifTrue: [^tmp hash]]. 	"Else, I cannot be exactly equal to a Float, use own hash algorithm. 	(Assume the fraction is already reduced)"	^numerator hash bitXor: denominator hash! !