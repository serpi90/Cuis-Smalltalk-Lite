'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 5 December 2010 at 3:32:34 pm'!!BareTextMorph methodsFor: 'accessing' stamp: 'di 7/12/2001 22:25'!autoFit: trueOrFalse	self isAutoFit = trueOrFalse ifTrue: [^ self].	self autoFitOnOff! !!BareTextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 15:48'!contents: stringOrText	^ self contentsAsIs: stringOrText! !!BareTextMorph methodsFor: 'accessing' stamp: 'ar 8/23/2001 21:23'!crAction	"Return the action to perform when encountering a CR in the input"	^self valueOfProperty: #crAction! !!BareTextMorph methodsFor: 'accessing' stamp: 'di 10/5/1998 13:56'!editor	"Return my current editor, or install a new one."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!BareTextMorph methodsFor: 'accessing' stamp: 'di 7/12/2001 14:01'!isAutoFit	^ self valueOfProperty: #autoFitContents ifAbsent: [true]! !!BareTextMorph methodsFor: 'accessing' stamp: 'RAA 8/21/2001 11:18'!isWrapped		^wrapFlag! !!BareTextMorph methodsFor: 'accessing' stamp: 'di 7/21/2001 10:37'!textColor	^ color! !!BareTextMorph methodsFor: 'accessing' stamp: 'di 7/21/2001 10:35'!textColor: aColor	color = aColor ifTrue: [^ self].	color _ aColor.	self changed.! !!BareTextMorph methodsFor: 'accessing' stamp: 'di 7/27/2001 13:10'!wrapFlag: aBoolean	"Change whether contents are wrapped to the container."	aBoolean == wrapFlag ifTrue: [^ self].	wrapFlag _ aBoolean.	self composeToBounds! !!BareTextMorph methodsFor: 'anchors' stamp: 'jmv 3/8/2010 14:24'!anchorMorph: aMorph at: aPoint type: anchorType	| relPt index newText block |	aMorph owner == self ifTrue:[self removeMorph: aMorph].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	self addMorphFront: aMorph.	aMorph textAnchorType: anchorType.	aMorph relativeTextAnchorPosition: nil.	anchorType == #document ifTrue:[^self].	relPt _ self internalizePosition: aPoint from: self world.	index _ (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ Text string: (String value: 1) attribute: (TextAnchor new anchoredMorph: aMorph).	anchorType == #inline ifTrue:[		self paragraph replaceFrom: index to: index-1 with: newText.	] ifFalse:[		index _ index min: paragraph text size.		index _ paragraph text string lastIndexOf: Character cr startingAt: index ifAbsent:[0].		block _ paragraph characterBlockForIndex: index+1.		aMorph relativeTextAnchorPosition: (relPt x - bounds left) @ (relPt y - block top ).		self paragraph replaceFrom: index+1 to: index with: newText.	].	self fit.! !!BareTextMorph methodsFor: 'caching' stamp: 'jm 11/13/97 16:32'!releaseCachedState	super releaseCachedState.	self releaseParagraph.! !!BareTextMorph methodsFor: 'drawing' stamp: 'di 7/12/2001 10:45'!debugDrawLineRectsOn: aCanvas	"Shows where text line rectangles are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!BareTextMorph methodsFor: 'editing' stamp: 'di 4/22/1998 10:57'!acceptContents	"The message is sent when the user hits enter or Cmd-S.	Accept the current contents and end editing."	self updateFromParagraph.	editView accept.! !!BareTextMorph methodsFor: 'editing' stamp: 'sw 8/12/2002 00:02'!acceptOnCR	"Answer whether the receiver wants to accept when the Return key is hit"	^ acceptOnCR == true! !!BareTextMorph methodsFor: 'editing' stamp: 'di 4/22/1998 11:03'!cancelEdits	"The message is sent when the user hits enter or Cmd-L.	Cancel the current contents and end editing."	self releaseParagraph.	editView cancel! !!BareTextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseAlignment	self editor changeAlignment.	self updateFromParagraph! !!BareTextMorph methodsFor: 'editing' stamp: 'sw 9/27/1999 12:13'!chooseEmphasisOrAlignment	self editor changeEmphasisOrAlignment.	self updateFromParagraph! !!BareTextMorph methodsFor: 'editing' stamp: 'ar 12/17/2001 13:09'!chooseFont	self editor changeTextFont.	self updateFromParagraph.! !!BareTextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseStyle	self editor changeStyle.	self updateFromParagraph! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 7/29/2009 18:37'!enterClickableRegion: evt	| index isLink |	evt hand hasSubmorphs ifTrue:[^self].	evt hand temporaryCursor ifNotNil:[^self].	paragraph ifNotNil:[		index _ (paragraph characterBlockAtPoint: evt position) stringIndex.		isLink _ (paragraph text attributesAt: index) 					anySatisfy:[:attr| attr mayActOnClick].		isLink ifTrue:[Cursor webLink show] ifFalse:[Cursor normal show].	].! !!BareTextMorph methodsFor: 'editing' stamp: 'di 4/12/98 11:36'!handleEdit: editBlock	"Ensure that changed areas get suitably redrawn"	self selectionChanged.  "Note old selection"		editBlock value.	self selectionChanged.  "Note new selection"	self updateFromParagraph  "Propagate changes as necessary"! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 9/2/2009 13:51'!handleInteraction: interactionBlock	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple ParagraphEditor to Morphic keyboard events"	| oldEditor oldParagraph oldSize |	oldEditor _ editor.	oldParagraph _ paragraph.	oldSize _ oldParagraph text size.	self selectionChanged.  "Note old selection"		interactionBlock value.	(oldParagraph == paragraph) ifTrue:[		"this will not work if the paragraph changed"		editor _ oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	(oldSize = paragraph text size)		ifFalse:[self updateFromParagraph].! !!BareTextMorph methodsFor: 'editing' stamp: 'di 4/21/1998 13:23'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag in my view."	editView hasUnacceptedEdits: aBoolean! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 10/9/2009 12:50'!autoScrollView: evt	"This is kind of a hack because the PluggableTextMorph expects me to first expand the selection before auto scrolling will work."	| localEvt |	localEvt _ evt internalizedToOwnerOf: self from: editView.	super mouseMove: localEvt.	editView scrollSelectionIntoView: localEvt.! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 11/18/2008 13:53'!handlesKeyboard	^self visible! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 1/6/2005 23:43'!handlesMouseDown: evt	^ self innerBounds containsPoint: evt cursorPoint! !!BareTextMorph methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:03'!handleKeystroke: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:	[^ self].	anEvent wasHandled: true.	self keyStroke: anEvent! !!BareTextMorph methodsFor: 'events-processing' stamp: 'ar 9/26/2001 22:21'!handleMouseMove: anEvent	"Re-implemented to allow for mouse-up move events"	anEvent wasHandled ifTrue:[^self]. "not interested"	(anEvent hand hasSubmorphs) ifTrue:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 9/12/2009 23:30'!container	"Return the container for composing this text.  There are 2 cases:	1.  container is nil, and wrap is true -- grow downward as necessary,	2.  container is nil, and wrap is false -- grow in 2D as necessary."	wrapFlag ifTrue: [		^ self innerBounds withHeight: 9999999].	^ self innerBounds topLeft extent: 9999999@9999999! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 9/12/2009 23:07'!extent: aPoint 	| newExtent priorEditor |	priorEditor _ editor.	self isAutoFit		ifTrue: [wrapFlag ifFalse: [^ self].  "full autofit can't change"				newExtent _ aPoint truncated max: self minimumExtent.				newExtent x = self extent x ifTrue: [^ self].  "No change of wrap width"				self releaseParagraph.  "invalidate the paragraph cache"				super extent: newExtent.				priorEditor					ifNil: [self fit]  "since the width has changed..."					ifNotNil: [self installEditorToReplace: priorEditor]]		ifFalse: [super extent: (aPoint truncated max: self minimumExtent).				wrapFlag ifFalse: [^ self].  "no effect on composition"				self composeToBounds]! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 3/2/2010 16:42'!privateMoveBy: delta 	super privateMoveBy: delta.	editor 		ifNil: [ paragraph ifNotNil: [paragraph moveBy: delta]]		ifNotNil: [ 			"When moving text with an active editor, save and restore all state."			paragraph moveBy: delta.			self installEditorToReplace: editor]! !!BareTextMorph methodsFor: 'geometry' stamp: 'di 3/1/98 11:40'!textBounds	^ bounds! !!BareTextMorph methodsFor: 'layout' stamp: 'tk 6/30/1998 17:06'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !!BareTextMorph methodsFor: 'menu' stamp: 'jmv 10/25/2010 20:59'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	"Add text-related menu items to the menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu 		addUpdating: #autoFitString		target: self		action: #autoFitOnOff.	aCustomMenu 		addUpdating: #wrapString		target: self		action: #wrapOnOff! !!BareTextMorph methodsFor: 'menu' stamp: 'di 7/27/2001 13:19'!autoFitOnOff	self setProperty: #autoFitContents toValue: self isAutoFit not.	self isAutoFit ifTrue: [self fit]! !!BareTextMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 22:06'!autoFitString	"Answer the string to put in a menu that will invite the user to 	switch autoFit mode"	^ (self isAutoFit		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text auto fit' translated! !!BareTextMorph methodsFor: 'menu' stamp: 'di 7/27/2001 13:20'!wrapOnOff	self wrapFlag: wrapFlag not! !!BareTextMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 22:18'!wrapString	"Answer the string to put in a menu that will invite the user to 	switch autoFit mode"	^ (wrapFlag		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text wrap to bounds' translated! !!BareTextMorph methodsFor: 'submorphs-add/remove' stamp: 'ar 12/17/2001 13:21'!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	aMorph textAnchorType == #document 		ifFalse:[^self anchorMorph: aMorph at: wp type: aMorph textAnchorType].	self addMorphFront: aMorph.! !!BareTextMorph methodsFor: 'private' stamp: 'di 11/30/97 12:13'!selectionChanged	self paragraph selectionRects do: [:r | self invalidRect: r]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 5/8/2009 19:00'!yellowButtonActivity: shiftKeyState	^ editView yellowButtonActivity: shiftKeyState! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 8/26/2010 11:36'!onBlinkCursor	"Blink the cursor"	paragraph ifNil: [ ^nil ].	paragraph showCaret: paragraph showCaret not | pauseBlinking.	pauseBlinking _ false.	paragraph caretRect ifNotNil: [ :r | self invalidRect: r].! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/10/2010 10:41'!pauseBlinking	"Show a solid cursor (non blinking) for a short while"	pauseBlinking _ true.	paragraph ifNotNil: [		"Show cursor right now if needed"		paragraph showCaret ifFalse: [			paragraph showCaret: true.			paragraph caretRect ifNotNil: [ :r | self invalidRect: r ]]]! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/10/2010 10:40'!startBlinking	"And show the cursor"	pauseBlinking _ true.	"Start blinking in a short while"	paragraph ifNotNil: [ paragraph showCaret: true ].	self		startStepping: #onBlinkCursor		at: Time millisecondClockValue		arguments: nil		stepTime: 500.! !!BareTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/10/2010 10:42'!stopBlinking	"And do not show cursor anymore."	self stopSteppingSelector: #onBlinkCursor.	paragraph ifNotNil: [		"Hide cursor right now if needed"		paragraph showCaret ifTrue: [			paragraph showCaret: false.			paragraph caretRect ifNotNil: [ :r | self invalidRect: r ]]]! !!BareTextMorph methodsFor: 'accept/cancel' stamp: 'di 9/11/1998 15:42'!acceptOnCR: trueOrFalse	acceptOnCR _ trueOrFalse! !!BareTextMorph methodsFor: 'edit view' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !!BareTextMorph methodsFor: 'edit view' stamp: 'di 4/21/1998 13:09'!setEditView: editPane	editView _ editPane! !!BareTextMorph methodsFor: 'macpal' stamp: 'di 11/10/1998 10:13'!flash	^ editView flash! !!BareTextMorph methodsFor: 'miscellaneous' stamp: 'jmv 9/10/2010 09:12'!selectAll	"Tell my editor to select all the text"	self editor selectAll.	self changed! !!BareTextMorph class methodsFor: 'new-morph participation' stamp: 'kfr 5/1/2000 13:42'!includeInNewMorphMenu	^ true! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 7/30/2009 11:36'!editorClass	^editorClass! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 4/11/2010 22:21'!textMorph	^ textMorph! !!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 5/10/2009 09:42'!wrapFlag: aBoolean	textMorph wrapFlag: aBoolean! !!TextModelMorph methodsFor: 'dependents access' stamp: 'di 4/20/1998 18:52'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!TextModelMorph methodsFor: 'dependents access' stamp: 'di 4/20/1998 18:56'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ hasUnacceptedEdits! !!TextModelMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 5/27/2006 17:49'!wantsDroppedMorph: aMorph event: anEvent 	^false! !!TextModelMorph methodsFor: 'editor access' stamp: 'di 5/22/1998 12:35'!scrollSelectionIntoView	"Scroll my text into view if necessary and return true, else return false"	^ self scrollSelectionIntoView: nil! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 9/10/2010 09:10'!selectAll	"Tell my textMorph's editor to select all"	textMorph selectAll! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 6/30/2010 23:21'!doubleClick: event	textMorph doubleClick: event! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 11/18/2008 13:53'!handlesKeyboard	self flag: #jmv.	"Not answering true helps not hitting pluggable texts twice during navigation. Only the internal text morph will receive it.	If some problem is found, introduce a new selector, that answers ^self handlesKeyboard in morph (and LW) 	and only in this class it will answer false""	^self visible" 	^ super handlesKeyboard! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 9/17/2010 14:58'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	textMorph keyStroke: evt.	self eventHandler ifNotNil: [		self eventHandler keyStroke: evt fromMorph: self ]! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 9/10/2010 22:53'!mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: textMorph ]! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 8/30/2010 10:40'!extent: newExtent 	super extent: newExtent.	textMorph ifNotNil: [ textMorph extent: self viewableWidth @ self height ].	self setScrollDeltas! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 7/2/2009 12:44'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	scroller hasSubmorphs ifFalse: [ ^1].	^ scroller firstSubmorph defaultLineHeight! !!TextModelMorph methodsFor: 'initialization' stamp: 'di 9/11/1998 15:46'!acceptOnCR: trueOrFalse	textMorph acceptOnCR: trueOrFalse! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jcg 11/5/2000 22:25'!correctSelectionWithString: aString	| result newPosition |	"I can't tell if this is a hack or if it's the right thing to do."	self setSelection: selectionInterval. 	result _ self correctFrom: selectionInterval first to: selectionInterval last with: aString.	newPosition _ selectionInterval first + aString size.	self setSelection: (newPosition to: newPosition - 1).	^ result! !!TextModelMorph methodsFor: 'layout' stamp: 'jcg 7/7/2000 11:08'!acceptDroppingMorph: aMorph event: evt 	"This message is sent when a morph is dropped onto a morph that has     	agreed to accept the dropped morph by responding 'true' to the     	wantsDroppedMorph:Event: message. The default implementation just     	adds the given morph to the receiver."	"Here we let the model do its work."	self model		acceptDroppingMorph: aMorph		event: evt		inMorph: self.! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 10/25/2010 20:58'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	^self yellowButtonActivity: false! !!TextModelMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval _ sel! !!TextModelMorph methodsFor: 'model access' stamp: 'sw 2/6/2001 01:24'!setTextColor: aColor	"Set the color of my text to the given color"	textMorph color: aColor! !!TextModelMorph methodsFor: 'scroll bar events' stamp: 'rr 3/10/2004 09:29'!yellowButtonActivity: shiftKeyState	"Invoke the text-editing menu"	| menu |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu invokeModal]! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'di 4/20/1998 18:53'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 22:55'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 22:55'!hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!TextModelMorph methodsFor: 'scrolling' stamp: 'jmv 10/1/2009 09:48'!hTotalScrollRange"Return the width of the widest item in the list"	textMorph ifNil: [ ^0 ].	textMorph isWrapped ifTrue:[ ^0 ].	^super hTotalScrollRange! !!TextModelMorph methodsFor: 'scrolling' stamp: 'jmv 9/30/2009 11:46'!mightNeedHorizontalScrollBar	textMorph ifNil: [ ^false ].	textMorph isWrapped ifTrue: [ ^false ].	^super mightNeedHorizontalScrollBar! !!TextModelMorph methodsFor: 'focus handling' stamp: 'jmv 11/12/2008 10:16'!focusText	self activeHand newKeyboardFocus: textMorph! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 8/18/2009 22:47'!styler: anObject		styler := anObject! !!TextModelMorph methodsFor: 'notifications' stamp: 'jmv 9/18/2009 14:02'!possiblyChanged	"A hook for notificating possible interested parties	Not used in base system"! !