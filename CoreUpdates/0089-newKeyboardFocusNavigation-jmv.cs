'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 14 November 2008 at 12:51:39 pm'!!LightWidget methodsFor: 'events-processing' stamp: 'jmv 11/12/2008 13:27'!keyStroke: aKeyboardEvent	"Handle a keystroke event. 	As there are no EventHandlers in LightWidgets, all what this default implementation does	is to use some keystrokes to send keyboard focus to other widgets.	Therefore, subclasses should only call super for events that were not handled,	to activate this default behavior."	aKeyboardEvent keyValue caseOf: {		[ 28 ] -> [			aKeyboardEvent hand keyboardFocusPrevious ].		[ 29 ] -> [			aKeyboardEvent hand keyboardFocusNext ].		[ 30 ] -> [			aKeyboardEvent hand keyboardFocusPrevious ].		[ 31 ] -> [			aKeyboardEvent hand keyboardFocusNext ] }		otherwise: []! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 11/12/2008 12:35'!keyStroke: anEvent			anEvent keyValue = 13 ifTrue: [		self performAction.		^self updateView].	"Call super for ignored keys"	super keyStroke: anEvent! !!ButtonLW methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:32'!mouseDown: evt	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self ].	pressed _ true.	self updateView! !!CheckBoxLW methodsFor: 'event handling' stamp: 'jmv 11/12/2008 12:35'!keyStroke: anEvent			anEvent keyValue = 13 ifTrue: [		selected _ selected not.		target perform: action with: selected.		^self updateView].	"Call super for ignored keys"	super keyStroke: anEvent! !!CheckBoxLW methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:31'!mouseDown: evt	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self ]! !!CheckBoxLW methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:33'!mouseUp: evt	"Handle a mouse up event."	(self containsPoint: evt cursorPoint) ifTrue: [		selected _ selected not.		target perform: action with: selected.		self updateView]! !!EntryFieldLW methodsFor: 'events-processing' stamp: 'jmv 11/12/2008 13:23'!keyStroke: aKeyboardEvent	| c |	aKeyboardEvent commandKeyPressed  ifTrue:[^super keyStroke: aKeyboardEvent].	target isNil ifTrue:[ ^ self].		c _ aKeyboardEvent keyCharacter.	( aKeyboardEvent shiftPressed and:[ c isLetter not] ) ifTrue:[^ self selectionChanged: aKeyboardEvent].	c = Character arrowRight ifTrue:[^ self moveCursorForth].	c = Character arrowLeft ifTrue:[ ^ self moveCursorBack].	c = Character backspace ifTrue:[^ self backspaceEntered].	c = Character delete ifTrue:[^self deleteEntered].	c = Character end ifTrue:[ ^ self moveCursorToEnd].	c = Character home ifTrue:[ ^ self moveCursorToBeggining].	c  = Character escape ifTrue:[^ self escapeEntered].	c isSeparator ifTrue:[^self separatorEntered:c].	c asciiValue >= 32		ifTrue: [ self characterEntered: c ]		ifFalse: [			"Call super for ignored keys"			^ super keyStroke: aKeyboardEvent]! !!MenuListLW methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:36'!mouseDown: evt	| y current |	current _ ActiveHand keyboardFocus.	(current notNil and: [current owner == self]) ifTrue: [		y _ evt position y.		y - bounds top < 30 ifTrue: [			evt hand keyboardFocusPrevious ].		bounds bottom - y < 30 ifTrue: [			evt hand keyboardFocusNext ]	]	! !!OldMorph methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:03'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	(anEvent commandKeyPressed and: [ self focusKeyboardFor: anEvent ])		ifTrue: [ ^ self ].	self eventHandler ifNotNil:		[self eventHandler keyStroke: anEvent fromMorph: self].! !!OldMorph methodsFor: 'events-processing' stamp: 'jmv 11/12/2008 12:59'!focusKeyboardFor: aKeyboardEvent	"If aKeyboardEvent is an arrow key, use it to navigate keyboard focus"	^aKeyboardEvent keyValue caseOf: {		[ 28 ] -> [			aKeyboardEvent hand keyboardFocusPrevious.			true ].		[ 29 ] -> [			aKeyboardEvent hand keyboardFocusNext.			true ].		[ 30 ] -> [			aKeyboardEvent hand keyboardFocusPrevious.			true ].		[ 31 ] -> [			aKeyboardEvent hand keyboardFocusNext.			true ] }		otherwise: [ false ]! !!OldHandMorph methodsFor: 'events-processing' stamp: 'jmv 11/12/2008 13:30'!handleEvent: anEvent	| evt ofs |	owner ifNil:[^self].	evt _ anEvent.	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[	Display fill: (0@0 extent: 250@120) rule: Form over fillColor: Color white.	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	self keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!OldOneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:00'!keyStroke: evt	"Handle a keystroke event."	(evt commandKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	"CR - check for special action	Note: Code below assumes that this was some	input field reacting on CR. Break the keyboard	focus so that the receiver can be safely deleted.	jmv - Currently not implemented"	"	evt keyValue = 13 ifTrue: [		action _ self crAction.		action ifNotNil: [			evt hand newKeyboardFocus: nil.			^action value ] ].	"	self handleInteraction: [editor readKeyboard] fromEvent: evt.	self updateFromContents.	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!OldScrollPane methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:03'!keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	(evt commandKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	(self scrollByKeyboard: evt) ifTrue: [^self].	scroller submorphs last keyStroke: evt! !!OldPluggableListMorph methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:02'!keyStroke: event 	"Process keys 	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"		| aChar aSpecialKey |	(event commandKeyPressed and: [ self focusKeyboardFor: event ])		ifTrue: [ ^ self ].	(self scrollByKeyboard: event) ifTrue: [^self].	aChar _ event keyCharacter.	aSpecialKey _ aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!OldPluggableTextMorph methodsFor: 'event handling' stamp: 'jmv 11/12/2008 12:55'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(evt commandKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	textMorph keyStroke: evt.	self eventHandler ifNotNil:		[self eventHandler keyStroke: evt fromMorph: self].! !!OldSimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/12/2008 12:55'!keyStroke: event 	"Process potential command keys"	| args aCharacter |	(event commandKeyPressed and: [ self focusKeyboardFor: event ])		ifTrue: [ ^ self ].	(self scrollByKeyboard: event) ifTrue: [^self].	aCharacter := event keyCharacter.	keystrokeActionSelector isNil ifTrue: [^self arrowKey: aCharacter].	(args := keystrokeActionSelector numArgs) = 1 		ifTrue: [^model perform: keystrokeActionSelector with: aCharacter].	args = 2 		ifTrue: 			[^model 				perform: keystrokeActionSelector				with: aCharacter				with: self].	^self 		error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!OldTextMorph methodsFor: 'event handling' stamp: 'jmv 11/12/2008 12:56'!keyStroke: evt	"Handle a keystroke event."	| action |	(evt commandKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	evt keyValue = 13 ifTrue:["CR - check for special action"		action _ self crAction.		action ifNotNil:[			"Note: Code below assumes that this was some			input field reacting on CR. Break the keyboard			focus so that the receiver can be safely deleted."			evt hand newKeyboardFocus: nil.			^action value]].	self handleInteraction: [editor readKeyboard] fromEvent: evt.	self updateFromParagraph.	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!OldStringMorphEditor methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:00'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor oldSel newSel |	(evt commandKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	oldSel _ self editor selectionInterval.	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	oldSel = newSel ifTrue:		["There is a bug that causes characters to be misplaced when the second		character typed is wider than the first.  This fixes it (ugh)."		self editor selectFrom: newSel first + 1 to: newSel last + 1].! !!OldTextMorphForEditView methodsFor: 'event handling' stamp: 'jmv 11/12/2008 13:00'!keyStroke: evt	| view |	(evt commandKeyPressed and: [ self focusKeyboardFor: evt ])		ifTrue: [ ^ self ].	(editView scrollByKeyboard: evt) ifTrue: [^self].	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!SliderLW methodsFor: 'event handling' stamp: 'jmv 11/12/2008 11:11'!keyDown: evt	"Handle a keystroke event."	(evt  keyCharacter = Character arrowRight) ifTrue: [self cursorMovedForth].	(evt  keyCharacter = Character arrowLeft) ifTrue: [self cursorMovedBack].	super keyStroke: evt	 ! !!TextEntryFieldLW methodsFor: 'events-processing' stamp: 'jmv 11/12/2008 13:23'!keyStroke: aKeyboardEvent	| c |	aKeyboardEvent commandKeyPressed  ifTrue:[^super keyStroke: aKeyboardEvent].	target isNil ifTrue:[ ^ self].	c _ aKeyboardEvent keyCharacter.	( aKeyboardEvent shiftPressed and:[ c isLetter not] ) ifTrue:[^ self selectionChanged: aKeyboardEvent].	c = Character arrowRight ifTrue:[^ self moveCursorForth].	c = Character arrowLeft ifTrue:[ ^ self moveCursorBack].	c = Character backspace ifTrue:[^ self backspaceEntered].	c = Character delete ifTrue:[^self backspaceEntered].	c = Character end ifTrue:[ ^ self moveCursorToEnd].	c = Character home ifTrue:[ ^ self moveCursorToBeggining].	c  = Character escape ifTrue:[^ self escapeEntered].	c isSeparator ifTrue:[^self separatorEntered:c].		c asciiValue >= 32		ifTrue: [ self characterEntered: c ]		ifFalse: [			"Call super for ignored keys"			^ super keyStroke: aKeyboardEvent]! !MenuItemLW removeSelector: #mouseUp:!