'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 5 August 2011 at 7:37:17 pm'!!classDefinition: #ClosureExtractor category: #'Kernel-Methods'!InstructionClient subclass: #ClosureExtractor	instanceVariableNames: 'action scanner'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!ClosureExtractor commentStamp: 'mha 9/21/2010 11:16' prior: 0!A ClosureExtractor is a utility class that is used to extract all BlockClosures from a CompiledMethod. It inherits from InstructionClient and understands only one single message, namely that corresponding to the push closure bytecode instruction. Being sent this message, a ClosureExtractor will create a BlockClosure instance and evaluate the block it holds as an instance variable with that closure as parameter.!!classDefinition: #Process category: #'Kernel-Processes'!Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList errorHandler name threadId '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Process commentStamp: 'jmv 8/5/2011 18:26' prior: 0!I represent an independent path of control in the system. This path of control may be stopped (by sending the message suspend) in such a way that it can later be restarted (by sending the message resume). When any one of several paths of control can be advanced, the single instance of ProcessorScheduler named Processor determines which one will actually be advanced partly using the value of priority.The threadId variable is used by multi-threaded CogVMs to control process-to-thread binding. It's required to be the fourth instance variable. See SystemDictionary >> #processHasThreadIdInstVar: for further information.(If anyone ever makes a subclass of Process, be sure to use allSubInstances in anyProcessesAbove:.)!!ProtoObject methodsFor: 'debugging' stamp: 'jmv 8/5/2011 19:20'!withArgs: argArray executeMethod: compiledMethod	"Execute compiledMethod against the receiver and args in argArray"	<primitive: 188>	self primitiveFailed! !!Object methodsFor: 'events-removing' stamp: 'jmv 8/5/2011 15:55'!removeActionsSatisfying: aOneArgBlock forEvent: anEventSelector	self		setActionSequence:			((self actionSequenceForEvent: anEventSelector)				reject: aOneArgBlock)		forEvent: anEventSelector! !!Object methodsFor: 'message handling' stamp: 'jmv 8/5/2011 19:23'!executeMethod: compiledMethod	"Execute compiledMethod against the receiver with no args"	<primitive: 189>	^ self withArgs: #() executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'jmv 8/5/2011 19:23'!with: arg1 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1"	<primitive: 189>	^ self withArgs: {arg1} executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'jmv 8/5/2011 19:23'!with: arg1 with: arg2 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1 & arg2"	<primitive: 189>	^ self withArgs: {arg1. arg2} executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'jmv 8/5/2011 19:23'!with: arg1 with: arg2 with: arg3 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1, arg2, & arg3"	<primitive: 189>	^ self withArgs: {arg1. arg2. arg3} executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'jmv 8/5/2011 19:23'!with: arg1 with: arg2 with: arg3 with: arg4 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1, arg2, arg3, & arg4"	<primitive: 189>	^ self withArgs: {arg1. arg2. arg3. arg4} executeMethod: compiledMethod! !!BitBlt methodsFor: 'private' stamp: 'jmv 8/27/2009 08:48'!colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"		| srcIndex map mapsForSource mapsForSourceAndDest |	ColorConvertingMaps 		ifNil: [ColorConvertingMaps _ (1 to: 10) collect: [:i | Array new: 32]].			srcIndex _ sourceDepth.	sourceDepth > 8 ifTrue: [ srcIndex _ keepSubPix ifTrue: [9] ifFalse: [10] ].	mapsForSource _ ColorConvertingMaps at: srcIndex.	(mapsForSourceAndDest _ mapsForSource at: destDepth) ifNil: [		mapsForSourceAndDest _ mapsForSource at: destDepth put: Dictionary new ].		map _ mapsForSourceAndDest at: targetColor ifAbsentPut: [		Color 			computeColorConvertingMap: targetColor 			from: sourceDepth 			to: destDepth 			keepSubPixelAA: keepSubPix ].	^ map! !!BlockClosure methodsFor: 'accessing' stamp: 'jmv 8/5/2011 18:30'!size	"Extract this closure's bytecode size (number of bytes) by accessing the closure	creation bytecode in the enclosing method."		^ ((self method at: self startpc - 2) bitShift: 8) + (self method at: self startpc - 1)! !!BlockClosure methodsFor: 'evaluating' stamp: 'jmv 8/5/2011 15:52'!valueSupplyingAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^self		on: ProvideAnswerNotification		do: [ :notification |			| caption |			caption := notification messageText withSeparatorsCompacted. "to remove new lines"			aListOfPairs				detect:  [ :each |					caption = each first						or: [ (caption includesSubstring: each first caseSensitive: false)						or: [ each first match: caption ] ] ]				ifFound: [ :answer | notification resume: answer second ]				ifNone: [					(ProvideAnswerNotification signal: notification messageText)						ifNil: [ notification resume ]						ifNotNil: [ :outerAnswer | notification resume: outerAnswer ] ] ]! !!BlockClosure methodsFor: 'exceptions' stamp: 'jmv 8/5/2011 15:45'!on: exc1 do: block1 on: exc2 do: block2	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2! !!BlockClosure methodsFor: 'exceptions' stamp: 'jmv 8/5/2011 15:46'!on: exc1 do: block1 on: exc2 do: block2 on: exc3 do: block3	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2		on: exc3		do: block3! !!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'jmv 8/5/2011 19:31'!tempCountForBlockAt: pc in: method	"Compute the number of local temporaries in a block.	 If the block begins with a sequence of push: nil bytecodes then some of	 These could be initializing local temps.  We can only reliably disambuguate	 them from other uses of nil by parsing the stack and seeing what the offset	 of the stack pointer is at the end of the block.	 There are short-cuts.  The ones we take here are		- if there is no sequence of push nils there can be no local temps		- we follow forward jumps to shorten the amount of scanning"	stackPointer := 0.	scanner := InstructionStream new method: method pc: pc.	scanner interpretNextInstructionFor: self.	blockEnd ifNil:		[self error: 'pc is not that of a block'].	scanner nextByte = Encoder pushNilCode ifTrue:		[joinOffsets := Dictionary new.		 [scanner pc < blockEnd] whileTrue:			[scanner interpretNextInstructionFor: self]].	^stackPointer! !!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'jmv 8/5/2011 19:31'!testTempCountForBlockAt: startPc in: method	"Compute the number of local temporaries in a block.	 If the block begins with a sequence of push: nil bytecodes then some of	 These could be initializing local temps.  We can only reliably disambuguate	 them from other uses of nil by parsing the stack and seeing what the offset	 of the stack pointer is at the end of the block.There are short-cuts.  The only	 one we take here is		- if there is no sequence of push nils there can be no local temps"	| symbolicLines line prior thePc |	symbolicLines := Dictionary new.	method symbolicLinesDo:		[:pc :lineForPC| symbolicLines at: pc put: lineForPC].	stackPointer := 0.	scanner := InstructionStream new method: method pc: startPc.	scanner interpretNextInstructionFor: self.	blockEnd ifNil:		[self error: 'pc is not that of a block'].	scanner nextByte = Encoder pushNilCode ifTrue:		[joinOffsets := Dictionary new.		 [scanner pc < blockEnd] whileTrue:			[line := symbolicLines at: scanner pc.			 prior := stackPointer.			 thePc := scanner pc.			 scanner interpretNextInstructionFor: self.			 Transcript cr; print: prior; nextPutAll: '->'; print: stackPointer;  tab; print: thePc; tab; nextPutAll: line]].	^stackPointer! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 8/5/2011 16:03'!selectSuchThat: aBlock	"select all changes for which block returns true"	listSelections _ changeList collect: aBlock.	self changed: #allSelections! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:18'!action	^ action! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:18'!action: aBlock	action := aBlock! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:35'!scanner	^ scanner! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:35'!scanner: anInstructionStream	scanner := anInstructionStream! !!ClosureExtractor methodsFor: 'instruction decoding' stamp: 'mha 9/21/2010 13:25'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize		"Create a BlockClosure corresponding to the closure bytecode	and execute the action block with it. The created BlockClosure is only a pseudo value,	it is not populated with meaningful context and argument information."		action value:		(BlockClosure			outerContext: (MethodContext				sender: thisContext				receiver: self				method: scanner method				arguments: (Array new: scanner method numArgs))			startpc: scanner pc			numArgs: numArgs			copiedValues: (Array new: numCopied))! !!ClosureExtractor class methodsFor: 'instance creation' stamp: 'mha 9/21/2010 11:34'!withAction: aBlock andScanner: anInstructionStream	"The passed block must accept one value, which will be a BlockClosure."	^ self new action: aBlock; scanner: anInstructionStream! !!Collection methodsFor: 'enumerating' stamp: 'jmv 8/5/2011 15:49'!detect: aBlock ifFound: foundBlock ifNone: exceptionBlock 	"foundBlock takes one argument, the found object."	self 		do: [ :element | (aBlock value: element) ifTrue: [ ^foundBlock value: element ] ].	^exceptionBlock value! !!Debugger class methodsFor: 'opening' stamp: 'jmv 8/5/2011 15:18'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| errorWasInUIProcess |	Preferences logDebuggerStackToFile ifTrue: [		Smalltalk logError: title inContext: context to: 'CuisDebug.log'].	errorWasInUIProcess _ ProjectX newProcessIfUIX: process.	"schedule debugger in deferred UI message to address redraw	problems after opening a debugger e.g. from the testrunner."	WorldState addDeferredUIMessage: [ 		[	| debugger |			debugger _ self new process: process controller: nil context: context.			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			debugger errorWasInUIProcess: errorWasInUIProcess.		] on: Error do: [ :ex |			self primitiveError:				'Error while trying to open Debugger', String cr,				'Orginal error: ', 				title asString, '.', String cr,				'	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	process suspend! !!DecompilerTests methodsFor: 'utilities' stamp: 'jmv 8/5/2011 18:41'!decompilerFailures	"here is the list of failures: DNU resulting in trying to decompile the following methods"	^ #((AdditionalMethodState at:ifAbsent:)		(AdditionalMethodState at:ifAbsentPut:)		(AdditionalMethodState at:put:)		(AdditionalMethodState hasLiteralSuchThat:)		(AdditionalMethodState hasLiteralThorough:)		(AdditionalMethodState includesProperty:)		(AdditionalMethodState keysAndValuesDo:)		(AdditionalMethodState pragmas)		(AdditionalMethodState properties)		(AdditionalMethodState propertyKeysAndValuesDo:)		(AdditionalMethodState propertyValueAt:ifAbsent:)		(AdditionalMethodState removeKey:ifAbsent:)		(AdditionalMethodState setMethod:)		(BalloonEngineSimulation circleCosTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		 (BalloonEngineSimulation circleSinTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		(BlockNode emitCodeExceptLast:encoder:)		(BlockNode sizeCodeExceptLast:)		(Categorizer changeFromCategorySpecs:)		(Categorizer elementCategoryDict)		(ChatNotes storeAIFFOnFile:)		(ClosureTests testToDoInsideTemp)		(Command veryDeepFixupWith:)		(CompiledMethod =)		(CompiledMethod getPreambleFrom:at:)		(CompiledMethod hasLiteralSuchThat:)		(CompiledMethod hasLiteralThorough:)		(CompiledMethod sameTraitCodeAs:)		(Date printOn:)		(DependencyBrowser computePackageDependencies:)		(EventSensor eventTickler)		(Float printPaddedWith:to:)		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(Form preMultiplyAlpha)		(FTPClient getDataInto:)		 (GeniePlugin primSameClassAbsoluteStrokeDistanceMyPoints:otherPoints:myVectors:otherVectors:mySquaredLengths:otherSquaredLengths:myAngles:otherAngles:maxSizeAndReferenceFlag:rowBase:rowInsertRemove:rowInsertRemoveCount: "Cannot compile -- stack including temps is too deep")		(GZipReadStream on:from:to:)		(GraphMorph drawDataOn:)		(HttpUrl checkAuthorization:retry:)		(Integer asBytesDescription)		(IntegerTest testNumberOfDigits)		(IntegerTest testPrintStringBase)		(JPEGReadWriter decodeBlockInto:component:dcTable:acTable:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(MessageTally treePrintOn:tabs:thisTab:total:totalTime:tallyExact:orThreshold:)		(MessageTrace selectAllBetweenAnchorAnd:)		(MethodPragmaTest testCompileCharacter)		(MultiByteBinaryOrTextStream next:)		(MultiByteFileStream next:)		(MVCProject textWindows)		(MVCToolBuilder setLayout:in:)		(Paragraph selectionRectsFrom:to:)		(PackageDependencyTest testPackage:dependsExactlyOn:)		(PasteUpMorph dropFiles:)		(Player veryDeepFixupWith:)		(PluggableTabButtonMorph calculateArcLengths)		(PluggableTabButtonMorph drawTabOn:)		(PluckedSound reset)		(PNGReadWriter copyPixelsGray:)		(PNGReadWriter processInterlaced)		(PNMReadWriter nextPutRGB:)		(PNMReadWriter nextPutBW:reverse:)		(PNMReadWriter readBWreverse:)		(PNMReadWriter readGray)		(PNMReadWriter readPlainRGB)		(PNMReadWriter writeHeader:)		(PointTest testTheta)		(PopUpMenu readKeyboard)		(PostscriptCanvas outlineQuadraticBezierShape:)		(QPickable2D pick:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(QUsersPane userEntryCompare:to:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(RelativeInstructionPrinter print:)		(RemoteHandMorph appendNewDataToReceiveBuffer)		(ScaledDecimalTest testConvertFromFraction)		(SHMCClassDefinition allInstVarNames)		(SHMCClassDefinition withAllSuperclasses)		(ShortIntegerArray writeOn:)		(SHParserST80 isBinary)		(StandardScriptingSystem holderWithAlphabet)		(StrikeFontSet displayStringR2L:on:from:to:at:kern:)		(String howManyMatch:)		(String keywords)		(StringTest testWthNoLineLongerThan)		(SyntaxMorph replaceKeyWord:menuItem:)		(SyntaxMorph replaceSel:menuItem:)		(TextDiffBuilder lcsFor:and:)		(TextURL actOnClickFor:)		(TShaderProgram vertexStrings) "foo ifTrue: []. => foo. => ."		(TShaderProgram fragmentStrings) "foo ifTrue: []. => foo. => ."		(TTContourConstruction segmentsDo:) "out of scope variable"		(TTCFontReader processCharacterMappingTable:)		(TTFileDescription getGlyphFlagsFrom:size:)		(TTFileDescription processCharacterMappingTable:)		(TTFontReader getGlyphFlagsFrom:size:)		(TTFontReader processCharacterMappingTable:)		(TTFontReader processHorizontalMetricsTable:length:)		(TWindow zoomWindow:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(WaveEditor showEnvelope)		(WeakSet scanForLoadedSymbol:)		"(PNMReadWriter nextImage) (Collection #ifEmpty:ifNotEmpty:) (Collection #ifEmpty:) (Collection #ifNotEmpty:ifEmpty:) (Text #alignmentAt:ifAbsent:) (ObjectWithDocumentation propertyAt:ifAbsent:)")! !!InstructionStream methodsFor: 'scanning' stamp: 'jmv 8/5/2011 18:46'!scanFor: scanBlock	"Check all bytecode instructions with scanBlock, answer true if scanBlock answers true.	This can be used to, e.g., check whether a method contains 'push closure' bytecodes like this:	aMethod scanFor: [ :b | b = 143 ]"	| method end byte |	method := self method.	end := method endPC.	[pc <= end] whileTrue: 		[(scanBlock value: (byte := method at: pc)) ifTrue:			[^true].		 pc := self nextPc: byte].	^false! !!BlockContext methodsFor: 'evaluating' stamp: 'jmv 8/5/2011 15:54'!valueSupplyingAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^self		on: ProvideAnswerNotification		do: [ :notification |			| caption |			caption := notification messageText withSeparatorsCompacted. "to remove new lines"			aListOfPairs				detect:  [ :each |					caption = each first						or: [ (caption includesSubstring: each first caseSensitive: false)						or: [ each first match: caption ] ] ]				ifFound: [ :answer | notification resume: answer second ]				ifNone: [					(ProvideAnswerNotification signal: notification messageText)						ifNil: [ notification resume ]						ifNotNil: [ :outerAnswer | notification resume: outerAnswer ] ] ]! !!BlockContext methodsFor: 'exceptions' stamp: 'jmv 8/5/2011 15:46'!on: exc1 do: block1 on: exc2 do: block2	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2! !!BlockContext methodsFor: 'exceptions' stamp: 'jmv 8/5/2011 15:46'!on: exc1 do: block1 on: exc2 do: block2 on: exc3 do: block3	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2		on: exc3		do: block3! !!MessageSet class methodsFor: 'utilities' stamp: 'jmv 8/5/2011 17:46'!parse: methodRef toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	self flag: #mref.	"compatibility with pre-MethodReference lists"	methodRef ifNil: [^ csBlock value: nil value: nil].	(methodRef isKindOf: MethodReference) ifTrue: [		^methodRef setClassAndSelectorIn: csBlock	].	methodRef isEmpty ifTrue: [^ csBlock value: nil value: nil].	tuple _ methodRef asString findTokens: ' .'.	cl _ Smalltalk at: tuple first asSymbol ifAbsent: [^ csBlock value: nil value: nil].	(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [^ csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [^ csBlock value: cl class value: (tuple at: 3) asSymbol]! !!MethodContext methodsFor: 'testing' stamp: 'jmv 8/5/2011 18:47'!atEnd	^ self isExecutingBlock		ifTrue: [ self closure startpc + self closure size - 1 = self pc ]		ifFalse: [ self pc >= self method endPC ]! !!MethodReference methodsFor: 'queries' stamp: 'jmv 8/5/2011 17:45'!actualClass 	^Smalltalk at: classSymbol ifPresent: [ :actualClass |		classIsMeta			ifTrue: [ actualClass class ]			ifFalse: [ actualClass ] ]! !!CodeWindow methodsFor: 'misc' stamp: 'jmv 8/5/2011 16:05'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages |	(selector _ model selectedMessageName) ifNil: [^ self].	method _ (model selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: nil.	(method isNil or: [(messages _ method messages) size = 0])		 ifTrue: [^ aBlock value: selector].	(messages size = 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	Smalltalk		showMenuOf: messages		withFirstItem: selector		ifChosenDo: aBlock! !!IndentingListItemMorph methodsFor: 'enumeration' stamp: 'jmv 8/5/2011 16:04'!childrenDo: aBlock	firstChild ifNotNil: [		firstChild withSiblingsDo: aBlock ]! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 8/5/2011 17:29'!drawOn: aCanvas	| |	listItems size = 0 ifTrue: [ ^self ]. 	self drawSelectionOn: aCanvas.	(self topVisibleRowForCanvas: aCanvas) to: (self bottomVisibleRowForCanvas: aCanvas) do: [ :row |		(listSource itemSelectedAmongMultiple:  row) ifTrue: [			self drawBackgroundForMulti: row on: aCanvas. ].		self display: (self item: row) asStringOrText atRow: row on: aCanvas.	].	listSource potentialDropRow > 0 ifTrue: [		self highlightPotentialDropRow: listSource potentialDropRow on: aCanvas ].! !!LazyListMorph methodsFor: 'scroll range' stamp: 'jmv 10/1/2009 09:47'!hTotalScrollRange"Ok, this is a bit messed up. We need to return the width of the widest item in the list. If we grab every item in the list, it defeats the purpose of LazyListMorph. If we don't, then we don't know the size. This is a compromise -- if the list is less then 30 items, we grab them all. If not, we grab currently visible ones, until we've checked itemsToCheck of them, then take the max width out of that 'sampling', then double it. If you know a better way, please chime in."	| maxW count itemsToCheck item |	itemsToCheck _ 30.	maxW _ 0. 	count _ 0.	listItems do: 		[ :each |			each ifNotNil: 				[maxW _ maxW max: (self widthToDisplayItem: each contents)]].					(count < itemsToCheck) ifTrue:		[1 to: listItems size do: 			[:i | (listItems at: i) ifNil: 							[item _ self item: i.							maxW _ maxW max: (self widthToDisplayItem: item contents).							((count _ count + 1) > itemsToCheck) ifTrue:[ ^maxW * 2]]]].		^maxW ! !!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 8/5/2011 15:59'!becomeActiveDuring: aBlock	"Make the receiver the ActiveWorld during the evaluation of aBlock.	Note that this method does deliberately *not* use #ensure: to prevent	re-installation of the world on project switches."	| priorWorld priorHand priorEvent |	priorWorld _ ActiveWorld.	priorHand _ ActiveHand.	priorEvent _ ActiveEvent.	ActiveWorld _ self.	ActiveHand _ self hands first. "default"	ActiveEvent _ nil. "not in event cycle"	aBlock		on: Error		do: [:ex | 			ActiveWorld _ priorWorld.			ActiveEvent _ priorEvent.			ActiveHand _ priorHand.			ex pass]! !!RemoteString methodsFor: 'accessing' stamp: 'jmv 8/5/2011 17:59'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	theFile := (SourceFiles at: (sourceFileNumber ifNil: [ ^nil ])) ifNil: [ ^nil ].	theFile size < filePositionHi ifTrue: [		self error: 'RemoteString past end of file' ].	^theFile		position: filePositionHi;		nextChunkText! !!Scanner methodsFor: 'expression types' stamp: 'jmv 8/5/2011 18:01'!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment ifNotNil:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark ifNotNil:		[(token == #- 		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType == #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType == #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])				ifTrue: 					[self scanLitWord.					 token == #true ifTrue: [token := true].					 token == #false ifTrue: [token := false].					 token == #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(self typeTableAt: hereChar) == #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken ] repeat! !!Scanner methodsFor: 'expression types' stamp: 'jmv 8/5/2011 18:02'!scanLitByteVec	| stream |	stream := (ByteArray new: 16) writeStream.	[ tokenType == #rightBracket or: [ tokenType == #doIt ] ] whileFalse: [		tokenType == #word			ifTrue: [ self scanLitWord ].		(token isInteger and: [ token between: 0 and: 255 ])			ifFalse: [ ^ self offEnd: '8-bit integer or right bracket expected' ].		stream nextPut: token.		self scanToken ].	token := stream contents! !!Scanner methodsFor: 'expression types' stamp: 'jmv 8/5/2011 18:02'!scanLitWord	"Accumulate keywords and asSymbol the result."	token := (String streamContents: [ :stream |		stream nextPutAll: token.		[ (self typeTableAt: hereChar) == #xLetter ] whileTrue: [			self xLetter.			stream nextPutAll: token ] ]) asSymbol! !!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 8/5/2011 18:57'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type := self typeTableAt: hereChar) == #xLetter		or: [type == #xDigit		or: [type == #xUnderscore and:[self allowUnderscoreSelectors]]]] whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar := aheadChar.			aheadChar := source atEnd							ifTrue: [30 asCharacter "doit"]							ifFalse: [source next]].	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])					ifTrue: 						[buffer nextPut: self step.						"Allow any number of embedded colons in literal symbols"						[(self typeTableAt: hereChar) == #xColon] whileTrue:							[buffer nextPut: self step].						#keyword]					ifFalse: 						[#word].	token := buffer contents! !!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 8/5/2011 18:06'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start := mark.	self step. "litQuote"	self scanToken.	tokenType == #leftParenthesis		ifTrue: [			self scanToken; scanLitVec.			mark := start + 1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: [			tokenType == #leftBracket				ifTrue: [					self scanToken; scanLitByteVec.					mark := start + 1.					tokenType == #doIt						ifTrue: [self offEnd: 'Unmatched bracket']]				ifFalse: [					(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])						ifTrue: [self scanLitWord]						ifFalse: [tokenType == #string							ifTrue: [token := token asSymbol]							ifFalse: [(tokenType == #binary or: [ tokenType == #verticalBar ]) 								ifFalse: [self notify: 'Invalid literal character' at: start + 1]]]]].	mark := start.	tokenType := #literal	"#(Pen)	#Pen	#'Pen'	##Pen	###Pen	"! !!Parser methodsFor: 'expression types' stamp: 'jmv 8/5/2011 18:58'!pattern: fromDoit inContext: ctxt	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>	{selector, arguments, precedence}."	| args selector |	doitFlag := fromDoit.	fromDoit ifTrue:		[^ctxt == nil			ifTrue: [{#DoIt. {}. 1}]			ifFalse: [{#DoItIn:. {encoder encodeVariable: encoder doItInContextName}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar]) ifTrue: 		[selector := self advance asSymbol.		args := Array with: (encoder bindArg: self argumentName).		^ {selector. args. 2}].	hereType == #keyword ifTrue: 		[selector := WriteStream on: (String new: 32).		args := OrderedCollection new.		[hereType == #keyword] whileTrue:[			selector nextPutAll: self advance.			args addLast: (encoder bindArg: self argumentName).		].		^ {selector contents asSymbol. args. 3}].	^self expected: 'Message pattern'! !!Parser methodsFor: 'public access' stamp: 'jmv 8/5/2011 19:32'!encoder	encoder ifNil:		[encoder := EncoderForV3PlusClosures new].	^encoder! !!Parser methodsFor: 'public access' stamp: 'jmv 8/5/2011 19:32'!encoderClass: anEncoderClass	encoder ifNotNil: [		self error: 'encoder already set'].	encoder := anEncoderClass new! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 8/5/2011 15:40'!polynomialEval: thisX	"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power."	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"	| index sum |	sum := self at: (index := self size).	[ (index := index - 1) >= 1 ] whileTrue: [		sum := sum * thisX + (self at: index) ].	^sum! !!CompiledMethod methodsFor: 'closures' stamp: 'jmv 8/5/2011 18:40'!containsBlockClosures	^ self scanner scanFor: [ :bc | bc = 143 "push closure bytecode" ]! !!CompiledMethod methodsFor: 'closures' stamp: 'jmv 8/5/2011 18:48'!embeddedBlockClosures	"	(CompiledMethod >> #embeddedBlockClosures)embeddedBlockClosures	"	| bms extractor scanner |	bms := OrderedCollection new.	scanner := self scanner.	extractor := ClosureExtractor withAction: [ :c | bms add: c ] andScanner: scanner.	[ scanner pc <= self endPC ] whileTrue: [ scanner interpretNextInstructionFor: extractor ].	^ bms! !!RunArray methodsFor: 'private' stamp: 'jmv 8/5/2011 15:42'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values _ values collect: mapBlock! !!SequentialSound methodsFor: 'copying' stamp: 'jmv 8/5/2011 16:00'!transformSounds: tfmBlock	"Private!! Support for copying. Copy my component sounds."	sounds _ sounds collect: tfmBlock! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 8/5/2011 15:24'!selectWord	"Select delimited text or word--the result of double-clicking."	| leftDelimiters rightDelimiters |	"Warning. Once me (jmv) added Character cr to the delimiters, to make double-click at and of line select whole line.	This had the bad effect that if a class name is the last word of a line, double-click would correctly select it, but after that,	doing ctrl-b to browse it would select the whole line..."	leftDelimiters _ '([{<|''"'.	rightDelimiters _ ')]}>|''"'.	^self selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters! !!Socket methodsFor: 'sending' stamp: 'jmv 8/5/2011 17:38'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	^ self sendSomeData: aStringOrByteArray startIndex: startIndex count: count for: Socket standardTimeout! !!SocketStream class methodsFor: 'instance creation' stamp: 'jmv 8/5/2011 17:26'!openConnectionToHost: hostIP port: portNumber	^ self openConnectionToHost: hostIP port: portNumber timeout: Socket standardTimeout! !!SocketStream class methodsFor: 'instance creation' stamp: 'jmv 8/5/2011 17:26'!openConnectionToHost: hostIP port: portNumber timeout: timeout	| socket |	socket := Socket new.	socket connectTo: hostIP port: portNumber waitForConnectionFor: timeout.	^self on: socket! !!String methodsFor: 'converting' stamp: 'jmv 8/5/2011 19:08'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end |				| pastEnd lineStart |				pastEnd := endWithoutDelimiters + 1.				"eliminate spaces at beginning of line"				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [pastEnd]) min: pastEnd.				[| lineStop lineEnd spacePosition |				lineEnd := lineStop  := lineStart + aNumber min: pastEnd..				spacePosition := lineStart.				[spacePosition < lineStop] whileTrue: [					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [pastEnd].					spacePosition <= lineStop ifTrue: [lineEnd := spacePosition].				].				"split before space or before lineStop if no space"				stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).				"eliminate spaces at beginning of next line"				lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd ifAbsent: [pastEnd].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: pastEnd to: end) ] ]		estimatedSize: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"! !!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 8/5/2011 18:52'!eliotsClosureMeasurementsOn: m over: aFiveArgBlock	"	See senders.	Or try something like:		Smalltalk			eliotsClosureMeasurementsOn: FileList >> #defaultContents			over: [ :closuresCount :hasCopiedValuesForClosure :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesUAR :anyClosureUsesSelf |				(Array with: closuresCount with: hasCopiedValuesForClosure with: hasIndirectTemps with: anyClosureHasCopied with: anyClosureDoesUAR with: anyClosureUsesSelf)]	From http://www.mirandabanda.org/cogblog/2008/11/14/mechanised-modifications-and-miscellaneous-measurements/	by Eliot Miranda		Note: This could perhaps be refactored to use the newer #embeddedBlockClosures and testing methods on the closures themselves.	"	| s nextScanStart thisClosureHasCopied closuresCount hasIndirectTemps blkPc blkSz anyClosureHasCopied anyClosureDoesUAR anyClosureUsesSelf analyzedClosures |	closuresCount := 0.	hasIndirectTemps := false.	anyClosureHasCopied :=  anyClosureDoesUAR := anyClosureUsesSelf := false.	s := InstructionStream on: m.	s scanFor: [ :b |		b = 16r8F "16r8F = 143 closure creation" ifTrue: [			closuresCount := closuresCount + 1].		(b = 16r8A "16r8A = 138indirect temp vector creation" and: [ s followingByte <= 127]) ifTrue: [				hasIndirectTemps := true].		false].	nextScanStart := m initialPC.	analyzedClosures := 0.	[ analyzedClosures < closuresCount ] whileTrue: [		s pc: nextScanStart; scanFor: [ :b | b = 16r8F ].	"16r8F = 143 Search for first closure"		analyzedClosures := analyzedClosures + 1.		thisClosureHasCopied := s followingByte >= 16r10.		anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.		blkSz := s interpretNextInstructionFor: BlockStartLocator new.		"Findout size of first closure"		blkPc := s pc.		s scanFor: [ :b |			s pc >= (blkPc + blkSz)				ifTrue: [					nextScanStart := s pc.					true]				ifFalse: [					b = 16r8F ifTrue: [									thisClosureHasCopied := s followingByte >= 16r10.						anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.						analyzedClosures := analyzedClosures + 1 ].					anyClosureDoesUAR := anyClosureDoesUAR or: [s willReturn and: [s willBlockReturn not]].					anyClosureUsesSelf := anyClosureUsesSelf or: [b = 16r70 "pushSelf"										or: [b < 16r10 "pushInstVar"										or: [(b = 16r80 and: [s followingByte <= 16r3F]) "pushInstVar"										or: [(b between: 16r60 and: 16r60 + 7) "storePopInstVar"										or: [(b = 16r82 and: [s followingByte <= 63]) "storePopInstVar"										or: [(b = 16r81 and: [s followingByte <= 63]) "storeInstVar"										or: [b = 16r84 and: [s followingByte = 160]]]]]]]].					false]]].	^aFiveArgBlock valueWithArguments: (Array			with: closuresCount			with: hasIndirectTemps			with: anyClosureHasCopied			with: anyClosureDoesUAR			with: anyClosureUsesSelf)! !!TempVariableNode methodsFor: 'code generation' stamp: 'jmv 8/5/2011 19:33'!sizeCodeForLoad: encoder	^remoteNode		ifNil: [0]		ifNotNil: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !!RemoteTempVectorNode methodsFor: 'printing' stamp: 'jmv 8/5/2011 19:32'!printDefinitionForClosureAnalysisOn: aStream 	| refs |	aStream		nextPut: ${;		nextPutAll: key.	definingScope ifNotNil: [definingScope blockExtent ifNotNil: [:be| aStream nextPutAll: ' d@'; print: be first]].	readingScopes ifNotNil: [		refs := Set new.		readingScopes do: [:elems| refs addAll: elems].		refs asSortedCollection do: [:read| aStream nextPutAll: ' r@'; print: read]].	remoteTemps		do: [:rt| rt printDefinitionForClosureAnalysisOn: aStream]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $}! !SystemDictionary removeSelector: #atOrBelow:ifAbsent:!CompiledMethod removeSelector: #allEmbeddedBlockMethods!CompiledMethod removeSelector: #embeddedBlockMethods!CompiledMethod removeSelector: #isBlockMethod!CompiledMethod removeSelector: #isBlockMethod:!CompiledMethod removeSelector: #isClosureCompiled:!CompiledMethod removeSelector: #method!CompiledMethod removeSelector: #remoteReturns!CompiledMethod removeSelector: #searchImageForHomeMethod!Process removeSelector: #errorHandler!Process removeSelector: #errorHandler:!!classDefinition: #Process category: #'Kernel-Processes'!Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList threadId name'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!Morph removeSelector: #submorphThat:ifNone:!Class removeSelector: #compileAll!