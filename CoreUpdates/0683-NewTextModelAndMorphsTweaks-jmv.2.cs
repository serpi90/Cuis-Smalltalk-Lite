'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 3 December 2010 at 3:03:30 pm'!!classDefinition: #PluggableTextModel category: #'System-Text'!TextModel subclass: #PluggableTextModel	instanceVariableNames: 'contentsProvider textProvider getTextSelector setTextSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!BareTextMorph methodsFor: 'private' stamp: 'jmv 12/3/2010 11:57'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	"release editor too"	editor ifNotNil: [		self selectionChanged.		editor _ nil].	paragraph ifNotNil: [		paragraph selectionStart: nil selectionStop: nil.	"most likely not needed"		paragraph _ nil]! !!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 12/3/2010 10:56'!is: aSymbol	aSymbol == #CodeProvider		ifTrue: [ ^textProvider is: aSymbol ].	^ aSymbol == #hasTextProvider or: [ super is: aSymbol ]! !!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 12/3/2010 10:56'!refusesToAccept	^textProvider refusesToAccept! !!PluggableTextModel methodsFor: 'self-updating' stamp: 'jmv 12/3/2010 10:56'!updatePaneIfNeeded	"revisar estos delegadores..."	textProvider updatePaneIfNeeded! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 12/3/2010 10:56'!forceRefetch	textProvider setContentsToForceRefetch.	actualContents _ textProvider acceptedContents: getTextSelector! !!PluggableTextModel methodsFor: 'updating' stamp: 'jmv 12/3/2010 10:55'!update: aSymbol	"We are being notified of a change in our provider.	Notify our dependents"	self changed: aSymbol! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/3/2010 11:00'!model: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	|styler answer |	answer _ self new.false ifTrue:[		self  == PluggableTextMorph ifTrue: [		answer _ TextModelMorph new ]].	(Preferences syntaxHighlightingAsYouType 			and: [ anObject respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel.	^answer! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/3/2010 11:00'!noShoutModel: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	| answer |	answer _ self new.false ifTrue:[		self  == PluggableTextMorph ifTrue: [		answer _ TextModelMorph new ]].	answer		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel.	^answer! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 12/3/2010 11:08'!model: o	"Set my model and make me me a dependent of the given object."	| anObject |	anObject _ o.	(anObject isKindOf: TextModel) ifFalse: [		self halt ].		super model: anObject.	textMorph		model: model wrappedTo: self viewableWidth.! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 12/3/2010 12:23'!model: aTextProvider textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	| newModel |	editorClass _ aTextProvider editorClass.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	self borderWidth: 1.""	(aTextProvider isKindOf: TextModel)		ifTrue: [			newModel _ aTextProvider ]		ifFalse: [			newModel _ PluggableTextModel on: aTextProvider.			newModel getTextSelector: getTextSelector setTextSelector: setTextSelector.			"?"			aTextProvider removeDependent: model.			aTextProvider addDependent: newModel.  			].""					self model: newModel.	model forceRefetch.	self maybeStyle.		self setSelection: self getSelection.! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 12/3/2010 12:16'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: [			model forceRefetch.			self maybeStyle.			"Some day, it would be nice to keep objects and update them			instead of throwing them away all the time for no good reason..."			textMorph releaseParagraph.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: self textProvider autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ]! !!TextMorph methodsFor: 'private' stamp: 'jmv 12/3/2010 11:57'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	"release editor too"	editor ifNotNil: [		self selectionChanged.		editor _ nil].	paragraph ifNotNil: [		paragraph selectionStart: nil selectionStop: nil.	"most likely not needed"		paragraph _ nil]! !!classDefinition: #PluggableTextModel category: #'System-Text'!TextModel subclass: #PluggableTextModel	instanceVariableNames: 'textProvider getTextSelector setTextSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!