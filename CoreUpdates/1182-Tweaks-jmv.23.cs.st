'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 28 December 2011 at 7:48:30 pm'!!Browser methodsFor: 'code pane' stamp: 'jmv 12/28/2011 19:31'! compileMessage: aText notifying: aController	"Compile the code that was accepted by the user, placing the compiled method into an appropriate message category.  Return true if the compilation succeeded, else false."	| fallBackCategory fallBackMessage originalSelectorName result |	self selectedMessageCategoryName ifNil: [		self selectOriginalCategoryForCurrentMethod 				ifFalse: [ "Select the '--all--' category"				self messageCategoryListIndex: 1]]. 	self selectedMessageCategoryName asSymbol == ClassOrganizer allCategory		ifTrue: [			"User tried to save a method while the ALL category was selected"			fallBackCategory _ selectedMessageCategory.			fallBackMessage _ selectedMessage.			editSelection == #newMessage				ifTrue: [					"Select the 'as yet unclassified' category"					selectedMessageCategory _ nil.					(result _ self defineMessageFrom: aText notifying: aController)						ifNil: [							"Compilation failure:  reselect the original category & method"							selectedMessageCategory _ fallBackCategory.							selectedMessage _ fallBackMessage ]						ifNotNil: [							self setSelector: result]]				ifFalse: [					originalSelectorName _ self selectedMessageName.					self setOriginalCategoryIndexForCurrentMethod.					selectedMessage _ fallBackMessage _ originalSelectorName.					(result _ self defineMessageFrom: aText notifying: aController)						ifNotNil: [							self setSelector: result]						ifNil: [							"Compilation failure:  reselect the original category & method"							selectedMessageCategory _ fallBackCategory.							selectedMessage _ fallBackMessage.							^ result notNil]].			self changed: #messageCategoryList.			^ result notNil]		ifFalse: [			"User tried to save a method while the ALL category was NOT selected"			^ (self defineMessageFrom: aText notifying: aController) notNil ]! !!Browser methodsFor: 'message category list' stamp: 'jmv 12/28/2011 19:31'!             messageCategoryListIndex	"Answer the index of the selected message category."	selectedMessageCategory ifNil: [ ^0 ].	selectedMessageCategory == ClassOrganizer allCategory ifTrue: [ ^1 ].	^(self classOrMetaClassOrganizer categories indexOf: selectedMessageCategory) + 1! !!Browser methodsFor: 'message category list' stamp: 'jmv 12/28/2011 19:32'!                             selectOriginalCategoryForCurrentMethod	"private - Select the message category for the current method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected. 	 	 Returns: true on success, false on failure."	| aSymbol selectorName |	aSymbol _ self categoryOfCurrentMethod.	selectorName _ self selectedMessageName.	(aSymbol notNil and: [aSymbol ~~ ClassOrganizer allCategory])		ifTrue: [			selectedMessageCategory _ aSymbol.			selectedMessage _ selectorName.			self changed: #messageCategorySelectionChanged.			self changed: #messageCategoryListIndex.	"update my selection"			self changed: #messageList.			self changed: #messageListIndex.			^ true].	^ false! !!Browser methodsFor: 'message list' stamp: 'jmv 12/28/2011 19:32'!                 messageList	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!), it is reset to zero."	| sel |	(sel _ self messageCategoryListSelection) ifNil: [		^ self classOrMetaClassOrganizer			ifNil: [ #() ]			ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]].	^ sel == ClassOrganizer allCategory		ifTrue:  [			self classOrMetaClassOrganizer				ifNil: [ #() ]				ifNotNil:	[ self classOrMetaClassOrganizer allMethodSelectors ]]		ifFalse: [			selectedMessageCategory				ifNil: [ #()]				ifNotNil: [					(self classOrMetaClassOrganizer listAtCategoryNamed: selectedMessageCategory)						ifNil: [							selectedMessageCategory _ nil.							#() ]]]! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:01'!                       currentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	| aList |	aList _ OrderedCollection new.	1 to: changeList size do: [ :i |		(listSelections at: i) ifTrue: [			| aClass aChange |			aChange _ changeList at: i.			(aChange type == #method				and: [(aClass _ aChange methodClass) notNil				and: [aClass includesSelector: aChange methodSelector]])					ifTrue: [						aList add: (							MethodReference new								setStandardClass: aClass  								methodSymbol: aChange methodSelector						)					]]].	^ aList! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:02'!                       destroyCurrentCodeOfSelections	"Actually remove from the system any in-memory methods with class and selector identical to items current selected.  This may seem rather arcane but believe me it has its great uses, when trying to split out code.  To use effectively, first file out a change set that you wish to split off.  Then open a ChangeList browser on that fileout.  Now look through the methods, and select any of them which you want to remove completely from the system, then issue this command.  For those methods where you have made changes to pre-existing versions, of course, you won't want to remove them from the system, so use this mechanism with care!!"	|  aClass aChange aList |	aList _ OrderedCollection new.	1 to: changeList size do:		[:index |			(listSelections at: index) ifTrue:				[aChange _ changeList at: index.				(aChange type == #method					and: [(aClass _ aChange methodClass) notNil					and: [aClass includesSelector: aChange methodSelector]])						ifTrue:							[aList add: {aClass. aChange methodSelector}]]].	aList size > 0 ifTrue:		[(self confirm: 'Warning!! This will actually remove ', aList size printString,  ' method(s) from the system!!') ifFalse: [^ self]].	aList do:		[:aPair | Transcript cr; show: 'Removed: ', aPair first printString, '.', aPair second.			aPair first removeSelector: aPair second]! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:02'!      selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	Cursor read showWhile: [		|  aClass aChange |		1 to: changeList size do: [ :i | 			aChange _ changeList at: i.			listSelections at: i put:				(aChange type == #method				and: [(aClass _ aChange methodClass) notNil				and: [ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:02'!  selectConflicts	"Selects all method definitions for which there is ALSO an entry in changes"	Cursor read showWhile: [		| change class  |		1 to: changeList size do: [ :i | 			change _ changeList at: i.			listSelections at: i put:				(change type == #method				and: [(class _ change methodClass) notNil				and: [(ChangeSet current atSelector: change methodSelector						class: class) ~~ #none]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:02'! selectConflicts: changeSetOrList	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList"	Cursor read showWhile: [		| change class systemChanges |		(changeSetOrList isKindOf: ChangeSet) ifTrue: [			1 to: changeList size do: [ :i | 				change _ changeList at: i.				listSelections at: i put:					(change type == #method					and: [(class _ change methodClass) notNil					and: [(changeSetOrList atSelector: change methodSelector						class: class) ~~ #none]])]]			ifFalse: ["a ChangeList"			1 to: changeList size do: [ :i | 				change _ changeList at: i.				listSelections at: i put:					(change type == #method					and: [(class _ change methodClass) notNil					and: [changeSetOrList list includes: (list at: i)]])]]	].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:02'!       selectEquivalentMethods	"Selects all method definitions for which there is already an equivalent method in the current image, 	(meaning that the difference is cosmetic and not in behavior)"	Cursor wait showWhile: [		1 to: changeList size do: [ :i | 			| change class |			change _ changeList at: i.			listSelections at: i put:				((change type == #method and: [					(class _ change methodClass) notNil]) and: [						(class includesSelector: change methodSelector) and: [							| cmWithNode |							cmWithNode _ [class basicCompile: change string notifying: nil trailer: class defaultMethodTrailer ifFail: nil] 								on: SyntaxErrorNotification do: [ :ex | ex return ].							(cmWithNode notNil and: [								| current inChange |								current _ (class compiledMethodAt: change methodSelector) copyWithTrailerBytes: #(0).								inChange _cmWithNode method copyWithTrailerBytes: #(0).								current = inChange or: [									| currentCmWithNode |									currentCmWithNode _ [class basicCompile: (class decompilerClass new decompile: change methodSelector in: class) decompileString											notifying: nil trailer: class defaultMethodTrailer ifFail: nil] on: SyntaxErrorNotification do: [ :ex | ex return ].									(currentCmWithNode notNil and: [										current _ currentCmWithNode method copyWithTrailerBytes: #(0).										current = inChange])								]							])						]]				)]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:02'!                selectMethodsForAbsentClasses	"Selects all method definitions for which there is no counterpart method in the current image"	Cursor read showWhile: [		| change |		1 to: changeList size do: [ :i | 			change _ changeList at: i.			listSelections at: i put:				((change type == #method and:					[change methodClass isNil]))]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:03'!            selectNewMethods	"Selects all method definitions for which there is no counterpart method in the current image"	Cursor read showWhile: [		| change class |		1 to: changeList size do: [ :i | 			change _ changeList at: i.			listSelections at: i put:				((change type == #method and:					[((class _ change methodClass) isNil) or:						[(class includesSelector: change methodSelector) not]]))]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/28/2011 19:03'!       selectUnchangedMethods	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"	Cursor read showWhile: [		| change class |		1 to: changeList size do: [ :i | 			change _ changeList at: i.			listSelections at: i put:				((change type == #method and:					[(class _ change methodClass) notNil]) and:						[(class includesSelector: change methodSelector) and:							[change string withBlanksCondensed = (class sourceCodeAt: change methodSelector) asString withBlanksCondensed ]])]].	self changed: #allSelections! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/28/2011 19:17'! fileOutChangesFor: class on: stream 	"Write out all the method changes for this class."	| changes |	changes _ Set new.	(self methodChangesAtClass: class name) associationsDo: 		[:mAssoc | (mAssoc value == #remove or: [mAssoc value == #addedThenRemoved])			ifFalse: [changes add: mAssoc key]].	changes isEmpty ifFalse: 		[class fileOutChangedMessages: changes on: stream.		stream cr]! !!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 12/28/2011 19:44'!             acceptedStringOrText	"return the source code that shows in the bottom pane"	| sel class strm changeType answer |	self changed: #clearUserEdits.	currentClassName ifNil: [^ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector)		ifNotNil: [			changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).changeType class == Symbol ifFalse: [	'' print.	thisContext printStack: 10 ].			changeType == #remove				ifTrue: [^'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^'Added then removed (see versions)'].			class ifNil: [^'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^'Method was added, but cannot be found!!'].			answer _  (class sourceCodeAt: sel).			(#(prettyPrint prettyLineDiffs prettyWordDiffs) includes: contentsSymbol) ifTrue: [				answer _ (class compilerClass new						format: answer						in: class 						notifying: nil)].			self showingAnyKindOfDiffs				ifTrue: [ answer _ (self diffFromPriorSourceFor: answer) ].			^ answer asText makeSelectorBoldIn: class ]		ifNil: [			strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do: [ :each |each class == Symbol ifFalse: [	'' print.	thisContext printStack: 10 ].				each == #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each == #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each == #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each == #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each == #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each == #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each == #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ strm contents].! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'jmv 12/28/2011 19:44'!                           noteChangeType: changeSymbol fromClass: classchangeSymbol class == Symbol ifFalse: [	'' print.	thisContext printStack: 10 ].	(changeSymbol == #new or: [changeSymbol == #add]) ifTrue: [		changeTypes add: #add.		changeTypes remove: #change ifAbsent: nil.		^ self].	changeSymbol == #change ifTrue: [		(changeTypes includes: #add) ifTrue: [^ self].		^ changeTypes add: changeSymbol].	changeSymbol == #addedThenRemoved ifTrue:		[^ self].  "An entire class was added but then removed"	changeSymbol == #comment ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol == #reorganize ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol == #rename ifTrue:		[^ changeTypes add: changeSymbol].	(changeSymbol beginsWith: 'oldName: ') ifTrue: [		"Must only be used when assimilating other changeSets"		(changeTypes includes: #add) ifTrue: [^ self].		priorName _ changeSymbol copyFrom: 'oldName: ' size + 1 to: changeSymbol size.		^ changeTypes add: #rename].	changeSymbol == #remove ifTrue: [		(changeTypes includes: #add)			ifTrue: [changeTypes add: #addedThenRemoved]			ifFalse: [changeTypes add: #remove].		^ changeTypes removeAllFoundIn: #(add change comment reorganize)].	self error: 'Unrecognized changeType'! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'jmv 12/28/2011 19:28'!          methodsInCategory: aSymbol 	"Answer a list of the methods of the receiver that are in category named aName"		| aColl |	aColl _ Set withAll: (aSymbol == ClassOrganizer allCategory			ifTrue: [self organization allMethodSelectors]			ifFalse: [self organization listAtCategoryNamed: aSymbol]).	^ aColl asArray sort! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 12/28/2011 19:30'!                    fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors _ (aSymbol == ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!ClassDescription methodsFor: 'method dictionary' stamp: 'jmv 12/28/2011 19:28'!                      allMethodsInCategory: aSymbol	"Answer a list of all the method categories of the receiver and all its superclasses"	| aColl |	aColl _ OrderedCollection new.	self withAllSuperclasses do:		[:aClass | aColl addAll:			(aSymbol == ClassOrganizer allCategory				ifTrue:					[aClass organization allMethodSelectors]				ifFalse:					[aClass organization listAtCategoryNamed: aSymbol])].	^ aColl asSet asSortedArray"TileMorph allMethodsInCategory: #initialization"! !!Categorizer class methodsFor: 'class initialization' stamp: 'jmv 12/28/2011 19:09'!                allCategory	"Return a symbol that represents the virtual all methods category."	^ #'-- all --'! !!Color class methodsFor: 'colormaps' stamp: 'jmv 12/26/2011 13:49'!                     computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.	keepSubPix		ifTrue: [ Answer colors that also include subpixelAA ]		ifFalse: [ 			Take fullpixel luminance level. Apply it to targetColor.			I.e. answer colors with NO subpixelAA ]"	| mask map c bitsPerColor r g b f v |	destDepth > 8		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"		ifFalse: [bitsPerColor _ 4].	"Usually a bit less is enough, but make it configurable"	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.	mask _ (1 bitShift: bitsPerColor) - 1.	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).	0 to: map size - 1 do: [:i |		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.		b _ (i bitShift: 0) bitAnd: mask.		f _ 1.0 - (r + g + b / 3.0 / mask).		c _ targetColor			ifNotNil: [				(keepSubPix and: [destDepth > 8]) ifTrue: [						Color							r: 1.0 - (r asFloat/mask) * targetColor red							g: 1.0 - (g asFloat/mask) * targetColor green							b: 1.0 - (b asFloat/mask) * targetColor blue							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]				ifFalse: [					destDepth = 32						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"		v _ destDepth = 32			ifTrue: [ c pixelValueForDepth: destDepth]			ifFalse: [				f < 0.1					ifTrue: [ 0 ]					ifFalse: [ c pixelValueForDepth: destDepth ]].		map at: i + 1 put: v ].	^ map! !!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/28/2011 19:22'!                         defaultSelector 	"Invent and answer an appropriate message selector (a Symbol) for me, 	that is, one that will parse with the correct number of arguments."	^#DoIt numArgs: self numArgs! !!CompositionScanner methodsFor: 'scanning' stamp: 'jmv 12/28/2011 19:05'!                     composeFrom: startIndex inRectangle: lineRectangle firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition xtraSpaceBefore spaceAfterParagraph |		lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font, style, etc"	"Set up margins"	leftMargin _ lineRectangle left.	rightMargin _ lineRectangle right.	xtraSpaceBefore _ 0.	spaceAfterParagraph _ 0.	paragraphStyle ifNotNil: [		leftSide ifTrue: [			leftMargin _ leftMargin +				((firstLine and: [ paragraphStyle isListStyle not ])					ifTrue: [ paragraphStyle firstIndent ]					ifFalse: [ paragraphStyle restIndent ])].		rightSide ifTrue: [			rightMargin _ rightMargin - paragraphStyle rightIndent].		firstLine ifTrue: [ xtraSpaceBefore _ paragraphStyle spaceBefore ].		spaceAfterParagraph _ paragraphStyle spaceAfter ].	destX _ spaceX _ leftMargin.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	line isFirstLine: firstLine.	spaceCount _ 0.	leftMargin _ destX.	line leftMargin: leftMargin.	done _ false.	self placeEmbeddedObject.	[ done ]		whileFalse: [			stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition) ifTrue: [				^ line 					lineHeight: lineHeight + xtraSpaceBefore + 						(stopCondition == #cr ifTrue: [spaceAfterParagraph] ifFalse: [0]) 					baseline: baseline + xtraSpaceBefore ]]! !!ContextPart methodsFor: 'printing' stamp: 'jmv 12/28/2011 19:45'!                   printOn: aStream 	| selector class mclass |	self method		ifNil: [^ super printOn: aStream].	class := self receiver class.	mclass := self methodClass.	selector := self selector ifNil: [ self method defaultSelector].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector.	selector == #doesNotUnderstand: ifTrue: [		aStream space.		(self tempAt: 1) selector printOn: aStream.	].! !!FileList methodsFor: 'private' stamp: 'jmv 12/28/2011 18:26'! sortBlock	"Answer block to decide what order to display the directory entries."	^ [ :xx :yy | | x y |		(xx isDirectory == yy isDirectory) 			ifTrue: [  				sortAscending					ifTrue: [ x _ xx. y _ yy ]					ifFalse: [ x _ yy. y _ xx ].				"sort by user-specified criterion"				sortMode = #name 					ifTrue: [(x name compare: y name) <= 2]					ifFalse: [ sortMode = #date						ifTrue: [ x modificationTime = y modificationTime								ifTrue: [ (x name compare: y name) <= 2 ]								ifFalse: [ x modificationTime <= y modificationTime ] ]						ifFalse: [ "size"							x fileSize = y fileSize 								ifTrue: [ (x name compare: y name) <= 2 ]								ifFalse: [ x fileSize <= y fileSize ] ] ] ]			ifFalse: [				"directories always precede files"				xx isDirectory ] ]! !!Integer methodsFor: 'arithmetic' stamp: 'jmv 12/24/2011 08:43'!         * aNumber	"Refer to the comment in Number * " 	aNumber isInteger ifTrue: [		^ self			digitMultiply: aNumber			neg: (self negative xor: aNumber negative) ].	^ aNumber adaptToInteger: self andSend: #*! !!MessageSet methodsFor: 'private' stamp: 'jmv 12/28/2011 19:42'!             contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].	class ifNil: [^ false].	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:		[oldSelector == #Comment ifTrue:			[class comment: aString stamp: Utilities changeStamp.			self changed: #annotation. 			self changed: #clearUserEdits.			^ false].		oldSelector == #Definition ifTrue:			["self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self changed: #clearUserEdits. 			^ false].		oldSelector == #Hierarchy ifTrue:			[self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector		ifNil: [^ false].	selector == oldSelector ifFalse: [		self reformulateListNoting: selector].	self changed: #annotation.	^ true! !!MethodReference methodsFor: 'setting' stamp: 'jmv 12/28/2011 19:00'!             setClass: aClass methodSymbol: methodSym stringVersion: aString 	classSymbol _ aClass theNonMetaClass name asSymbol.	classIsMeta _ aClass isMeta.	methodSymbol _ methodSym asSymbol.	stringVersion _ aString.! !!MethodReference methodsFor: 'setting' stamp: 'jmv 12/28/2011 18:59'!   setClassSymbol: classSym classIsMeta: isMeta methodSymbol: methodSym stringVersion: aString 	classSymbol _ classSym asSymbol.	classIsMeta _ isMeta.	methodSymbol _ methodSym asSymbol.	stringVersion _ aString! !!MethodReference methodsFor: 'setting' stamp: 'jmv 12/28/2011 19:00'!  setStandardClass: aClass methodSymbol: methodSym	classSymbol _ aClass theNonMetaClass name asSymbol.	classIsMeta _ aClass isMeta.	methodSymbol _ methodSym asSymbol.	stringVersion _ aClass name , ' ' , methodSym.! !!MethodReference methodsFor: 'comparisons' stamp: 'jmv 12/28/2011 19:16'!                         <= anotherMethodReference	classSymbol < anotherMethodReference classSymbol ifTrue: [^true].	classSymbol > anotherMethodReference classSymbol ifTrue: [^false].	classIsMeta == anotherMethodReference classIsMeta ifFalse: [^classIsMeta not].	^methodSymbol <= anotherMethodReference methodSymbol! !!MethodReference methodsFor: 'comparisons' stamp: 'jmv 12/28/2011 19:00'!         = anotherMethodReference 	"Answer whether the receiver and the argument represent the 	same object."	^ self species == anotherMethodReference species		and: [self classSymbol == anotherMethodReference classSymbol]		and: [self classIsMeta == anotherMethodReference classIsMeta]		and: [self methodSymbol == anotherMethodReference methodSymbol]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/28/2011 18:28'!                          dropEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^ (self valueOfProperty: #dropEnabled) ifNil: [ false ]! !!PackageList methodsFor: 'actions' stamp: 'jmv 12/28/2011 18:48'!              update: aSymbol	aSymbol == #packages ifTrue: [		packages _ nil.		self			changed: #packageList;			changed: #packageSelection ]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/28/2011 18:28'!           dropEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^ (self valueOfProperty: #dropEnabled) ifNil: [ true ]! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/28/2011 18:15'!    hideOrShowScrollBars	| wasHShowing wasVShowing useVerticalScrollbar useHorizontalScrollbar |	wasVShowing _ self vIsScrollbarShowing.	wasHShowing _ self hIsScrollbarShowing.	"Assume for a moment we don't need an horizontal scrollbar"	useHorizontalScrollbar _ false.	useVerticalScrollbar _ self vIsScrollbarNeeded: useHorizontalScrollbar.		"Avoid all this if we know for sure we won't need an horizontal scrollbar"	self mightNeedHorizontalScrollBar ifTrue: [				"We are cheating here. May be useVerticalScrollbar is false, and we later need it."		useHorizontalScrollbar _ self hIsScrollbarNeeded: useVerticalScrollbar.						"If horizontal scrollbar is needed, maybe vertical scrollbar will be needed too."		(useVerticalScrollbar not and: [ useHorizontalScrollbar ]) ifTrue: [						"In this case, there is no chance of modifying the need of horizontal scrollbar: it was already needed.			Therefore, there is no circularity here."			useVerticalScrollbar _ self vIsScrollbarNeeded: useHorizontalScrollbar ]].	wasVShowing == useVerticalScrollbar ifFalse: [		useVerticalScrollbar			ifTrue: [ self vShowScrollBar ]			ifFalse: [ self vHideScrollBar ]].	wasHShowing == useHorizontalScrollbar ifFalse: [		useHorizontalScrollbar			ifTrue: [ self hShowScrollBar ]			ifFalse: [ self hHideScrollBar ]]! !!PluggableMessageCategoryListMorph methodsFor: 'model access' stamp: 'jmv 12/28/2011 19:30'!                       getList	"Differs from the generic in that here we obtain and cache the raw list, then cons it together with the special #'-- all --' item to produce the list to be used in the browser.  This special handling is done in order to avoid excessive and unnecessary reformulation of the list in the step method"	getRawListSelector ifNil: ["should not happen!!" priorRawList _ nil.  ^ #()].	model classListIndex = 0 ifTrue: [^ priorRawList _ list _ Array new].	priorRawList _ model perform: getRawListSelector.	list := (Array with: ClassOrganizer allCategory), priorRawList.	^list! !!PluggableTextModel methodsFor: 'updating' stamp: 'jmv 12/28/2011 18:47'!            update: aSymbol	"We are being notified of a change in our provider.	Notify our dependents"	"	self changed: aSymbol	"	aSymbol == textGetter ifTrue: [ ^self changed: #acceptedContents ].	aSymbol == selectionGetter ifTrue: [ ^self changed: #initialSelection ].	"do not try to autoselect on other than the main contents pane.	I.e., in a 'senders' view, do not flash the annotations for not including the sent symbol"	(aSymbol == #autoSelect and: [ textGetter ~~ #acceptedContents ])		ifTrue: [ ^self ].	self changed: aSymbol! !!SHParserST80 methodsFor: 'scan' stamp: 'jmv 12/28/2011 19:01'!      scanPast: rangeType 	"record rangeType for current token .	record argument and temp declarations.	scan and answer the next token"	rangeType == #blockPatternArg ifTrue: [self pushArgument: currentToken].	rangeType == #blockPatternTempVar ifTrue: [self pushTemporary: currentToken].	rangeType == #patternArg ifTrue: [self pushArgument: currentToken].	rangeType == #patternTempVar ifTrue: [self pushTemporary: currentToken].	^self		rangeType: rangeType;		scanNext! !!Symbol methodsFor: 'comparing' stamp: 'jmv 12/28/2011 19:23'!     = another	"Use == between two symbols..."	self == another ifTrue: [		^ true].  "Was == "	another class == Symbol ifTrue: [		^ false].  "Was not == "	"Otherwise use string =..."	^ super = another! !!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 12/28/2011 19:28'!       browseAllMethodsInCategory: aSymbol 	^self		browseMessageList: (self allMethodsInCategory: aSymbol)		name: aSymbol! !!SystemWindow methodsFor: 'label' stamp: 'jmv 12/28/2011 18:46'!    update: aSymbol	super update: aSymbol.	aSymbol == #relabel		ifTrue: [ model ifNotNil: [ self setLabel: model labelString ]]! !!FileListWindow methodsFor: 'updating' stamp: 'jmv 12/28/2011 18:48'!                      update: aSymbol	super update: aSymbol.	aSymbol == #updateButtonRow		ifTrue: [ self updateButtonRow]! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 12/28/2011 18:15'!            setEmphasisHereFromTextForward: f	| i forward delta prevIsSeparator nextIsSeparator |	i _ self pointIndex.	"Try to set emphasisHere correctly after whitespace.	Most important after a cr, i.e. at the start of a new line"	prevIsSeparator _  i > 1 and: [ (model actualContents at: i-1) isSeparator ].	nextIsSeparator _ i <= model textSize and: [ (model actualContents at: i) isSeparator ].	forward _ prevIsSeparator == nextIsSeparator		ifTrue: [ f ]		ifFalse: [ nextIsSeparator ].	delta _ forward ifTrue: [ 1 ] ifFalse: [ 0 ].	emphasisHere _ (model actualContents attributesAt: (i - delta max: 1))					select: [:att | att mayBeExtended].	morph possiblyChanged ! !!Utilities class methodsFor: 'recent method submissions' stamp: 'jmv 12/28/2011 19:16'!   event: anEvent	"Hook for SystemChangeNotifier"	(anEvent isCommented and: [anEvent itemKind = SystemChangeNotifier classKind])		ifTrue: [self noteMethodSubmission: #Comment forClass: anEvent item].	((anEvent isAdded or: [anEvent isModified]) and: [anEvent itemKind == SystemChangeNotifier methodKind])		ifTrue: [anEvent itemRequestor ifNotNil: [self noteMethodSubmission: anEvent itemSelector forClass: anEvent itemClass]].	((anEvent isAdded or: [anEvent isModified]) and: [anEvent itemKind == SystemChangeNotifier methodKind]) ifTrue:[		InMidstOfFileinNotification signal			ifFalse: [Utilities changed: #recentMethodSubmissions].	].! !