'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 28 December 2010 at 11:41:22 am'!!classDefinition: #DebuggerMethodMap category: #'Tools-Debugger'!Object subclass: #DebuggerMethodMap	instanceVariableNames: 'timestamp methodReference methodNode abstractSourceRanges sortedSourceMap '	classVariableNames: 'MapCache MapCacheEntries AccessLock '	poolDictionaries: ''	category: 'Tools-Debugger'!!classDefinition: #Mutex category: #'Kernel-Processes'!Object subclass: #Mutex	instanceVariableNames: 'semaphore owner'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Mutex commentStamp: '<historical>' prior: 0!A Mutex is a light-weight MUTual EXclusion object being used when two or more processes need to access a shared resource concurrently. A Mutex grants ownership to a single process and will suspend any other process trying to aquire the mutex while in use. Waiting processes are granted access to the mutex in the order the access was requested.Instance variables:	semaphore	<Semaphore>		The (primitive) semaphore used for synchronization.	owner		<Process>		The process owning the mutex.!!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 08:39'!forMethod: aMethod "<CompiledMethod>"	"Answer a DebuggerMethodMap suitable for debugging activations of aMethod.	 Answer an existing instance from the cache if it exists, cacheing a new one if required."		^self protected: [ 		MapCache			at: aMethod			ifAbsent: [self						cacheDebugMap:							(self								forMethod: aMethod								methodNode: aMethod methodNode)						forMethod: aMethod] ]! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'mtf 9/19/2010 19:50'!cleanUp	self initialize! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'ul 11/15/2010 08:38'!voidMapCache	self protected: [ 		MapCache := WeakIdentityKeyDictionary new.		MapCacheEntries := 16 ]! !!DebuggerMethodMap class methodsFor: 'debugger support' stamp: 'ul 11/15/2010 08:44'!cacheDebugMap: aDebuggerMethodMap forMethod: aCompiledMethod		^self protected: [ 		MapCache size >= MapCacheEntries ifTrue: [			MapCache slowSize >= MapCacheEntries 				ifFalse: [ MapCache rehash ]				ifTrue: [					| mapsByAge |					mapsByAge := MapCache keys sort: [ :m1 :m2 |						"We are holding strongly on the keys, so #at: is suitable."						(MapCache at: m1) timestamp < (MapCache at: m2) timestamp].					mapsByAge from: 1 to: mapsByAge size - MapCacheEntries do: [ :each |						MapCache removeKey: each ] ] ].		MapCache			at: aCompiledMethod			put: aDebuggerMethodMap ]! !!DebuggerMethodMap class methodsFor: 'synchronization' stamp: 'ul 11/15/2010 08:38'!protected: aBlock	^(AccessLock ifNil: [ AccessLock := Mutex new ]) critical: aBlock! !!Mutex methodsFor: 'initialize' stamp: 'das 11/3/2005 22:53'!initialize	semaphore := Semaphore forMutualExclusion.! !!Mutex methodsFor: 'mutual exclusion' stamp: 'das 11/3/2005 22:53'!critical: aBlock	"Evaluate aBlock protected by the receiver."	| activeProcess |	activeProcess := Processor activeProcess.	activeProcess == owner ifTrue:[^aBlock value].	^semaphore critical:[		owner := activeProcess.		aBlock ensure:[owner := nil]].! !!classDefinition: #DebuggerMethodMap category: #'Tools-Debugger'!Object subclass: #DebuggerMethodMap	instanceVariableNames: 'timestamp methodReference methodNode abstractSourceRanges sortedSourceMap'	classVariableNames: 'AccessLock MapCache MapCacheEntries'	poolDictionaries: ''	category: 'Tools-Debugger'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."DebuggerMethodMap initialize!