'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 24 October 2011 at 3:57:50 pm'!!ScrollPane methodsFor: 'geometry' stamp: 'jmv 10/24/2011 15:48'!hSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta w |	scroller hasSubmorphs ifFalse:[scrollBar interval: 1.0. ^self].		delta _ self scrollDeltaWidth.	range _ self hLeftoverScrollRange.	range = 0 ifTrue: [ hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0. ^self].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	w _ self viewableWidth.	hScrollBar scrollDelta: (delta / range) asFloat pageDelta: (w - delta / range) asFloat.	hScrollBar interval: (w / self hTotalScrollRange) asFloat.	hScrollBar setValue: ((scroller scrollerOffset x / range) min: 1.0) asFloat.! !!ScrollPane methodsFor: 'geometry' stamp: 'jmv 10/24/2011 15:47'!vSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta h |	scroller hasSubmorphs ifFalse:[scrollBar interval: 1.0. ^self].		delta _ self scrollDeltaHeight.	range _ self vLeftoverScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	h _ self viewableHeight.	scrollBar scrollDelta: (delta / range) asFloat pageDelta: (h - delta / range) asFloat.	scrollBar interval: (h / self vTotalScrollRange) asFloat.	scrollBar setValue: (scroller scrollerOffset y / range min: 1.0) asFloat.! !!ScrollPane methodsFor: 'initialization' stamp: 'jmv 10/24/2011 15:52'!initializeScrollBars	"initialize the receiver's scrollBars"	scrollBar := ScrollBar new model: self setValueSelector: #vScrollBarValue:.	hScrollBar := ScrollBar new model: self setValueSelector: #hScrollBarValue:.	scroller := TransformMorph new color: Color transparent.	scroller scrollerOffset: 0@ 0.	self addMorph: scroller! !!ScrollPane methodsFor: 'scrolling' stamp: 'jmv 10/24/2011 15:49'!hHideScrollBar	self hIsScrollbarShowing ifFalse: [		^scroller scrollerOffset: 0@scroller scrollerOffset y ].	self removeMorph: hScrollBar.	scroller scrollerOffset: 0@scroller scrollerOffset y.	 self resizeScroller! !!ScrollPane methodsFor: 'scrolling' stamp: 'jmv 10/24/2011 15:48'!hScrollBarValue: scrollValue	| x |	self hIsScrollbarShowing ifFalse: [		^scroller scrollerOffset: 0@scroller scrollerOffset y ].	(x _ self hLeftoverScrollRange * scrollValue) <= 0		ifTrue: [ x _ 0 ].	scroller scrollerOffset: x@scroller scrollerOffset y! !!ScrollPane methodsFor: 'scrolling' stamp: 'jmv 10/24/2011 15:48'!scrollBy: delta	"Move the contents in the direction delta."	| newYoffset r newXoffset |		"Set the offset on the scroller"	newYoffset _ scroller scrollerOffset y - delta y max: 0.	newXoffset _ scroller scrollerOffset x - delta x max: 0.		scroller scrollerOffset: newXoffset@ newYoffset.	"Update the scrollBars"	(r _ self vLeftoverScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r].	(r _ self hLeftoverScrollRange) = 0		ifTrue: [hScrollBar value: 0.0]		ifFalse: [hScrollBar value: newXoffset asFloat / r]! !!ScrollPane methodsFor: 'scrolling' stamp: 'jmv 10/24/2011 15:48'!scrollToShow: aRectangle	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space"	| range scrollValue |	((aRectangle top - scroller scrollerOffset y) >= 0 and: [		(aRectangle bottom - scroller scrollerOffset y) <= self viewableHeight ])		ifTrue: [			"already visible"			^self ].	range _ self vLeftoverScrollRange.	scrollValue _ range > 0		ifTrue: [			(aRectangle top / range				truncateTo: scrollBar scrollDelta) min: 1]		ifFalse: [0].	scrollBar value: scrollValue.	scroller scrollerOffset: 0 @ (range * scrollValue).! !!ScrollPane methodsFor: 'scrolling' stamp: 'jmv 10/24/2011 15:47'!vHideScrollBar	self vIsScrollbarShowing ifFalse: [^self].	self removeMorph: scrollBar.	scroller scrollerOffset: scroller scrollerOffset x@ 0.	self resizeScroller! !!ScrollPane methodsFor: 'scrolling' stamp: 'jmv 10/24/2011 15:47'!vScrollBarValue: scrollValue	scroller hasSubmorphs ifFalse: [^ self].	scroller scrollerOffset: (scroller scrollerOffset x @ (self vLeftoverScrollRange * scrollValue) rounded)! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 10/24/2011 15:55'!drawLinesOn: aCanvas 	| lColor clippedCanvas |	lColor _ self lineColor.	clippedCanvas _ aCanvas		copyOffset: scroller txOffset negated truncated		clipRect: scroller innerBounds.	scroller submorphs do: [ :submorph | 		(submorph isExpanded or:			[ (clippedCanvas isVisible: submorph fullBounds) or:		"needs #fullBounds 'in Owner'"				"strange!! #isVisible expects a rectangle, and #nextSibling answers a Morph... Looks like it never gets here!! (jmv)"				[ submorph nextSibling notNil and: [ clippedCanvas isVisible: submorph nextSibling ] ] ]) ifTrue: [			submorph				drawLinesOn: clippedCanvas				lineColor: lColor ] ]! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 10/24/2011 15:46'!selectionIndex: idx	"Called internally to select the index-th item."	| theMorph range index |	idx ifNil: [^ self].	index := idx min: scroller submorphs size max: 0.	(theMorph _ index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index])		ifNotNil:		[((theMorph bounds top - scroller scrollerOffset y) >= 0			and: [(theMorph bounds bottom - scroller scrollerOffset y) <= self viewableHeight]) ifFalse: [			"Scroll into view -- should be elsewhere"			range _ self vTotalScrollRange.			scrollBar value: (range > 0				ifTrue: [((index-1 * theMorph height) / self vTotalScrollRange)									truncateTo: scrollBar scrollDelta]				ifFalse: [0]).			scroller scrollerOffset: -3 @ (range * scrollBar value)]].	self selectedMorph: theMorph! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 10/24/2011 15:45'!accept	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller scrollerOffset.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' ) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					World activeHand  newKeyboardFocus: textMorph.					scroller scrollerOffset: saveScrollerOffset.					self setScrollDeltas ]]] 			on: Error			do: nil! !!TransformMorph methodsFor: 'accessing' stamp: 'jmv 10/24/2011 15:44'!scrollerOffset	^ txOffset + bounds topLeft! !!TransformMorph methodsFor: 'accessing' stamp: 'jmv 10/24/2011 15:45'!scrollerOffset: newOffset	| o |	o _ newOffset - bounds topLeft.	txOffset = o ifFalse: [		txOffset _ o.		self redrawNeeded ]! !!TransformMorph methodsFor: 'change reporting' stamp: 'jmv 10/24/2011 15:54'!invalidRect: damageRect from: aMorph	"Translate damage reports from submorphs by the scrollOffset."	aMorph == self		ifTrue:[super invalidRect: damageRect from: self]		ifFalse:[super invalidRect: (((damageRect translateBy: txOffset negated) intersect: bounds) expandBy: 1) from: self].! !!TransformMorph methodsFor: 'drawing' stamp: 'jmv 10/24/2011 15:54'!drawSubmorphsOn: aCanvas	| clippedCanvas |	clippedCanvas _ aCanvas		copyOffset: txOffset negated truncated		clipRect: bounds.	submorphs reverseDo: [ :m | m fullDrawOn: clippedCanvas ]! !!TransformMorph methodsFor: 'geometry' stamp: 'jmv 10/24/2011 15:54'!externalizePosition: pointInSelf to: aReferenceMorph	"aPoint is in our coordinate system	answer is in aReferenceMorph's coordinateSystem"	| pointInOwner |	self == aReferenceMorph		ifTrue: [ ^pointInSelf ].	pointInOwner _ pointInSelf - txOffset.		"This might actually indicate an error condition. For now, just answer something!!"	self flag: #jmv.	owner ifNil: [		^pointInOwner ].		^owner externalizePosition: pointInOwner to: aReferenceMorph! !!TransformMorph methodsFor: 'geometry' stamp: 'jmv 10/24/2011 15:54'!internalizePosition: pointInReferenceMorph from: aReferenceMorph	"aPoint is in aReferenceMorph's coordinateSystem	answer is in our coordinate system"	| pointInOwner |	self == aReferenceMorph		ifTrue: [ 			self revisar.			"Sending #txOffset here is not correct but needed for morphic event translation"			^pointInReferenceMorph + txOffset].	"This might actually indicate an error condition. For now, just answer something!!"	self flag: #jmv.	owner ifNil: [		^pointInReferenceMorph + txOffset].	pointInOwner _ owner internalizePosition: pointInReferenceMorph from: aReferenceMorph.	^ pointInOwner + txOffset! !!TransformMorph methodsFor: 'geometry testing' stamp: 'jmv 10/24/2011 15:53'!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	self hasSubmorphs		ifTrue: [			self submorphsDo: [ :m |				(m containsPoint: aPoint + txOffset)					ifTrue: [^ true]].			^ false]		ifFalse: [^ true]! !TransformMorph removeSelector: #offset!TransformMorph removeSelector: #offset:!