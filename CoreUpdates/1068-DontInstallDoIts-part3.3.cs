'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 30 August 2011 at 8:56:12 am'!!Behavior methodsFor: 'user interface' stamp: 'jmv 8/30/2011 08:27'!allLocalCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."	| aSet special byte cls |	aSet _ Set new.	cls _ self theNonMetaClass.	special _ Smalltalk 		hasSpecialSelector: aSymbol		ifTrueSetByte: [ :b | byte _ b ].	cls withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [ :sel | aSet add: class name , ' ', sel ]].	cls class withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [ :sel | Set add: class name , ' ', sel]].	^aSet! !!Behavior methodsFor: 'user interface' stamp: 'jmv 8/30/2011 08:28'!allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	^ self allInstVarNames copy reject: [ :ivn | | any definingClass |		any _ false.		definingClass _ self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses do: [ :class |			any ifFalse: [				(class whichSelectorsAccess: ivn asSymbol) do: [ :sel | any _ true ]]].			any ]! !!Behavior methodsFor: 'user interface' stamp: 'jmv 8/30/2011 08:37'!unreferencedInstanceVariables	"Return a list of the instance variables defined in the receiver which are not referenced in the receiver or any of its subclasses.  2/26/96 sw"	"	Object unreferencedInstanceVariables	"	^ self instVarNames copy reject: [ :ivn | | any |		any _ false.		self withAllSubclasses do: [ :class |			(class whichSelectorsAccess: ivn) do: [ :sel |				any _ true ]].		any ]! !!ChangeSet methodsFor: 'method changes' stamp: 'jmv 8/30/2011 08:46'!atSelector: selector class: class put: changeType	(self changeRecorderFor: class) atSelector: selector put: changeType! !!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 8/30/2011 08:34'!replaceSilently: old to: new	"text-replace any part of a method.  Used for class and pool variables.  Don't touch the header.  Not guaranteed to work if name appears in odd circumstances"	| oldName newName |	oldName _ old asString.	newName _ new asString.	self withAllSubclasses do: [ :cls | | oldCode newCode sels |		sels _ cls selectors.		sels do: [ :sel | | parser header body |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].		cls isMeta ifFalse: [			oldCode _ cls comment.			newCode _ oldCode copyReplaceTokens: oldName with: newName.			newCode ~= oldCode ifTrue: [				cls comment: newCode]]]! !!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 8/30/2011 08:56'!defaultSelector 	"Invent and answer an appropriate message selector (a Symbol) for me, 	that is, one that will parse with the correct number of arguments.""jmv: is this ever used?????"'' print.thisContext printStack: 10.	^#DoIt numArgs: self numArgs! !!CompiledMethod class methodsFor: 'services' stamp: 'jmv 8/30/2011 08:50'!unboundMethods	^self allInstances reject: [ :m | m isInstalled ]! !!DecompilerTests methodsFor: 'utilities' stamp: 'jmv 8/30/2011 08:35'!isFailure: cls sel: selector 	"self new isKnowProblem: PNMReaderWriter sel: #nextImage"	"#((PNMReadWriter nextImage)) includes: {PNMReadWriter	name asSymbol . #nextImage}."	"Too many failures here. May be check #decompilerFailures when the decompiler is enhanced..."	self flag: #expectedFailure.	true ifTrue: [^true].	^self decompilerFailures includes: {cls name asSymbol. selector}! !!MethodReference methodsFor: 'queries' stamp: 'jmv 8/30/2011 08:40'!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	(aClass _ self actualClass) ifNil: [^ false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 8/30/2011 08:22'!allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."	"Answer a Collection of all the methods that call on aLiteral."	| aCollection special aList byte |	#(23 48 'fred' (new open:label:)) size."Example above should find #open:label:, though it is deeply embedded here."	aCollection _ OrderedCollection new.	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].	Cursor wait showWhile: [		self allBehaviorsDo: [:class |			aList _ class whichSelectorsReferTo: aLiteral special: special byte: byte.			aList do: [ :sel |									"For special selectors, look for the literal in the source code.				Otherwise, for example, searching for senders of #== will include senders of #ifNil:"				(byte isNil or: [					((class sourceCodeAt: sel)						findString: aLiteral) > 0]) ifTrue: [					aCollection add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel					)				]			]		]	].	^ aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 8/30/2011 08:22'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"	| list classCount adder |	list _ Set new.	adder _ [ :mrClass :mrSel |	list add:		(MethodReference new			setStandardClass: mrClass			methodSymbol: mrSel) ].	'Searching all source code...'		displayProgressAt: Sensor mousePoint		from: 0		to: Smalltalk classNames size		during: [ :bar |			classCount _ 0.			Smalltalk allClassesDo: [ :class |				bar value: (classCount _ classCount + 1).				(Array					with: class					with: class class) do: [ :cl |					cl selectorsDo: [ :sel |						((cl sourceCodeAt: sel)							findString: aString							startingAt: 1							caseSensitive: caseSensitive) > 0 ifTrue: [							adder								value: cl								value: sel ]].					(cl organization classComment asString						findString: aString						startingAt: 1						caseSensitive: caseSensitive) > 0 ifTrue: [						adder							value: cl							value: #Comment ]]]].	^ list asArray sort.! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 8/30/2011 08:23'!allMethodsWithString: aString	"Answer a sorted Collection of all the methods that contain, in a string literal, aString as a substring.  2/1/96 sw.  The search is case-sensitive, and does not dive into complex literals, confining itself to string constants.	5/2/96 sw: fixed so that duplicate occurrences of aString in the same method don't result in duplicated entries in the browser"	| aStringSize list |	aStringSize _ aString size.	list _ Set new.	Cursor wait showWhile: [		self allBehaviorsDo: [ :class |			class selectorsDo: [ :sel |				(class compiledMethodAt: sel) literalsDo: [ :aLiteral |					((aLiteral isMemberOf: String) and: [ aLiteral size >= aStringSize ]) ifTrue: [						(aLiteral							findString: aString							startingAt: 1) > 0 ifTrue: [ list add: class name , ' ' , sel ]]]]]].	^ list asArray sort.! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 8/30/2011 08:21'!allSelect: aBlock	"Answer a SortedCollection of each method that, when used as the block 	argument to aBlock, gives a true result."	| aCollection |	aCollection _ SortedCollection new.	Cursor execute showWhile: [		self allBehaviorsDo: [ :class |			class selectorsDo: [ :sel |				(aBlock value: (class compiledMethodAt: sel)) ifTrue: [					aCollection add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel)				]]]].	^ aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 8/30/2011 08:24'!isThereAReferenceTo: aLiteral	"Answer a Collection of all the methods that call on aLiteral."	"	Smalltalk isThereAReferenceTo: #open:label:	"	| special byte |	#(23 48 'fred' (new open:label:)) size."Example above should find #open:label:, though it is deeply embedded here."	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].	Cursor wait showWhile: [		self allBehaviorsDo: [:class |			(class whichSelectorsReferTo: aLiteral special: special byte: byte) do: [ :sel |				^true			]		]	].	^ false! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 8/30/2011 08:25'!unimplemented	"Answer an Array of each message that is sent by an expression in a method but is not implemented by any object in the system."	| all unimplemented entry |	all _ IdentitySet new: Symbol instanceCount * 2.	Cursor wait showWhile: 		[self allBehaviorsDo: [:cl | cl selectorsDo: [:aSelector | all add: aSelector]]].	unimplemented _ IdentityDictionary new.	Cursor execute showWhile: [		self allBehaviorsDo: [:cl |			 cl selectorsDo: [:sel |				(cl compiledMethodAt: sel) messages do: [:m |					(all includes: m) ifFalse: [						entry _ unimplemented at: m ifAbsent: [Array new].						entry _ entry copyWith: (cl name, '>', sel).						unimplemented at: m put: entry]]]]].	"remove some clutter from the result:"	#(doPrimitive: primitiveFail success:)		do: [ :sel | unimplemented removeKey: sel ifAbsent: nil].	^ unimplemented! !!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 8/30/2011 08:23'!browseAllAccessesTo: instVarName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."	"self new browseAllAccessesTo: 'contents' from: Collection."		| coll |	coll _ OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsAccess: instVarName) do: [:sel |				coll add: (					MethodReference new						setStandardClass: class 						methodSymbol: sel)			]		].	].	^ self 		browseMessageList: coll 		name: 'Accesses to ' , instVarName 		autoSelect: instVarName! !!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 8/30/2011 08:21'!browseAllSelect: aBlock name: aName autoSelect: autoSelectString	"Create and schedule a message browser on each method that, when used 	as the block argument to aBlock gives a true result.   Do not return an #DoIt traces."	"Smalltalk browseAllSelect: [:method | method numLiterals > 10] name: 'Methods with more than 10 literals' autoSelect: 'isDigit'"	^ self browseMessageList: (self allSelect: aBlock) name: aName autoSelect: autoSelectString! !!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 8/30/2011 08:23'!browseAllStoresInto: instVarName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."		"self new browseAllStoresInto: 'contents' from: Collection."	| coll |	coll _ OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsStoreInto: instVarName) do: [:sel |				coll add: (					MethodReference new						setStandardClass: class 						methodSymbol: sel				)			]		].	].	^ self		browseMessageList: coll 		name: 'Stores into ' , instVarName 		autoSelect: instVarName! !!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 8/30/2011 08:23'!browseViewReferencesFromNonViews	"	Smalltalk browseViewReferencesFromNonViews	"	| aList aLiteral aCollection |	aCollection _ OrderedCollection new.	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)""	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"	PluggableMorph withAllSubclassesDo: [ :view |"	MenuMorph withAllSubclassesDo: [ :view |"				aLiteral _ view name.				"tweak to linclude refs to SysWindow subhierarchy or not"		(view includesBehavior: SystemWindow) 		& false		ifFalse: [					Smalltalk allBehaviorsDo: [ :class |				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [					aList _ class						whichSelectorsReferTo: aLiteral						special: false						byte: nil.					aList do: [ :sel |						"For special selectors, look for the literal in the source code.						Otherwise, for example, searching for senders of #== will include senders of #ifNil:"						((class sourceCodeAt: sel) findString: aLiteral) > 0  ifTrue: [							aCollection add:								(MethodReference new									setStandardClass: class									methodSymbol: sel) ]]]]]].	Smalltalk		browseMessageList: aCollection asSet asArray sort		name: 'References to Views from non-Views'		autoSelect: ''.! !SystemDictionary removeSelector: #allSelectNoDoits:!SystemDictionary removeSelector: #forgetDoIts!Symbol removeSelector: #isDoIt!ParseNode removeSelector: #isDoIt!ClassDescription removeSelector: #forgetDoIts!Behavior removeSelector: #forgetDoIts!