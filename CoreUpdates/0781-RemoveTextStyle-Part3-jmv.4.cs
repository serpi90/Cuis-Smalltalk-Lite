'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 24 January 2011 at 4:52:57 pm'!!classDefinition: #CharacterScanner category: #'Graphics-Text'!Object subclass: #CharacterScanner	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth kern actualTextStyle paragraphStyle '	classVariableNames: 'DefaultStopConditions '	poolDictionaries: ''	category: 'Graphics-Text'!!classDefinition: #EmptyLine category: #'Morphic-Text Support'!TextLine subclass: #EmptyLine	instanceVariableNames: 'textStyle paragraphStyle '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!StringMorph commentStamp: 'jmv 1/24/2011 16:46' prior: 0!StringMorph is a "lightweight" Morph to display a String. It supports only a single font, color, and emphasis combination. For multiple text styles, use TextMorph.Structure:instance var    	Type              Description font 			StrikeFont 		(normally nil; then the accessor #font gives back  a Font or nil #defaultFont) emphasis 		SmallInteger	bitmask determining character attributes (underline, bold, 	italics, struckout) contents 		String 			The text that will be displayed. hasFocus 		Boolean 		Do I have the keyboard focus or not? If you shift-click on a StringMorph you can edit its string. This is accomplished the following way: StringMorph can launch a StringMorphEditor if it receives a #mouseDown event.A StringMorph may also be used like a SimpleButtonMorph to do an action when clicked. Use the menu 'extras' / 'add mouseUpAction'.The following propery will be defined:aStringMorph valueOfProperty: #mouseUpCodeToRun!!Text commentStamp: '<historical>' prior: 0!I represent a character string that has been marked with abstract changes in character appearance. Text associates a set of TextAttributes with each character in its character string.  These attributes may be fonts, emphases such as bold or italic, or hyperling actions. Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.  Each of my instances has	string		a String	runs		a RunArray			From the comment at #deepCopy, written by Dan on 11/9/97:"Both string and runs are assumed to be read-only"!!TextAlignment commentStamp: '<historical>' prior: 0!Warning: TextAlignment and ParagraphStyleReference should always be applied to whole 'paragraphs' in the text. See #isParagraphAttribute((Text string: 'This text has no tyle set', String cr),(Text string: 'This is centered', String cr attribute: TextAlignment centered),(Text string: 'This text has no tyle set', String cr)) edit!!BareTextMorph methodsFor: 'initialization' stamp: 'jmv 1/24/2011 16:29'!initialize	super initialize.	wrapFlag _ true.	acceptOnCR _ false! !!CharacterScanner methodsFor: 'private' stamp: 'jmv 1/24/2011 16:41'!setFont	| priorFont |	"Set the font and other emphasis.	In fact set actual ParagraphStyle (or nil), alignment, font and emphasis"		priorFont _ font.	text		withAttributeValuesAt: lastIndex 		do: [ :fontInText :colorInText :alignmentInText :paragraphStyleInText :characterStyleInText :kernInText |			self setActualFont: fontInText.			colorInText ifNotNil: [ self textColor: colorInText ].			alignment _ alignmentInText.			kern _ kernInText.			paragraphStyle _ paragraphStyleInText ].	priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].	destX _ destX - font descentKern.	kern _ kern - font baseKern.	"Install various parameters from the font."	spaceWidth _ font widthOf: Character space.	xTable _ font xTable.	map _ font characterToGlyphMap.	stopConditions _ DefaultStopConditions! !!CharacterScanner methodsFor: 'private' stamp: 'jmv 1/24/2011 16:37'!text: aText	text _ aText.	paragraphStyle _ nil! !!CharacterScanner methodsFor: 'stop conditions' stamp: 'jmv 1/24/2011 16:37'!tabDestX	"This is the basic method of adjusting destX for a tab."	^paragraphStyle		ifNotNil: [			paragraphStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin ]		ifNil: [			"The only interesting thing in this method is the 24..."			destX - leftMargin // 24 + 1 * 24 + leftMargin min: rightMargin ]! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 1/24/2011 16:40'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line _ textLine.	rightMargin _ line rightMargin.	lastIndex _ line first.	self setStopConditions.		"also sets font"	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ line lineHeight)					textLine: line].	destX _ leftMargin _ line leftMarginForAlignment: alignment.	destY _ line top.	runLength _ text runLengthFor: line first.	lineStop _ characterIndex	"scanning for index"		ifNil: [ line last ].			"scanning for point"	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	self placeEmbeddedObject.	done  _ false.	[ done ] whileFalse: [		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth ifNil: [ font widthOf: (text at: lastIndex) ]).		(self perform: stopCondition) ifTrue: [			^characterIndex				ifNil: ["Result for characterBlockAtPoint: "						(CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifNotNil: ["Result for characterBlockForIndex: "						(CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern - kern max: 0)@ 0)							extent: lastCharacterExtent)									textLine: line]]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'jmv 1/24/2011 16:37'!composeFrom: startIndex inRectangle: lineRectangle firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition xtraSpaceBefore spaceAfterParagraph |		lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font, style, etc"	"Set up margins"	leftMargin _ lineRectangle left.	rightMargin _ lineRectangle right.	xtraSpaceBefore _ 0.	spaceAfterParagraph _ 0.	paragraphStyle ifNotNil: [		leftSide ifTrue: [			leftMargin _ leftMargin +				((firstLine and: [ paragraphStyle isListStyle not ])					ifTrue: [ paragraphStyle firstIndent ]					ifFalse: [ paragraphStyle restIndent ])].		rightSide ifTrue: [			rightMargin _ rightMargin - paragraphStyle rightIndent].		firstLine ifTrue: [ xtraSpaceBefore _ paragraphStyle paragraphSpacingBefore ].		spaceAfterParagraph _ paragraphStyle paragraphSpacingAfter ].	destX _ spaceX _ leftMargin.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	line isFirstLine: firstLine.	spaceCount _ 0.	leftMargin _ destX.	line leftMargin: leftMargin.	done _ false.	self placeEmbeddedObject.	[ done ]		whileFalse: [			stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition) ifTrue: [				^ line 					lineHeight: lineHeight + xtraSpaceBefore + 						(stopCondition = #cr ifTrue: [spaceAfterParagraph] ifFalse: [0]) 					baseline: baseline + xtraSpaceBefore ]]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 1/24/2011 16:41'!tab	"Advance destination x according to tab settings in the current	ParagraphStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX _ self tabDestX.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex _ lastIndex + 1.	^false! !!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 1/24/2011 16:38'!displayBulletIfAppropriateFor: textLine offset: offset	| paragraphEnd count pattern |	paragraphStyle ifNotNil: [		(textLine isFirstLine and: [ paragraphStyle isListStyle ]) ifTrue: [			pattern _ paragraphStyle listBulletPattern.			"Count how many paragraphs before this one already used the pattern"			count _ 0.			paragraphEnd _ textLine first-1.			[			paragraphEnd > 0 and: [ (text paragraphStyleAt: paragraphEnd) listBulletPattern = pattern ]] whileTrue: [				count _ count + 1.				paragraphEnd _ text string endOfParagraphBefore: paragraphEnd ].			"Our number in the list, is one more than the count of previous contiguous paragraphs with this pattern"			self				displayBulletOffset: offset				number: count + 1]]! !!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 1/24/2011 16:37'!displayBulletOffset: offset number: bulletNumber	| pattern i c j s bullet bulletPos bulletSize prefix |	pattern _ paragraphStyle listBulletPattern.	bullet _ pattern.	(i _ pattern indexOf: $%) > 0		ifTrue: [ bullet _ bulletNumber asString]		ifFalse: [			(i _ pattern indexOf: $z) > 0				ifTrue: [ bullet _ (Character value: 96 + bulletNumber) asString ]				ifFalse: [					(i _ pattern indexOf: $Z) > 0						ifTrue: [ bullet _ (Character value: 64 + bulletNumber) asString ]]].	prefix _ 0.	i > 0 ifTrue: [		c _ pattern at: i.		j _ i.		s _ pattern size.		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].		j _ j - 1.		bulletSize _ j-i+1.		prefix _ bulletSize - bullet size max: 0.		bullet size > bulletSize ifTrue: [			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].	bulletPos _ paragraphStyle firstIndent + offset x + ((font widthOf: $9) * prefix)@destY.	font displayString: bullet on: bitBlt from: 1 to: bullet size at: bulletPos kern: kern! !!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 1/24/2011 16:38'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos priorFont |	line _ textLine.	morphicOffset _ offset.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	rightMargin _ line rightMargin + offset x.	lastIndex _ line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin _ (line leftMarginForAlignment: alignment) + offset x.	destX _ runX _ leftMargin.	destY _ lineY + line baseline - font ascent.	textLine isEmptyLine ifTrue: [		textLine paragraphStyle ifNotNil: [ :ps |			ps = paragraphStyle ifFalse: [				""				foregroundColor _ paragraphColor.				priorFont _ font.				self setActualFont: ps font.				ps color ifNotNil: [ :color | self textColor: color ].				alignment _ ps alignment.				paragraphStyle _ ps.				priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].				destX _ destX - font descentKern.				kern _ 0 - font baseKern.				spaceWidth _ font widthOf: Character space.				xTable _ font xTable.				map _ font characterToGlyphMap.				stopConditions _ DefaultStopConditions.				font installOn: bitBlt foregroundColor: foregroundColor.				text ifNotNil:[destY _ lineY + line baseline - font ascent]				""			]		].		self displayBulletIfAppropriateFor: textLine offset: offset.		^leftInRun ].	self displayBulletIfAppropriateFor: textLine offset: offset.	lastIndex _ line first.	leftInRun <= 0		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	string _ text string.	self placeEmbeddedObject.	[done] whileFalse:[		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!DisplayScanner methodsFor: 'private' stamp: 'jmv 1/24/2011 16:38'!text: t foreground: foreColor ignoreColorChanges: shadowMode	text _ t.	paragraphStyle _ nil.	foregroundColor _ paragraphColor _ foreColor.	ignoreColorChanges _ shadowMode! !!EmptyLine methodsFor: 'accessing' stamp: 'jmv 1/24/2011 16:34'!paragraphStyle	^paragraphStyle! !!EmptyLine methodsFor: 'accessing' stamp: 'jmv 1/24/2011 16:34'!paragraphStyle: aParagraphtStyle	paragraphStyle _ aParagraphtStyle! !!Pen methodsFor: 'operations' stamp: 'jmv 1/24/2011 16:43'!print: str withFont: font	"Print the given string in the given font at the current heading"	| lineStart form charStart rowStart scale wasDown bb pix |	scale _ sourceForm width.	wasDown _ penDown.	lineStart _ location.	str do:		[:char |		char = Character cr ifTrue:			[self place: lineStart; up; turn: 90; go: font height*scale; turn: -90; down]		ifFalse:			[form _ font characterFormAt: char.			charStart _ location.wasDown ifTrue: [			self up; turn: -90; go: font descent*scale; turn: 90; down.			0 to: form height-1 do:				[:y |				rowStart _ location.				bb _ BitBlt current bitPeekerFromForm: form.				pix _ RunArray newFrom:					((0 to: form width-1) collect: [:x | bb pixelAt: x@y]).				pix runs with: pix values do:					[:run :value |					value = 0						ifTrue: [self up; go: run*scale; down]						ifFalse: [self go: run*scale]].				self place: rowStart; up; turn: 90; go: scale; turn: -90; down].].			self place: charStart; up; go: form width*scale; down].			].	wasDown ifFalse: [self up]"Display restoreAfter:[Pen new squareNib: 2; color: Color red; turn: 45;	print: 'The owl and the pussycat went to seain a beautiful pea green boat.' withFont: AbstractFont default]"! !!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:52'!reset	"Reset the cache of derivative emphasized fonts"		derivativeFonts ifNotNil: [		derivativeFonts withIndexDo: [ :f :i |			(f notNil and: [ f isSynthetic ]) 				ifTrue: [ derivativeFonts at: i put: nil ]].		derivativeFonts size > 16 ifTrue: [			derivativeFonts _ derivativeFonts copyFrom: 1 to: 16 ]]! !!StrikeFont methodsFor: 'character shapes' stamp: 'jmv 1/24/2011 16:44'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	ascii < minAscii ifTrue: [^ self error: 'Cant store characters below min ascii'].	ascii > maxAscii ifTrue:		[(self confirm:'This font does not accomodate ascii values higher than ' , maxAscii printString , '.Do you wish to extend it permanently to handle values up to ' , ascii printString)			ifTrue: [self extendMaxAsciiTo: ascii]			ifFalse: [^ self error: 'No change made']].	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height depth: glyphs depth.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		xTable _ xTable copy.		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent)		from: 0@0 in: characterForm rule: Form over"| f |  f _ AbstractFont default.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StringMorph methodsFor: 'accessing' stamp: 'jmv 1/24/2011 16:46'!font: aFont emphasis: emphasisCode	font _ aFont.	emphasis _ emphasisCode.	self fitContents."in inspector say,	 self font: StrikeFont default emphasis: 1"! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:49'!alignmentAt: characterIndex	self withAttributeValuesAt: characterIndex do: [ :font :color :alignment :paragraphStyle :characterStyle :kern |		^alignment ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:49'!characterStyleOrNilIfApplying: textAttributes	"Answer the ParagraphStyle for characters as specified by the argument."		self withAttributeValues: textAttributes do: [ :font :color :alignment :paragraphStyle :characterStyle :kern |		^characterStyle ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:49'!fontAt: characterIndex	"Answer the font for characters in the run beginning at characterIndex."		self withAttributeValuesAt: characterIndex do: [ :font :color :alignment :paragraphStyle :characterStyle :kern |		^font ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:49'!fontIfApplying: textAttributes	"Answer the font for characters as specified by the argument."		self withAttributeValues: textAttributes do: [ :font :color :alignment :paragraphStyle :characterStyle :kern |		^font ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:30'!paragraphStyleAt: characterIndex	| paragraphStyle |	self size = 0 ifTrue: [ ^ nil ].	paragraphStyle _ nil.	(runs at: characterIndex) do: [ :attribute | 		attribute forParagraphStyleReferenceDo: [ :s | paragraphStyle _ s ] ].	^paragraphStyle! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:32'!paragraphStyleIfApplying: textAttributes	"Answer the ParagraphStyle for characters as specified by the argument."		self withAttributeValues: textAttributes do: [ :font :color :alignment :paragrapStyle :characterStyle :kern |		^paragrapStyle ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:52'!withAttributeValues: attributes do: aBlock	"Evaluate aBlock with the values of various attributes applied in the correct order	The order is (each overwriting the previous one)	1) initialStyle	2) ParagraphStyleReferene	3) CharacterStyleReference	4) TextFontReference	5) TextEmphasis"	| paragraphStyle characterStyle font emphasis alignment color kern |	paragraphStyle _ nil.	emphasis _ 0.	kern _ 0.	color _ nil.	alignment _ 0.	font _ StrikeFont default.		"ParagraphStyle is the first to set several values"	attributes do: [ :attribute |		attribute forParagraphStyleReferenceDo: [ :s | 			paragraphStyle _ s]].	paragraphStyle		ifNotNil: [			font _ paragraphStyle font.			alignment _ paragraphStyle alignment.			paragraphStyle color ifNotNil: [ :c | color _ c ]].	"CharacterStyle, if present, can override font and color"	attributes do: [ :attribute |		attribute forCharacterStyleReferenceDo: [ :s | 			characterStyle _ s.			font _ characterStyle font.			characterStyle color ifNotNil: [ :c | color _ c ]]].		"Hardcoded color for TextAction comes before TextColor"	attributes do: [ :attribute |		attribute forTextActionInfoDo: [ :info | color _ TextAction purple ]].	"These will not interfere with each other, and all of them take precedence over previous values"	attributes do: [ :attribute |		attribute forFontReferenceDo: [ :f | font _ f ].		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].		attribute forTextColorDo: [ :c | color _ c ].		attribute forTextAlignmentDo: [ :a | alignment _ a ].		attribute forTextKernDo: [ :k | kern _ kern + k ].	].	"Finally, the font must include any specified emphasis"	font _ font emphasized: emphasis.		"Done. Now evaluate the block."	aBlock valueWithArguments: {font. color. alignment. paragraphStyle. characterStyle. kern }! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:50'!withAttributeValuesAt: idx do: aBlock	"Evaluate aBlock with the values of various attributes at position idx	The order is (each overwriting the previous one)	1) initialStyle	2) ParagraphStyleReferene	3) CharacterStyleReference	4) TextFontReference	5) TextEmphasis"	| attributes |	attributes _ self size = 0		ifTrue: [ #() ]		ifFalse: [ runs at: idx ].	^self withAttributeValues: attributes do: aBlock! !!Text methodsFor: 'as yet unclassified' stamp: 'jmv 1/24/2011 16:39'!paragraphStyleChunksDo: aBlock	"Evaluate aBlock over each chunk (sequence of paragraphs) that have the same paragraphStyle"	| start nextStart style |	start _ 1.	nextStart _ 1.	[ start <= self size ] whileTrue: [		style _ self paragraphStyleAt: start.		[ nextStart <= self size and: [ (self paragraphStyleAt: nextStart) = style ]] whileTrue: [			nextStart _nextStart + 1 ].		aBlock value: (start to: nextStart-1) value: style.		start _ nextStart ]! !!TextAttribute methodsFor: 'iterating' stamp: 'jmv 1/24/2011 16:29'!forParagraphStyleReferenceDo: aBlock	"No action is the default"! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 1/24/2011 16:35'!addEmptyTrailingLine	"The line to add is always the first line of a new paragraph"	| ts f h bs r lm rm w a leftMarginForAlignment s |	s _ theText size+1.	f _ editor		ifNotNil: [ editor lastFont ]		ifNil: [ theText fontAt: s ].	ts _ editor		ifNotNil: [ editor lastParagraphStyle ]		ifNil: [ theText paragraphStyleAt: s].	h _ f height.	bs _ f ascent.	lm _ 0.	rm _ 0.	w _ theContainer width.	a _ 0.	ts ifNotNil: [		h _h + ts paragraphSpacingBefore + ts paragraphSpacingAfter.		bs _ bs + ts paragraphSpacingBefore.		lm _ (ts isListStyle not			ifTrue: [ts firstIndent]			ifFalse: [ts restIndent]).		rm _ ts rightIndent.		a _ ts alignment ].		leftMarginForAlignment _ a = CharacterScanner rightFlushCode		ifTrue: [ w - rm]		ifFalse: [			a = CharacterScanner centeredCode				ifTrue: [ (w - rm - lm) //2 + lm]				ifFalse: [ lm ]].	r _ theContainer left + leftMarginForAlignment @ currentY extent: 0@h.	lines addLast: (		EmptyLine new			firstIndex: s lastIndex: s - 1;			rectangle: r;			lineHeight: h baseline: bs;			paragraphStyle: ts)! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 1/24/2011 16:50'!currentParagraphStyle	"Answer the ParagraphStyle for the current selection or cursor location if any"		| i t |	i _ self startIndex.	t _ paragraph text.	^i > t size		ifTrue: [ t paragraphStyleIfApplying: emphasisHere ]		ifFalse: [ t paragraphStyleAt: i ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 1/24/2011 16:50'!lastParagraphStyle	"Answer the ParagraphStyle for to be used if positioned at the end of the text"		| t |	t _ paragraph text.	^self startIndex > t size		ifTrue: [ paragraph text paragraphStyleIfApplying: emphasisHere ]		ifFalse: [ paragraph text paragraphStyleAt: t size +1 ]! !!Utilities class methodsFor: 'support windows' stamp: 'jmv 1/24/2011 16:51'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 10000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.Preferences editAnnotations.Utilities reinstateDefaultFlaps. Preferences resetCategoryInfo(FileStream oldFileNamed: 'Lives of the Wolves') edit.(FileStream oldFileNamed: 'tuesdayFixes.cs') fileInChangeList browseFile: 'myChanges.st'StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode in mvc""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspect.Utilities storeTextWindowContentsToFileNamed: 'TextWindows'Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'ScriptingSystem resetStandardPartsBin.ScheduledControllers screenController openMorphicConstructionWorld.ScheduledControllers screenController openMorphicWorld.SystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[Smalltalk allCallsOn: #asOop]MessageTally spyOn: [Smalltalk allCallsOn: #asOop].""Utilities openStandardWorkspace"! !TextAttribute removeSelector: #forTextStyleReferenceDo:!Text removeSelector: #styleIfApplying:!Text removeSelector: #textStyleAt:!Text removeSelector: #textStyleChunksDo:!EmptyLine removeSelector: #textStyle!EmptyLine removeSelector: #textStyle:!!classDefinition: #EmptyLine category: #'Morphic-Text Support'!TextLine subclass: #EmptyLine	instanceVariableNames: 'paragraphStyle'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!classDefinition: #CharacterScanner category: #'Graphics-Text'!Object subclass: #CharacterScanner	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth kern paragraphStyle'	classVariableNames: 'DefaultStopConditions'	poolDictionaries: ''	category: 'Graphics-Text'!AbstractFont removeSelector: #textStyleName!