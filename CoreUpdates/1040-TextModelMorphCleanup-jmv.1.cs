'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 23 June 2011 at 4:05:23 pm'!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR styler askBeforeDiscardingEdits hasUnacceptedEdits '	classVariableNames: 'AutoCompletter '	poolDictionaries: ''	category: 'Morphic-Text Support'!!BareTextMorph commentStamp: '<historical>' prior: 0!BareTextMorphs support display of text with emphasis.  They also support reasonable text-editing capabilities, as well as embedded hot links, and the ability to embed submorphs in the text. They are 'bare' in the sense that they can not clip contents to some window, or scroll it by themselves.Text display is clipped to the innerBounds of the rectangle, and text composition is normally performed within a rectangle which is innerBounds inset by the margins parameter.Comment about Shout specifics:-----------------------------------------Instances of me are usually created using my #on:text:accept:readSelection:menu: class method.In order to colour the text, I use an instance of SHTextStylerST80, which I store in my 'styler' instance variable.When my setText: method is called, I use my styler to ...	a) optionally set all assignments to ansi or leftArrow. 	b) Colour my text (immediately, if the text is less than 4096 chars in length, or in a backgroundProcess otherwise)	When my text is changed, my hasUnacceptedEdits: method is called with true, and I ask my styler to re-colour my text. This is performed in a background process so that typing remains responsive regardless of the length of the text.	Just before my styler is about to format/style the text, I send #stylerAboutToStyle:  to my model. This gives my model a chance to veto the styling (by answering false), or to initialize the styler with information it needs in order to parse the text correctly (e.g. the class to which a method belongs, or the workspace in which I am contained).	My styler informs me that it has finished styling by triggering the #stylerStyled: and #stylerStyledInBackground: events which I handle. I then update the textAttributes of my text and refresh the display. 	My 'unstyledAcceptText' instance variable is used in conjunction with my #acceptTextInModel and #correctFrom:to:with: methods to ensure that when my text is modified during a method compilation (removing unused vars etc), I do not lose those changes.!!classDefinition: #TextModelMorph category: #'Morphic-Views for Models'!ScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph hasUnacceptedEdits askBeforeDiscardingEdits hasEditingConflicts editorClass styler '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!TextModelMorph commentStamp: '<historical>' prior: 0!The main morph for text editors!!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 6/23/2011 15:34'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 6/23/2011 16:00'!model: aTextModel	model _ aTextModel.	styler ifNotNil: [ styler textModel: model ].	self releaseParagraph.	"So the model is properly set on the editor and the paragraph"! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 6/23/2011 15:56'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		self redrawNeeded].	aBoolean ifFalse: [ editView hasEditingConflicts: false].	"shout:  re-style the text iff aBoolean is true	Do not apply any formatting (i.e. changes to the characters in the text),	just styling (i.e. TextAttributes)"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess ]! !!BareTextMorph methodsFor: 'initialization' stamp: 'jmv 6/23/2011 15:34'!initialize	super initialize.	wrapFlag _ true.	acceptOnCR _ false.	hasUnacceptedEdits _ false.	askBeforeDiscardingEdits _ true! !!BareTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/23/2011 15:16'!styler: anSHTextStyler		styler _ anSHTextStyler.	anSHTextStyler ifNotNil: [ model ifNotNil: [ anSHTextStyler textModel: model ]]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 6/23/2011 15:25'!installEditorToReplace: priorEditor 	"Install an editor for my paragraph. Install also the paragraph if not there.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [ stateArray _ priorEditor stateArray] .	editor _ model editorClass new morph: self.	editor model: model.	paragraph		ifNotNil: [			editor changeParagraph: paragraph.			editor resetState ]		ifNil: [			"...Code here to recreate the paragraph..."			paragraph _ Paragraph new.			paragraph focused: self hasKeyboardFocus.			paragraph setModel: model container: self container.			editor changeParagraph: paragraph.			editor setEmphasisHereFromText.			paragraph composeAll.			wrapFlag ifFalse: [				"Was given huge container at first... now adjust"				paragraph adjustRightX].			self fit.			editor resetState.		].	stateArray ifNotNil: [ editor stateArrayPut: stateArray ].	self selectionChanged.	^editor! !!BareTextMorph methodsFor: 'testing' stamp: 'jmv 6/23/2011 15:52'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!BareTextMorph methodsFor: 'testing' stamp: 'jmv 6/23/2011 15:53'!hasUnacceptedEdits	^hasUnacceptedEdits! !!BareTextMorph methodsFor: 'miscellaneous' stamp: 'jmv 6/23/2011 15:55'!disregardUnacceptedEdits	^ self hasUnacceptedEdits: false! !!BareTextMorph methodsFor: 'shout' stamp: 'jmv 6/23/2011 15:58'!formatAndStyleIfNeeded	"Apply both formatting (changes to the characters in the text, such as	preferred assignment operators), and styling (TextAttributes to make	Smalltalk code easier to understand)"	self okToStyle ifTrue: [		styler formatAndStyle ]! !!BareTextMorph methodsFor: 'shout' stamp: 'jmv 6/23/2011 15:41'!okToStyle	styler ifNil: [ ^false ].	^model shoutAboutToStyle: styler! !!TextModelMorph methodsFor: 'dependents access' stamp: 'jmv 6/23/2011 15:51'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ textMorph canDiscardEdits! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 6/23/2011 15:47'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						textMorph hasUnacceptedEdits							ifTrue: [								bc _ Color red]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Theme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 6/23/2011 15:57'!initialize	super initialize.	hasEditingConflicts _ false.	textMorph _ BareTextMorph new.	textMorph setEditView: self.	scroller addMorph: textMorph! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 6/23/2011 16:01'!model: aTextModel	super model: aTextModel.	textMorph		model: model wrappedTo: self viewableWidth.	model refetch! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 6/23/2011 15:57'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	textMorph askBeforeDiscardingEdits: aBoolean! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 6/23/2011 15:57'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag in my morph."	textMorph hasUnacceptedEdits: aBoolean! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 6/23/2011 15:59'!update: aSymbol	super update: aSymbol.	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents ifTrue: [		"Some day, it would be nice to keep objects and update them		instead of throwing them away all the time for no good reason..."		textMorph releaseParagraph.		textMorph formatAndStyleIfNeeded.		^self].	aSymbol == #acceptedContents ifTrue: [		textMorph hasUnacceptedEdits ifTrue: [			self hasEditingConflicts: true.				^self redrawNeeded ].		model refetch.		^self].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self].	aSymbol == #initialSelection ifTrue: [		^self setSelection: model getSelection].	aSymbol == #autoSelect ifTrue: [		self handleEdit: [			TextEditor abandonChangeText.	"no replacement!!"			self editor				setSearch: model autoSelectString;				againOrSame: true many: true ]].	"Quite ugly"	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #shoutStyle ifTrue: [		self stylerStyled.		^self redrawNeeded ].! !!TextModelMorph methodsFor: 'menu' stamp: 'jmv 6/23/2011 15:23'!getMenu	| menu |	menu _ MenuMorph new defaultTarget: self.	^model editorClass paneMenu: menu! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 6/23/2011 16:01'!styler: anSHTextStyler		textMorph styler: anSHTextStyler! !TextModelMorph removeSelector: #disregardUnacceptedEdits!TextModelMorph removeSelector: #editorClass!TextModelMorph removeSelector: #formatAndStyleIfNeeded!TextModelMorph removeSelector: #okToStyle!!classDefinition: #TextModelMorph category: #'Morphic-Views for Models'!ScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph hasEditingConflicts'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!BareTextMorph removeSelector: #askBeforeDiscardingEdits!BareTextMorph removeSelector: #editorClass!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler'	classVariableNames: 'AutoCompletter'	poolDictionaries: ''	category: 'Morphic-Text Support'!!BareTextMorph reorganize!('accessing' askBeforeDiscardingEdits: contents: contentsAsIs: crAction editor isWrapped model model: model:wrappedTo: text textColor textColor: wrapFlag:)('anchors' anchorMorph:at:)('caching' releaseCachedState)('classification' is:)('drawing' debugDrawLineRectsOn: drawOn:)('editing' acceptContents acceptOnCR cancelEdits chooseAlignment chooseEmphasisOrAlignment chooseFont enterClickableRegion: handleEdit: handleInteraction: hasUnacceptedEdits:)('event handling' autoScrollView: doubleClick: handlesKeyboard handlesMouseDown: keyStroke: keyboardFocusChange: mouseDown: mouseMove: mouseUp: processKeyStroke:)('events-processing' handleKeystroke: handleMouseMove:)('geometry' container extent: minimumExtent privateMoveBy: textBounds)('initialization' defaultColor initialize)('layout' acceptDroppingMorph:event:)('menu' addCustomMenuItems:hand: wrapOnOff wrapString)('submorphs-add/remove' addMorphFront:fromWorldPosition: styler:)('private' composeToBounds fit installEditorToReplace: mouseButton2Activity paragraph releaseParagraph removedMorph: selectionChanged updateFromParagraph)('notifications' possiblyChanged)('testing' canDiscardEdits hasUnacceptedEdits isOpaqueMorph)('blinking cursor' onBlinkCursor pauseBlinking startBlinking stopBlinking)('accept/cancel' acceptOnCR:)('edit view' editView setEditView:)('macpal' flash)('miscellaneous' clearSelection disregardUnacceptedEdits selectAll)('shout' formatAndStyleIfNeeded okToStyle)!