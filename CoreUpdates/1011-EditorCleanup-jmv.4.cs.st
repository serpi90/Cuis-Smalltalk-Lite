'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 28 May 2011 at 12:07:20 am'!!CharacterBlock commentStamp: '<historical>' prior: 0!My instances contain information about displayed characters. They are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the instance obsolete.My instances are effectively inmutable, as the only method settings instance variables is private and used just to build new instances.!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph pointBlock markBlock beginTypeInBlock emphasisHere otherInterval lastParenLocation oldInterval beginTypeInIndex '	classVariableNames: 'ChangeText FindText UndoInterval UndoMessage UndoParagraph UndoSelection Undone '	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #TextModelMorph category: #'Morphic-Views for Models'!ScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval hasEditingConflicts editorClass styler '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 5/27/2011 10:10'!mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: event].	event hand		waitForSimulatedMouseButton2: self		event: event		dblClkSel: #doubleClick:! !!CharacterBlock methodsFor: 'private' stamp: 'jmv 5/27/2011 11:08'!setStringIndex: anInteger text: aText topLeft: topLeft extent: extent textLine: aLine	stringIndex _ anInteger.	text _ aText.	textLine _ aLine.	self setOrigin: topLeft corner: topLeft + extent! !!CharacterBlock class methodsFor: 'instance creation' stamp: 'jmv 5/27/2011 11:08'!stringIndex: anInteger text: aText topLeft: topLeft extent: extent textLine: aLine	^self new setStringIndex: anInteger text: aText topLeft: topLeft extent: extent textLine: aLine! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 5/27/2011 11:10'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop done stopCondition |	line _ textLine.	rightMargin _ line rightMargin.	lastIndex _ line first.	self setStopConditions.		"also sets font"	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ CharacterBlock					stringIndex: line first					text: text					topLeft: line leftMargin@line top					extent: 0 @ line lineHeight					textLine: line].	destX _ leftMargin _ line leftMarginForAlignment: alignment.	destY _ line top.	runLength _ text runLengthFor: line first.	lineStop _ characterIndex	"scanning for index"		ifNil: [ line last ].			"scanning for point"	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	self placeEmbeddedObject.	done  _ false.	[ done ] whileFalse: [		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth ifNil: [ font widthOf: (text at: lastIndex) ]).		(self perform: stopCondition) ifTrue: [			^characterIndex				ifNil: ["Result for characterBlockAtPoint: "						CharacterBlock							stringIndex: lastIndex							text: text							topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0)							textLine: line ]				ifNotNil: ["Result for characterBlockForIndex: "						CharacterBlock							stringIndex: characterIndex							text: text							topLeft: characterPoint + ((font descentKern - kern max: 0)@ 0)							extent: lastCharacterExtent							textLine: line]]]! !!Editor methodsFor: 'new selection' stamp: 'jmv 5/27/2011 15:25'!selectInvisiblyFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	self markIndex: start pointIndex: stop + 1! !!Editor methodsFor: 'new selection' stamp: 'jmv 5/27/2011 15:25'!selectInvisiblyMark: mark point: point	"Select the designated characters, inclusive.  Make no visual changes."	self markIndex: mark pointIndex: point + 1! !!Paragraph methodsFor: 'selection' stamp: 'jmv 5/27/2011 11:10'!defaultCharacterBlock	^ CharacterBlock		stringIndex: 1		text: self text		topLeft: lines first topLeft		extent: 0 @ 0		textLine: lines first! !!Parser methodsFor: 'error correction' stamp: 'jmv 5/26/2011 19:26'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| correctSelector userSelection |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [^proposedKeyword asSymbol].		"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"	"	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])		ifFalse: [ ^ proposedKeyword asSymbol ].	"	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	correctSelector _ UnknownSelector name: proposedKeyword.	correctSelector ifNil: [^abortAction value].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	self substituteSelector: correctSelector keywords wordIntervals: spots.	^(proposedKeyword last ~~ $:	   and: [correctSelector last == $:])		ifTrue: [abortAction value]		ifFalse: [correctSelector]! !!Parser methodsFor: 'error correction' stamp: 'jmv 5/26/2011 19:27'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding _ requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].		"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"	"	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])		ifFalse: [ ^encoder undeclared: proposedVariable ].	"	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	"Build the menu with alternatives"	action _ UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 15:25'!markIndex: anIndex pointIndex: anotherIndex	markIndex _ anIndex min: string size + 1 max: 1.	pointIndex _ anotherIndex min: string size + 1 max: 1! !!SimpleEditor methodsFor: 'events' stamp: 'jmv 5/27/2011 15:26'!mouseDown: evt index: index		self closeTypeIn.	evt shiftPressed		ifFalse: [			self markIndex: index pointIndex: index ]		ifTrue: [			self mouseMove: evt ]! !!SimpleEditor methodsFor: 'events' stamp: 'jmv 5/27/2011 15:23'!mouseMove: evt index: index	"Change the selection in response to mouse-down drag"	self pointIndex: index! !!SimpleEditor methodsFor: 'initialize-release' stamp: 'jmv 5/27/2011 10:49'!stateArray	"nothing if not built yet"	selectionShowing ifNil: [ ^nil ].		^ {	self selectionInterval.		beginTypeInIndex}! !!SimpleEditor methodsFor: 'mvc compatibility' stamp: 'jmv 5/27/2011 15:26'!zapSelectionWith: aString	| start stop |	self deselect.	start _ self startIndex.	stop _ self stopIndex.	(start = stop and: [aString size = 0]) ifFalse: [		string _ string copyReplaceFrom: start to: stop-1 with: aString.		self markIndex: start pointIndex: start + aString size.		self userHasEdited  " -- note text now dirty" ]! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 15:20'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over; 	(3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  	 Delete all the clusters.  The code is shorter than the comment."	| saveLimit |	saveLimit _ beginTypeInIndex		ifNil: [self openTypeIn. self stopIndex].	self markIndex: startIndex.	startIndex < saveLimit ifTrue: [		beginTypeInIndex _ self startIndex.].	self zapSelectionWith: ''.	self markIndex: self pointIndex! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 15:20'!processKeyStroke: aKeyboardEvent	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."			self deselect.					(self dispatchOn: aKeyboardEvent) ifTrue: [			self doneTyping.			^self].		self openTypeIn.		self markIndex: self pointIndex! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 5/27/2011 09:55'!replace: anInterval with: newText and: selectingBlock 	"Replace the text in anInterval with newText and execute selectingBlock to establish the new selection.  Create an undoAndReselect:redoAndReselect: undoer to allow perfect undoing."	| undoInterval |	undoInterval _ self selectionInterval.	undoInterval = anInterval ifFalse: [self selectInterval: anInterval].	UndoSelection _ self selection.	self zapSelectionWith: newText.	selectingBlock value.	self undoer: #undoAndReselect:redoAndReselect: with: undoInterval with: self selectionInterval! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 5/27/2011 10:52'!replaceSelectionWith: aTextOrString	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	UndoSelection _ self selection.	self zapSelectionWith: aTextOrString.	self undoer: #undoReplace! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!hasCaret	^ markBlock = pointBlock! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:25'!markIndex	^ markBlock stringIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:33'!markIndex: anIndex	"Called, for example, when selecting text with shift+arrow keys"	markBlock _ (paragraph characterBlockForIndex: anIndex)! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 15:25'!markIndex: anIndex pointIndex: anotherIndex	"Called, for example, when selecting text with shift+arrow keys"	markBlock _ (paragraph characterBlockForIndex: anIndex).	pointBlock _ (paragraph characterBlockForIndex: anotherIndex)! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!pointIndex	^ pointBlock stringIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:33'!pointIndex: anIndex	"Called, for example, when selecting text with shift+arrow keys"	pointBlock _ (paragraph characterBlockForIndex: anIndex)! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!startBlock	^ pointBlock min: markBlock! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!stopBlock	^ pointBlock max: markBlock! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 5/27/2011 15:27'!recomputeInterval	"The same characters are selected but their coordinates may have changed."	self markIndex: self markIndex pointIndex: self pointIndex! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 5/27/2011 10:24'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing _ selectionShowing not.	paragraph reverseFrom: pointBlock to: markBlock! !!TextEditor methodsFor: 'events' stamp: 'jmv 5/27/2011 10:23'!mouseDown: evt 	| clickPoint b |	clickPoint _ evt position.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint for: model) ifTrue: [		markBlock _ b.		pointBlock _ b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			self closeTypeIn.			markBlock _ b.			pointBlock _ b ]! !!TextEditor methodsFor: 'events' stamp: 'jmv 5/27/2011 10:29'!mouseMove: evt	"Change the selection in response to mouse-down drag"	pointBlock _ (paragraph characterBlockAtPoint: (evt position)).	self storeSelectionInParagraph! !!TextEditor methodsFor: 'events' stamp: 'jmv 5/27/2011 15:33'!mouseUp: evt	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |	evt shiftPressed		ifTrue: [			"Squeak classic behavior for click, move, shift-click sequence "			"pointBlock _(paragraph characterBlockAtPoint: (evt position))."			"Mac behavior"			cursorBlock _ paragraph characterBlockAtPoint: evt position.			cursorIndex _ cursorBlock stringIndex.			startBlock _ self startBlock min: cursorBlock.			startIndex _ startBlock stringIndex.			stopBlock _ self stopBlock max: cursorBlock.			stopIndex _ stopBlock stringIndex.			(stopIndex - cursorIndex) < (cursorIndex - startIndex)				ifTrue: [					markBlock _ startBlock.					pointBlock _ cursorBlock ]				ifFalse: [					markBlock _ stopBlock.					pointBlock _ cursorBlock ]].	self storeSelectionInParagraph.	self setEmphasisHereFromText! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 5/27/2011 11:13'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	markBlock _ paragraph defaultCharacterBlock.	pointBlock _ markBlock.	beginTypeInIndex _ nil.	UndoInterval _ 1 to: 0.	self setEmphasisHereFromText.	selectionShowing _ false! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 5/27/2011 10:49'!stateArray	"nothing if not built yet"	selectionShowing ifNil: [ ^nil ].	^ {		self selectionInterval.		beginTypeInIndex.		emphasisHere}! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 5/27/2011 10:48'!stateArrayPut: stateArray	| sel |	sel _ stateArray at: 1.	self selectFrom: sel first to: sel last.	beginTypeInIndex _ stateArray at: 2.	emphasisHere _ stateArray at: 3.	morph possiblyChanged! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/26/2011 18:01'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: ''.	reply size = 0 ifTrue: [		^ self].	self setSearch: reply.	ChangeText _ FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true."	morph installEditorToReplace: self"! !!TextEditor methodsFor: 'mvc compatibility' stamp: 'jmv 5/27/2011 10:39'!storeSelectionInParagraph	"for proper display of selected text"	paragraph selectionStart: self startBlock selectionStop: self stopBlock! !!TextEditor methodsFor: 'mvc compatibility' stamp: 'jmv 5/27/2011 15:27'!zapSelectionWith: replacement	| start stop rep |	self deselect.	start _ self startIndex.	stop _ self stopIndex.	(replacement isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (self text attributesAt: start) select: [:att | att mayBeExtended]].	(start = stop and: [ replacement isEmpty ]) ifFalse: [		(replacement is: #Text)			ifTrue: [				"If we are pasting a text that doesn't bring a ParagraphStyleReference in the past paragraph, and we need it,				but it won't be provided by our text, as we are at the end, then add any paragraph attribute from emphasisHere"				(replacement notEmpty and: [ (replacement last = Character cr) not and: [ stop > self text size ]])					ifTrue: [						rep _ (replacement, (Text string: String cr attributes: emphasisHere)) copyFrom: 1 to: replacement size ]					ifFalse: [ rep _ replacement ]]			ifFalse: [ rep _ Text string: replacement attributes: emphasisHere ].		self text replaceFrom: start to: stop - 1 with: rep.		paragraph			recomposeFrom: start			to:  start + rep size - 1			delta: rep size - (stop-start).		self markIndex: start pointIndex: start + rep size.		UndoInterval _ self selectionInterval.		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 5/27/2011 09:53'!selectCurrentTypeIn: aKeyboardEvent 	"Select what would be replaced by an undo (e.g., the last typeIn)."	self closeTypeIn.	self closeTypeIn.	self selectInterval: UndoInterval.	^ true! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 15:20'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over;	(3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInIndex		ifNil: [self openTypeIn. UndoSelection _ self nullText. self stopIndex].	self markIndex: startIndex.	startIndex < saveLimit ifTrue: [		newBackovers _ beginTypeInIndex - startIndex.		beginTypeInIndex _ self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(self text copyFrom: startIndex to: saveLimit - 1).		UndoMessage hasArguments ifTrue: [ 			UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers]].	self zapSelectionWith: self nullText.	markBlock _ pointBlock! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 10:49'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInIndex ifNotNil: [		(UndoMessage sends: #noUndoer) ifTrue: [ "should always be true, but just in case..."			begin _ beginTypeInIndex.			stop _ self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInIndex _ nil]! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 10:47'!doneTyping	beginTypeInIndex _ nil! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 10:47'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInIndex ifNil: [		UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInIndex _ self startIndex]! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 15:20'!processKeyStroke: aKeyboardEvent	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."			self deselect.					(self dispatchOn: aKeyboardEvent) ifTrue: [		self doneTyping.		self storeSelectionInParagraph.		^self].	self openTypeIn.							self hasSelection ifTrue: [ "save highlighted characters"		UndoSelection _ self selection].	markBlock _ pointBlock.					self storeSelectionInParagraph! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 5/27/2011 10:47'!forwardDelete: aKeyboardEvent	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ self markIndex.	startIndex > self text size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInIndex ifNil: [	"no previous typing.  openTypeIn"		self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval copy.	upara _ UndoParagraph copy.	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection is: #Text) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with: self nullText]].	^false! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/26/2011 19:25'!againOrSame: useOldKeys	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.	 1/26/96 sw: real worked moved to againOrSame:many:"	self againOrSame: useOldKeys many: false! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/26/2011 19:26'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText _ UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText _ ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: "just inserted at a caret"			[home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home _ self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 5/27/2011 09:52'!initializeBasicCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor test"	"Editor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		"arranged in QWERTY keyboard order"	cmds _ #(		$w #backWord:		$a #selectAll:		$f #find:		$g #findAgain:		$h #setSearchString:		$z #undo:		$x #cut:		$c #copySelection:		$v #paste:		$R	#indent:		$Y	#makeUppercase:		$U	#changeLfToCr:		$S	#search:		$H	#cursorTopHome:		$J	#doAgainMany:		$L	#outdent:		$Z	#makeCapitalized:		$X	#makeLowercase:		$C	#compareToClipboard:		$M	#selectCurrentTypeIn:	).	1 to: cmds size		by: 2		do: [ :i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions _ cmdMap! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 5/27/2011 23:59'!handleEdit: editBlock	| result |	textMorph handleEdit: [ result _ editBlock value ].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 5/26/2011 19:28'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest cpHere |	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [event anyButtonPressed]) ifTrue: [  "Check for autoscroll"		cpHere _ scroller externalizePosition: event position to: self.		cpHere y <= bounds top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= bounds bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ textMorph bounds: rectToTest in: self.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!TextModelMorph methodsFor: 'interactive error protocol' stamp: 'jmv 5/26/2011 19:37'!correctSelectionWithString: aString	| result newPosition sel |	sel _ self editor selectionInterval.	result _ self correctFrom: sel first to: sel last with: aString.	newPosition _ sel first + aString size.	self setSelection: (newPosition to: newPosition - 1).	^ result! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 5/28/2011 00:00'!printIt	| result oldEditor |	textMorph handleEdit: [result _ (oldEditor _ textMorph editor) evaluateSelection].	(result == #failedDoit) ifTrue: [^self flash].	textMorph installEditorToReplace: oldEditor.	textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	self scrollSelectionIntoView.! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 5/26/2011 19:29'!setSelection: sel	self editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [ scroller redrawNeeded ]! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 5/26/2011 19:35'!stylerStyled	"jmv - 11/2010 The next line used to be commented out but it is needed to fix lines whose	length might change due to font change (i.e., styled comments are shorter than unstyled)"	textMorph paragraph composeAll.	"older comment: caused chars to appear in wrong order esp. in demo mode. remove this line when sure it is fixed"		textMorph updateFromParagraph.	self editor setEmphasisHereFromText.	self editor blinkParen.	self scrollSelectionIntoView! !TextModelMorph removeSelector: #mouseLeave:!TextModelMorph removeSelector: #selectionInterval:!!classDefinition: #TextModelMorph category: #'Morphic-Views for Models'!ScrollPane subclass: #TextModelMorph	instanceVariableNames: 'textMorph hasUnacceptedEdits askBeforeDiscardingEdits hasEditingConflicts editorClass styler'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!TextEditor removeSelector: #disregardNextMouseUp!TextEditor removeSelector: #duplicate:!TextEditor removeSelector: #exchange!TextEditor removeSelector: #exchange:!TextEditor removeSelector: #exchangeWith:!TextEditor removeSelector: #markBlock!TextEditor removeSelector: #markBlock:!TextEditor removeSelector: #pointBlock!TextEditor removeSelector: #pointBlock:!TextEditor removeSelector: #setViewSelection!TextEditor removeSelector: #startOfTyping!TextEditor removeSelector: #swapChars:!TextEditor removeSelector: #unselect!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph pointBlock markBlock beginTypeInIndex emphasisHere lastParenLocation'	classVariableNames: 'ChangeText FindText UndoInterval UndoMessage UndoParagraph UndoSelection Undone'	poolDictionaries: ''	category: 'System-Text'!SimpleEditor removeSelector: #startOfTyping!Editor removeSelector: #unselect!CompilerExceptionsTest removeSelector: #selectionInterval:!CharacterBlock removeSelector: #stringIndex:text:topLeft:extent:!CharacterBlock removeSelector: #textLine:!