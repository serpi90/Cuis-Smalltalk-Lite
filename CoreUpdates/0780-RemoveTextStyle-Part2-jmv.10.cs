'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 24 January 2011 at 4:26:21 pm'!!classDefinition: #AbstractFont category: #'Graphics-Text'!Object subclass: #AbstractFont	instanceVariableNames: 'defaultTextStyle '	classVariableNames: 'AvailableFonts DefaultFont '	poolDictionaries: ''	category: 'Graphics-Text'!!classDefinition: #Text category: #'System-Text'!ArrayedCollection subclass: #Text	instanceVariableNames: 'string runs initialStyle '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!Text commentStamp: '<historical>' prior: 0!I represent a character string that has been marked with abstract changes in character appearance. Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used.  A Text associates a set of TextAttributes with each character in its character string.  These attributes may be font numbers, emphases such as bold or italic, or hyperling actions.  Font numbers are interpreted relative to whatever textStyle appears, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.  Each of my instances has	string		a String	runs		a RunArray			From the comment at #deepCopy, written by Dan on 11/9/97:"Both string and runs are assumed to be read-only"!!classDefinition: #TextComposer category: #'Morphic-Text Support'!Object subclass: #TextComposer	instanceVariableNames: 'lines maxRightX currentY scanner possibleSlide nowSliding prevIndex prevLines currCharIndex startCharIndex stopCharIndex deltaCharIndex theText theContainer isFirstLine defaultLineHeight actualHeight anythingComposed editor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!BalloonMorph class methodsFor: 'private' stamp: 'jmv 1/24/2011 16:03'!getTextMorph: aStringOrMorph for: balloonOwner	"Construct text morph."	| m text fontToUse |	(aStringOrMorph is: #Morph)		ifTrue: [ m _ aStringOrMorph ]		ifFalse: [			text _ Text string: aStringOrMorph attribute: TextAlignment centered.			(fontToUse _ balloonOwner balloonFont)				ifNotNil: [					text font: fontToUse ].			m _ StringMorph new contents: text].	^ m! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 1/24/2011 15:49'!minimumExtent	^(9@(StrikeFont default height+2))! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 1/24/2011 15:49'!fit	"Adjust my bounds to fit the text.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para |	newExtent := (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).	newExtent ~= bounds extent 		ifTrue: [			para := paragraph.	"Save para (layoutChanged smashes it)"			self basicExtent: newExtent.			paragraph := para].	"These statements should be pushed back into senders"	self paragraph positionWhenComposed: self position.	self changed.	"Too conservative: only paragraph composition					should cause invalidation."	editView innerHeight: newExtent y! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 1/24/2011 16:03'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change class s1 s2 differDesc diffWords |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])		ifTrue: [			s1 _ (class sourceCodeAt: change methodSelector) asString.			s2 _ change string.			s1 = s2				ifTrue: [^ self inform: 'Exact Match'].			diffWords _ self shouldDiffWords.			differDesc _ diffWords				ifTrue: [ 'Words']				ifFalse: [ 'Lines'].			(TextModel new				actualContents: (					(DifferenceFinder						displayPatchFrom: s1 to: s2						tryWords: diffWords						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))							font: Preferences standardCodeFont))				openLabel: 'Comparison to Current Version: ', differDesc, 					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]		ifFalse: [self flash]! !!CharacterScanner methodsFor: 'private' stamp: 'jmv 1/24/2011 15:28'!text: aText	text _ aText.	actualTextStyle _ nil! !!CharacterScanner methodsFor: 'stop conditions' stamp: 'jmv 1/24/2011 16:22'!tabDestX	"This is the basic method of adjusting destX for a tab."	^actualTextStyle		ifNotNil: [			actualTextStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin ]		ifNil: [			"The only interesting thing in this method is the 24..."			destX - leftMargin // 24 + 1 * 24 + leftMargin min: rightMargin ]! !!DisplayScanner methodsFor: 'private' stamp: 'jmv 1/24/2011 15:28'!text: t foreground: foreColor ignoreColorChanges: shadowMode	text _ t.	actualTextStyle _ nil.	foregroundColor _ paragraphColor _ foreColor.	ignoreColorChanges _ shadowMode! !!EntryField2LW methodsFor: 'drawing' stamp: 'jmv 1/24/2011 16:03'!characterIndexAtPoint: aPoint	| line block |		line _ TextLine 		start: 1		stop: contents size		internalSpaces: 0		paddingWidth: 0.	line		rectangle: bounds;		lineHeight: font height baseline: font ascent.			block _ (CharacterBlockScanner new text: 			(contents asText font: font))		characterBlockAtPoint: aPoint index: nil		in: line.	^ block stringIndex! !!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 1/24/2011 16:03'!characterIndexAtPoint: aPoint	| line block f |	f _ self fontToUse.		line _ TextLine 		start: 1		stop: contents size		internalSpaces: 0		paddingWidth: 0.	line		rectangle: bounds;		lineHeight: f height baseline: f ascent.			block _ (CharacterBlockScanner new text: 			(contents asText font: font))		characterBlockAtPoint: aPoint index: nil		in: line.	^ block stringIndex! !!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 1/24/2011 15:55'!rectanglesAt: y	(y+1) > self bottom ifTrue: [^ Array new].	^ Array with: (origin x @ y corner: corner x @ (y+1))! !!Text methodsFor: 'copying' stamp: 'jmv 1/24/2011 16:06'!copy	^ self class new setString: string copy setRuns: runs copy! !!Text methodsFor: 'copying' stamp: 'jmv 1/24/2011 16:06'!copyFrom: start to: stop 	"Answer a copied subrange of the receiver."	| realStart realStop |	stop > self size		ifTrue: [realStop _ self size]		"handle selection at end of string"		ifFalse: [realStop _ stop].	start < 1		ifTrue: [realStart _ 1]			"handle selection before start of string"		ifFalse: [realStart _ start].	^Text		string: (string copyFrom: realStart to: realStop)		runs: (runs copyFrom: realStart to: realStop)! !!Text methodsFor: 'converting' stamp: 'jmv 1/24/2011 16:06'!reversed	"Answer a copy of the receiver with element order reversed."		| answer |	answer _ self class string: string reversed runs: runs reversed.	"Ensure the ParagraphAttributes invariant for the interval that could have been affected.	The way it is done could be considered to be wrong. In this case, instead of making the text to take	the ParagraphAttributes from the cr characters, it could be done the other way, making the cr's take 	the ParagraphAttributes of the preceeding char. This way, the attributes would be mostrly preserved.	I don't know if this is of much use anyway"	answer fixParagraphAttributesFrom: 1 to: answer size.	^answer  "  It is assumed that  self size = runs size  holds. "! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 16:03'!font: aFont	"Apply aFont to the entire contents"	self addAttribute: (TextFontReference toFont: aFont)! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 15:36'!textStyleAt: characterIndex	| textStyle |	self size = 0 ifTrue: [ ^ nil ].	textStyle _ nil.	(runs at: characterIndex) do: [ :attribute | 		attribute forTextStyleReferenceDo: [ :s | textStyle _ s ] ].	^textStyle! !!Text methodsFor: 'emphasis' stamp: 'jmv 1/24/2011 15:46'!withAttributeValues: attributes do: aBlock	"Evaluate aBlock with the values of various attributes applied in the correct order	The order is (each overwriting the previous one)	1) initialStyle	2) TextStyleReferene	3) CharacterStyleReference	4) TextFontReference	5) TextEmphasis"	| textStyle characterStyle font emphasis alignment color kern |	textStyle _ nil.	emphasis _ 0.	kern _ 0.	color _ nil.	alignment _ 0.	font _ StrikeFont default.		"TextStyle is the first to set several values"	attributes do: [ :attribute |		attribute forTextStyleReferenceDo: [ :s | 			textStyle _ s]].	textStyle		ifNotNil: [			font _ textStyle font.			alignment _ textStyle alignment.			textStyle color ifNotNil: [ :c | color _ c ]].	"CharacterStyle, if present, can override font and color"	attributes do: [ :attribute |		attribute forCharacterStyleReferenceDo: [ :s | 			characterStyle _ s.			font _ characterStyle font.			characterStyle color ifNotNil: [ :c | color _ c ]]].		"Hardcoded color for TextAction comes before TextColor"	attributes do: [ :attribute |		attribute forTextActionInfoDo: [ :info | color _ TextAction purple ]].	"These will not interfere with each other, and all of them take precedence over previous values"	attributes do: [ :attribute |		attribute forFontReferenceDo: [ :f | font _ f ].		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].		attribute forTextColorDo: [ :c | color _ c ].		attribute forTextAlignmentDo: [ :a | alignment _ a ].		attribute forTextKernDo: [ :k | kern _ kern + k ].	].	"Finally, the font must include any specified emphasis"	font _ font emphasized: emphasis.		"Done. Now evaluate the block."	aBlock valueWithArguments: {font. color. alignment. textStyle. characterStyle. kern }! !!Text methodsFor: 'private' stamp: 'jmv 1/24/2011 16:05'!setString: aString setRuns: anArray	"Warning. No attempt is done to ensure the invariant that TextAttributes that answer true to	 #isParagraphAttribute are only applied to whole paragraphs.	Use with care. "	string _ aString.	self privateSetRuns: anArray! !!Text methodsFor: 'attributes' stamp: 'jmv 1/24/2011 16:05'!hasAnyAttribute	"Return false if there are no emphasis (i.e., a String would not make a difference)"	^runs values anySatisfy: [ :emphArray | emphArray notEmpty ]! !!Text class methodsFor: 'instance creation' stamp: 'jmv 1/24/2011 16:12'!initialFont: aStrikeFont string: aString attribute: att	"Answer an instance of me whose characters are aString.	att is a TextAttribute."	^self string: aString attributes: {TextFontReference toFont: aStrikeFont. att}! !!Text class methodsFor: 'instance creation' stamp: 'jmv 1/24/2011 16:09'!initialFont: aStrikeFont stringOrText: aStringOrText	"Answer an instance of me whose characters are aString."	(aStringOrText isKindOf: Text) ifTrue: [		^ aStringOrText font: aStrikeFont ].		^self string: aStringOrText attributes: {TextFontReference toFont: aStrikeFont}! !!Text class methodsFor: 'private' stamp: 'jmv 1/24/2011 16:06'!string: aString runs: anArray 	^self basicNew setString: aString setRuns: anArray! !!Text class methodsFor: 'instance creation' stamp: 'jmv 1/24/2011 16:07'!string: aString attributes: atts	"Answer an instance of me whose characters are those of aString.	atts is an array of TextAttributes."	^self string: aString runs: (RunArray new: aString size withAll: atts)! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 1/24/2011 15:33'!addEmptyTrailingLine	"The line to add is always the first line of a new paragraph"	| ts f h bs r lm rm w a leftMarginForAlignment s |	s _ theText size+1.	f _ editor		ifNotNil: [ editor lastFont ]		ifNil: [ theText fontAt: s ].	ts _ editor		ifNotNil: [ editor lastParagraphStyle ]		ifNil: [ theText textStyleAt: s].	h _ f height.	bs _ f ascent.	lm _ 0.	rm _ 0.	w _ theContainer width.	a _ 0.	ts ifNotNil: [		h _h + ts paragraphSpacingBefore + ts paragraphSpacingAfter.		bs _ bs + ts paragraphSpacingBefore.		lm _ (ts isListStyle not			ifTrue: [ts firstIndent]			ifFalse: [ts restIndent]).		rm _ ts rightIndent.		a _ ts alignment ].		leftMarginForAlignment _ a = CharacterScanner rightFlushCode		ifTrue: [ w - rm]		ifFalse: [			a = CharacterScanner centeredCode				ifTrue: [ (w - rm - lm) //2 + lm]				ifFalse: [ lm ]].	r _ theContainer left + leftMarginForAlignment @ currentY extent: 0@h.	lines addLast: (		EmptyLine new			firstIndex: s lastIndex: s - 1;			rectangle: r;			lineHeight: h baseline: bs;			textStyle: ts)! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 1/24/2011 15:56'!composeAllLines	[currCharIndex <= theText size and: [			currentY < theContainer bottom]] whileTrue: [		nowSliding ifTrue: [			self slideOneLineDown ifNil: [^nil].		] ifFalse: [			self composeOneLine ifNil: [^nil].		]	].! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 1/24/2011 15:56'!composeAllRectangles: rectangles	| charIndexBeforeLine numberOfLinesBefore reasonForStopping |	actualHeight _ 1.	charIndexBeforeLine _ currCharIndex.	numberOfLinesBefore _ lines size.	reasonForStopping _ self composeEachRectangleIn: rectangles.	currentY _ currentY + actualHeight.	currentY > theContainer bottom ifTrue: [		"Oops -- the line is really too high to fit -- back out"		currCharIndex _ charIndexBeforeLine.		lines size - numberOfLinesBefore timesRepeat: [lines removeLast].		^self	].		"It's OK -- the line still fits."	maxRightX _ maxRightX max: scanner rightX.	1 to: rectangles size - 1 do: [ :i |		"Adjust heights across rectangles if necessary"		(lines at: lines size - rectangles size + i)			lineHeight: lines last lineHeight			baseline: lines last baseline	].	anythingComposed _ true.	isFirstLine _ currCharIndex = 1 or: [		 (theText at: currCharIndex-1) = Character cr].	reasonForStopping == #columnBreak ifTrue: [^nil].	currCharIndex > theText size ifTrue: [		^nil		"we are finished composing"	]! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 1/24/2011 15:56'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY text: argText container: argContainer	lines _ argLinesCollection.	theText _ argText.	theContainer _ argContainer.	deltaCharIndex _ argDelta.	currCharIndex _ startCharIndex _ argStart.	stopCharIndex _ argStop.	prevLines _ argPriorLines.	currentY _ argStartY.	maxRightX _ theContainer left.	possibleSlide _ stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding _ false.	prevIndex _ 1.	scanner _ CompositionScanner new text: theText.	isFirstLine _ currCharIndex = 1 or: [		 (theText at: currCharIndex-1) = Character cr].	anythingComposed _ false.	self composeAllLines.	(anythingComposed not or: [ theText last = Character cr ])		ifTrue: [			self addEmptyTrailingLine ].	^{lines asArray. maxRightX}! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 1/24/2011 15:55'!composeOneLine	| rectangles |	rectangles := theContainer rectanglesAt: currentY.	rectangles notEmpty 		ifTrue: [(self composeAllRectangles: rectangles) ifNil: [^nil]]		ifFalse: [currentY := currentY + 1].	self checkIfReadyToSlide! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 1/24/2011 15:49'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	scroller hasSubmorphs ifFalse: [ ^1].	^ StrikeFont default height! !TextModel class removeSelector: #normal!TextComposer class removeSelector: #characterForColumnBreak!!classDefinition: #TextComposer category: #'Morphic-Text Support'!Object subclass: #TextComposer	instanceVariableNames: 'lines maxRightX currentY scanner possibleSlide nowSliding prevIndex prevLines currCharIndex startCharIndex stopCharIndex deltaCharIndex theText theContainer isFirstLine actualHeight anythingComposed editor'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!Text class removeSelector: #initialStyle:string:!Text class removeSelector: #initialStyle:string:attributes:!Text class removeSelector: #initialStyle:string:runs:!Text removeSelector: #initialFont:!Text removeSelector: #initialStyle!Text removeSelector: #initialStyleOrNil!Text removeSelector: #setInitialStyle:setString:setRuns:!!classDefinition: #Text category: #'System-Text'!ArrayedCollection subclass: #Text	instanceVariableNames: 'string runs'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!Rectangle removeSelector: #rectanglesAt:height:!BareTextMorph removeSelector: #defaultLineHeight!AbstractFont removeSelector: #defaultTextStyle!!classDefinition: #AbstractFont category: #'Graphics-Text'!Object subclass: #AbstractFont	instanceVariableNames: ''	classVariableNames: 'AvailableFonts DefaultFont'	poolDictionaries: ''	category: 'Graphics-Text'!Smalltalk removeClassNamed: #TextStyle!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Preferences resetHaloSpecifications!