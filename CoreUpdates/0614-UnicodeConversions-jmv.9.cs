'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 7 October 2010 at 5:48:56 pm'!!classDefinition: #Character category: #'Kernel-Text'!Magnitude subclass: #Character	instanceVariableNames: 'value '	classVariableNames: 'CharacterTable ClassificationTable LetterBits LowercaseBit UppercaseBit UnicodeCodePoints '	poolDictionaries: ''	category: 'Kernel-Text'!!Character commentStamp: '<historical>' prior: 0!I represent a character by storing its associated Latin-9 code (ISO 8859-15). My instances are created uniquely, so that all instances of a character ($R, for example) are identical.!!classDefinition: #String category: #'Kernel-Text'!ArrayedCollection variableByteSubclass: #String	instanceVariableNames: ''	classVariableNames: 'CSLineEnders CSNonSeparators CSSeparators CaseInsensitiveOrder CaseSensitiveOrder Latin1ToUtf8Encodings Latin1ToUtf8Map LowercasingTable Tokenish UppercasingTable '	poolDictionaries: ''	category: 'Kernel-Text'!!Character methodsFor: 'accessing' stamp: 'jmv 10/7/2010 16:46'!iso8859s15Code	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding."	^value! !!Character methodsFor: 'accessing' stamp: 'jmv 10/7/2010 16:26'!unicodeCodePoint	"	self assert: $A unicodeCodePoint hex = '16r41'.	self assert: $¤ unicodeCodePoint hex = '16r20AC'.	"	^UnicodeCodePoints at: value+1! !!Character class methodsFor: 'class initialization' stamp: 'jmv 10/7/2010 15:52'!initialize	"Create the table of unique Characters.	Character initialize	"	self initializeClassificationTable.	self initializeUnicodeCodePoints! !!Character class methodsFor: 'class initialization' stamp: 'jmv 10/7/2010 15:52'!initializeUnicodeCodePoints	"Initialize the table if Unicode code points"	UnicodeCodePoints _ Array new: 256.	0 to: 255 do: [ :code |		UnicodeCodePoints at: code + 1 put: code ].		"The following codes are different in ISO 8859-15 from those in ISO 8859-1,	so the character code is not equal to the Unicode code point"	UnicodeCodePoints at: 16rA4+1 put: 16r20AC.		"euro sign"	UnicodeCodePoints at: 16rA6+1 put: 16r160.		"latin capital letter S with caron"	UnicodeCodePoints at: 16rA8+1 put: 16r161.		"latin small letter s with caron"	UnicodeCodePoints at: 16rB4+1 put: 16r17D.		"latin capital letter Z with caron"	UnicodeCodePoints at: 16rB8+1 put: 16r17E.		"latin small letter z with caron"	UnicodeCodePoints at: 16rBC+1 put: 16r152.		"latin capital ligature OE"	UnicodeCodePoints at: 16rBD+1 put: 16r153.		"latin small ligature oe"	UnicodeCodePoints at: 16rBE+1 put: 16r178.		"latin capital letter Y with diaeresis"! !!Character class methodsFor: 'instance creation' stamp: 'jmv 10/7/2010 16:28'!unicodeCodePoint: codePoint	"	Answer nil if the Unicode codePoint is not a valid ISO 8859-15 character		self assert: (Character unicodeCodePoint: 16r41) = $A.	self assert: (Character unicodeCodePoint: 16r20AC) = $¤.	"	| code |	code _ (UnicodeCodePoints indexOf: codePoint) -1.	code = -1 ifTrue: [ ^nil ].	^Character value: code! !!Character class methodsFor: 'converting' stamp: 'jmv 10/7/2010 16:47'!iso8859s15CodeForUnicodeCodePoint: codePoint	"	Answer nil if the Unicode codePoint is not a valid ISO 8859-15 character		self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r41) = $A iso8859s15Code.	self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r20AC) = $¤ iso8859s15Code.	"	| code |	code _ (UnicodeCodePoints indexOf: codePoint) -1.	code = -1 ifTrue: [ ^nil ].	^code! !!Clipboard methodsFor: 'accessing' stamp: 'jmv 10/7/2010 17:48'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard.	Note:		Smalltalk clipboard can hold a String or a Text.		OS clipboard currently supports ony a String"	| iso8859s15Format primitiveFormat |	primitiveFormat _ self primitiveClipboardText.	"The VM uses UTF-8 for clipboard"	iso8859s15Format _ primitiveFormat utf8ToISO8859s15.	^(iso8859s15Format isEmpty or: [iso8859s15Format = contents asString])		ifTrue: [ contents ]		ifFalse: [ iso8859s15Format ]! !!Clipboard methodsFor: 'accessing' stamp: 'jmv 10/7/2010 08:43'!clipboardText: textOrString	"Set text currently on the clipboard.  Also export to OS"	| primitiveFormat |	contents _ textOrString.	self noteRecentClipping: textOrString.	"The VM uses UTF-8 for clipboard"	primitiveFormat _ textOrString asString iso8859s15ToUtf8.	self primitiveClipboardText: primitiveFormat! !!HandMorph methodsFor: 'private events' stamp: 'jmv 10/7/2010 17:06'!generateKeyboardEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type keyValue pressType stamp |	stamp _ evtBuf second.	stamp = 0 ifTrue: [stamp _ Time millisecondClockValue].	keyValue _ evtBuf sixth > 0		ifTrue: [ (Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) ifNil: [^nil] ]		"Is there any current VM that doesn't set the Unicode code point?		This could perhaps be removed!!"		ifFalse: [ Character macRomanToLatin1: evtBuf third ].	pressType _ evtBuf fourth.	pressType = EventKeyDown ifTrue: [type _ #keyDown].	pressType = EventKeyUp ifTrue: [type _ #keyUp].	pressType = EventKeyChar ifTrue: [type _ #keystroke].	modifiers _ evtBuf fifth.	buttons _ modifiers bitShift: 3.	^KeyboardEvent new 		setType: type		buttons: buttons		position: self position		keyValue: keyValue		hand: self		stamp: stamp! !!Integer class methodsFor: 'UTF-8 conversion' stamp: 'jmv 10/7/2010 16:26'!evaluate: aBlock withUtf8BytesOfUnicodeCodePoint: aCodePoint	"	See #utf8BytesOfCodePont: for typical usage		| characters bytes |	characters _ 'áåæñÆ¥ü' readStream.	bytes _ ByteArray streamContents: [ :strm |		[ characters atEnd ] whileFalse: [			Integer evaluate: [ :byte | strm nextPut: byte ] withUtf8BytesOfUnicodeCodePoint: characters next asciiValue ]].	self assert: bytes hex = 'C3A1C3A5C3A6C3B1C386C2A5C3BC'	"	| mask nBytes shift |	aCodePoint < 128 ifTrue: [		^aBlock value: aCodePoint ].	nBytes _ aCodePoint highBit + 3 // 5.	mask _ #(128 192 224 240 248 252 254 255) at: nBytes.	shift _ nBytes - 1 * -6.	aBlock value: (aCodePoint bitShift: shift) + mask.	2 to: nBytes do: [ :i | 		shift _ shift + 6.		aBlock value: ((aCodePoint bitShift: shift) bitAnd: 63) + 128.	]! !!Integer class methodsFor: 'UTF-8 conversion' stamp: 'jmv 10/7/2010 16:26'!nextUnicodeCodePointFromUtf8: anUtf8Stream	"	anUtf8Stream can be over a ByteArray or a String	Answer nil if conversion not possible	| bytes string |	bytes _ (ByteArray readHexFrom: 'C3A1C3A5C3A6C3B1C386C2A5C3BC') readStream.	string _ String streamContents: [ :strm |		[bytes atEnd ] whileFalse: [			strm nextPut: (Character value: (Integer nextUnicodeCodePointFromUtf8: bytes )) ]].	self assert: string = 'áåæñÆ¥ü'	"	| byte1 byte2 byte3 byte4 |	byte1 _ anUtf8Stream next asInteger.	byte1 < 128 ifTrue: [	"single byte"		^byte1 ].		"At least 2 bytes"	byte2 _ anUtf8Stream next asInteger.	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"		^ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ].		"At least 3 bytes"	byte3 _ anUtf8Stream next asInteger.	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"		^ ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63) ].	byte4 _ anUtf8Stream next asInteger.	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"		^ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12) + ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63) ].	^nil! !!Integer class methodsFor: 'UTF-8 conversion' stamp: 'jmv 10/7/2010 16:26'!unicodeCodePointOfUtfBytes: aByteArray	"	self assert: (Integer unicodeCodePointOfUtfBytes: (ByteArray readHexFrom: '24')) hex = '16r24'.	self assert: (Integer unicodeCodePointOfUtfBytes: (ByteArray readHexFrom: 'C2A2')) hex = '16rA2'.	self assert: (Integer unicodeCodePointOfUtfBytes: (ByteArray readHexFrom: 'E282AC')) hex = '16r20AC'.	self assert: (Integer unicodeCodePointOfUtfBytes: (ByteArray readHexFrom: 'F0A4ADA2')) hex = '16r24B62'.	"	^ Integer nextUnicodeCodePointFromUtf8: aByteArray readStream! !!Integer class methodsFor: 'UTF-8 conversion' stamp: 'jmv 10/7/2010 16:26'!utf8BytesOfUnicodeCodePoint: aCodePoint	"	self assert: (Integer utf8BytesOfUnicodeCodePoint: 16r0024) hex =  '24'.	self assert: (Integer utf8BytesOfUnicodeCodePoint: 16r00A2) hex =  'C2A2'.	self assert: (Integer utf8BytesOfUnicodeCodePoint: 16r20AC) hex = 'E282AC'.	self assert: (Integer utf8BytesOfUnicodeCodePoint: 16r024B62) hex = 'F0A4ADA2'.	"	^ ByteArray streamContents: [ :strm |		self			evaluate: [ :byte |				strm nextPut: byte ]			withUtf8BytesOfUnicodeCodePoint: aCodePoint ].! !!String methodsFor: 'converting' stamp: 'jmv 10/7/2010 16:29'!iso8859s15ToUtf8	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)"	"	self assert: ('A¢¤' iso8859s15ToUtf8 asByteArray) hex = '41C2A2E282AC'	"	^String streamContents: [ :strm | | characters |		characters _ self readStream.		[ characters atEnd ] whileFalse: [			Integer				evaluate: [ :byte | strm nextPut: (Character value: byte) ]				withUtf8BytesOfUnicodeCodePoint: characters next unicodeCodePoint ]]! !!String methodsFor: 'converting' stamp: 'jmv 10/7/2010 16:28'!utf8ToISO8859s15	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"	"Skip any unicode chars not in ISO Latin 9 (ISO 8859-15)"	"	self assert: (ByteArray readHexFrom: '41C2A2E282AC') asString utf8ToISO8859s15 = 'A¢¤'	"	^String streamContents: [ :strm | | bytes |		bytes _ self readStream.		[ bytes atEnd ] whileFalse: [			(Integer nextUnicodeCodePointFromUtf8: bytes) ifNotNil: [ :codePoint |				(Character unicodeCodePoint: codePoint) ifNotNil: [ :char |					strm nextPut: char ]]]]! !!String class methodsFor: 'initialization' stamp: 'jmv 10/7/2010 16:30'!initialize	"	String initialize	"	| order newOrder |	"Case insensitive compare sorts space, digits, letters, all the rest..."	newOrder _ Array new: 256.	order _ -1.	32 to: 63 do: [ :c |		newOrder at: c + 1 put: (order _ order+1)].	Character letterPairs do: [ :upperAndLowercase |		order _ order+1.		upperAndLowercase do: [ :c |			newOrder at: c asciiValue + 1 put: order ]].	1 to: newOrder size do: [ :i |		(newOrder at: i) ifNil: [			newOrder at: i put: (order _ order+1)]].	CaseInsensitiveOrder _ newOrder asByteArray.		"Case sensitive compare sorts space, digits, letters, all the rest..."	newOrder _ Array new: 256.	order _ -1.	32 to: 63 do: [ :c |		newOrder at: c + 1 put: (order _ order+1)].	Character letterPairs do: [ :upperAndLowercase |		upperAndLowercase size > 1 ifTrue: [			newOrder at: upperAndLowercase first asciiValue + 1 put: (order _ order+1) ]].	Character letterPairs do: [ :upperAndLowercase |		newOrder at: upperAndLowercase last asciiValue + 1 put: (order _ order+1) ].	1 to: newOrder size do: [ :i |		(newOrder at: i) ifNil: [			newOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	CaseSensitiveOrder _ newOrder asByteArray.	"a table for translating to lower case"	LowercasingTable _ String withAll: (Character allCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable _ String withAll: (Character allCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish _ String withAll: (Character allCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement! !String initialize!String class removeSelector: #initializeUtf8ConversionMaps!String removeSelector: #latin1ToMacRoman!String removeSelector: #latin1ToUtf8!String removeSelector: #macRomanToLatin1!String removeSelector: #utf8ToLatin1!!classDefinition: #String category: #'Kernel-Text'!ArrayedCollection variableByteSubclass: #String	instanceVariableNames: ''	classVariableNames: 'CSLineEnders CSNonSeparators CSSeparators CaseInsensitiveOrder CaseSensitiveOrder LowercasingTable Tokenish UppercasingTable'	poolDictionaries: ''	category: 'Kernel-Text'!Character initialize!Character removeSelector: #latin1ToMacRoman!Character removeSelector: #macRomanToLatin1!!classDefinition: #Character category: #'Kernel-Text'!Magnitude subclass: #Character	instanceVariableNames: 'value'	classVariableNames: 'CharacterTable ClassificationTable LetterBits LowercaseBit UnicodeCodePoints UppercaseBit'	poolDictionaries: ''	category: 'Kernel-Text'!