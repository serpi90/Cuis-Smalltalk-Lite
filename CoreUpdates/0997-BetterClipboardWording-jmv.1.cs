'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 20 May 2011 at 10:03:10 am'!!Morph methodsFor: 'menus' stamp: 'jmv 5/20/2011 10:01'!addCopyItemsTo: aMenu 	"Add copy-like items to the halo menu"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'copy to clipboard' action: #copyToClipboard:.	aMenu add: 'copy & print...' subMenu: subMenu! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 5/20/2011 10:01'!copyToClipboard: evt	self okayToDuplicate ifTrue: [ Clipboard storeObject: self]! !!SimpleEditor methodsFor: 'menu messages' stamp: 'jmv 5/20/2011 10:01'!copySelection	"Copy the current selection and store it in the Clipboard, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	self clipboardTextPut: self selection! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/20/2011 10:01'!copySelection	"Copy the current selection and store it in the Clipboard, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection _ self selection.	self undoer: #undoCutCopy: with: self clipboardStringOrText.	UndoInterval _ self selectionInterval.	self clipboardTextPut: UndoSelection! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/20/2011 10:01'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the Clipboard.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start _ self startIndex.	stop _ self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue: [			before _ prior last < start.			selection _ self selection.			priorSelection _ self text copyFrom: prior first to: prior last.			delta _ before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta _ before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval _ prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval _ start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse: [			morph flash]! !!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/20/2011 10:02'!newMorph	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."	| menu subMenu catDict shortCat class |	menu _ self menu: 'Add a new morph'.	menu		add: 'from clipboard'		target: myHand		action: #pasteMorph;				add: 'from alphabetical list'		subMenu: self alphabeticalMorphMenu.	menu addLine.	Preferences classicNewMorphMenu ifTrue: [		menu addLine.		catDict _ Dictionary new.		SystemOrganization categories do: [ :cat |			((cat beginsWith: 'Morphic-') and: [ (#('Morphic-Menus' 'Morphic-Support' ) includes: cat) not ]) ifTrue: [				shortCat _ (cat					copyFrom: 'Morphic-' size + 1					to: cat size).				(SystemOrganization listAtCategoryNamed: cat) do: [ :cName |					class _ Smalltalk at: cName.					((class inheritsFrom: Morph) and: [ class includeInNewMorphMenu ]) ifTrue: [						(catDict includesKey: shortCat)							ifTrue: [ (catDict at: shortCat) addLast: class ]							ifFalse: [								catDict									at: shortCat									put: (OrderedCollection with: class) ]]]]].		catDict keys sort do: [ :categ |			subMenu _ MenuMorph new.			((catDict at: categ) asArray sort: [ :c1 :c2 |				c1 name < c2 name ]) do: [ :cl |				subMenu					add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl ].			menu				add: categ				subMenu: subMenu ]].	self doPopUp: menu.! !Morph removeSelector: #copyToPasteBuffer:!