'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 19 October 2010 at 2:16:58 pm'!!classDefinition: #DateAndTime category: #'Kernel-Chronology'!Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos '	classVariableNames: 'ClockProvider DaysSinceEpoch LastMilliSeconds LastTick LastTickSemaphore LocalTimeZone MilliSecondOffset OffsetsAreValid '	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!DateAndTime class methodsFor: 'ansi protocol' stamp: 'jmv 10/19/2010 14:13'!now 	| nanoTicks msm |	"This is usually only during system startup..."	self waitForOffsets.		nanoTicks _ (msm _ self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick _ nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [	 	 		LastTick _  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 10/19/2010 14:13'!milliSecondsSinceMidnight	| msm msClock |	"This is usually only during system startup..."	self waitForOffsets.	msClock _ self millisecondClockValue.	msClock < LastMilliSeconds ifTrue: [ "rolled over"		MilliSecondOffset _ MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds _ msClock.	[	msm _ msClock + MilliSecondOffset.	msm >= 86400000 ] whileTrue: [		"next day"		LastTick _ -1.		DaysSinceEpoch _ DaysSinceEpoch + 1.		MilliSecondOffset _ MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	(LastTick = -1 and: [		(Duration			days: SqueakEpoch			hours: 0			minutes: 0			seconds: self clock totalSeconds) days ~= DaysSinceEpoch ]) ifTrue: [		self initializeOffsets.		^ self milliSecondsSinceMidnight ].	^ msm.! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 10/19/2010 14:14'!todayAtMilliSeconds: milliSecondsSinceMidnight	"This is usually only during system startup..."	self waitForOffsets.	 ^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (milliSecondsSinceMidnight // 1000) 			nano: (milliSecondsSinceMidnight  \\ 1000 * 1000000  ) 			offset: self localOffset	 " [ 100000 timesRepeat: [ self fromMilliSeconds: self milliSecondsSinceMidnight. ] ] timeToRun."! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 10/19/2010 14:14'!todayAtNanoSeconds: nanoSecondsSinceMidnight	"This is usually only during system startup..."	self waitForOffsets.	^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (nanoSecondsSinceMidnight // 1000000000) 			nano: (nanoSecondsSinceMidnight  \\ 1000000000  ) 			offset: self localOffset ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'jmv 10/19/2010 14:07'!initializeOffsets	| durationSinceEpoch secondsSinceMidnight nowSecs |	LastTick _ 0.	nowSecs _ self clock secondsWhenClockTicks.	LastMilliSeconds _ self millisecondClockValue.	durationSinceEpoch _ Duration		days: SqueakEpoch		hours: 0		minutes: 0		seconds: nowSecs.	DaysSinceEpoch _ durationSinceEpoch days.	secondsSinceMidnight _ (durationSinceEpoch -		(Duration			days: DaysSinceEpoch			hours: 0			minutes: 0			seconds: 0)) totalSeconds.	MilliSecondOffset _ secondsSinceMidnight * 1000 - LastMilliSeconds! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'jmv 10/19/2010 14:07'!startUp: resuming	resuming ifFalse: [ ^ self ].	OffsetsAreValid _ false.	[		self initializeOffsets.		OffsetsAreValid _ true	] forkAt: Processor userInterruptPriority.! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'jmv 10/19/2010 14:10'!waitForOffsets	OffsetsAreValid ifFalse: [		[			(Delay forSeconds: 1) wait.			OffsetsAreValid		] whileFalse	]! !!classDefinition: #DateAndTime category: #'Kernel-Chronology'!Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos'	classVariableNames: 'ClockProvider DaysSinceEpoch LastMilliSeconds LastTick LastTickSemaphore LocalTimeZone MilliSecondOffset OffsetsAreValid'	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."DateAndTime startUp: true!