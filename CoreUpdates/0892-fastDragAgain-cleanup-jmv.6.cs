'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 28 March 2011 at 7:53:35 pm'!!classDefinition: #HandMorph category: #'Morphic-Kernel'!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder temporaryCursor temporaryCursorOffset hasChanged savedPatch userInitials lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds '	classVariableNames: 'DoubleClickTime EventStats NormalCursor ShowEvents '	poolDictionaries: ''	category: 'Morphic-Kernel'!!classDefinition: #LayoutAdjustingMorph category: #'Morphic-Layouts'!Morph subclass: #LayoutAdjustingMorph	instanceVariableNames: 'hand indicator '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!classDefinition: #RectangleIndicatorMorph category: #'Morphic-Widgets'!Morph subclass: #RectangleIndicatorMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!Form class methodsFor: 'instance creation' stamp: 'jmv 3/28/2011 18:45'!fromUser	"Answer an instance of me with bitmap initialized from the area of the 	display screen designated by the user."	^ self fromDisplay: Rectangle fromUser! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/28/2011 19:04'!addPossiblyUncoveredAreasIn: aRectangle to: aCollection	"Answer an array of rectangles encompassing those areas in aRectangle not completely	covered by self.	All areas that might possibly be uncovered must be included."	(self isOrthoRectangularMorph and: [ self isOpaqueMorph ]) ifTrue: [		aRectangle areasOutside: bounds do: [ :r |  aCollection add: r ].		^self ].	aCollection add: aRectangle! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 3/28/2011 16:13'!enterClickableRegion: evt	| index isLink |	evt hand hasSubmorphs ifTrue: [ ^self ].	paragraph ifNotNil:[		index _ (paragraph characterBlockAtPoint: evt position) stringIndex.		isLink _ (paragraph text attributesAt: index) 					anySatisfy:[:attr| attr mayActOnClick].		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 3/28/2011 16:08'!pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt oldCursor |	aHand _ aMorph ifNil: [self activeHand] ifNotNil: [aMorph activeHand].	aHand ifNil: [aHand _ self currentHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullDisplayBounds.	self owner ifNil: [^ self].	oldCursor _ Sensor currentCursor.	ColorPickerMorph eyeDropperCursor show.	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	localPt _ Sensor cursorPoint - self topLeft.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt) ifTrue:			["Click or drag the drag-dot means to anchor as a modeless picker"			^ self anchorAndRunModeless: aHand].	].	(clickedTranslucency _ TransparentBox containsPoint: localPt)		ifTrue: [selectedColor _ originalColor].	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	aHand newMouseFocus: nil;		flushEvents.	oldCursor show.	self delete.		  ! !!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 3/28/2011 16:10'!anchorAndRunModeless: aHand	"If user clicks on the drag-dot of a modal picker,	anchor it, and change to modeless operation."	self initializeModal: false; originalColor: originalColor.  "reset as modeless"	aHand flushEvents.  "Drop any events gathered during modal loop"	aHand position: Sensor cursorPoint; grabMorph: self.  "Slip into drag operation"! !!ColorPickerMorph class methodsFor: 'class initialization' stamp: 'jmv 3/28/2011 16:03'!initialize	"ColorPickerMorph initialize"	ColorChart _ Color colorPaletteForDepth: 16 extent: 190@60.	DragBox _  (11@0) extent: 9@8.	RevertBox _ (ColorChart width - 20)@1 extent: 9@8.	FeedbackBox _ (ColorChart width - 10)@1 extent: 9@8.	TransparentBox _ DragBox topRight corner: RevertBox bottomLeft.		ColorChart fillBlack: ((DragBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((TransparentBox left)@0 extent: 1@9).		ColorChart fillBlack: ((FeedbackBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((RevertBox left - 1)@0 extent: 1@9).		(Form dotOfSize: 5) displayOn: ColorChart at: DragBox center + (0@1).	TransText _ (Form extent: 63@8 depth: 1   "Where there's a will there's a way..."			fromArray: #(4194306 1024 4194306 1024 15628058 2476592640					4887714 2485462016 1883804850 2486772764 4756618					2485462016 4748474 1939416064 0 0)			offset: 0@0).	TransText _ ColorForm mappingWhiteToTransparentFrom: TransText.	EyedropperIcon _ nil! !!ColorPickerMorph class methodsFor: 'accessing - icons' stamp: 'jmv 3/28/2011 16:07'!eyeDropperCursor	| cursor form |	form _ self eyedropperIcon.	cursor _ CursorWithAlpha extent: form extent depth: 32.	cursor fillColor: Color red.	form displayOn: cursor.	cursor offset: -6@-31."	cursor preMultiplyAlpha."	^cursor! !!ColorPickerMorph class methodsFor: 'accessing - icons' stamp: 'jmv 3/28/2011 16:04'!eyedropperIcon	"Created using:	Clipboard default storeObject:	 	((PNGReadWriter bytesFor: aForm) asString base64Encoded)	"	^ EyedropperIcon ifNil: [		EyedropperIcon _ Form fromBinaryStream: 'iVBORw0KGgoAAAANSUhEUgAAACYAAAAkCAYAAADl9UilAAABiklEQVR4XuXYoZKDMBAGYO6ZYpBIJBKJYngTHoHJEyCRlUhMfCWyEonc5l+aTI62c+qy6TQzO7HfbDY/abPvX5+yjNZk2paMUqTtngbKQsiCiPcHzpYsykIYdCrgWimcCTH2KH05WJZR13UUGaX52F6hQhgqKszP1BsUZkwx6oeSQrUe9Y8wjoFH/XV80VDHzVMcB8f+AqUEUFj6FAO+Y4/8ctGgYqI8DoAA5+q5SxFR4zjSPM+MCGdJFDVNE63rSljLsjDmOQ4EUNu2MWrfd7per5zk6JJGakjMVIi63W5kjD1FO/DKdqrve96joy6XC3foF8p+gvI89wjumMdFRKGA0lYFVFmWcs+Yc6eAwkwpybcV4sANOaO0obquqSgK2U6FN8+hmqaRQyGbzijMk+hMhSjcPIdKolNhRgEV/Sn8aqZCFDJKtFNI9HNGAYU0F0PhlYAPsosDdAhxIIpqzfE6cCjMU1VV8r+YAUMcuM/LMAxp/IwHDEcmeutCzLtK5t+YpDDfD/vkdQfdhqlIh/LZTwAAAABJRU5ErkJggg==' base64Decoded asByteArray readStream]! !!HandMorph methodsFor: 'cursor' stamp: 'jmv 3/28/2011 16:13'!cursorBounds	^self position extent: NormalCursor extent! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/28/2011 16:14'!drawOn: aCanvas 	"Draw the hand itself (i.e., the cursor)."	 aCanvas image: NormalCursor at: bounds topLeft.	self hasUserInformation 		ifTrue: [			aCanvas 				drawString: userInitials				at: self cursorBounds topRight + (0 @ 4)				font: nil				color: color.			self userPicture ifNotNil: [ :userPic |				aCanvas image: userPic at: self cursorBounds topRight + (0 @ 24)]]! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/28/2011 16:15'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ (submorphs anySatisfy: [ :ea | ea visible ])			or: [ self hasUserInformation ]])		ifTrue: [			"using the software cursor; hide the hardware one"			Sensor currentCursor == Cursor blank ifFalse: [Cursor blank show].			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/28/2011 17:49'!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas image: savedPatch at: savedPatch offset.		self hasUserInformation ifTrue: [ ^self ].	"cannot use hw cursor if so"		submorphs notEmpty ifTrue: [ ^self ].		"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."		super			invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset)			from: self.		Sensor currentCursor == Cursor normal ifFalse: [ Cursor normal show ].	"show hardware cursor"		savedPatch _ nil ]! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/28/2011 16:49'!savePatchFrom: aCanvas 	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| damageRect myBnds |	damageRect _ myBnds _ self fullDisplayBounds.	damageRect _ myBnds _ self displayBounds.	savedPatch ifNotNil: [		damageRect _ myBnds merge: (savedPatch offset extent: savedPatch extent)].	(savedPatch isNil or: [savedPatch extent ~= myBnds extent]) 		ifTrue: [			"allocate new patch form if needed"			savedPatch _ Form extent: myBnds extent depth: aCanvas depth ].	aCanvas		contentsOfArea: (myBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: myBnds topLeft.	^damageRect! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/28/2011 18:09'!savePatchFrom: aCanvas appendDamageTo: aStream	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| ownBnds fullBnds bw |	ownBnds _ self displayBounds.	fullBnds _ self fullDisplayBounds.	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 		ifTrue: [			"allocate new patch form if needed"			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].	aCanvas		contentsOfArea: (fullBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: fullBnds topLeft.	Preferences fastDragWindowForMorphic ifTrue: [		bw _ HandMorph fastDragBorderWidth.		aStream nextPut: ownBnds.		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].		(fullBnds areasOutside: (fullBnds insetBy: bw)) do: [ :r |			aStream nextPut: r ].		prevFullBounds ifNotNil: [			(prevFullBounds areasOutside: (prevFullBounds insetBy: bw)) do: [ :r |				aStream nextPut: r ]]]	ifFalse: [		prevFullBounds ifNil: [			aStream nextPut: fullBnds ]		ifNotNil: [			aStream nextPut: (fullBnds merge: prevFullBounds)]].	prevBounds _ ownBnds.	prevFullBounds _ fullBnds! !!HandMorph methodsFor: 'initialization' stamp: 'jmv 3/28/2011 16:11'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseFocus _ nil.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	self initForEvents.! !!HandMorph class methodsFor: 'utilities' stamp: 'jmv 3/28/2011 18:08'!fastDragBorderWidth	^4! !!LayoutAdjustingMorph methodsFor: 'event handling' stamp: 'jmv 3/28/2011 17:53'!mouseDown: anEvent	super mouseDown: anEvent.	self cursor show.	hand _ anEvent hand.	self startStepping.	Preferences fastDragWindowForMorphic ifTrue: [		indicator _ RectangleIndicatorMorph new.		indicator bounds: self initialIndicatorBounds.		indicator openInWorld ]! !!LayoutAdjustingMorph methodsFor: 'event handling' stamp: 'jmv 3/28/2011 10:18'!mouseEnter: anEvent	super mouseEnter: anEvent.	self cursor show.	hand _ anEvent hand.	self startStepping! !!LayoutAdjustingMorph methodsFor: 'event handling' stamp: 'jmv 3/28/2011 10:18'!mouseLeave: anEvent	super mouseLeave: anEvent.	"Does it make any sense to send #mouseLeave: if the hand is still inside our bounds?"	(self containsPoint: anEvent position) ifFalse: [		hand _ nil ]! !!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 3/28/2011 19:09'!handPoint	^ hand cursorPoint adhereTo: owner bounds! !!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 3/28/2011 09:53'!initialIndicatorBounds	^bounds outsetBy: 1! !!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:28'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: 2 borderStyleSymbol: #raised! !!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 3/28/2011 19:09'!step	"got the #mouseLeave: message"	| p |	hand ifNil: [		indicator ifNotNil: [			indicator delete.			indicator _ nil ].		Cursor normal show.		^self stopStepping ].	"hasn't got the #mouseLeave: message (yet)"	p _ self handPoint.	hand lastEvent mouseButton1Pressed		ifTrue: [			indicator				ifNil: [ self adjustOwnerAt: p ]				ifNotNil: [ self adjustIndicatorAt: p ]]		ifFalse: [			indicator ifNotNil: [				indicator delete.				indicator _ nil.				self adjustOwnerAt: p ].			"If the button was unpressed outside the morph (can happen if you try to go outside container),			we might not get the #mouseLeave: message"			(self containsPoint: hand position) ifFalse: [				hand _ nil.				Cursor normal show.				self stopStepping ]]! !!LayoutAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 3/28/2011 10:17'!adjustIndicatorAt: aPoint	owner direction = #vertical		ifTrue: [			indicator position: indicator position x @ (aPoint y-(indicator height//2)) ]		ifFalse: [			indicator position: (aPoint x-(indicator width//2)) @ indicator position y ]! !!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/28/2011 17:57'!flashRects: rectangleList	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt _ (BitBlt current toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: self viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect _ r translateBy: self viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 250) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/28/2011 16:11'!restoreMorphicDisplay	DisplayScreen startUp.	self		extent: Display extent;		viewBox: Display boundingBox;		handsDo: [ :h | h visible: true ];		fullRepaintNeeded.	WorldState addDeferredUIMessage: [ Cursor normal show ]! !!Preferences class methodsFor: 'standard queries' stamp: 'jmv 3/28/2011 19:52'!debugShowDamage	"Useful for debugging, but also for simulating vnc over a slow network"	^ self		valueOfFlag: #debugShowDamage		ifAbsent: [ false ].! !!Preferences class methodsFor: 'standard queries' stamp: 'jmv 3/28/2011 19:14'!fastDragWindowForMorphic	^ self		valueOfFlag: #fastDragWindowForMorphic		ifAbsent: [ false ]! !!Preferences class methodsFor: 'themes' stamp: 'jmv 3/28/2011 17:56'!juans	"	Preferences juans	"	self setPreferencesFrom:	#(		(balloonHelpEnabled false)		(browseWithPrettyPrint false)		(browserShowsPackagePane false)		(caseSensitiveFinds true)		(checkForSlips true)		(cmdDotEnabled true)		(collapseWindowsInPlace false)		(diffsInChangeList true)		(diffsWithPrettyPrint false)		(fastDragWindowForMorphic false)		(menuKeyboardControl true)		(optionalButtons true)		(extraDebuggerButtons true)		(restartAlsoProceeds false)		(simpleMenus false)		(smartUpdating true)		(subPixelRenderFonts true)		(thoroughSenders true)	)! !!Preferences class methodsFor: 'themes' stamp: 'jmv 3/28/2011 18:57'!slowMachine	self setPreferencesFrom: #(		(balloonHelpEnabled false)		(browseWithPrettyPrint false)		(browserShowsPackagePane false)		(caseSensitiveFinds true)		(checkForSlips false)		(cmdDotEnabled true)		(collapseWindowsInPlace false)		(diffsInChangeList false)		(diffsWithPrettyPrint false)		(fastDragWindowForMorphic true)		(menuKeyboardControl false)		(optionalButtons false)		(restartAlsoProceeds false)		(simpleMenus false)		(smartUpdating false)		(subPixelRenderFonts false)		(thoroughSenders false)	).	ClassicTheme beCurrent! !!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 3/28/2011 19:04'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas |	"Make sure the intersection is non-empty"     (self intersects: aRectangle)		ifFalse: [^Array with: self].	areas := OrderedCollection new.	self areasOutside: aRectangle do: [ :r |  areas add: r ].	^areas! !!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 3/28/2011 19:04'!areasOutside: aRectangle do: aBlock	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| yOrigin yCorner |	"Make sure the intersection is non-empty"     (self intersects: aRectangle)		ifFalse: [			aBlock value: self.			^self ].	aRectangle origin y > origin y		ifTrue: [ aBlock value: (origin corner: corner x @ (yOrigin := aRectangle origin y))] 		ifFalse: [ yOrigin _ origin y ].	aRectangle corner y < corner y		ifTrue: [ aBlock value: (origin x @ (yCorner := aRectangle corner y) corner: corner) ]		ifFalse: [ yCorner _ corner y ].	aRectangle origin x > origin x 		ifTrue: [ aBlock value: (origin x @ yOrigin corner: aRectangle origin x @ yCorner) ].	aRectangle corner x < corner x 		ifTrue: [ aBlock value: (aRectangle corner x @ yOrigin corner: corner x @ yCorner) ]! !!Rectangle methodsFor: 'transforming' stamp: 'jmv 3/28/2011 16:11'!newRectFrom: newRectBlock	"Track the outline of a new rectangle until mouse button changes.	newFrameBlock produces each new rectangle from the previous"	| rect newRect buttonStart buttonNow aHand delay |	delay _ Delay forMilliseconds: 10.	buttonStart _ buttonNow _ Sensor anyButtonPressed.	rect _ self.	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	[buttonNow == buttonStart] whileTrue: 		[delay wait.		buttonNow _ Sensor anyButtonPressed.		newRect _ newRectBlock value: rect.		newRect = rect ifFalse:			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.			rect _ newRect]].	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	" pay the price for reading the sensor directly ; get this party started "	aHand _ World activeHand.	aHand		newMouseFocus: nil;		flushEvents.	Sensor processEvent: Sensor createMouseEvent.	^ rect! !!Rectangle class methodsFor: 'instance creation' stamp: 'jmv 3/28/2011 19:50'!fromUser	"Answer a Rectangle that is determined by having the user 	designate the top left and bottom right corners."	| originRect |	originRect _ Cursor origin showWhile: 		[(Sensor cursorPoint extent: 0@0) newRectFrom:			[:f | Sensor cursorPoint  extent: 0@0]].	^ Cursor corner showWhile:		[originRect newRectFrom:			[:f | f origin corner: Sensor cursorPoint ]]! !!Rectangle class methodsFor: 'instance creation' stamp: 'jmv 3/28/2011 19:51'!originFromUser: extentPoint	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint."	^ Cursor origin showWhile: 		[(Sensor cursorPoint extent: extentPoint) newRectFrom:			[:f | Sensor cursorPoint extent: extentPoint]].! !!RectangleIndicatorMorph methodsFor: 'drawing' stamp: 'jmv 3/28/2011 09:40'!drawOn: aCanvas	| bw |	bw _ 2.	aCanvas frameRectangle: bounds borderWidth: bw color: Color black.	aCanvas frameRectangle: (bounds insetBy: bw) borderWidth: bw color: Color white! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/28/2011 19:04'!addPossiblyUncoveredAreasIn: aRectangle to: aCollection	"Answer an array of rectangles encompassing those areas in aRectangle not completely	covered by self. These are the areas that might require further drawing (of morphs below us)	All areas that might possibly be uncovered must be included."	 | r |	color mightBeTranslucent ifTrue: [		aCollection add: aRectangle.		^self ].	"Solid rectangle.	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"	Theme current roundWindowCorners ifFalse: [		aRectangle areasOutside: bounds do: [ :rr |  aCollection add: rr ].		^self ].	"The solid rectangle does not include the corners.	Report a couple of rows (top and bottom) or columns (left and right) as uncovered areas.	We could also try to be more careful and answer each rounded corner...	Right now, report top and bottom rows as uncovered areas"	r _ Theme current roundedWindowRadius.	aRectangle areasOutside: (bounds insetBy: 0@r) do: [ :rr |  aCollection add: rr ]! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 3/28/2011 18:44'!justDroppedInto: aMorph event: anEvent	isCollapsed		ifTrue: [			self position: (self position max: 0@0).			collapsedFrame _ bounds]		ifFalse: [			fullFrame _ bounds.			TopWindow ~~ self ifTrue: [self activate]].	^super justDroppedInto: aMorph event: anEvent! !!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 3/28/2011 09:35'!adjustIndicatorAt: aPoint	indicator perform: selector with: (aPoint+1 perform: coordinateGetter)! !!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 3/28/2011 17:54'!adjustOwnerAt: aPoint	owner ifNotNil: [		owner perform: selector with: (aPoint+1 perform: coordinateGetter) ]! !!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 3/28/2011 19:10'!handPoint	^ hand cursorPoint! !!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 3/28/2011 09:50'!initialIndicatorBounds	^owner bounds! !!WindowEdgeAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 2/25/2011 15:11'!drawOn: aCanvas! !!WorldState methodsFor: 'drawing' stamp: 'jmv 3/28/2011 18:10'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw allDamage |	submorphs do: [:m | m doLayoutIfNeeded].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].	"repair world's damage on canvas"	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	allDamage _ Array streamContents: [ :strm |		strm nextPutAll: worldDamageRects.		handsToDraw do: [ :h | 			h savePatchFrom: canvas appendDamageTo: strm ]].	"draw hands onto world canvas"	handsToDraw reverseDo: [ :h | self drawHand: h ].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [ aWorld flashRects: allDamage ].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [ self forceDamageToScreen: allDamage ]		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].	"restore world canvas under hands"	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].	Display deferUpdates: false; forceDisplayUpdate! !!WorldState methodsFor: 'drawing' stamp: 'jmv 3/28/2011 18:09'!drawHand: aHandMorph	| bw r |	Preferences fastDragWindowForMorphic ifTrue: [		bw _ HandMorph fastDragBorderWidth // 2.		r _ aHandMorph fullDisplayBounds.		canvas frameRectangle: r borderWidth: bw color: Color black.		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.		canvas drawMorph: aHandMorph ]	ifFalse: [		canvas fullDrawMorph: aHandMorph ]! !!WorldState methodsFor: 'drawing' stamp: 'jmv 3/28/2011 17:32'!drawInvalidAreasWorld: aWorld submorphs: submorphs	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: aWorld viewBox.	damageRecorder reset.			currentRectsToRepair _ OrderedCollection new.	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.	morphsToDraw _ OrderedCollection new.	rectsForEachMorph _ OrderedCollection new.	thisMorphRects _ OrderedCollection new.	n _ submorphs size.	i _ 1.	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [		morph _ submorphs at: i.		morph visible ifTrue: [			morphBounds _morph fullDisplayBounds.			reuse _ currentRectsToRepair.			currentRectsToRepair _ newRectsToRepair.			newRectsToRepair _ reuse resetTo: 1.			currentRectsToRepair do: [ :r |				(morphBounds intersects: r)					ifTrue: [						morphClipRect _ morphBounds intersect: r.						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]					ifFalse: [						newRectsToRepair add: r ]].			thisMorphRects ifNotEmpty: [				morphsToDraw add: morph.				rectsForEachMorph add: thisMorphRects.				thisMorphRects _ OrderedCollection new.			]].		i _ i + 1 ].	i > n  ifTrue: [		newRectsToRepair do: [ :r |			(canvas copyClipRect: r) drawMorph: aWorld.]].	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |		"Here we could merge all xrects into just one call... Most likely, that would be slower, though.""		rr _ nil."		xrects do: [ :r |"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."			(canvas copyClipRect: r) fullDrawMorph: m 		]."		(canvas copyClipRect: rr) fullDrawMorph: m "	].		"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...	(think of vnc over slow networks)"	^ initialRectsToRepair! !Rectangle class removeSelector: #fromUser:!Rectangle class removeSelector: #originFromUser:grid:!Rectangle removeSelector: #addAreasOutside:to:!Rectangle removeSelector: #allAreasOutsideList:do:!Rectangle removeSelector: #allAreasOutsideList:startingAt:do:!Point removeSelector: #grid:!PasteUpMorph removeSelector: #flashRects:color:!PasteUpMorph removeSelector: #morphsInFrontOf:overlapping:do:!!classDefinition: #LayoutAdjustingMorph category: #'Morphic-Layouts'!Morph subclass: #LayoutAdjustingMorph	instanceVariableNames: 'hand indicator'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!HandMorph class removeSelector: #attach:!HandMorph removeSelector: #position!HandMorph removeSelector: #position:!HandMorph removeSelector: #showTemporaryCursor:!HandMorph removeSelector: #showTemporaryCursor:hotSpotOffset:!HandMorph removeSelector: #temporaryCursor!!classDefinition: #HandMorph category: #'Morphic-Kernel'!Morph subclass: #HandMorph	instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder hasChanged savedPatch userInitials lastEventBuffer lastKeyDownValue lastMouseEventTime prevBounds prevFullBounds'	classVariableNames: 'DoubleClickTime EventStats NormalCursor ShowEvents'	poolDictionaries: ''	category: 'Morphic-Kernel'!ColorPickerMorph initialize!Morph removeSelector: #morphsInFrontOf:overlapping:do:!Form class removeSelector: #fromUser:!Cursor removeSelector: #showGridded:!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Preferences juans!