'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 2 October 2011 at 10:15:27 pm'!!ArrayedCollection methodsFor: 'sorting' stamp: 'ul 9/10/2011 20:50'!quickSortFrom: from to: to by: sortBlock	"Sort elements i through j of self to be nondescending according to sortBlock using an in-place quicksort with simple median-of-three partitioning with guaranteed O(log(n)) space usage."	| i j |	i := from.	j := to.	[		| k l dij temp ij di dj n |		"The prefix d means the data at that index."		"Sort di,dj."		di := self at: i.		dj := self at: j.		(sortBlock ifNil: [ di <= dj ] ifNotNil: [ sortBlock value: di value: dj ]) ifFalse: [			temp := self at: i. self at: i put: (self at: j); at: j put: temp.			temp := di. di := dj. dj := temp ].		(n := j + 1  - i) <= 2 ifTrue: [ ^self ].		"More than two elements."		ij := (i + j) // 2.  "ij is the midpoint of i and j."		dij := self at: ij.  "Sort di,dij,dj.  Make dij be their median."		(sortBlock ifNil: [ di <= dij ] ifNotNil: [ sortBlock value: di value: dij ])			ifTrue: [				(sortBlock ifNil: [ dij <= dj ] ifNotNil: [ sortBlock value: dij value: dj ]) ifFalse: [					temp := self at: j. self at: j put: (self at: ij); at: ij put: temp.					dij := dj ] ]			ifFalse: [				temp := self at: i. self at: i put: (self at: ij); at: ij put: temp.				dij := di ].		n = 3 ifTrue: [ ^self ].		"More than three elements."		"Find k>i and l<j such that dk,dij,dl are in reverse order.		Swap k and l.  Repeat this procedure until k and l pass each other."		k := i.		l := j.		[			[ k <= (l := l - 1) and: [ 				sortBlock ifNil: [ dij <= (self at: l) ] ifNotNil: [ sortBlock value: dij value: (self at: l) ] ] ] whileTrue.  "i.e. while dl succeeds dij"			[ (k := k + 1) <= l and: [				sortBlock ifNil: [ (self at: k) <= dij ] ifNotNil: [ sortBlock value: (self at: k) value: dij ] ] ] whileTrue.  "i.e. while dij succeeds dk"			k <= l ] whileTrue: [ temp := self at: k. self at: k put: (self at: l); at: l put: temp. ].		"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk through dj. Sort the larger segment in this method and call another quicksort for the smaller segment. This ensures O(log(n)) space usage."		i < l 			ifFalse: [				k < j					ifFalse: [ ^self ]					ifTrue: [ i := k ] ]			ifTrue: [				k < j					ifFalse: [ j := l ]					ifTrue: [						l - i <  (j - k)							ifTrue: [ 								self quickSortFrom: i to: l by: sortBlock.								i := k ]							ifFalse: [								self quickSortFrom: k to: j by: sortBlock.								j := l ] ] ] ] repeat! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'jmv 10/2/2011 21:51'!rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext	"Answer the indices in the source code for the supplied pc.	 If the context is the actve context (is at the hot end of the stack)	 then its pc is the current pc.  But if the context isn't, because it is	 suspended sending a message, then its current pc is the previous pc."	| pc end |	pc _ self method abstractPCForConcretePC:		(contextIsActiveContext			ifTrue: [ contextsConcretePC ]			ifFalse: [				(self method pcPreviousTo: contextsConcretePC) ifNil: [ contextsConcretePC ]]).	(self abstractSourceMap includesKey: pc) ifTrue: [		^self abstractSourceMap at: pc].	sortedSourceMap ifNil: [		sortedSourceMap _ self abstractSourceMap.		sortedSourceMap _ (sortedSourceMap keys			collect: [ :key | key -> (sortedSourceMap at: key)])				asSortedCollection ].	sortedSourceMap		findBinaryIndex: [ :assoc | pc - assoc key ]		do: [ :i | ^(sortedSourceMap at: i) value ]		ifNone: [ :lower :upper |			lower = 0 ifTrue: [ ^1 to: 0 ].			upper <= sortedSourceMap size ifTrue: [				^(sortedSourceMap at: upper) value ].    "No match, but  a nearby element."			end _ sortedSourceMap detectMax: [ :each |				each value last ].			end _ end value last.			^end + 1 to: end ].	"| method source scanner map |	 method := DebuggerMethodMap compiledMethodAt: #rangeForPC:contextIsActiveContext:.	method := Debugger >> #pcRange.	source := method getSourceFromFile asString.	scanner := InstructionStream on: method.	map := method debuggerMap.	Array streamContents:		[:ranges|		[scanner atEnd] whileFalse:			[| range |			 range := map rangeForPC: scanner pc contextIsActiveContext: true.			 ((map abstractSourceMap includesKey: scanner abstractPC)			  and: [range first ~= 0]) ifTrue:				[ranges nextPut: (source copyFrom: range first to: range last)].			scanner interpretNextInstructionFor: InstructionClient new]]"! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 9/14/2011 14:50'!privateTempRefsForContext: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents	"Answer the sequence of temps in scope in aContext in the natural order,	 outermost arguments and temporaries first, innermost last.  Each temp is	 a pair of the temp's name followed by a reference.  The reference can be		integer - index of temp in aContext		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index in aContext		#( outer. temp reference ) - a temp reference in an outer context."	blockExtentsToTempRefs ifNil:		[blockExtentsToTempRefs := (aContext method holdsTempNames										ifTrue: [aContext method]										ifFalse: [methodNode]) blockExtentsToTempsMap.		 blockExtentsToTempRefs ifNil:			["an empty method.  shouldn't be able to step into here but it			  can happen in weird circumstances (i.e. with MethodWrapper)."			blockExtentsToTempRefs := Dictionary new.			blockExtentsToTempRefs				at: (theContextsStartpcsToBlockExtents at: aContext startpc)				put: {}].		 startpcsToTempRefs := Dictionary new].	^startpcsToTempRefs		at: aContext startpc		ifAbsentPut:			[| localRefs |			 localRefs := blockExtentsToTempRefs at: (theContextsStartpcsToBlockExtents at: aContext startpc).			 aContext outerContext				ifNil: [localRefs]				ifNotNil:					[:outer| | outerTemps |					"Present temps in the order outermost to innermost left-to-right, but replace					 copied outermost temps with their innermost copies"					 outerTemps := (self										privateTempRefsForContext: outer										startpcsToBlockExtents: theContextsStartpcsToBlockExtents) collect:						[:outerPair|						localRefs							detect: [:localPair| outerPair first = localPair first]							ifNone: [{ outerPair first. { #outer. outerPair last } }]].					outerTemps,					 (localRefs reject: [:localPair| outerTemps anySatisfy: [:outerPair| localPair first = outerPair first]])]]! !!Dictionary class methodsFor: 'instance creation' stamp: 'jmv 10/2/2011 21:57'!newFromPairs: anArray 	"Answer an instance of me associating (anArray at:i) to (anArray at: i+1)	 for each odd i.  anArray must have an even number of entries."	| newDictionary |	newDictionary := self new: (anArray size/2).	1 to: (anArray size-1) by: 2 do: [ :i|		newDictionary at: (anArray at: i) put: (anArray at: i+1).	].	^ newDictionary	"  Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}. "! !!SortedCollection methodsFor: 'private' stamp: 'ul 6/8/2011 23:18'!reSort	firstIndex < lastIndex ifTrue: [ 		array quickSortFrom: firstIndex to: lastIndex by: sortBlock ]! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 10/2/2011 22:07'!okayToSave	| wasCog isCog |	[ wasCog _ self imageFormatVersionFromFile allMask: 1 ]		on: Error		do: [ :ignore |			"probably save-as to non-existing file"			^ true ].	isCog _ Smalltalk isRunningCog.	^(isCog not or: [wasCog]) or: [		self confirm: 'Images saved under Cog cannot be opened on an interpreter again!!Really save?' ]! !SortedCollection removeSelector: #sort:to:!