'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 2 December 2008 at 11:07:32 am'!!classDefinition: #ClassBuilder category: #'Kernel-Classes'!Object subclass: #ClassBuilder	instanceVariableNames: 'environ classMap instVarMap progress maxClassIndex currentClassIndex '	classVariableNames: 'QuietMode '	poolDictionaries: ''	category: 'Kernel-Classes'!!classDefinition: #Class category: #'Kernel-Classes'!ClassDescription subclass: #Class	instanceVariableNames: 'subclasses name classPool sharedPools environment category '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!classDefinition: #DeepCopier category: #'System-Object Storage'!Object subclass: #DeepCopier	instanceVariableNames: 'references uniClasses newUniClasses '	classVariableNames: 'NextVariableCheckTime '	poolDictionaries: ''	category: 'System-Object Storage'!!DeepCopier commentStamp: 'jmv 11/27/2008 12:59' prior: 0!DeepCopier does a veryDeepCopy.  It is a complete tree copy using a dictionary.  Any object that is in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy.  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).When a tree of morphs points at a morph outside of itself, that morph should not be copied.  Use our own kind of weak pointers for the 'potentially outside' morphs.   Default is that any new class will have all of its fields deeply copied.  If a field needs to be weakly copied, define veryDeepInner: and veryDeepFixupWith:.     veryDeepInner: has the loop that actually copies the fields.  If a class defines its own copy of veryDeepInner: (to leave some fields out), then veryDeepFixupWith: will be called on that object at the end.  veryDeepInner: can compute an alternate object to put in a field.  (Object veryDeepCopyWith: discovers which superclasses did not define veryDeepInner:, and very deeply copies the variables defined in those classes).	To decide if a class needs veryDeepInner: and veryDeepFixupWith:, ask this about an instance:  If I duplicate this object, does that mean that I also want to make duplicates of the things it holds onto?  If yes, (i.e. a Paragraph does want a new copy of its Text) then do nothing.  If no, (i.e. an undo command does not want to copy the objects it acts upon), then define veryDeepInner: and veryDeepFixupWith:.	Here is an analysis for the specific case of a morph being held by another morph.  Does field X contain a morph ?  If not, no action needed.Is the morph in field X already a submorph of the object?  Is it down lower in the submorph tree?	If so, no action needed.Could the morph in field X every appear on the screen (be a submorph of some other morph)?	If not, no action needed.	If it could, you must write the methods veryDeepFixupWith:   and   veryDeepInner:, and in them, refrain from sending veryDeepCopyWith: to the contents of field X.----- Things Ted is still considering -----Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepCopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)Dependents are now fixed up.  Suppose a model has a dependent view.  In the DependentFields dictionary, model -> (view ...).  	If only the model is copied, no dependents are created (no one knows about the new model).  	If only the view is copied, it is inserted into DependentFields on the right side.  model -> (view  copiedView ...).  	If both are copied, the new model has the new view as its dependent.	If additional things depend on a model that is copied, the caller must add them to its dependents.!!OldPasteUpMorph commentStamp: 'jmv 11/27/2008 14:56' prior: 0!A morph whose submorphs comprise a paste-up of rectangular subparts which "show through".A World, the entire Smalltalk screen, is a PasteUpMorph.  A World responds true to isWorld.  A PasteUpMorph that is a world, builds its menu in HandMorph buildWorldMenu.cursor		??backgroundMorph		A Form that covers the background.worldState		If I am also a World, keeps the hands, damageRecorder, stepList etc.!!ReferenceStream commentStamp: 'jmv 11/27/2008 13:30' prior: 0!This is a way of serializing a tree of objects into disk file. A ReferenceStream can storeone or more objects in a persistent form, including sharing and cycles.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.ReferenceStreams can now write "weak" references. nextPutWeak:writes a "weak" reference to an object, which refers to that object*if* it also gets written to the stream by a normal nextPut:.A ReferenceStream should be treated as a read-stream *or* as a write-stream, *not* as a read/write-stream. The reference-remembering mechanism would probably do bad things if you tried to read and write from the same ReferenceStream.[TBD] Should we override "close" to do (self forgetReferences)?Instance variables references -- an IdentityDictionary mapping objects already written	to their byteStream positions. If asked to write any object a	second time, we just write a reference to its stream position.	This handles shared objects and reference cycles between objects.	To implement "weak references" (for Aliases), the references	dictionary also maps objects not (yet?) written to a Collection	of byteStream positions with hopeful weak-references to it. If	asked to definitely write one of these objects, we'll fixup those	weak references. objects -- an IdentityDictionary mapping relative byte stream positions to	objects already read in. If asked to follow a reference, we	return the object already read.	This handles shared objects and reference cycles between objects. currentReference -- the current reference position. Positon relative to the 	start of object data in this file.  (Allows user to cut and paste smalltalk 	code from the front of the file without effecting the reference values.)  	This variable is used to help install each new object in "objects" as soon	as it's created, **before** we start reading its contents, in	case any of its content objects reference it. fwdRefEnds -- A weak reference can be a forward reference, which	requires advance-reading the referrent. When we later come to the	object, we must get its value from "objects" and not re-read it so	refs to it don't become refs to copies. fwdRefEnds remembers the	ending byte stream position of advance-read objects. skipping -- true if <what?> insideASegment -- true if we are being used to collect objects that will be 	included in an ImageSegment.  (jmv currently not set. See the comment in the setter)If the object is referenced before it is done being created, it might get created twice.  Just store the object the moment it is created in the 'objects' dictionary.  If at the end, comeFullyUpOnReload returns a different object, some refs will have the temporary object (this is an unlikely case).  At the moment, no implementor of comeFullyUpOnReload returns a different object except DiskProxy, and that is OK.!!classDefinition: #SmartRefStream category: #'System-Object Storage'!ReferenceStream subclass: #SmartRefStream	instanceVariableNames: 'structures steady reshaped renamed renamedConv superclasses progressBar objCount classInstVars '	classVariableNames: 'ScannedObject '	poolDictionaries: ''	category: 'System-Object Storage'!!SmartRefStream commentStamp: 'jmv 11/27/2008 13:31' prior: 0!Ordinary ReferenceStreams assume that the names and order of instance variables is exactly the same when an object file is written and read.  	SmartRefStream allows object files to be read even after instance variables have changed or the entire class has been renamed.When an object file is written, no one knows how the classes will change in the future.  Therefore, all conversion must be done when the file is read.  The key is to store enough information in the file about the names of the instance variables of all outgoing classes.  SmartRefStream works best with only one tree of objects per file.  You can nextPut: more than once, but each object tree gets its own class structure description, which is big.  Conversion of old objects is done by a method in each class called (convertToCurrentVersion: varDict refStream: smartRefStrm).  At fileOut time, ChangeSet>>checkForConversionMethods creates a prototype of this method (if Preference #conversionMethodsAtFileOut is true).  The programmer must edit this method to (1) test if the incoming object needs conversion, (2) put non-nil values into any new inst vars that need them, and (3) save the data of any inst vars that are being deleted. Determining which old version is represented by the incoming object can be done in several ways: noticing that a current inst var is nil when it should have data, noticing that there is an older inst var name in the variable dictionary (varDict), checking kinds of objects in one or more inst vars, or retrieving the classVersion of the incoming object from the ref stream.  If a class is renamed, a method goes into SmartRefStream telling the new name.  The conversion method of the new class must be prepared to accept instances of the old class also.  If no inst var names have changed, the conversion method does nothing.An example:  	Suppose we change the representation of class Rectangle from ('origin' 'corner') to ('origin' 'extent').  Suppose lots of Rectangle instances are already out on files (in .pr project files, especially).  	The programmer changes the class definition, modifies all the methods, and filesOut.  A series of dialogs appear, asking if instances Rectangle might be in an object file, if 'extent' needs to be non-nil (yes), and if the info in 'corner' needs to be preserved (yes).  This method appears:Rectangle >> convertToCurrentVersion: varDict refStream: smartRefStrm	"These variables are automatically stored into the new instance: #('origin').	Test for this particular conversion.  Get values using expressions like (varDict at: 'foo')."	"New variables: #('extent').  If a non-nil value is needed, please assign it."	"These are going away #('corner').  Possibly store their info in some other variable?"	"Move your code above the ^ super...  Delete extra comments."	^ super convertToCurrentVersion: varDict refStream: smartRefStrmThe programmer modifies it to be:Rectangle >> convertToCurrentVersion: varDict refStream: smartRefStrm(varDict includesKey: 'extent') ifFalse: ["old version!!"	"Create the new extent, and preserve the info from the old corner"	extent _ (varDict at: 'corner') - origin.	].^ super convertToCurrentVersion: varDict refStream: smartRefStrm	This conversion method stays in the system and is ready to convert the old format of Rectangle whenever one is encountered in an object file.  Note that the subclasses of Rectangle, (B3DViewport, CharacterBlock, and Quadrangle) do not need conversion methods.  Their instances will be converted by the code in Rectangle.  	Files written by SmartRefStream are in standard fileout format.  You can mix raw objects with code to be filed in.  The file starts out in the normal fileOut format.  Definitions of new classes on the front.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now from the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name.  Make an instance of the new			class, and send it the conversion call.				(old class name symbol -> new class name).  renamedConv	Dictionary of conversion selector for Classes who have a different name.				(old class name symbol -> conversion selector).  topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, the top object if deep inside.See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.  A class may be stored inside an ImageSegment that itself is stored in a SmartRefStream.There is a separate subclass for doing veryDeepCopy (in memory).  Currently, any object for which objectToStoreOnDataStream return an object other than self, does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.Some metaclasses are put into the structures table.  This is for when a block has a receiver that is a class.  See checkFatalReshape:.ImageSegments:	A ReferenceStream is used to enumerate objects to put inside an ImageSegment.	A SmartRefStream is used to store the ImageSegment.  Roots are nil, and the segment is a wordArray.  We are encoding the outPointers.  Structures contains all classes from both places.--Ted Kaehler and Bob Arning.!!Object methodsFor: 'copying' stamp: 'jmv 11/27/2008 12:59'!copyAddedStateFrom: anotherObject	"Copy over the values of instance variables added by the receiver's class from anotherObject to the receiver."	self class superclass instSize + 1 to: self class instSize do:		[:index | self instVarAt: index put: (anotherObject instVarAt: index)]! !!Behavior methodsFor: 'initialize-release' stamp: 'jmv 11/27/2008 16:05'!nonObsoleteClass	"Attempt to find and return the current version of this obsolete class"	| obsName |	obsName _ self name.	[obsName beginsWith: 'AnObsolete']		whileTrue: [obsName _ obsName copyFrom: 'AnObsolete' size + 1 to: obsName size].	^ Smalltalk at: obsName asSymbol! !!Behavior methodsFor: 'testing' stamp: 'jmv 11/27/2008 16:05'!shouldNotBeRedefined	"Return true if the receiver should not be redefined.	The assumption is that compact classes,	classes in Smalltalk specialObjects and 	Behaviors should not be redefined"	^(Smalltalk compactClassesArray includes: self)		or:[(Smalltalk specialObjectsArray includes: self)			or:[self isKindOf: self]]! !!Behavior methodsFor: 'instance creation' stamp: 'jmv 11/27/2008 16:04'!basicNew	"Primitive. Answer an instance of the receiver (which is a class) with no 	indexable variables. Fail if the class is indexable. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [ ^ self basicNew: 0 ].	"space must be low"	Smalltalk signalLowSpace.	^ self basicNew  "retry if user proceeds"! !!Behavior methodsFor: 'instance creation' stamp: 'jmv 11/27/2008 16:04'!basicNew: sizeRequested 	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	(sizeRequested isInteger and: [sizeRequested >= 0]) ifTrue:		["arg okay; space must be low."		Smalltalk signalLowSpace.		^ self basicNew: sizeRequested  "retry if user proceeds"].	self primitiveFailed! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'jmv 11/27/2008 16:04'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	| subclassNames |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subclassNames _ SortedCollection new.	self subclassesDo: [:subC | subclassNames add: subC name].	subclassNames do:		[:name | (Smalltalk at: name)			allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 11/27/2008 16:05'!whichSelectorsReferTo: literal 	"Answer a Set of selectors whose methods access the argument as aliteral."	| special byte |	special _ Smalltalk hasSpecialSelector: literal ifTrueSetByte: [:b |byte _ b].	^self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."! !!Behavior methodsFor: 'user interface' stamp: 'jmv 11/27/2008 16:04'!allLocalCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."	| aSet special byte cls |	aSet _ Set new.	cls _ self theNonMetaClass.	special _ Smalltalk hasSpecialSelector: aSymbol					ifTrueSetByte: [:b | byte _ b ].	cls withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel ~~ #DoIt ifTrue: [aSet add: class name , ' ', sel]]].	cls class withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel ~~ #DoIt ifTrue: [aSet add: class name , ' ', sel]]].	^aSet! !!Behavior methodsFor: 'private' stamp: 'jmv 11/27/2008 16:04'!becomeCompact	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct index |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'jmv 11/27/2008 16:04'!becomeCompactSimplyAt: index	"Make me compact, but don't update the instances.  For importing segments.""Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	(cct at: index) ifNotNil: [^ self halt: 'compact table slot already in use'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Caller must convert the instances"! !!Behavior methodsFor: 'private' stamp: 'jmv 11/27/2008 16:05'!becomeUncompact	| cct index |	cct _ Smalltalk compactClassesArray.	(index _ self indexIfCompact) = 0		ifTrue: [^ self].	(cct includes: self)		ifFalse: [^ self halt  "inconsistent state"].	"Update instspec so future instances will not be compact"	format _ format - (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Make sure there are no compact ones left around"	Smalltalk garbageCollect.	"Remove this class from the compact class table"	cct at: index put: nil.! !!Behavior methodsFor: '*system-support' stamp: 'jmv 11/27/2008 16:04'!allCallsOn	"Answer a SortedCollection of all the methods that refer to me by name or 	as part of an association in a global dict."	^ (Smalltalk		allCallsOn: (Smalltalk associationAt: self theNonMetaClass name))		, (Smalltalk allCallsOn: self theNonMetaClass name)! !!Behavior methodsFor: '*system-support' stamp: 'jmv 11/27/2008 16:04'!allUnsentMessages	"Answer an array of all the messages defined by the receiver that are not sent anywhere in the system."	^ Smalltalk allUnSentMessagesIn: self selectors! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:36'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| file slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: 'cs']				ifFalse: [(self name , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'cs') asFileName].	Cursor write		showWhile: [[file := self defaultChangeSetDirectory newFileNamed: nameToUse.			file timeStamp.			self fileOutPreambleOn: file.			self fileOutOn: file.			self fileOutPostscriptOn: file]				ensure: [file close]].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')					= 2])		ifTrue: [Smalltalk browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:31'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict changeType classRecord currentDef |	classRecord _ changeRecords at: class name ifAbsent: [^ self].	dict _ classRecord methodChangeTypes.	dict keysSortedSafely do:		[:key | changeType _ dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [stream nextChunkPut: class name,						' removeSelector: ', key storeString; cr]			ifFalse: [(key = #initialize and: [class isMeta]) ifTrue:						[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]].	((classRecord includesChangeType: #change)			and: [(currentDef _ class definition) ~= (self fatDefForClass: class)]) ifTrue: [		stream nextPut: $!!; nextChunkPut: class definitionPreamble; cr;			nextChunkPut: currentDef; cr].	(classRecord includesChangeType: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'private' stamp: 'jmv 11/27/2008 15:34'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue: [		stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream nextPut: $!!; nextChunkPut: class definitionPreamble; cr;		nextChunkPut: (self fatDefForClass: class); cr.		DeepCopier new checkClass: class.	"If veryDeepCopy weakly copies some inst 			vars in this class, warn author when new ones are added." 	] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream nextPut: $!!; nextChunkPut: class definitionPreamble; cr;			nextChunkPut: class definition; cr.			DeepCopier new checkClass: class.	"If veryDeepCopy weakly copies some inst 				vars in this class, warn author when new ones are added." 		].	].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.		stream cr].! !!ClassBuilder methodsFor: 'initialize' stamp: 'jmv 11/27/2008 16:00'!initialize	instVarMap _ IdentityDictionary new.! !!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 11/27/2008 15:58'!class: oldClass instanceVariableNames: instVarString unsafe: unsafe	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass needNew copyOfOldClass |	instVars _ Scanner new scanFieldNames: instVarString.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass or not"	needNew _ self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.	needNew ifNil:[^nil]. "some error"	needNew ifFalse:[^oldClass]. "no new class needed"	"Create the new class"	copyOfOldClass _ oldClass copy.	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass.			newClass _ self recompile: false from: oldClass to: newClass mutate: false.	self doneCompiling: newClass.	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 11/27/2008 16:02'!name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category	"Define a new class in the given environment"	^self 		name: className 		subclassOf: newSuper 		type: type 		instanceVariableNames: instVarString 		classVariableNames: classVarString 		poolDictionaries: poolString 		category: category		unsafe: false! !!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 11/27/2008 16:01'!name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory |	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ Smalltalk at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	copyOfOldClass _ oldClass copy.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew _ self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined!! \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass _ self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass _ oldClass.	].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	newCategory _ category asSymbol.	organization _ Smalltalk organization.	oldClass isNil ifFalse: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].	organization classify: newClass name under: newCategory.	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(Smalltalk at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[Smalltalk at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		Smalltalk flushClassNameCache.	].	self doneCompiling: newClass.		"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category].	^newClass! !!ClassBuilder methodsFor: 'validation' stamp: 'jmv 11/27/2008 15:58'!validateClassName: aString	"Validate the new class name"	aString first isUppercase ifFalse:[		self error: 'Class names must be capitalized'.		^false].	Smalltalk at: aString ifPresent:[:old|		(old isKindOf: Behavior) ifFalse:[			self notify: aString asText allBold, 						' already exists!!\Proceed will store over it.' withCRs]].	^true! !!ClassBuilder methodsFor: 'public' stamp: 'jmv 11/27/2008 16:03'!superclass: newSuper	subclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class."	^self 		name: t		subclassOf: newSuper		type: newSuper typeOfClass		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'jmv 11/27/2008 16:03'!superclass: aClass	variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable byte-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(aClass isVariable and: [aClass isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a byte subclass of a class with pointer fields'].	^self 		name: t		subclassOf: aClass		type: #bytes		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'jmv 11/27/2008 16:03'!superclass: aClass	variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		subclassOf: aClass		type: #variable		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'jmv 11/27/2008 16:03'!superclass: aClass	variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable word-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a word subclass of a class with named fields'].	(aClass isVariable and: [aClass isBytes])		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a word subclass of a class with pointer fields'].	^self 		name: t		subclassOf: aClass		type: #words		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'jmv 11/27/2008 16:03'!superclass: aClass	weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		subclassOf: aClass		type: #weak		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassDescription methodsFor: 'printing' stamp: 'jmv 11/27/2008 16:07'!sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	^String streamContents: [ :stream |		self sharedPools 			do: [ :each |				stream nextPutAll: (Smalltalk					keyAtIdentityValue: each 					ifAbsent: [ 'private' ]) ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'jmv 11/27/2008 16:06'!recoverFromMDFaultWithTrace	"This method handles emthodDict faults to support, eg, discoverActiveClasses (qv)."	self recoverFromMDFault.	Smalltalk at: #MDFaultDict ifPresent:		[:faultDict | faultDict at: self name put:			(String streamContents:				[:strm | (thisContext stackOfSize: 20) do: [:item | strm print: item; cr]])]"Execute the following statement to induce MD fault tracing.  This means that, not only will all active classes be recorded but, after a test run, MDFaultDict will contain, for every class used, a stack trace showing how it came to be used.  This statement should be executed just prior to any such text, in order to clear the traces.	Smalltalk at: #MDFaultDict put: Dictionary new."! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 16:06'!definition	"Answer a String that defines the receiver."	| aStream path |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [path _ ''.				Smalltalk scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:36'!fileOutCategory: catName	"FileOut the named category"	| fileStream |	fileStream _ FileStream newFileNamed: self name , '-' , catName , '.st'.	fileStream timeStamp.	self fileOutCategory: catName on: fileStream moveSource: false toFile: 0.	fileStream close! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:38'!fileOutMethod: selector	"Write source code of a single method on a file.  Make up a name for the file."	| fileStream nameBody |	(selector == #Comment) ifTrue: [^ self inform: 'Sorry, cannot file out class comment in isolation.'].	(self includesSelector: selector) ifFalse: [^ self error: 'Selector ', selector asString, ' not found'].	nameBody _ self name , '-' , (selector copyReplaceAll: ':' with: '').	fileStream _ FileStream newFileNamed: nameBody , '.st'.	fileStream timeStamp.	self printMethodChunk: selector withPreamble: true		on: fileStream moveSource: false toFile: 0.	fileStream close! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:31'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	"File a description of the receiver on aFileStream. If the boolean 	argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the 	source code."	aFileStream nextPut: $!!; nextChunkPut: self definitionPreamble; cr.	aFileStream nextChunkPut: self definition.	self organization		putCommentOnFile: aFileStream		numbered: fileIndex		moveSource: moveSource		forClass: self.	self organization categories do: 		[:heading |		self fileOutCategory: heading			on: aFileStream			moveSource: moveSource			toFile: fileIndex]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:34'!printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod 	"Print a method category preamble.  This must have a category name.	It may have an author/date stamp, and it may have a prior source link.	If it has a prior source link, it MUST have a stamp, even if it is empty.""The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."	aFileStream cr; nextPut: $!!.	aFileStream nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.		(changeStamp ~~ nil and:			[changeStamp size > 0 or: [priorMethod ~~ nil]]) ifTrue:			[strm nextPutAll: ' stamp: '; print: changeStamp].		priorMethod ~~ nil ifTrue:			[strm nextPutAll: ' prior: '; print: priorMethod sourcePointer]]).! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'jmv 11/27/2008 16:07'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c | c removeFromSystem].	^ Smalltalk garbageCollect - oldFree! !!Class methodsFor: 'initialize-release' stamp: 'jmv 11/27/2008 16:06'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	Smalltalk forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'jmv 11/27/2008 16:07'!sharing: poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| oldPools found |	oldPools _ self sharedPools.	sharedPools _ OrderedCollection new.	(Scanner new scanFieldNames: poolString) do: 		[:poolName | 		sharedPools add: (Smalltalk at: poolName asSymbol ifAbsent:[			(self confirm: 'The pool dictionary ', poolName,' does not exist.',						'\Do you want it automatically created?' withCRs)				ifTrue:[Smalltalk at: poolName asSymbol put: Dictionary new]				ifFalse:[^self error: poolName,' does not exist']])].	sharedPools isEmpty ifTrue: [sharedPools _ nil].	oldPools do: [:pool | found _ false.				self sharedPools do: [:p | p == pool ifTrue: [found _ true]].				found ifFalse: [^ true "A pool got deleted"]].	^ false! !!Class methodsFor: 'testing' stamp: 'jmv 11/27/2008 16:06'!isObsolete	"Return true if the receiver is obsolete."	^(Smalltalk at: name ifAbsent:[nil]) ~~ self! !!Class methodsFor: 'class name' stamp: 'jmv 11/27/2008 16:06'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	(newName _ aString asSymbol) ~= self name		ifFalse: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	Smalltalk renameClass: self as: newName.	name _ newName! !!Class methodsFor: 'instance variables' stamp: 'jmv 11/27/2008 16:02'!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."		| answer |	answer _ ClassBuilder new		name: self name		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: self instanceVariablesString, ' ', aString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Class methodsFor: 'instance variables' stamp: 'jmv 11/27/2008 16:02'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString answer |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString _ ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString _ newInstVarString , ' ' , varName].	answer _ ClassBuilder new		name: self name		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: newInstVarString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Class methodsFor: 'compiling' stamp: 'jmv 11/27/2008 16:05'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Next look in shared pools."	self sharedPools do:[:pool | 		binding := pool bindingOf: aSymbol.		binding ifNotNil:[^binding].	].	"Next look in declared environment."	binding := Smalltalk bindingOf: aSymbol.	binding ifNotNil:[^binding].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ nil]		ifFalse: [^ superclass bindingOf: aSymbol].! !!Class methodsFor: 'compiling' stamp: 'jmv 11/27/2008 16:06'!possibleVariablesFor: misspelled continuedFrom: oldResults	| results |	results _ misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.	self sharedPools do: [:pool | 		results _ misspelled correctAgainstDictionary: pool continuedFrom: results ].	superclass == nil		ifTrue: 			[ ^ misspelled correctAgainstDictionary: Smalltalk continuedFrom: results ]		ifFalse:			[ ^ superclass possibleVariablesFor: misspelled continuedFrom: results ]! !!Class methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:36'!fileOut	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| fileStream |	fileStream _ FileStream newFileNamed: self name, FileDirectory dot, 'st'.	fileStream timeStamp.	self sharedPools size > 0 ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: fileStream]].	self fileOutOn: fileStream moveSource: false toFile: 0.	fileStream close.	"DeepCopier new checkVariables."! !!Class methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 16:05'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName aValue |	(aPool  isKindOf: SharedPool class) ifTrue:[^self notify: 'we do not fileout SharedPool type shared pools for now'].	aPoolName _ Smalltalk keyAtIdentityValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asSortedCollection do: [ :aKey |		aValue _ aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!Class methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 16:05'!fileOutSharedPoolsOn: aFileStream	"file out the shared pools of this class after prompting the user about each pool"	| poolsToFileOut |	poolsToFileOut _ self sharedPools select: 		[:aPool | (self shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool))].	poolsToFileOut do: [:aPool | self fileOutPool: aPool onFileStream: aFileStream].	! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'jmv 11/27/2008 12:56'!initialize: size	references _ IdentityDictionary new: size.	"self isItTimeToCheckVariables ifTrue: [self checkVariables]."		"no more checking at runtime"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'jmv 11/27/2008 13:40'!copyFromRootsForExport: rootArray 	"When possible, use copySmartRootsExport:.  This way may not copy a complete tree of objects.  Add to roots: all of the methods pointed to from the outside by blocks."	| newRoots list segSize symbolHolder |	arrayOfRoots _ rootArray.	Smalltalk forgetDoIts.  	symbolHolder _ Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize _ segment size.	[(newRoots _ self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots _ self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots _ newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	"classes of receivers of blocks"	list _ self compactClassesArray.	outPointers _ outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) class == BlockContext ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].	symbolHolder.! !!ImageSegment methodsFor: 'testing' stamp: 'jmv 11/27/2008 13:41'!findRogueRootsAllMorphs: rootArray 
	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.
1) assemble all objects should be in seg:  morph tree, presenter, scripts, player classes, metaclasses.  Put in a Set.
2) Remove the roots from this list.  Ask for senders of each.  Of the senders, forget the ones that are in the segment already.  Keep others.  The list is now all the 'incorrect' pointers into the segment."

	| inSeg testRoots pointIn xRoots |
	Smalltalk garbageCollect.
	inSeg := IdentitySet new: 200.
	arrayOfRoots := rootArray.
	testRoots := rootArray.
	xRoots := testRoots.
	xRoots do: 
			[:obj | 
			"root is a project"

			obj isMorph 
				ifTrue: 
					[obj allMorphs do: 
							[:mm | 
							inSeg add: mm].
					]].
	testRoots do: [:each | inSeg remove: each ifAbsent: []].
	"want them to be pointed at from outside"
	pointIn := IdentitySet new: 400.
	inSeg do: [:ob | pointIn addAll: (Smalltalk pointersTo: ob except: inSeg)].
	testRoots do: [:each | pointIn remove: each ifAbsent: []].
	pointIn remove: inSeg array ifAbsent: [].
	pointIn remove: pointIn array ifAbsent: [].
	inSeg do: 
			[:obj | 
			(obj isMorph) 
				ifTrue: 
					[pointIn remove: (obj instVarAt: 3)
						ifAbsent: 
							["submorphs"

							].
					"associations in extension"
					pointIn remove: obj extension ifAbsent: [].
					obj extension ifNotNil: 
							[obj extension otherProperties ifNotNil: 
									[obj extension otherProperties 
										associationsDo: [:ass | pointIn remove: ass ifAbsent: []]
									"*** and extension actorState"
									"*** and ActorState instantiatedUserScriptsDictionary ScriptInstantiations"]]].
			].
	"*** presenter playerlist"
	self halt: 'Examine local variables pointIn and inSeg'.
	^pointIn! !!ImageSegment methodsFor: 'testing' stamp: 'jmv 11/27/2008 13:41'!findRogueRootsImSeg: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) Break all owner pointers in submorphs and all scripts.2) Create the segment and look at outPointers.3) Remove those we expect.4) Remember to quit without saving -- the owner pointers are smashed."| suspects bag1 bag2 |arrayOfRoots _ rootArray.self findRogueRootsPrep.	"and free that context!!"Smalltalk forgetDoIts.Smalltalk garbageCollect.self copyFromRoots: arrayOfRoots sizeHint: 0.suspects _ outPointers select: [:oo | oo isMorph].suspects size > 0 ifTrue: [suspects inspect].bag1 _ Bag new.  bag2 _ Bag new.outPointers do: [:key | 	(key isKindOf: Class) 		ifTrue: [bag2 add: key class name]		ifFalse: [(#(Symbol Point Rectangle True False String Float Color Form ColorForm StrikeFont Metaclass UndefinedObject TranslucentColor) includes: key class name)			ifTrue: [bag2 add: key class name]			ifFalse: [bag1 add: key class name]]]."(bag sortedCounts) is the SortedCollection"(StringHolder new contents: bag1 sortedCounts printString, '', bag2 sortedCounts printString) 	openLabel: 'Objects pointed at by the outside'.self halt: 'Examine local variables pointIn and inSeg'."Use this in inspectors:	outPointers select: [:oo | oo class == <a Class>].		"! !!LightWidget methodsFor: 'compatibility' stamp: 'jmv 11/27/2008 15:08'!isPlayfieldLike	^ false! !!LightWidget methodsFor: 'meta actions' stamp: 'jmv 3/23/2008 18:56'!handlerForBlueButtonDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event.	Note: Halos handle blue button events themselves so we will only be asked if there is currently no halo on top of us."	self wantsHaloFromClick ifFalse:[^nil].	anEvent handler ifNil:[^self].	anEvent handler isPlayfieldLike ifTrue:[^self]. "by default exclude playfields"	(anEvent shiftPressed)		ifFalse:[^nil] "let outer guy have it"		ifTrue:[^self] "let me have it"! !!MethodFinder methodsFor: 'initialize' stamp: 'jmv 11/27/2008 14:50'!initialize
	"The methods we are allowed to use.  (MethodFinder new initialize) "

	Approved _ Set new.
	AddAndRemove _ Set new.
	Blocks _ Set new.
	"These modify an argument and are not used by the MethodFinder: longPrintOn: printOn: storeOn: sentTo: storeOn:base: printOn:base: absPrintExactlyOn:base: absPrintOn:base: absPrintOn:base:digitCount: writeOn: writeScanOn: possibleVariablesFor:continuedFrom: printOn:format:"

"Object"  
	#("in class, instance creation" initialInstance  newFrom: readCarefullyFrom:
"accessing" at: basicAt: basicSize bindWithTemp: in: size yourself 
"testing" ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isColor isFloat isFraction isInMemory isInteger isMorph isNil isNumber isPoint isPseudoContext isText isTransparent isWebBrowser knownName notNil pointsTo: wantsSteps 
"comparing" = == closeTo: hash hashMappedBy: identityHash identityHashMappedBy: identityHashPrintString ~= ~~ 
"copying" clone copy shallowCopy 
"dependents access" canDiscardEdits dependents hasUnacceptedEdits 
"updating" changed changed: okToChange update: windowIsClosing 
"printing" fullPrintString isLiteral longPrintString printString storeString stringForReadout stringRepresentation 
"class membership" class isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass 
"error handling" 
"user interface" defaultLabelForInspector initialExtent modelWakeUp 
"system primitives" asOop instVarAt: instVarNamed: 
"private" 
"associating" -> 
"converting" as: asOrderedCollection asString 
"casing" caseOf: caseOf:otherwise: 
"binding" bindingOf: 
"macpal" contentsChanged currentEvent currentHand currentWorld flash ifKindOf:thenDo: instanceVariableValues 
"flagging" flag: 
"translation support" "objects from disk" "finalization" ) do: [:sel | Approved add: sel].
	#(at:add: at:modify: at:put: basicAt:put: "NOT instVar:at:"
"message handling" perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: 
) do: [:sel | AddAndRemove add: sel].

"Boolean, True, False, UndefinedObject"  
	#("logical operations" & eqv: not xor: |
"controlling" and: ifFalse: ifFalse:ifTrue: ifTrue: ifTrue:ifFalse: or:
"copying" 
"testing" isEmptyOrNil) do: [:sel | Approved add: sel].

"Behavior" 
	#("initialize-release"
"accessing" compilerClass decompilerClass evaluatorClass format methodDict parserClass sourceCodeTemplate subclassDefinerClass
"testing" instSize instSpec isBits isBytes isFixed isPointers isVariable isWeak isWords
"copying"
"printing" printHierarchy
"creating class hierarchy"
"creating method dictionary"
"instance creation" basicNew basicNew: new new:
"accessing class hierarchy" allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses subclasses superclass withAllSubclasses withAllSuperclasses
"accessing method dictionary" allSelectors changeRecordsAt: compiledMethodAt: compiledMethodAt:ifAbsent: firstCommentAt: lookupSelector: selectors selectorsDo: selectorsWithArgs: "slow but useful ->" sourceCodeAt: sourceCodeAt:ifAbsent: sourceMethodAt: sourceMethodAt:ifAbsent:
"accessing instances and variables" allClassVarNames allInstVarNames allSharedPools classVarNames instVarNames instanceCount sharedPools someInstance subclassInstVarNames
"testing class hierarchy" inheritsFrom: kindOfSubclass
"testing method dictionary" canUnderstand: classThatUnderstands: hasMethods includesSelector: scopeHas:ifTrue: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichSelectorsStoreInto:
"enumerating"
"user interface"
"private" indexIfCompact) do: [:sel | Approved add: sel].

"ClassDescription"
	#("initialize-release" 
"accessing" classVersion isMeta name theNonMetaClass
"copying" 
"printing" classVariablesString instanceVariablesString sharedPoolsString
"instance variables" checkForInstVarsOK: 
"method dictionary" 
"organization" category organization whichCategoryIncludesSelector:
"compiling" acceptsLoggingOfCompilation wantsChangeSetLogging
"fileIn/Out" definition
"private" ) do: [:sel | Approved add: sel].

"Class"
	#("initialize-release" 
"accessing" classPool
"testing"
"copying" 
"class name" 
"instance variables" 
"class variables" classVarAt: classVariableAssociationAt:
"pool variables" 
"compiling" 
"subclass creation" 
"fileIn/Out" ) do: [:sel | Approved add: sel]. 

"Metaclass"
	#("initialize-release" 
"accessing" soleInstance
"copying" "instance creation" "instance variables"  "pool variables" "class hierarchy"  "compiling"
"fileIn/Out"  nonTrivial ) do: [:sel | Approved add: sel].

"Context, BlockContext"
	#(receiver client method receiver tempAt: 
"debugger access" mclass pc selector sender shortStack sourceCode tempNames tempsAndValues
"controlling"  "printing" "system simulation" 
"initialize-release" 
"accessing" hasMethodReturn home numArgs
"evaluating" value value:ifError: value:value: value:value:value: value:value:value:value: valueWithArguments:
"controlling"  "scheduling"  "instruction decoding"  "printing" "private"  "system simulation" ) do: [:sel | Approved add: sel].
	#(value: "<- Association has it as a store" ) do: [:sel | AddAndRemove add: sel].

"Message"
	#("inclass, instance creation" selector: selector:argument: selector:arguments:
"accessing" argument argument: arguments sends:
"printing" "sending" ) do: [:sel | Approved add: sel].
	#("private" setSelector:arguments:) do: [:sel | AddAndRemove add: sel].

"Magnitude"
	#("comparing" < <= > >= between:and:
"testing" max: min: min:max: ) do: [:sel | Approved add: sel].

"Date, Time"
	#("in class, instance creation" fromDays: fromSeconds: fromString: newDay:month:year: newDay:year: today
	"in class, general inquiries" dateAndTimeNow dayOfWeek: daysInMonth:forYear: daysInYear: firstWeekdayOfMonth:year: indexOfMonth: leapYear: nameOfDay: nameOfMonth:
"accessing" day leap monthIndex monthName weekday year
"arithmetic" addDays: subtractDate: subtractDays:
"comparing"
"inquiries" dayOfMonth daysInMonth daysInYear daysLeftInYear firstDayOfMonth previous:
"converting" asSeconds
"printing" mmddyy mmddyyyy printFormat: 
"private" firstDayOfMonthIndex: weekdayIndex 
	"in class, instance creation" fromSeconds: now 
	"in class, general inquiries" dateAndTimeFromSeconds: dateAndTimeNow millisecondClockValue millisecondsToRun: totalSeconds
"accessing" hours minutes seconds
"arithmetic" addTime: subtractTime:
"comparing"
"printing" intervalString print24 
"converting") do: [:sel | Approved add: sel].
	#("private" hours: hours:minutes:seconds: day:year: 
		 ) do: [:sel | AddAndRemove add: sel].

"Number"
	#("in class" readFrom:base: 
"arithmetic" * + - / // \\ abs negated quo: reciprocal rem:
"mathematical functions" arcCos arcSin arcTan arcTan: cos exp floorLog: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan
"truncation and round off" ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated
"comparing"
"testing" even isDivisibleBy: isInf isInfinite isNaN isZero negative odd positive sign strictlyPositive
"converting" @ asInteger asNumber asPoint asSmallAngleDegrees degreesToRadians radiansToDegrees
"intervals" to: to:by: 
"printing" printStringBase: storeStringBase: ) do: [:sel | Approved add: sel].

"Integer"
	#("in class" primesUpTo:
"testing" isPowerOfTwo
"arithmetic" alignedTo:
"comparing"
"truncation and round off" atRandom normalize
"enumerating" timesRepeat:
"mathematical functions" degreeCos degreeSin factorial gcd: lcm: take:
"bit manipulation" << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:
"converting" asCharacter asColorOfDepth: asFloat asFraction asHexDigit
"printing" asStringWithCommas hex hex8 radix:
"system primitives" lastDigit replaceFrom:to:with:startingAt:
"private" "benchmarks" ) do: [:sel | Approved add: sel].

"SmallInteger, LargeNegativeInteger, LargePositiveInteger"
	#("arithmetic" "bit manipulation" highBit "testing" "comparing" "copying" "converting" "printing" 
"system primitives" digitAt: digitLength 
"private" fromString:radix: ) do: [:sel | Approved add: sel].
	#(digitAt:put: ) do: [:sel | AddAndRemove add: sel].

"Float"
	#("arithmetic"
"mathematical functions" reciprocalFloorLog: reciprocalLogBase2 timesTwoPower:
"comparing" "testing"
"truncation and round off" exponent fractionPart integerPart significand significandAsInteger
"converting" asApproximateFraction asIEEE32BitWord asTrueFraction
"copying") do: [:sel | Approved add: sel].

"Fraction, Random"
	#(denominator numerator reduced next nextValue) do: [:sel | Approved add: sel].
	#(setNumerator:denominator:) do: [:sel | AddAndRemove add: sel].

"Collection"
	#("accessing" anyOne
"testing" includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isEmpty isSequenceable occurrencesOf:
"enumerating" collect: collect:thenSelect: count: detect: detect:ifNone: detectMax: detectMin: detectSum: inject:into: reject: select: select:thenCollect:
"converting" asBag asCharacterSet asSet asSortedArray asSortedCollection asSortedCollection:
"printing"
"private" maxSize
"arithmetic"
"math functions" average max median min range sum) do: [:sel | Approved add: sel].
	#("adding" add: addAll: addIfNotPresent:
"removing" remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat: remove:ifAbsent:) do: [:sel | AddAndRemove add: sel].

"SequenceableCollection"
	#("comparing" hasEqualElements:
"accessing" allButFirst allButLast at:ifAbsent: atAll: atPin: atRandom: atWrap: fifth first fourth identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last second sixth third
"removing"
"copying" , copyAfterLast: copyAt:put: copyFrom:to: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithout: copyWithoutAll: forceTo:paddingWith: shuffled sortBy:
"enumerating" collectWithIndex: findFirst: findLast: pairsCollect: with:collect: withIndexCollect: polynomialEval:
"converting" asArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray reversed
"private" copyReplaceAll:with:asTokens: ) do: [:sel | Approved add: sel].
	#( swap:with:) do: [:sel | AddAndRemove add: sel].

"ArrayedCollection, Bag"
	#("private" defaultElement 
"sorting" isSorted
"accessing" cumulativeCounts sortedCounts sortedElements "testing" "adding" add:withOccurrences: "removing" "enumerating" 
	) do: [:sel | Approved add: sel].
	#( mergeSortFrom:to:by: sort sort: add: add:withOccurrences:
"private" setDictionary ) do: [:sel | AddAndRemove add: sel].

"Other messages that modify the receiver"
	#(atAll:put: atAll:putAll: atAllPut: atWrap:put: replaceAll:with: replaceFrom:to:with:  removeFirst removeLast) do: [:sel | AddAndRemove add: sel].

	self initialize2.

"
MethodFinder new initialize.
MethodFinder new organizationFiltered: Set
"

! !!MethodFinder methodsFor: 'initialize' stamp: 'jmv 11/27/2008 15:28'!initialize2	"The methods we are allowed to use.  (MethodFinder new initialize) ""Set"	#("in class" sizeFor:"testing" "adding" "removing" "enumerating""private" array findElementOrNil: "accessing" someElement) do: [:sel | Approved add: sel]."Dictionary, IdentityDictionary, IdentitySet"	#("accessing" associationAt: associationAt:ifAbsent: at:ifPresent: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keyAtValue:ifAbsent: keys"testing" includesKey: ) do: [:sel | Approved add: sel].	#(removeKey: removeKey:ifAbsent:) do: [:sel | AddAndRemove add: sel]."LinkedList, Interval, MappedCollection"	#("in class"  from:to: from:to:by:"accessing" contents) do: [:sel | Approved add: sel].	#("adding" addFirst: addLast:) do: [:sel | AddAndRemove add: sel]."OrderedCollection, SortedCollection"	#("accessing" after: before:"copying" copyEmpty"adding"  growSize"removing" "enumerating" "private" "accessing" sortBlock) do: [:sel | Approved add: sel].	#("adding" add:after: add:afterIndex: add:before: addAllFirst: addAllLast: addFirst: addLast:"removing" removeAt: removeFirst removeLast"accessing" sortBlock:) do: [:sel | AddAndRemove add: sel]."Character"	#("in class, instance creation" allCharacters digitValue: new separators	"accessing untypeable characters" backspace cr enter lf linefeed nbsp newPage space tab	"constants" alphabet characterTable"accessing" asciiValue digitValue"comparing""testing" isAlphaNumeric isDigit isLetter isLowercase isSafeForHTTP isSeparator isSpecial isUppercase isVowel tokenish"copying""converting" asIRCLowercase asLowercase asUppercase	) do: [:sel | Approved add: sel]."String"	#("in class, instance creation" crlf fromPacked:	"primitives" findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: 	"internet" valueOfHtmlEntity:"accessing" byteAt: endsWithDigit findAnySubStr:startingAt: findBetweenSubStrs: findDelimiters:startingAt: findString:startingAt: findString:startingAt:caseSensitive: findTokens: findTokens:includes: findTokens:keep: includesSubString: includesSubstring:caseSensitive: indexOf:startingAt: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: skipAnySubStr:startingAt: skipDelimiters:startingAt: startsWithDigit"comparing" alike: beginsWith: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: crc16 endsWith: endsWithAnyOf: sameAs: startingAt:match:startingAt:"copying" copyReplaceTokens:with: padded:to:with:"converting" asByteArray asDate asDisplayText asFileName asLegalSelector asPacked asText asTime asUnHtml asUrlRelativeTo: capitalized compressWithTable: contractTo: correctAgainst: encodeForHTTP initialIntegerOrNil keywords quoted sansPeriodSuffix splitInteger stemAndNumericSuffix substrings surroundedBySingleQuotes truncateWithElipsisTo: withBlanksTrimmed withFirstCharacterDownshifted withNoLineLongerThan: withSeparatorsCompacted withoutLeadingDigits withoutTrailingBlanks"displaying" "printing""system primitives" compare:with:collated: "Celeste" withCRs"internet" decodeMimeHeader decodeQuotedPrintable unescapePercents withInternetLineEndings withSqueakLineEndings withoutQuoting"testing" isAllSeparators lastSpacePosition"paragraph support" indentationIfBlank:"arithmetic" ) do: [:sel | Approved add: sel].	#(byteAt:put: translateToLowercase match:) do: [:sel | AddAndRemove add: sel]."Symbol"	#("in class, private" hasInterned:ifTrue:	"access" morePossibleSelectorsFor: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:"accessing" "comparing" "copying" "converting" "printing" "testing" isInfix isKeyword isPvtSelector isUnary) do: [:sel | Approved add: sel]."Array"	#("comparing" "converting" evalStrings "printing" "private" hasLiteralSuchThat:) do: [:sel | Approved add: sel]."Array2D"	#("access" at:at: atCol: atCol:put: atRow: extent extent:fromArray: height width width:height:type:) do: [:sel | Approved add: sel].	#(at:at:add: at:at:put: atRow:put: ) do: [:sel | AddAndRemove add: sel]."ByteArray"	#("accessing" doubleWordAt: wordAt: "platform independent access" longAt:bigEndian: shortAt:bigEndian: unsignedLongAt:bigEndian: unsignedShortAt:bigEndian: "converting") do: [:sel | Approved add: sel].	#(doubleWordAt:put: wordAt:put: longAt:put:bigEndian: shortAt:put:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:put:bigEndian:	) do: [:sel | AddAndRemove add: sel]."FloatArray"		"Dont know what happens when prims not here"	false ifTrue: [#("accessing" "arithmetic" *= += -= /="comparing""primitives-plugin" primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:"primitives-translated" primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:"converting" "private" "user interface") do: [:sel | Approved add: sel].	]."IntegerArray, WordArray""RunArray"	#("in class, instance creation" runs:values: scanFrom:"accessing" runLengthAt: "adding" "copying""private" runs values) do: [:sel | Approved add: sel].	#(coalesce addLast:times: repeatLast:ifEmpty: repeatLastIfEmpty:		) do: [:sel | AddAndRemove add: sel]."Stream  -- many operations change its state"	#("testing" atEnd) do: [:sel | Approved add: sel].	#("accessing" next: nextMatchAll: nextMatchFor: upToEndnext:put: nextPut: nextPutAll: "printing" print: printHtml:	) do: [:sel | AddAndRemove add: sel]."PositionableStream"	#("accessing" contentsOfEntireFile originalContents peek peekFor: "testing""positioning" position ) do: [:sel | Approved add: sel].	#(nextDelimited: nextLine upTo: position: reset resetContents setToEnd skip: skipTo: upToAll: ) do: [:sel | AddAndRemove add: sel].	"Because it is so difficult to test the result of an operation on a Stream (you have to supply another Stream in the same state), we don't support Streams beyond the basics.  We want to find the messages that convert Streams to other things.""ReadWriteStream"	#("file status" closed) do: [:sel | Approved add: sel].	#("accessing" next: on: ) do: [:sel | AddAndRemove add: sel]."WriteStream"	#("in class, instance creation" on:from:to: with: with:from:to:		) do: [:sel | Approved add: sel].	#("positioning" resetToStart"character writing" crtab crtab:) do: [:sel | AddAndRemove add: sel]."LookupKey, Association, Link"	#("accessing" key nextLink) do: [:sel | Approved add: sel].	#(key: key:value: nextLink:) do: [:sel | AddAndRemove add: sel]."Point"	#("in class, instance creation" r:degrees: x:y:"accessing" x y "comparing" "arithmetic" "truncation and round off""polar coordinates" degrees r theta"point functions" bearingToPoint: crossProduct: dist: dotProduct: eightNeighbors flipBy:centerAt: fourNeighbors grid: nearestPointAlongLineFrom:to: nearestPointOnLineFrom:to: normal normalized octantOf: onLineFrom:to: onLineFrom:to:within: quadrantOf: rotateBy:centerAt: transposed unitVector"converting" asFloatPoint asIntegerPoint corner: extent: rect:"transforming" adhereTo: rotateBy:about: scaleBy: scaleFrom:to: translateBy: "copying""interpolating" interpolateTo:at:) do: [:sel | Approved add: sel]."Rectangle"	#("in class, instance creation" center:extent: encompassing: left:right:top:bottom: 	merging: origin:corner: origin:extent: "accessing" area bottom bottomCenter bottomLeft bottomRight boundingBox center corner corners innerCorners left leftCenter origin right rightCenter top topCenter topLeft topRight"comparing""rectangle functions" adjustTo:along: amountToTranslateWithin: areasOutside: bordersOn:along: encompass: expandBy: extendBy: forPoint:closestSideDistLen: insetBy: insetOriginBy:cornerBy: intersect: merge: pointNearestTo: quickMerge: rectanglesAt:height: sideNearestTo: translatedToBeWithin: withBottom: withHeight: withLeft: withRight: withSide:setTo: withTop: withWidth:"testing" containsPoint: containsRect: hasPositiveExtent intersects: isTall isWide"truncation and round off""transforming" align:with: centeredBeneath: newRectFrom: squishedWithin: "copying"	) do: [:sel | Approved add: sel]."Color"	#("in class, instance creation" colorFrom: colorFromPixelValue:depth: fromRgbTriplet: gray: h:s:v: r:g:b: r:g:b:alpha: r:g:b:range:	"named colors" black blue brown cyan darkGray gray green lightBlue lightBrown lightCyan lightGray lightGreen lightMagenta lightOrange lightRed lightYellow magenta orange red transparent veryDarkGray veryLightGray veryVeryDarkGray veryVeryLightGray white yellow	"other" colorNames indexedColors pixelScreenForDepth: quickHighLight:"access" alpha blue brightness green hue luminance red saturation"equality""queries" isBitmapFill isBlack isGray isSolidFill isTranslucent isTranslucentColor"transformations" alpha: dansDarker darker lighter mixed:with: muchLighter slightlyDarker slightlyLighter veryMuchLighter alphaMixed:with:"groups of shades" darkShades: lightShades: mix:shades: wheel:"printing" shortPrintString"other" colorForInsets rgbTriplet"conversions" asB3DColor asColor balancedPatternForDepth: bitPatternForDepth: closestPixelValue1 closestPixelValue2 closestPixelValue4 closestPixelValue8 dominantColor halfTonePattern1 halfTonePattern2 indexInMap: pixelValueForDepth: pixelWordFor:filledWith: pixelWordForDepth: scaledPixelValue32"private" privateAlpha privateBlue privateGreen privateRGB privateRed "copying"	) do: [:sel | Approved add: sel]."	For each selector that requires a block argument, add (selector argNum) 		to the set Blocks.""ourClasses _ #(Object Boolean True False UndefinedObject Behavior ClassDescription Class Metaclass MethodContext BlockContext Message Magnitude Date Time Number Integer SmallInteger LargeNegativeInteger LargePositiveInteger Float Fraction Random Collection SequenceableCollection ArrayedCollection Bag Set Dictionary IdentityDictionary IdentitySet LinkedList Interval MappedCollection OrderedCollection SortedCollection Character String Symbol Array Array2D ByteArray FloatArray IntegerArray WordArray RunArray Stream PositionableStream ReadWriteStream WriteStream LookupKey Association Link Point Rectangle Color).ourClasses do: [:clsName | cls _ Smalltalk at: clsName.	(cls selectors) do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(cls formalParametersAt: aSel) withIndexDo: [:tName :ind |				(tName endsWith: 'Block') ifTrue: [					Blocks add: (Array with: aSel with: ind)]]]]]."#((timesRepeat: 1 ) (indexOf:ifAbsent: 2 ) (pairsCollect: 1 ) (mergeSortFrom:to:by: 3 ) (ifNotNil:ifNil: 1 ) (ifNotNil:ifNil: 2 ) (ifNil: 1 ) (at:ifAbsent: 2 ) (ifNil:ifNotNil: 1 ) (ifNil:ifNotNil: 2 ) (ifNotNil: 1 ) (at:modify: 2 ) (identityIndexOf:ifAbsent: 2 ) (sort: 1 ) (sortBlock: 1 ) (detectMax: 1 ) (repeatLastIfEmpty: 1 ) (allSubclassesWithLevelDo:startingLevel: 1 ) (keyAtValue:ifAbsent: 2 ) (in: 1 ) (ifTrue: 1 ) (or: 1 ) (select: 1 ) (inject:into: 2 ) (ifKindOf:thenDo: 2 ) (forPoint:closestSideDistLen: 2 ) (value:ifError: 2 ) (selectorsDo: 1 ) (removeAllSuchThat: 1 ) (keyAtIdentityValue:ifAbsent: 2 ) (detectMin: 1 ) (detect:ifNone: 1 ) (ifTrue:ifFalse: 1 ) (ifTrue:ifFalse: 2 ) (detect:ifNone: 2 ) (hasLiteralSuchThat: 1 ) (indexOfAnyOf:ifAbsent: 2 ) (reject: 1 ) (newRectFrom: 1 ) (removeKey:ifAbsent: 2 ) (at:ifPresent: 2 ) (associationAt:ifAbsent: 2 ) (withIndexCollect: 1 ) (repeatLast:ifEmpty: 2 ) (findLast: 1 ) (indexOf:startingAt:ifAbsent: 3 ) (remove:ifAbsent: 2 ) (ifFalse:ifTrue: 1 ) (ifFalse:ifTrue: 2 ) (caseOf:otherwise: 2 ) (count: 1 ) (collect: 1 ) (sortBy: 1 ) (and: 1 ) (asSortedCollection: 1 ) (with:collect: 2 ) (sourceCodeAt:ifAbsent: 2 ) (detect: 1 ) (scopeHas:ifTrue: 2 ) (collectWithIndex: 1 ) (compiledMethodAt:ifAbsent: 2 ) (bindWithTemp: 1 ) (detectSum: 1 ) (indexOfSubCollection:startingAt:ifAbsent: 3 ) (findFirst: 1 ) (sourceMethodAt:ifAbsent: 2 ) (collect:thenSelect: 1 ) (collect:thenSelect: 2 ) (select:thenCollect: 1 ) (select:thenCollect: 2 ) (ifFalse: 1 ) (indexOfAnyOf:startingAt:ifAbsent: 3 ) (indentationIfBlank: 1 ) ) do: [:anArray |	Blocks add: anArray].self initialize3."MethodFinder new initialize.MethodFinder new organizationFiltered: TranslucentColor class ""Do not forget class messages for each of these classes"! !!Class class methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 16:06'!fileOutPool: aString	"file out the global pool named aString"	| f |	f _ FileStream newFileNamed: aString, '.st'.	self new fileOutPool: (Smalltalk at: aString asSymbol) onFileStream: f. 	f close.	! !!FormsAndHelpsRepository class methodsFor: 'class initialization' stamp: 'jmv 11/27/2008 16:07'!initialize
	"Initialize the scripting system.  Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"

	(Smalltalk at: #ScriptingSystem ifAbsent: [nil]) ifNil:
		[Smalltalk at: #ScriptingSystem put: self new]

"StandardScriptingSystem initialize"! !!OldMorph methodsFor: 'classification' stamp: 'sw 1/29/98 21:51'!isPlayfieldLike	^ false! !!OldMorph methodsFor: 'meta-actions' stamp: 'jmv 12/5/2004 16:55'!handlerForBlueButtonDown: anEvent
	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event.
	Note: Halos handle blue button events themselves so we will only be asked if there is currently no halo on top of us."
	self wantsHaloFromClick ifFalse:[^nil].
	anEvent handler ifNil:[^self].
	anEvent handler isPlayfieldLike ifTrue:[^self]. "by default exclude playfields"
	(anEvent shiftPressed)
		ifFalse:[^nil] "let outer guy have it"
		ifTrue:[^self] "let me have it"
! !!OldMorph methodsFor: 'stepping and presenter' stamp: 'jmv 11/27/2008 14:53'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message. "! !!OldPasteUpMorph methodsFor: 'classification' stamp: 'sw 1/29/98 21:50'!isPlayfieldLike	^ true! !!OldSystemWindow methodsFor: 'stepping' stamp: 'jmv 11/27/2008 14:58'!stepAt: millisecondClockValue	"If the receiver is not collapsed, step it, after first stepping the model."	(isCollapsed not or: [self wantsStepsWhenCollapsed]) ifTrue: [		model ifNotNil: [model stepAt: millisecondClockValue in: self].		super stepAt: millisecondClockValue ]"Since this method ends up calling step, the model-stepping logic should not be duplicated there."! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:36'!fileOutChangeSet: aChangeSetOrNil andObject: theObject	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically."	"An experimental version to fileout a changeSet first so that a project can contain its own classes"	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self timeStamp.	aChangeSetOrNil ifNotNil: [		aChangeSetOrNil fileOutPreambleOn: self.		aChangeSetOrNil fileOutOn: self.		aChangeSetOrNil fileOutPostscriptOn: self.	].	"Append the object's raw data"	(SmartRefStream on: self)		nextPut: theObject;  "and all subobjects"		close.		"also closes me"! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:36'!fileOutChanges	"Append to the receiver a description of all class changes."	Cursor write showWhile: [		self timeStamp.		ChangeSet current fileOutOn: self.		self close]! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:37'!fileOutClass: extraClass andObject: theObject	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically."	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self timeStamp.	extraClass ifNotNil: [		class _ extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	"Append the object's raw data"	srefStream _ SmartRefStream on: self.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:37'!fileOutClass: extraClass andObject: theObject blocking: anIdentDict	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically.  Accept a list of objects to map to nil or some other object (blockers).  In addition to teh choices in each class's objectToStoreOnDataStream"	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self timeStamp.	extraClass ifNotNil: [		class _ extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	"Append the object's raw data"	srefStream _ SmartRefStream on: self.	srefStream blockers: anIdentDict.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!FileStream class methodsFor: 'file reader services' stamp: 'jmv 11/27/2008 15:27'!fileIn: fullName	"File in the entire contents of the file specified by the name provided"	| ff |	fullName ifNil: [^ Beeper beep].	ff _ self readOnlyFileNamed: (GZipReadStream uncompressedFileName: fullName).	ff fileIn! !!ReferenceStream methodsFor: 'writing' stamp: 'jmv 11/27/2008 13:30'!insideASegment: aBoolean	"In Squeak 3.7, this method was sent only for saving ImageSegments for Projects.	Projects were removed, but I believe it could make sense to set this to true for any ImageSegment"	self flag: #jmv.		insideASegment _ aBoolean! !!ReferenceStream class methodsFor: 'as yet unclassified' stamp: 'jmv 11/27/2008 13:34'!versionCode    "Answer a number representing the 'version' of the ReferenceStream facility; this is stashed at the beginning of ReferenceStreams, as a secondary versioning mechanism (the primary one is the fileTypeCode).   At present, it serves for information only, and is not checked for compatibility at reload time, but could in future be used to branch to variant code. "	" 1 = original version 1992"	" 2 = HyperSqueak.  PathFromHome used for Objs outside the tree.  SqueakSupport SysLibrary for shared globals like Display and StrikeFonts.  File has version number, class structure, then an IncomingObjects manager.  8/16/96 tk.  	Extended to SmartRefStream.  class structure also keeps superclasse chain.  Does analysis on structure to see when translation methods are needed.  Embedable in file-ins.  (factored out HyperSqueak support)  Feb-May 97 tk"	" 3 = Reference objects are byte offsets relative to the start of the object portion of the file.  Rectangles with values -2048 to 2047 are encoded compactly."	" 4 = If UniClasses (subclasses of Player) have class instance variables, append their values in the form (#Class43 (val1 val2 vla3)).  An array of those.  Can still read version 3."	"jmv. Can not really manage UniClasses, as there are no Etoys system in place. No class Player either.	Anyway, keep answering 4 (instead of 3) as it is quite possible that some other subtetlies have changed since version 3.	I know, the comment says that it is not checked at reload time, but see senders!! #nextAndClose did not call us in v3, but does now.	And several other places ask for the magic constant 4. So, more care is needed to change this to 3.	Anyway, I don't expect any problem, as files with UniClasses should never reach this image."	^ 4! !!SmartRefStream methodsFor: 'read write' stamp: 'jmv 11/27/2008 12:34'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	structures _ Dictionary new.	superclasses _ Dictionary new.	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	(refs includesKey: #AnImageSegment) 		ifFalse: [			refs keysDo: [:each | 				cls _ each class.				"cls isObsolete ifTrue: [self error: 'Trying to write ', cls name]."				(cls class ~~ Metaclass) & (cls isObsolete not) ifTrue: [					structures at: cls name put: false]]]		ifTrue: [self recordImageSegment: refs].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures at: #Point put: false.	"writeRectangle: does not put out class pointer"	structures at: #Rectangle put: false.	structures at: #LargePositiveInteger put: false.	"used in slow case of WordArray"	structures keysDo: [:nm | 		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'jmv 11/27/2008 12:35'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ #marked.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			self checkCrLf.			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regular object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			object _ super next.	"all the action here"			topCall _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'read write' stamp: 'jmv 11/27/2008 13:12'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		byteStream binary.		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		byteStream padToEndWith: $ .	"really want to truncate file, but can't"		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SpaceTally methodsFor: 'class analysis' stamp: 'jmv 11/27/2008 16:07'!computeSpaceUsage	| entry c |	1 to: results size do: [:i |		entry := results at: i.		c := Smalltalk at: entry analyzedClassName.		entry codeSize: c spaceUsed.		entry instanceCount: c instanceCount.		entry spaceForInstances: (self spaceForInstancesOf: c).		Smalltalk garbageCollectMost].	! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/27/2008 15:25'!classListMenu: aMenu shifted: shifted	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	shifted		ifTrue:			[^ self shiftedClassListMenu: aMenu].	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: 'message category functions' stamp: 'jmv 11/27/2008 15:16'!messageCategoryMenu: aMenu^ aMenu labels:'browsefileOutreorganizealphabetizeremove empty categoriescategorize all uncategorizednew category...rename...remove'	lines: #(2 7)	selections:		#(buildMessageCategoryBrowser fileOutMessageCategories		editMessageCategories alphabetizeMessageCategories removeEmptyCategories		categorizeAllUncategorizedMethods addCategory renameCategory removeMessageCategory)! !!Browser methodsFor: 'message functions' stamp: 'jmv 11/27/2008 15:26'!messageListMenu: aMenu shifted: shifted
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].

	aMenu addList:#(
			('what to show...'			offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry)
            		-
			('browse full (b)' 			browseMethodFull)
			('browse hierarchy (h)'			classHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'				fileOutMessage)
			-
			('senders of... (n)'			browseSendersOfMessages)
			('implementors of... (m)'		browseMessages)
			('inheritance (i)'			methodHierarchy)
			('versions (v)'				browseVersions)
			-
			('inst var refs...'			browseInstVarRefs)
			('inst var defs...'			browseInstVarDefs)
			('class var refs...'			browseClassVarRefs)
			('class variables'			browseClassVariables)
			('class refs (N)'			browseClassRefs)
			-
			('remove method (x)'			removeMessage)
			-
			('more...'				shiftedYellowButtonActivity)).
	^ aMenu
! !!Browser methodsFor: 'system category functions' stamp: 'jmv 11/27/2008 15:20'!systemCatSingletonMenu: aMenu	^ aMenu labels:'browse allbrowsefileOutupdaterename...remove' 	lines: #(2 3)	selections:		#(browseAllClasses buildSystemCategoryBrowser		fileOutSystemCategory updateSystemCategories		renameSystemCategory removeSystemCategory)! !!Browser methodsFor: 'system category functions' stamp: 'jmv 11/27/2008 15:22'!systemCategoryMenu: aMenu^ aMenu labels:'find class... (f)recent classes... (r)browse allbrowsefileOutreorganizealphabetizeupdateadd item...rename...removemove to topmove upmove downmove to bottom' 	lines: #(2 4 5 7 11)	selections:		#(findClass recent browseAllClasses buildSystemCategoryBrowser		fileOutSystemCategory		editSystemCategories alphabetizeSystemCategories updateSystemCategories		addSystemCategory renameSystemCategory removeSystemCategory 		moveSystemCategoryTop moveSystemCategoryUp 		moveSystemCategoryDown moveSystemCategoryBottom)! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/27/2008 15:38'!fileOutSelections 	| f |	f _ FileStream newFileNamed: (FillInTheBlank request: 'Enter file name' initialAnswer: 'Filename.st').	f ifNil: [^ self].	f timeStamp.	listSelections with: changeList do: 		[:selected :item | selected ifTrue: [item fileOutOn: f]].	f close! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 11/27/2008 12:41'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	aMenu title: 'Change set (shifted)'.		aMenu addStayUpItemSpecial.	"CONFLICTS SECTION"	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	parent ifNotNil:		[aMenu add: 'conflicts with change set opposite' action: #methodConflictsWithOtherSide.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in the one on the opposite side of the change sorter.'.			aMenu add: 'conflicts with category opposite' action: #methodConflictsWithOppositeCategory.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in ANY change set in the category list on the opposite side of this change sorter, other of course than this change set itself.  (Caution -- this could be VERY slow)'].	aMenu addLine.	"CHECKS SECTION"	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	aMenu add: 'check for uncommented classes' action: #checkForUncommentedClasses.	aMenu balloonTextForLastItem:'Check for classes with code in this changeset which lack class comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'.	aMenu add: 'check for any other authors' action: #checkForAnyAlienAuthorship.	aMenu balloonTextForLastItem:'Check this change set for methods any of whose authoring stamps do not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'promote to top of list' action: #promoteToTopChangeSet.	aMenu balloonTextForLastItem:'Make this change set appear first in change-set lists in all change sorters.'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'view affected class categories' action: #viewAffectedClassCategories.	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.		aMenu add: 'remove contained in class categories...' action: #removeContainedInClassCategories.	aMenu balloonTextForLastItem: ' Drops any changes in given class categories'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'file into new...' action: #fileIntoNewChangeSet.	aMenu balloonTextForLastItem: 'Load a fileout from disk and place its changes into a new change set (seldom needed -- much better to do this from a file-list browser these days.)'.	aMenu add: 'reorder all change sets' action: #reorderChangeSets.	aMenu balloonTextForLastItem:'Applies a standard reordering of all change-sets in the system -- at the bottom will come the sets that come with the release; next will come all the numbered updates; finally, at the top, will come all other change sets'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 11/27/2008 15:25'!classListMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the class list"	aMenu title: 'class list'.	aMenu addStayUpItemSpecial.	(parent notNil and: [shifted not])		ifTrue: [aMenu addList: #( "These two only apply to dual change sorters"			('copy class chgs to other side'			copyClassToOther)				('move class chgs to other side'			moveClassToOther))].	aMenu addList: (shifted		ifFalse: [#(			-			('delete class from change set (d)'		forgetClass)			('remove class from system (x)'			removeClass)			-			('browse full (b)'						browseMethodFull)			('browse hierarchy (h)'					spawnHierarchy)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut'								fileOutClass)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class vars'								browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('more...'								offerShiftedClassListMenu))]		ifTrue: [#(			-			('unsent methods'						browseUnusedMethods)			('unreferenced inst vars'				showUnreferencedInstVars)			('unreferenced class vars'				showUnreferencedClassVars)			-			('sample instance'						makeSampleInstance)			('inspect instances'						inspectInstances)			('inspect subinstances'					inspectSubInstances)			-			('more...'								offerUnshiftedClassListMenu ))]).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 11/27/2008 15:27'!messageMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	aMenu title: 'message list'.	aMenu addStayUpItemSpecial.	parent ifNotNil:		[aMenu addList: #(			('copy method to other side'			copyMethodToOther)			('move method to other side'			moveMethodToOther))].	aMenu addList: #(			('delete method from changeSet (d)'	forget)			-			('remove method from system (x)'	removeMessage)				-			('browse full (b)'					browseMethodFull)			('browse hierarchy (h)'				spawnHierarchy)			('browse method (O)'				openSingleMessageBrowser)			('browse protocol (p)'				browseFullProtocol)			-			('fileOut'							fileOutMessage)			-			('senders of... (n)'					browseSendersOfMessages)			('implementors of... (m)'				browseMessages)			('inheritance (i)'					methodHierarchy)			('versions (v)'						browseVersions)			-			('more...'							shiftedYellowButtonActivity)).	^ aMenu! !!ChangeSetBrowser methodsFor: 'menu' stamp: 'jmv 11/27/2008 12:40'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	aMenu title: 'Change set (shifted)'.		aMenu addStayUpItemSpecial.	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	aMenu addLine.	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	aMenu add: 'check for uncommented classes' action: #checkForUncommentedClasses.	aMenu balloonTextForLastItem:'Check for classes with code in this changeset which lack class comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'.		aMenu add: 'check for any other authors' action: #checkForAnyAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods any of whose previous authoring stamps do not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'jmv 11/27/2008 16:05'!unload
	"Unload the receiver from global registries"

	Smalltalk at: #FileList ifPresent: [:cl |
	cl unregisterFileReader: self]! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:24'!fileIntoNewChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fn ff |	fullName ifNil: [^ Beeper beep].	ff _ FileStream readOnlyFileNamed: (fn _ GZipReadStream uncompressedFileName: fullName).	self newChangesFromStream: ff named: (FileDirectory localNameFor: fn)! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'jmv 11/27/2008 15:22'!systemCatSingletonMenu: aMenu	^ aMenu labels:'find class... (f)browsefileOutupdaterename...remove' 	lines: #(1 3)	selections:		#(findClass buildSystemCategoryBrowser		fileOutSystemCategory updateSystemCategories		renameSystemCategory removeSystemCategory )! !!MessageSet methodsFor: 'filtering' stamp: 'jmv 11/27/2008 12:43'!filterMessageList
	"Allow the user to refine the list of messages."

	| aMenu evt |
	messageList size <= 1 
		ifTrue: [^self inform: 'this is not a propitious filtering situation'].

	"would like to get the evt coming in but thwarted by the setInvokingView: circumlocution"
	evt := self currentWorld activeHand lastEvent.
	aMenu := OldMenuMorph new defaultTarget: self.
	aMenu addTitle: 'Filter by only showing...'.
	aMenu addStayUpItem.
	aMenu 
		addList: #(#('unsent messages' #filterToUnsentMessages 'filter to show only messages that have no senders') #- #('messages that send...' #filterToSendersOf 'filter to show only messages that send a selector I specify') #('messages that do not send...' #filterToNotSendersOf 'filter to show only messages that do not send a selector I specify') #- #('messages whose selector is...' #filterToImplementorsOf 'filter to show only messages with a given selector I specify') #('messages whose selector is NOT...' #filterToNotImplementorsOf 'filter to show only messages whose selector is NOT a seletor I specify') #- #('messages in current change set' #filterToCurrentChangeSet 'filter to show only messages that are in the current change set') #('messages not in current change set' #filterToNotCurrentChangeSet 'filter to show only messages that are not in the current change set') #- #('messages in any change set' #filterToAnyChangeSet 'filter to show only messages that occur in at least one change set') #('messages not in any change set' #filterToNotAnyChangeSet 'filter to show only messages that do not occur in any change set in the system') #- #('messages authored by me' #filterToCurrentAuthor 'filter to show only messages whose authoring stamp has my initials') #('messages not authored by me' #filterToNotCurrentAuthor 'filter to show only messages whose authoring stamp does not have my initials') #- #('messages logged in .changes file' #filterToMessagesInChangesFile 'filter to show only messages whose latest source code is logged in the .changes file') #('messages only in .sources file' #filterToMessagesInSourcesFile 'filter to show only messages whose latest source code is logged in the .sources file') #- #('messages with prior versions' #filterToMessagesWithPriorVersions 'filter to show only messages that have at least one prior version') #('messages without prior versions' #filterToMessagesWithoutPriorVersions 'filter to show only messages that have no prior versions') #- #('uncommented messages' #filterToUncommentedMethods 'filter to show only messages that do not have comments at the beginning') #('commented messages' #filterToCommentedMethods 'fileter to show only messages that have comments at the beginning') #- #('messages that...' #filterToMessagesThat 'let me type in a block taking a class and a selector, which will specify yea or nay concerning which elements should remain in the list')).
	aMenu popUpEvent: evt hand lastEvent in: evt hand world! !!MessageNames class methodsFor: 'class initialization' stamp: 'jmv 11/27/2008 16:07'!unload
	"Unload the receiver from global registries"

	Smalltalk at: #FileList ifPresent: [:cl |
	cl unregisterFileReader: self]! !!RecentMessageSet methodsFor: 'message functions' stamp: 'jmv 11/27/2008 15:27'!messageListMenu: aMenu shifted: shifted	"Answer the message-list menu"	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList:#(			('what to show...'						offerWhatToShowMenu)			-			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('copy selector (c)'						copySelector)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			('remove from RecentSubmissions'		removeFromRecentSubmissions)			-			('more...'								shiftedYellowButtonActivity)).	^ aMenu! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 11/27/2008 15:37'!condenseChanges		"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges"	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f.			class putClassCommentToCondensedChangesFile: f.			class class moveChangesTo: f]].	LastQuitLogPosition _ f position.	f close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (StandardFileStream oldFileNamed: oldChanges name)! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 11/27/2008 15:37'!condenseSources		"Move all the changes onto a compacted sources file."	"Smalltalk condenseSources"	| f classCount dir newVersionString |	Utilities fixUpProblemsWithAllCategory.	"The above removes any concrete, spurious '-- all --' categories, which mess up the process."	dir _ FileDirectory default.	newVersionString _ FillInTheBlank request: 'Please designate the versionfor the new source code file...' initialAnswer: SourceFileVersionString.	newVersionString ifNil: [^ self].	newVersionString = SourceFileVersionString ifTrue:		[^ self error: 'The new source file must not be the same as the old.'].	SourceFileVersionString _ newVersionString.	"Write all sources with fileIndex 1"	f _ FileStream newFileNamed: self sourcesName.	f timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f close.	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self changesName		toBe: self changesName , '.old'.	(FileStream newFileNamed: self changesName)		timeStamp; close.	LastQuitLogPosition _ 0.	self setMacFileInfoOn: self changesName.	self setMacFileInfoOn: self sourcesName.	self openSourceFiles.	self inform: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 11/27/2008 15:29'!discardOddsAndEnds	"This method throws out lots of classes that are not frequently used."	"Smalltalk discardOddsAndEnds"	SystemOrganization removeSystemCategory: 'System-Serial Port'.	SystemOrganization removeSystemCategory: 'ST80-Symbols'.	SystemOrganization removeSystemCategory: 'Tools-File Contents Browser'.	SystemOrganization removeSystemCategory: 'System-Compression'.	SystemOrganization removeSystemCategory: 'Tools-Explorer'.	SystemOrganization removeSystemCategory: 'System-Digital Signatures'.	Form removeSelector: #edit.	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'ST80-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SystemMonitor.	Smalltalk removeClassNamed: #DocLibrary.	Smalltalk removeClassNamed: #ProtocolBrowser.	Smalltalk removeClassNamed: #ObjectExplorerWrapper.	Smalltalk removeClassNamed: #HierarchyBrowser.	Smalltalk removeClassNamed: #LinkedMessageSet.	Smalltalk removeClassNamed: #ObjectExplorer.	Smalltalk removeClassNamed: #PackageBrowser.	Smalltalk removeClassNamed: #AbstractHierarchicalList.	Smalltalk removeClassNamed: #ChangeList.	Smalltalk removeClassNamed: #VersionsBrowser.	Smalltalk removeClassNamed: #ChangeRecord.	Smalltalk removeClassNamed: #SelectorBrowser.	Smalltalk removeClassNamed: #CrLfFileStream.	Smalltalk removeClassNamed: #FXGrafPort.	Smalltalk removeClassNamed: #FXBlt.	Smalltalk at: #SampledSound ifPresent: [:c |c initialize].	#(Helvetica Palatino Courier ComicBold ComicPlain) do:		[:k | TextConstants removeKey: k ifAbsent: []].Preferences setButtonFontTo:	(StrikeFont familyName: #NewYork size: 12).Preferences setFlapsFontTo:	(StrikeFont familyName: #NewYork size: 12).#(GZipConstants ZipConstants KlattResonatorIndices ) do:	[:k | Smalltalk removeKey: k ifAbsent: []].! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'jmv 11/27/2008 15:23'!fileOutCategory: category	"FileOut all the classes in the named system category."	| fileStream |	fileStream _ FileStream newFileNamed: category asFileName , '.st'.	self fileOutCategory: category on: fileStream initializing: true.	fileStream close! !UndefinedObject removeSelector: #environment!Text removeSelector: #basicType!SystemOrganizer removeSelector: #fileOutCategory:asHtml:!MessageSet removeSelector: #filterToMessagesWithHardenedClasses!ChangeSorter removeSelector: #expungeUniclasses!Browser removeSelector: #printOutClass!Browser removeSelector: #printOutMessageCategories!Browser removeSelector: #printOutSystemCategory!StringHolder removeSelector: #printOutMessage!String removeSelector: #asHtml!String removeSelector: #basicType!CrLfFileStream removeSelector: #verbatim:!StandardFileStream removeSelector: #asHtml!StandardFileStream removeSelector: #verbatim:!SmartRefStream removeSelector: #appendClassDefns!SmartRefStream removeSelector: #restoreClassInstVars!SmartRefStream removeSelector: #saveClassInstVars!SmartRefStream removeSelector: #uniClassInstVarsRefs:!!classDefinition: #SmartRefStream category: #'System-Object Storage'!ReferenceStream subclass: #SmartRefStream	instanceVariableNames: 'structures steady renamed renamedConv superclasses progressBar objCount'	classVariableNames: 'ScannedObject'	poolDictionaries: ''	category: 'System-Object Storage'!PositionableStream removeSelector: #command:!PositionableStream removeSelector: #header!PositionableStream removeSelector: #trailer!PositionableStream removeSelector: #verbatim:!Point removeSelector: #basicType!OldTextMorph removeSelector: #basicType!OldTextMorph removeSelector: #insertContentsOf:!OldSketchMorph removeSelector: #basicType!OldMenuItemMorph removeSelector: #doButtonAction!OldImageMorph removeSelector: #basicType!OldMorph removeSelector: #doButtonAction!FormsAndHelpsRepository initialize!Object class removeSelector: #categoryForUniclasses!Object class removeSelector: #chooseUniqueClassName!Object class removeSelector: #instanceOfUniqueClass!Object class removeSelector: #instanceOfUniqueClassWithInstVarString:andClassInstVarString:!Object class removeSelector: #isUniClass!Object class removeSelector: #newUniqueClassInstVars:classInstVars:!Number removeSelector: #basicType!Metaclass removeSelector: #environment!ImageSegment removeSelector: #copyFromRootsLocalFileFor:sizeHint:!ImageSegment removeSelector: #rootsIncludingPlayers!GZipSurrogateStream removeSelector: #command:!GZipSurrogateStream removeSelector: #header!GZipSurrogateStream removeSelector: #trailer!EventHandler removeSelector: #forgetDispatchesTo:!DeepCopier removeSelector: #newUniClasses!DeepCopier removeSelector: #newUniClasses:!DeepCopier removeSelector: #uniClasses!!classDefinition: #DeepCopier category: #'System-Object Storage'!Object subclass: #DeepCopier	instanceVariableNames: 'references'	classVariableNames: 'NextVariableCheckTime'	poolDictionaries: ''	category: 'System-Object Storage'!Color removeSelector: #basicType!Class removeSelector: #environment!Class removeSelector: #environment:!Class removeSelector: #fileOutAsHtml:!Class removeSelector: #newSubclass!!classDefinition: #Class category: #'Kernel-Classes'!ClassDescription subclass: #Class	instanceVariableNames: 'subclasses name classPool sharedPools category'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!Class reorganize!('initialize-release' deactivate declare: obsolete removeFromSystem removeFromSystem: removeFromSystemUnlogged sharing: superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools: superclass:methodDictionary:format: unload)('accessing' classPool classPoolFrom: name)('testing' hasMethods isObsolete)('copying' copy)('class name' externalName rename:)('instance variables' addInstVarName: removeInstVarName:)('class variables' addClassVarName: allClassVarNames classVarNames ensureClassPool removeClassVarName:)('pool variables' addSharedPool: allSharedPools removeSharedPool: sharedPools)('compiling' bindingOf: canFindWithoutEnvironment: compileAll compileAllFrom: possibleVariablesFor:continuedFrom:)('subclass creation' subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: weakSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:)('fileIn/Out' fileOut fileOutInitializerOn: fileOutOn:moveSource:toFile: fileOutOn:moveSource:toFile:initializing: fileOutPool:onFileStream: fileOutSharedPoolsOn: objectForDataStream: reformatAll removeFromChanges shouldFileOutPool: shouldFileOutPools storeDataOn:)('accessing class hierarchy' addSubclass: removeSubclass: subclasses subclassesDo: subclassesDoGently:)('private' setName: spaceUsed)('*sunit-preload' sunitName)!ClassDescription removeSelector: #fileOutCategory:asHtml:!ClassDescription removeSelector: #fileOutMethod:asHtml:!ClassDescription removeSelector: #isUniClass!ClassBuilder removeSelector: #name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:!ClassBuilder removeSelector: #name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:unsafe:!!classDefinition: #ClassBuilder category: #'Kernel-Classes'!Object subclass: #ClassBuilder	instanceVariableNames: 'instVarMap progress maxClassIndex currentClassIndex'	classVariableNames: 'QuietMode'	poolDictionaries: ''	category: 'Kernel-Classes'!ChangeSet removeSelector: #expungeUniclasses!Boolean removeSelector: #basicType!Behavior removeSelector: #environment!Object removeSelector: #basicType!Object removeSelector: #veryDeepCopySibling!Smalltalk removeClassNamed: #HtmlFileStream!Smalltalk removeClassNamed: #ObjectScanner!