'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 28 December 2010 at 11:59:46 am'!!ConnectionQueue methodsFor: 'public' stamp: 'nice 12/26/2009 01:23'!connectionCount	"Return an estimate of the number of currently queued connections. This is only an estimate since a new connection could be made, or an existing one aborted, at any moment."	self pruneStaleConnections.	^accessSema critical: [connections size]! !!ConnectionQueue methodsFor: 'public' stamp: 'nice 12/26/2009 01:24'!getConnectionOrNil	"Return a connected socket, or nil if no connection has been established."	^accessSema critical: [		| result |		connections isEmpty			ifTrue: [result := nil]			ifFalse: [				result := connections removeFirst.				((result isValid) and: [result isConnected]) ifFalse: [  "stale connection"					result destroy.					result := nil]].		result]! !!ConnectionQueue methodsFor: 'public' stamp: 'nice 12/26/2009 01:25'!getConnectionOrNilLenient	"Return a connected socket, or nil if no connection has been established."	^accessSema critical: [		| result |		connections isEmpty ifTrue: [			result := nil		] ifFalse: [			result := connections removeFirst.			(result isValid and: [result isConnected or: [result isOtherEndClosed]]) ifFalse: [				"stale connection"				result destroy.				result := nil			]		].		result	].! !!ConnectionQueue methodsFor: 'private' stamp: 'ul 11/25/2010 21:27'!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	| newConnection |	socket := Socket newTCP.	"We'll accept four simultanous connections at the same time"	socket listenOn: portNumber backlogSize: 4.	"If the listener is not valid then the we cannot use the	BSD style accept() mechanism."	socket isValid ifFalse: [^self oldStyleListenLoop].	[true] whileTrue: [		socket isValid ifFalse: [			"socket has stopped listening for some reason"			socket destroy.			(Delay forMilliseconds: 10) wait.			^self listenLoop ].		newConnection := socket 			waitForAcceptFor: 10			ifTimedOut: [ nil ].		(newConnection notNil and: [newConnection isConnected]) ifTrue: [			accessSema critical: [connections addLast: newConnection.].			newConnection := nil.			self changed].		self pruneStaleConnections]. ! !!ConnectionQueue methodsFor: 'private' stamp: 'ul 11/25/2010 21:20'!oldStyleListenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	[true] whileTrue: [		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [			"try to create a new socket for listening"			socket := Socket createIfFail: [nil]].		socket == nil			ifTrue: [(Delay forMilliseconds: 100) wait]			ifFalse: [				socket isUnconnected ifTrue: [socket listenOn: portNumber].				socket 					waitForConnectionFor: 10					ifTimedOut: [						socket isConnected							ifTrue: [  "connection established"								accessSema critical: [connections addLast: socket].								socket := nil]							ifFalse: [								socket isWaitingForConnection									ifFalse: [socket destroy. socket := nil]]]].  "broken socket; start over"		self pruneStaleConnections].! !!ConnectionQueue methodsFor: 'private' stamp: 'nice 12/26/2009 01:25'!pruneStaleConnections	"Private!! The client may establish a connection and then disconnect while it is still in the connection queue. This method is called periodically to prune such sockets out of the connection queue and make room for fresh connections."	accessSema critical: [		| foundStaleConnection |		foundStaleConnection := false.		connections do: [:s |			s isUnconnected ifTrue: [				s destroy.				foundStaleConnection := true]].		foundStaleConnection ifTrue: [			connections := connections select: [:s | s isValid]]].! !!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21'!localAddress	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [ ^ByteArray new: 4 ] ].	^self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21'!localPort	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [ ^0] ].	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'connection open/close' stamp: 'marcus.denker 9/14/2008 21:20'!closeAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle ifNotNil: [			self isConnected ifTrue: [				self close.  "close this end"				(self waitForDisconnectionFor: timeoutSeconds) ifFalse: [						"The other end didn't close so we just abort the connection"						self primSocketAbortConnection: socketHandle]].			self destroy].! !!Socket methodsFor: 'waiting' stamp: 'dc 10/21/2008 08:19'!waitForAcceptFor: timeout	"Wait and accept an incoming connection. Return nil if it falis"	self waitForConnectionFor: timeout ifTimedOut: [^ nil].	^ self isConnected		ifTrue:[self accept]		! !!Socket methodsFor: 'waiting' stamp: 'nice 4/28/2009 21:26'!waitForConnectionFor: timeout ifTimedOut: timeoutBlock	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| startTime msecsDelta msecsEllapsed status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]		whileTrue: [			semaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed.			status := self primSocketConnectionStatus: socketHandle].	status = Connected ifFalse: [^timeoutBlock value].	^ true! !!Socket methodsFor: 'waiting' stamp: 'nice 4/29/2009 21:25'!waitForDataFor: timeout ifClosed: closedBlock ifTimedOut: timedOutBlock	"Wait for the given nr of seconds for data to arrive."		| startTime msecsDelta |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(Time millisecondsSince: startTime) < msecsDelta] whileTrue: [		(self primSocketReceiveDataAvailable: socketHandle)			ifTrue: [^self].		self isConnected			ifFalse: [^closedBlock value].		self readSemaphore waitTimeoutMSecs: 			(msecsDelta - (Time millisecondsSince: startTime) max: 0).	].	(self primSocketReceiveDataAvailable: socketHandle)		ifFalse: [			self isConnected				ifTrue: [^timedOutBlock value]				ifFalse: [^closedBlock value]].! !!Socket methodsFor: 'waiting' stamp: 'nice 4/28/2009 21:20'!waitForDisconnectionFor: timeout	"Wait for the given nr of seconds for the connection to be broken.	Return true if it is broken by the deadline, false if not.	The client should know the connection is really going to be closed	(e.g., because he has called 'close' to send a close request to the other end)	before calling this method."	| startTime msecsDelta status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	[((status == Connected) or: [(status == ThisEndClosed)]) and:	 [(Time millisecondsSince: startTime) < msecsDelta]] whileTrue: [		self discardReceivedData.		self readSemaphore waitTimeoutMSecs: 			(msecsDelta - (Time millisecondsSince: startTime) max: 0).		status := self primSocketConnectionStatus: socketHandle].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'Pmm 11/20/2010 23:47'!waitForSendDoneFor: timeout	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| startTime msecsDelta msecsEllapsed sendDone |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(sendDone := self primSocketSendDone: socketHandle) not and: [ self isConnected			"Connection end and final data can happen fast, so test in this order"		and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed].	^ sendDone! !!Socket class methodsFor: 'utilities' stamp: 'ul 11/25/2010 21:34'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.org' timeOutSecs: 15"	| serverAddr sockets startTime timeoutMsecs done result unconnectedCount connectedCount waitingCount |	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr ifNil: [ 			self inform: 'Could not find an address for ' , hostName.			^ #() ].	sockets := portList		collect: [ :portNum | 			| sock |			sock := Socket new.			[ sock connectTo: serverAddr port: portNum ] 				on: ConnectionTimedOut				do: [ ].			sock ].	startTime := Time millisecondClockValue.	timeoutMsecs := (1000 * timeOutSecs) truncated.	done := false.	[ done ]		whileFalse: [ 			unconnectedCount := 0.			connectedCount := 0.			waitingCount := 0.			sockets				do: [ :s | 					s isUnconnectedOrInvalid						ifTrue: [ unconnectedCount := unconnectedCount + 1 ]						ifFalse: [ 							s isConnected								ifTrue: [ connectedCount := connectedCount + 1 ].							s isWaitingForConnection								ifTrue: [ waitingCount := waitingCount + 1 ] ] ].			waitingCount = 0				ifTrue: [ done := true ].			connectedCount = sockets size				ifTrue: [ done := true ].			(Time millisecondsSince: startTime) >= timeoutMsecs				ifTrue: [ done := true ] ].	result := (sockets select: [ :s | s isConnected ]) collect: [ :s | self nameForWellKnownTCPPort: s remotePort ].	sockets do: [ :s | s destroy ].	^ result! !Socket class removeSelector: #deadlineSecs:!Socket class removeSelector: #standardDeadline!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Socket initialize!