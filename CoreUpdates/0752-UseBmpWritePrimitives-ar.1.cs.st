'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 13 January 2011 at 4:37:06 pm'!!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:48'!read24BmpFile	"Read 24-bit pixel data from the given a BMP stream."	| form formBits pixelLine bitsIndex bitBlt |	form := Form extent: biWidth@biHeight depth: 32.	pixelLine := ByteArray new: (((24 * biWidth) + 31) // 32) * 4.	bitsIndex := form height - 1 * biWidth + 1.	formBits := form bits.	1 to: biHeight do: [:i |		pixelLine := stream nextInto: pixelLine.		self read24BmpLine: pixelLine into: formBits startingAt: bitsIndex width: biWidth.		bitsIndex := bitsIndex - biWidth.	].	bitBlt := BitBlt toForm: form.	bitBlt combinationRule: 7 "bitOr:with:".	bitBlt halftoneForm: (Bitmap with: 16rFF000000).	bitBlt copyBits.	^ form! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 12/21/2010 20:11'!read24BmpLine: pixelLine into: formBits startingAt: formBitsIndex width: width	"Swizzles the bytes in a 24bpp scanline and fills in the given 32bpp form bits.	Ensures that color black is represented as 16rFF000001 so that Form paint	works properly."	| pixIndex rgb bitsIndex |	<primitive: 'primitiveRead24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := 			(pixelLine at: (pixIndex := pixIndex+1)) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 8) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 16).		rgb = 0 ifTrue:[rgb := 16rFF000001] ifFalse:[rgb := rgb + 16rFF000000].		formBits at: (bitsIndex := bitsIndex+1) put: rgb.	].! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57'!readColorMap	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."	| colorCount colors maxLevel b g r ccStream |	colorCount := (bfOffBits - 54) // 4.	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"	biBitCount >= 16 ifTrue:[^nil].	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"		"default monochrome color map"		biBitCount = 1 ifTrue: [^ Array with: Color white with: Color black].		"default gray-scale color map"		maxLevel := (2 raisedTo: biBitCount) - 1.		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].	ccStream := ReadStream on: (stream next: colorCount*4).	colors := Array new: colorCount.	1 to: colorCount do: [:i |		b := ccStream next.		g := ccStream next.		r := ccStream next.		ccStream next. "skip reserved"		colors at: i put: (Color r: r g: g b: b range: 255)].	^ colors! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:45'!readIndexedBmpFile: colors	"Read uncompressed pixel data of depth d from the given BMP stream, where d is 1, 4, 8, or 16"	| form bytesPerRow pixelData pixelLine startIndex map bitBlt mask |	colors 		ifNil:[form := Form extent: biWidth@biHeight depth: biBitCount]		ifNotNil:[form := ColorForm extent: biWidth@biHeight depth: biBitCount.				form colors: colors].	bytesPerRow := (((biBitCount* biWidth) + 31) // 32) * 4.	pixelData := ByteArray new: bytesPerRow * biHeight.	biHeight to: 1 by: -1 do: [:y |		pixelLine := stream next: bytesPerRow.		startIndex := ((y - 1) * bytesPerRow) + 1.		pixelData 			replaceFrom: startIndex 			to: startIndex + bytesPerRow - 1 			with: pixelLine 			startingAt: 1].	form bits copyFromByteArray: pixelData.	biBitCount = 16 ifTrue:[		map := ColorMap shifts: #(8 -8 0 0) masks: #(16rFF 16rFF00 0 0).		mask := 16r80008000.	].	biBitCount = 32 ifTrue:[		map := ColorMap shifts: #(24 8 -8 -24) masks: #(16rFF 16rFF00 16rFF0000 16rFF000000).		mask := 16rFF000000.	].	map ifNotNil:[		bitBlt := BitBlt toForm: form.		bitBlt sourceForm: form.		bitBlt colorMap: map.		bitBlt combinationRule: Form over.		bitBlt copyBits.	].	mask ifNotNil:[		bitBlt := BitBlt toForm: form.		bitBlt combinationRule: 7 "bitOr:with:".		bitBlt halftoneForm: (Bitmap with: mask).		bitBlt copyBits.	].	^ form! !!BMPReadWriter methodsFor: 'writing' stamp: 'ar 12/21/2010 20:03'!nextPutImage: aForm	| bhSize rowBytes rgb data colorValues depth image ppw scanLineLen pixline |	depth := aForm depth.	depth := #(1 4 8 32 ) detect: [ :each | each >= depth].	image := aForm asFormOfDepth: depth.	image unhibernate.	bhSize := 14.  "# bytes in file header"	biSize := 40.  "info header size in bytes"	biWidth := image width.	biHeight := image height.	biClrUsed := depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"	bfOffBits := biSize + bhSize + (4*biClrUsed).	rowBytes := ((depth min: 24) * biWidth + 31 // 32) * 4.	biSizeImage := biHeight * rowBytes.	"Write the file header"	stream position: 0.	stream nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"	stream nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	stream nextLittleEndianNumber: 4 put: 0.  "bfReserved"	stream nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	stream position: bhSize.	stream nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"	stream nextLittleEndianNumber: 4 put: image width.  "biWidth"	stream nextLittleEndianNumber: 4 put: image height.  "biHeight"	stream nextLittleEndianNumber: 2 put: 1.  "biPlanes"	stream nextLittleEndianNumber: 2 put: (depth min: 24).  "biBitCount"	stream nextLittleEndianNumber: 4 put: 0.  "biCompression"	stream nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	stream nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"	stream nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"	stream nextLittleEndianNumber: 4 put: biClrUsed.	stream nextLittleEndianNumber: 4 put: 0.  "biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues := image colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb := colorValues at: i.			0 to: 24 by: 8 do: [:j | stream nextPut: (rgb >> j bitAnd: 16rFF)]]].	depth < 32 ifTrue: [		"depth = 1, 4 or 8."		data := image bits asByteArray.		ppw := 32 // depth.		scanLineLen := biWidth + ppw - 1 // ppw * 4.  "# of bytes in line"		1 to: biHeight do: [:i |			stream next: scanLineLen putAll: data startingAt: (biHeight-i)*scanLineLen+1.		].	] ifFalse: [		data := image bits.		pixline := ByteArray new: (((biWidth * 3 + 3) // 4) * 4).		1 to: biHeight do:[:i |			self store24BitBmpLine: pixline from: data startingAt: (biHeight-i)*biWidth+1 width: biWidth.			stream nextPutAll: pixline.		].	].	stream position = (bfOffBits + biSizeImage) ifFalse: [self error:'Write failure'].	stream close.! !!BMPReadWriter methodsFor: 'writing' stamp: 'ar 12/21/2010 20:12'!store24BitBmpLine: pixelLine from: formBits startingAt: formBitsIndex width: width	"Stores a single scanline containing 32bpp RGBA values in a 24bpp scanline.	Swizzles the bytes as needed."	| pixIndex rgb bitsIndex |	<primitive: 'primitiveWrite24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := (formBits at: (bitsIndex := bitsIndex+1)) bitAnd: 16rFFFFFF.		pixelLine at: (pixIndex := pixIndex+1) put: (rgb bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -8) bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -16) bitAnd: 255).	].! !!BMPReadWriter class methodsFor: 'testing' stamp: 'ar 6/16/2002 18:55'!displayAllFrom: fd	"BMPReadWriter displayAllFrom: FileDirectory default"	fd fileNames do:[:fName|		(fName endsWith: '.bmp') ifTrue:[			[(Form fromBinaryStream: (fd readOnlyFileNamed: fName)) display.			Display forceDisplayUpdate] on: Error do:[:nix|].		].	].	fd directoryNames do:[:fdName|		self displayAllFrom: (fd directoryNamed: fdName)	].! !!BMPReadWriter class methodsFor: 'testing' stamp: 'ar 6/16/2002 18:56'!readAllFrom: fd	"MessageTally spyOn:[BMPReadWriter readAllFrom: FileDirectory default]"	fd fileNames do:[:fName|		(fName endsWith: '.bmp') ifTrue:[			[Form fromBinaryStream: (fd readOnlyFileNamed: fName)] on: Error do:[:nix].		].	].	fd directoryNames do:[:fdName|		self readAllFrom: (fd directoryNamed: fdName)	].! !