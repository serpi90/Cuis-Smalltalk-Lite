'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 2 December 2010 at 11:17:35 am'!!Editor commentStamp: '<historical>' prior: 0!New text editors.TextEditor provides most of the functionality that used to be in TextMorphEditor.SmalltalkEditor is has Smalltalk code specific features.SimpleEditor provides basic functionality for single line text editing. It does not handle fonts and styles, aligning and Smalltalk utilities. It handles one single line.CellStyleEditor allows entering alphabetic characters using only number keys, like many cell phones do.!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector getLabelSelector getMenuSelector arguments argumentsProvider argumentsSelector isPressed mouseIsOver '	classVariableNames: 'ButtonGradient ButtonGradientPressed RoundedCornerBL RoundedCornerBLPressed RoundedCornerBR RoundedCornerBRPressed RoundedCornerTL RoundedCornerTLPressed RoundedCornerTR RoundedCornerTRPressed '	poolDictionaries: ''	category: 'Morphic-Windows'!!classDefinition: #ScrollPane category: #'Morphic-Windows'!PluggableMorph subclass: #ScrollPane	instanceVariableNames: 'scrollBar scroller getMenuSelector getMenuTitleSelector hScrollBar hideScrollBars currentScrollRange drawKeyboardFocusIndicator '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!classDefinition: #PluggableListMorph category: #'Morphic-Windows'!ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list getListSelector getListSizeSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector handlesBasicKeys potentialDropRow listMorph menuGetter '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!classDefinition: #SimpleHierarchicalListMorph category: #'Tools-Explorer'!ScrollPane subclass: #SimpleHierarchicalListMorph	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect columns sortingSelector getSelectionSelector setSelectionSelector potentialDropMorph lineColor menuGetter '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!!classDefinition: #FileContentsEditor category: #'Tools-FileList'!SmalltalkEditor subclass: #FileContentsEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!!Array methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #Array or: [ super is: aSymbol ]! !!Color methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #Color or: [ super is: aSymbol ]! !!CompiledMethod methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #CompiledMethod or: [ super is: aSymbol ]! !!Conformist methodsFor: 'colors' stamp: 'jmv 12/2/2010 08:28'!paneBackgroundFrom: aColor	^ aColor alphaMixed: 0.7 with: Color black! !!FixedLayoutSpec methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #LayoutSpec or: [ super is: aSymbol ]! !!FloatArray methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #FloatArray or: [ super is: aSymbol ]! !!Form methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:36'!is: aSymbol	^ aSymbol == #Form or: [ super is: aSymbol ]! !!ColorForm methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:36'!is: aSymbol	^ aSymbol == #ColorForm or: [ super is: aSymbol ]! !!Cursor methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:36'!is: aSymbol	^ aSymbol == #Cursor or: [ super is: aSymbol ]! !!LayoutFrame methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:36'!is: aSymbol	^ aSymbol == #LayoutFrame or: [ super is: aSymbol ]! !!Matrix methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #Matrix or: [ super is: aSymbol ]! !!MessageSend methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:36'!is: aSymbol	^ aSymbol == #MessageSend or: [ super is: aSymbol ]! !!Morph methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #Morph or: [ super is: aSymbol ]! !!BareTextMorph methodsFor: 'classification' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #TextMorph or: [ super is: aSymbol ]! !!BorderedMorph methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #BorderedMorph or: [ super is: aSymbol ]! !!AlignmentMorph methodsFor: 'classification' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #AlignmentMorph or: [ super is: aSymbol ]! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2010 11:00'!createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean	"create the textPane"	| result frame |	result := PluggableTextMorph				model: self				textGetter: #response				textSetter: #response:				selectionGetter: #selectionInterval.	result extent: answerExtent.	result borderWidth: 1.	result hasUnacceptedEdits: true.	result acceptOnCR: acceptBoolean.	frame := LayoutFrame new.	frame leftFraction: 0.0;		 rightFraction: 1.0;		 topFraction: 0.2;		 bottomFraction: 0.7.	result layoutFrame: frame.	self addMorph: result.	^ result! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2010 11:00'!editorClass	^TextEditor! !!HandMorph methodsFor: 'classification' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #HandMorph or: [ super is: aSymbol ]! !!MorphicEvent methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #MorphicEvent or: [ super is: aSymbol ]! !!ObjectExplorer methodsFor: 'accessing' stamp: 'jmv 12/2/2010 11:01'!explorerFor: anObject 	| window listMorph |	rootObject := anObject.	window := (SystemWindow labelled: (rootObject printStringLimitedTo: 64)) model: self.	window addMorph: (listMorph := SimpleHierarchicalListMorph 						model: self						listGetter: #getList						indexGetter: #getCurrentSelection						indexSetter: #noteNewSelection:						menuGetter: #genericMenu:						keystrokeAction: #explorerKey:from:)		frame: (0 @ 0 corner: 1 @ 0.8).	window 		addMorph: ((PluggableTextMorph 				model: self				textGetter: nil				textSetter: nil				selectionGetter: nil) askBeforeDiscardingEdits: false)		frame: (0 @ 0.8 corner: 1 @ 1).	listMorph autoDeselect: false.	^window! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 12/2/2010 10:41'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed. If the button's actionSelector takes any arguments, they are obtained dynamically by sending the argumentSelector to the argumentsProvider"	actionSelector ifNotNil: [		actionSelector numArgs = 0			ifTrue: [ model perform: actionSelector ]			ifFalse: [ model perform: actionSelector withArguments: arguments ]]! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'jmv 12/2/2010 10:41'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model _ model.		Weakly copied""getStateSelector _ getStateSelector.		a Symbol""actionSelector _ actionSelector.		a Symbol""getLabelSelector _ getLabelSelector.		a Symbol""getMenuSelector _ getMenuSelector.		a Symbol"arguments _ arguments veryDeepCopyWith: deepCopier.isPressed _ isPressed.mouseIsOver _ mouseIsOver! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2010 10:46'!initialize	"initialize the state of the receiver"	super initialize.	model _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	isPressed _ false.	mouseIsOver _ false.	self extent: 20 @ 15! !!PluggableButtonMorph methodsFor: 'initialize-release' stamp: 'jmv 12/2/2010 10:45'!model: anObject stateGetter: getStateSel action: actionSel labelOrGetter: labelSelOrString	self model: anObject.	getStateSelector _ getStateSel.	actionSelector _ actionSel.	labelSelOrString isSymbol ifTrue: [		getLabelSelector _ labelSelOrString.		self update: labelSelOrString ]	ifFalse: [		self label: labelSelOrString ]! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 12/2/2010 10:47'!yellowButtonActivity: shiftKeyState	"Nothing to do right now..."! !!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jmv 12/2/2010 10:46'!model: anObject stateGetter: getStateSel action: actionSel	^ self new		model: anObject		stateGetter: getStateSel		action: actionSel		labelOrGetter: nil! !!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jmv 12/2/2010 10:45'!model: anObject stateGetter: getStateSel action: actionSel labelOrGetter: labelSelOrString	^ self new		model: anObject		stateGetter: getStateSel		action: actionSel		labelOrGetter: labelSelOrString! !!ProcessBrowser methodsFor: 'views' stamp: 'jmv 12/2/2010 11:02'!asPrototypeInWindow	"Create a pluggable version of me, answer a window"	| window aTextMorph |	window _ SystemWindow new model: self.	window		addMorph: ((PluggableListMorph				model: self				listGetter: #processNameList				indexGetter: #processListIndex				indexSetter: #processListIndex:				menuGetter: #processListMenu:				keystrokeAction: #processListKey:from:)				enableDragNDrop: false)		frame: (0 @ 0 extent: 0.5 @ 0.5).	window		addMorph: ((PluggableListMorph				model: self				listGetter: #stackNameList				indexGetter: #stackListIndex				indexSetter: #stackListIndex:				menuGetter: #stackListMenu:				keystrokeAction: #stackListKey:from:)				enableDragNDrop: false)		frame: (0.5 @ 0.0 extent: 0.5 @ 0.5).	aTextMorph _ PluggableTextMorph				model: self				textGetter: #selectedMethod				textSetter: nil				selectionGetter: nil.	window		addMorph: aTextMorph		frame: (0 @ 0.5 corner: 1 @ 1).	window setLabel: 'Process Browser'.	^ window! !!ProcessBrowser methodsFor: 'views' stamp: 'jmv 12/2/2010 11:01'!editorClass	^TextEditor! !!ProcessBrowser methodsFor: 'views' stamp: 'jmv 12/2/2010 11:02'!openAsMorph	"Create a pluggable version of me, answer a window"	| window aTextMorph |	window _ SystemWindow new				model: self.	deferredMessageRecipient _ WorldState.	window		addMorph: ((PluggableListMorph				model: self				listGetter: #processNameList				indexGetter: #processListIndex				indexSetter: #processListIndex:				menuGetter: #processListMenu:				keystrokeAction: #processListKey:from:)				enableDragNDrop: false)		frame: (0 @ 0 extent: 0.5 @ 0.5).	window		addMorph: ((PluggableListMorph				model: self				listGetter: #stackNameList				indexGetter: #stackListIndex				indexSetter: #stackListIndex:				menuGetter: #stackListMenu:				keystrokeAction: #stackListKey:from:)				enableDragNDrop: false)		frame: (0.5 @ 0.0 extent: 0.5 @ 0.5).	aTextMorph _ PluggableTextMorph				model: self				textGetter: #selectedMethod				textSetter: nil				selectionGetter: nil.	aTextMorph askBeforeDiscardingEdits: false.	window		addMorph: aTextMorph		frame: (0 @ 0.5 corner: 1 @ 1).	window setUpdatablePanesFrom: #(#processNameList #stackNameList ).	(window setLabel: 'Process Browser') openInWorld.	startedCPUWatcher ifTrue: [ self setUpdateCallbackAfter: 7 ].	^ window! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2010 09:49'!model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel menuGetter: getMenuSel keystrokeAction: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self 		borderWidth: 1;		updateList;		selectionIndex: self getCurrentSelectionIndex;		initForKeystrokes! !!PluggableListMorph methodsFor: 'menu' stamp: 'jmv 12/2/2010 09:48'!getMenu: shiftKeyState	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	menuGetter ifNil: [^ nil].	menu _ MenuMorph new defaultTarget: model.	menuGetter numArgs = 1 ifTrue: [		aMenu _ model perform: menuGetter with: menu.		aMenu ifNotNil: [aMenu commandKeyHandler: self ].		^ aMenu ].	menuGetter numArgs = 2 ifTrue: [		aMenu _ model perform: menuGetter with: menu with: shiftKeyState.		aMenu ifNotNil: [aMenu commandKeyHandler: self ].		^ aMenu ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 09:48'!model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel menuGetter: getMenuSel keystrokeAction: keyActionSel rawListGetter: getRawSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	getRawListSelector _ getRawSel.	self updateList.	self selectionIndex: self getCurrentSelectionIndex.	self initForKeystrokes! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'jmv 12/2/2010 08:43'!wantsFrameAdornments	"Answer whether the receiver wishes to have red borders, etc., used to show editing state"	"A 'long-term temporary workaround': a nonmodular, unsavory, but expedient way to get the desired effect, sorry.  Clean up someday."	(model is: #CodeProvider) ifFalse: [ ^false ].	^ (#(annotation searchString infoViewContents) includes: getTextSelector) not! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2010 10:58'!model: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	editorClass _ anObject editorClass.	self model: anObject.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	self borderWidth: 1.	self setText: self getText.	self setSelection: self getSelection.! !!PluggableTextMorph methodsFor: 'menu' stamp: 'jmv 12/2/2010 09:58'!getMenu: shiftKeyState	| menu |	menu _ MenuMorph new defaultTarget: model.	^editorClass paneMenu: menu shifted: shiftKeyState! !!PluggableTextMorph methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #HasTextSelector or: [ super is: aSymbol ]! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 11:03'!model: anObject textGetter: getTextSel textSetter: setTextSel	^ self		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 11:03'!model: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	|styler answer |false ifTrue: [	answer _ TextModelMorph new].	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ anObject respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel.	^answer! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 11:05'!noShoutModel: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	| answer |false ifTrue:[	answer _ TextModelMorph new ].	answer _ self new.	answer		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel.	^answer! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2010 09:48'!model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel menuGetter: getMenuSel keystrokeAction: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.! !!SimpleHierarchicalListMorph methodsFor: 'menu' stamp: 'jmv 12/2/2010 09:48'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	menuGetter ifNil: [^ nil].	menu _ MenuMorph new defaultTarget: model.	menuGetter numArgs = 1 ifTrue: [		^ model perform: menuGetter with: menu ].	menuGetter numArgs = 2 ifTrue: [		^ model perform: menuGetter with: menu with: shiftKeyState ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!Stream methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	"Return true if the receiver responds to the stream protocol (if that's what's asked)"	^ aSymbol == #Stream or: [ super is: aSymbol ]! !!SystemWindow methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #SystemWindow or: [ super is: aSymbol ]! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 12/2/2010 10:57'!buildDetailsText	detailsText _ PluggableTextMorph		model: self		textGetter: #details		textSetter: nil.	detailsText hideScrollBarsIndefinitely.	^detailsText! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 12/2/2010 10:57'!buildPassFailText	passFailText _ PluggableTextMorph		model: self		textGetter: #passFail		textSetter: nil.	passFailText hideScrollBarsIndefinitely.	^ passFailText! !!TestRunner methodsFor: 'menus' stamp: 'jmv 12/2/2010 10:54'!editorClass	^TextEditor! !!Text methodsFor: 'comparing' stamp: 'jmv 12/2/2010 08:36'!is: aSymbol	^ aSymbol == #Text or: [ super is: aSymbol ]! !!SmalltalkEditor methodsFor: 'private' stamp: 'jmv 12/2/2010 08:47'!codeProvider	^ (model is: #hasTextProvider)		ifTrue: [ model textProvider ]		ifFalse: [ model ]! !!TextEditor class methodsFor: 'menu' stamp: 'jmv 12/2/2010 09:56'!paneMenu: aMenu shifted: shifted	| donorMenu |	donorMenu _ shifted		ifTrue: [			self shiftedYellowButtonMenu]		ifFalse: [			self yellowButtonMenu].	aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections.	aMenu addTitle: 'Text Editor'; addStayUpIcons.	^aMenu! !!FileContentsEditor class methodsFor: 'menu' stamp: 'jmv 12/2/2010 10:35'!paneMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| shiftMenu services maybeLine extraLines brevityState fileName theModel |	shifted ifTrue: [		shiftMenu _ self shiftedYellowButtonMenu.		^ aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: shiftMenu selections].	theModel _ aMenu defaultTarget.	fileName _ theModel fileName.	fileName ifNotNil: [		brevityState _ theModel brevityState.		services _ OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue: [			services add: theModel serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse: [			services add: theModel serviceGetHex].		maybeLine _ services size.		(#('st' 'cs') includes: theModel suffixOfSelectedFile) ifTrue: [			services addAll:				(theModel servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines _ OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: theModel fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.				#find}.			{'find again (g)' translated.			#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.			#again}.			{'undo (z)' translated.				#undo}.			#-.			{'copy (c)' translated.				#copySelection}.			{'cut (x)' translated.					#cut}.			{'paste (v)' translated.				#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'do it (d)' translated.				#doIt}.			{'print it (p)' translated.				#printIt}.			{'inspect it (i)' translated.			#inspectIt}.			{'fileIn selection (G)' translated.		#fileItIn}.			#-.			{'accept (s)' translated.				#accept}.			{'cancel (l)' translated.				#cancel}.			#-.			{'more...' translated.					#shiftedYellowButtonActivity}}.	^ aMenu! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 12/2/2010 11:02'!openInMorphicWindowLabeled: labelString wrap: aBoolean	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: ((PluggableTextMorph 		model: self		textGetter: #actualContents 		textSetter: nil		selectionGetter: nil)			wrapFlag: aBoolean)				frame: (0@0 corner: 1@1).	^ window openInWorld! !!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:46'!is: aSymbol	aSymbol == #CodeProvider		ifTrue: [ ^contentsProvider is: aSymbol ].	^ aSymbol == #hasTextProvider or: [ super is: aSymbol ]! !!SyntaxError class methodsFor: 'instance creation' stamp: 'jmv 12/2/2010 11:02'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph 			model: aSyntaxError 			listGetter: #list			indexGetter: #listIndex 			indexSetter: nil 			menuGetter: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (PluggableTextMorph 			model: aSyntaxError			textGetter: #actualContents			textSetter: #contents:notifying: 			selectionGetter: #contentsSelection)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 12/2/2010 08:43'!wantsFrameAdornments	"Answer whether the receiver wishes to have red borders, etc., used to show editing state"	"A 'long-term temporary workaround': a nonmodular, unsavory, but expedient way to get the desired effect, sorry.  Clean up someday."	(model is: #CodeProvider) ifFalse: [ ^false ].	^ (#(annotation searchString infoViewContents) includes: getTextSelector) not! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2010 10:58'!model: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	editorClass _ anObject editorClass.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	self borderWidth: 1.	self model: anObject.	model forceRefetch.	self maybeStyle.		self setSelection: self getSelection.! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 12/2/2010 08:49'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	textToAccept := textMorph text.	ok := setTextSelector isNil or: [					setTextSelector numArgs = 2 						ifTrue: [							self textProvider								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [ self textProvider perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: [			model forceRefetch.			self maybeStyle.			self hasUnacceptedEdits: false.			(model dependents				detect: [ :dep | 					(dep isKindOf: PluggableTextMorph) 						and: [ dep getTextSelector == #annotation ]]				ifNone: nil) ifNotNil: [ :aPane | model changed: #annotation ]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 12/2/2010 08:50'!getSelection	"Answer the model's selection interval."	getSelectionSelector ifNil: [ ^ 1 to: 0 ].	"null selection"	^self textProvider perform: getSelectionSelector! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 12/2/2010 08:48'!textProvider	^ (model is: #hasTextProvider)		ifTrue: [ model textProvider ]		ifFalse: [ model ]! !!TextModelMorph methodsFor: 'unaccepted edits' stamp: 'jmv 12/2/2010 08:50'!promptForCancel	"Ask if it is OK to cancel changes to text"	(self confirm:'Changes have not been saved.Is it OK to cancel those changes?' translated)		ifTrue: [ self textProvider clearUserEditFlag ]! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 12/2/2010 08:50'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: [			model forceRefetch.			self maybeStyle.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: self textProvider autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ]! !!TextModelMorph methodsFor: 'menu' stamp: 'jmv 12/2/2010 09:58'!getMenu: shiftKeyState	| menu |	menu _ MenuMorph new defaultTarget: model.	^editorClass paneMenu: menu shifted: shiftKeyState! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 12/2/2010 08:50'!okToStyle	styler ifNil: [ ^false ].	^self textProvider shoutAboutToStyle: styler! !!TextModelMorph methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!is: aSymbol	^ aSymbol == #HasTextSelector or: [ super is: aSymbol ]! !!TextModelMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 11:04'!model: anObject textGetter: getTextSel textSetter: setTextSel	^ self		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil! !!TextModelMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 11:04'!model: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	|styler answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ anObject respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel.	^answer! !!TextModelMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2010 11:05'!noShoutModel: anObject textGetter: getTextSel textSetter: setTextSel selectionGetter: getSelectionSel	| answer |	answer _ self new.	answer		model: anObject		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: getSelectionSel.	^answer! !!TextMorph methodsFor: 'classification' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #TextMorph or: [ super is: aSymbol ]! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 12/2/2010 10:56'!addOptionalAnnotationsTo: window at: fractions plus: verticalOffset	"Add an annotation pane to the window if preferences indicate a desire for it, and return the incoming verticalOffset plus the height of the added pane, if any"	| aTextMorph divider delta |	self wantsAnnotationPane ifFalse: [^ verticalOffset].	aTextMorph _ PluggableTextMorph 		model: self		textGetter: #annotation 		textSetter: nil.	aTextMorph		askBeforeDiscardingEdits: false;		borderWidth: 0;		hideScrollBarsIndefinitely.	divider _ BorderedSubpaneDividerMorph forBottomEdge.	delta _ self defaultAnnotationPaneHeight.	window 		addMorph: aTextMorph 		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!CodeProvider methodsFor: 'construction' stamp: 'jmv 12/2/2010 10:59'!buildMorphicCodePaneWith: editString	"Construct the pane that shows the code.	Respect the Preference for standardCodeFont."	| codePane |	codePane := PluggableTextMorph				model: self				textGetter: #acceptedContents				textSetter: #contents:notifying:				selectionGetter: #contentsSelection.	editString		ifNotNil: [			codePane editString: editString.			codePane hasUnacceptedEdits: true].	^ codePane! !!CodeProvider methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:35'!is: aSymbol	^ aSymbol == #CodeProvider or: [ super is: aSymbol ]! !!Browser methodsFor: 'class comment pane' stamp: 'jmv 12/2/2010 11:05'!buildMorphicCommentPane	"Construct the pane that shows the class comment.	Respect the Preference for standardCodeFont."	| commentPane |	commentPane := BrowserCommentTextMorph				noShoutModel: self				textGetter: #classCommentText				textSetter: #classComment:notifying:				selectionGetter: nil.	commentPane styler: nil.	^ commentPane! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 12/2/2010 09:32'!buildMorphicMessageList	"Build a morphic message list, with #messageList as its list-getter"	| aListMorph |	(aListMorph := PluggableListMorph new)		model: self		listGetter: #messageList		indexGetter: #messageListIndex		indexSetter: #messageListIndex:		menuGetter: #messageListMenu:shifted:		keystrokeAction: #messageListKey:from:.	aListMorph enableDragNDrop: false.	^aListMorph! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 12/2/2010 10:59'!buildMorphicCodePaneWith: editString	| codePane |	codePane _ PluggableTextMorph		model: self		textGetter: #acceptedContents 		textSetter: nil		selectionGetter: nil.	editString ifNotNil: [		codePane editString: editString.		codePane hasUnacceptedEdits: true	].	^codePane! !!Debugger methodsFor: 'initialize' stamp: 'jmv 12/2/2010 11:03'!openFullMorphicLabel: aLabelString	"Open a full morphic debugger with the given label"	| window aListMorph oldContextStackIndex |	oldContextStackIndex _ contextStackIndex.	self expandStack. "Sets contextStackIndex to zero."	window _ (SystemWindow labelled: aLabelString) model: self.	aListMorph _ PluggableListMorph		model: self 		listGetter: #contextStackList		indexGetter: #contextStackIndex		indexSetter: #toggleContextStackIndex:		menuGetter: #contextStackMenu:shifted:		keystrokeAction: #contextStackKey:from:.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.25).	self addLowerPanesTo: window at: (0@0.25 corner: 1@0.8) with: nil.	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: self receiverInspector			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu: 			keystrokeAction: #inspectorKey:from:)		frame: (0@0.8 corner: 0.2@1).	window addMorph: (PluggableTextMorph 			model: self receiverInspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection)		frame: (0.2@0.8 corner: 0.5@1).	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: self contextVariablesInspector 			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu: 			keystrokeAction: #inspectorKey:from:)		frame: (0.5@0.8 corner: 0.7@1).	window addMorph: (PluggableTextMorph 			model: self contextVariablesInspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection)		frame: (0.7@0.8 corner: 1@1).	window openInWorld.	self toggleContextStackIndex: oldContextStackIndex.	^ window ! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 12/2/2010 10:59'!buildMorphicNotifierLabelled: label message: messageString 	| notifyPane window contentTop extentToUse |	self expandStack.	window := (SystemWindow labelled: label) model: self.	contentTop := 0.2.	extentToUse := 650 @ 320.	"nice and wide to show plenty of the error msg"	window addMorph: self buttonRowForPreDebugWindow		frame: (0 @ 0 corner: 1 @ contentTop).	messageString 		ifNil: [			notifyPane := PluggableListMorph 						model: self						listGetter: #contextStackList						indexGetter: #contextStackIndex						indexSetter: #debugAt:						menuGetter: nil						keystrokeAction: nil]		ifNotNil: [			notifyPane := PluggableTextMorph 						model: self						textGetter: nil						textSetter: nil						selectionGetter: nil.			notifyPane				editString: messageString;				askBeforeDiscardingEdits: false].	window addMorph: notifyPane frame: (0 @ contentTop corner: 1 @ 1).	^window openInWorldExtent: extentToUse! !!FileContentsBrowser methodsFor: 'creation' stamp: 'jmv 12/2/2010 11:00'!addLowerPanesTo: window at: nominalFractions with: editString	| verticalOffset column codePane infoPane infoHeight divider |	column _ AlignmentMorph proportional.	codePane _ PluggableTextMorph 		model: self		textGetter: #acceptedContents 		textSetter: #contents:notifying:		selectionGetter: #contentsSelection.	infoPane _ PluggableTextMorph 		model: self		textGetter: #infoViewContents 		textSetter: nil		selectionGetter: nil.	infoPane askBeforeDiscardingEdits: false.	verticalOffset _ 0.	infoHeight _ 20.	column 		addMorph: (codePane borderWidth: 0)		fullFrame: (			LayoutFrame 				fractions: (0@0 corner: 1@1) 				offsets: (0@verticalOffset corner: 0@infoHeight negated)		).	divider _ BorderedSubpaneDividerMorph forTopEdge.	column 		addMorph: divider		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@infoHeight negated corner: 0@(1-infoHeight))		).	column 		addMorph: (infoPane borderWidth: 0; hideScrollBarsIndefinitely)		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@(1-infoHeight) corner: 0@0)		).	window 		addMorph: column		frame: nominalFractions.	column on: #mouseEnter send: #paneTransition: to: window.	column on: #mouseLeave send: #paneTransition: to: window! !!FileList methodsFor: 'file list menu' stamp: 'jmv 12/2/2010 10:29'!editorClass	^FileContentsEditor! !!FileList methodsFor: 'accessing' stamp: 'jmv 12/2/2010 10:33'!brevityState	^brevityState! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 12/2/2010 10:56'!addVolumesAndPatternPanesTo: window at: upperFraction plus: offset forFileList: aFileList 	| column patternHeight volumeListMorph patternMorph divider dividerDelta |	column _ AlignmentMorph proportional.	patternHeight _ 25.	volumeListMorph _ (PluggableListMorph				model: aFileList				listGetter: #volumeList				indexGetter: #volumeListIndex				indexSetter: #volumeListIndex:				menuGetter: #volumeMenu:)				autoDeselect: false.	volumeListMorph enableDrag: false; enableDrop: true.	patternMorph _ PluggableTextMorph				model: aFileList				textGetter: #pattern				textSetter: #pattern:.	patternMorph acceptOnCR: true.	patternMorph hideScrollBarsIndefinitely.	divider _ BorderedSubpaneDividerMorph new.	dividerDelta _ 0.	volumeListMorph borderColor: Color transparent.	patternMorph borderColor: Color transparent.	dividerDelta _ 3.	column		addMorph: (volumeListMorph autoDeselect: false)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ patternHeight negated - dividerDelta)).	column		addMorph: divider		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ patternHeight negated - dividerDelta corner: 0 @ patternHeight negated)).	column		addMorph: patternMorph		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ patternHeight negated corner: 0 @ 0)).	window		addMorph: column		fullFrame: (LayoutFrame				fractions: upperFraction				offsets: (0 @ offset corner: 0 @ 0)).	column borderWidth: 2! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 12/2/2010 11:00'!openAsMorph	"Open a morphic view of a FileList on the default directory."	| dir aFileList window upperFraction offset |	dir := FileDirectory default.	aFileList := self new directory: dir.	window := (SystemWindow labelled: dir pathName) model: aFileList.	upperFraction := 0.3.	offset := 0.	self 		addVolumesAndPatternPanesTo: window		at: (0 @ 0 corner: 0.3 @ upperFraction)		plus: offset		forFileList: aFileList.	self 		addButtonsAndFileListPanesTo: window		at: (0.3 @ 0 corner: 1.0 @ upperFraction)		plus: offset		forFileList: aFileList.	window addMorph: (PluggableTextMorph 			model: aFileList			textGetter: #acceptedContents			textSetter: #put:			selectionGetter: #contentsSelection)		frame: (0 @ 0.3 corner: 1 @ 1).	^window openInWorld! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 12/2/2010 11:00'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	window _ (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView _ PluggableTextMorph 			model: fileModel			textGetter: #acceptedContents 			textSetter: #put:			selectionGetter: #contentsSelection)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	^ window! !!FileList2 methodsFor: 'user interface' stamp: 'jmv 12/2/2010 11:00'!morphicFileContentsPane	^PluggableTextMorph 		model: self		textGetter: #acceptedContents 		textSetter: #put:		selectionGetter: #contentsSelection! !!FileList2 methodsFor: 'user interface' stamp: 'jmv 12/2/2010 10:56'!morphicPatternPane	^PluggableTextMorph 		model: self		textGetter: #pattern 		textSetter: #pattern:		! !!Inspector class methodsFor: 'instance creation' stamp: 'jmv 12/2/2010 11:03'!openAsMorphOn: anObject withLabel: aLabel	" Inspector openAsMorphOn: SystemOrganization "	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel) model: inspector.	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: inspector 			listGetter: #fieldList			indexGetter: #selectionIndex			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu:			keystrokeAction: #inspectorKey:from:)		frame: (0@0 corner: self horizontalDividerProportion @ self verticalDividerProportion).	window addMorph: (PluggableTextMorph			model: inspector			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection)		frame: (self horizontalDividerProportion @0 corner: 1@self verticalDividerProportion).	window addMorph: ((PluggableTextMorph 			model: inspector			textGetter: nil 			textSetter: nil			selectionGetter: #contentsSelection)					askBeforeDiscardingEdits: false)		frame: (0@self verticalDividerProportion corner: 1@1).	window setUpdatablePanesFrom: #(fieldList).	^ window! !!MessageSet methodsFor: 'private' stamp: 'jmv 12/2/2010 09:33'!buildMorphicMessageList	"Build my message-list object in morphic"	| aListMorph |	aListMorph := PluggableListMorph new.	aListMorph 		model: self		listGetter: #messageList		indexGetter: #messageListIndex		indexSetter: #messageListIndex:		menuGetter: #messageListMenu:shifted:		keystrokeAction: #messageListKey:from:.	aListMorph enableDragNDrop: false.	^aListMorph! !!MessageNames methodsFor: 'initialization' stamp: 'jmv 12/2/2010 11:01'!inMorphicWindowWithInitialSearchString: initialString	"Answer a morphic window with the given initial search string, nil if none""MessageNames openMessageNames"	| window selectorListView firstDivider secondDivider horizDivider typeInPane searchButton plugTextMor |	window _ (SystemWindow labelled: 'Message Names') model: self.	firstDivider _ 0.07.	secondDivider _ 0.5.	horizDivider _ 0.5.	typeInPane _ AlignmentMorph proportional height: 14.	plugTextMor _ PluggableTextMorph 		model: self		textGetter: #searchString 		textSetter: #searchString:notifying:		selectionGetter: nil.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor textMorph		on: #mouseEnter send: #selectAll to: plugTextMor textMorph.	searchButton _ SimpleButtonMorph new 		target: self;		beTransparent;		label: 'Search';		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.	typeInPane addInProportionalRow: { searchButton. plugTextMor. }.	initialString isEmptyOrNil ifFalse:		[plugTextMor changeText: initialString].	window addMorph: typeInPane frame: (0@0 corner: horizDivider @ firstDivider).	selectorListView _ PluggableListMorph 		model: self		listGetter: #selectorList		indexGetter: #selectorListIndex		indexSetter: #selectorListIndex:		menuGetter: #selectorListMenu:		keystrokeAction: #selectorListKey:from:.	window addMorph: selectorListView frame: (0 @ firstDivider corner: horizDivider @ secondDivider).	window addMorph: self buildMorphicMessageList frame: (horizDivider @ 0 corner: 1@ secondDivider).	self 		addLowerPanesTo: window 		at: (0 @ secondDivider corner: 1@1) 		with: nil.	initialString isEmptyOrNil ifFalse: [		self searchString: initialString notifying: nil].	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'jmv 12/2/2010 11:02'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph 			model: self			textGetter: nil 			textSetter: nil			selectionGetter: nil)		frame: (0@0 corner: 1@1).	^ window openInWorld! !!WeakMessageSend methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:37'!is: aSymbol	^ aSymbol == #MessageSend or: [ super is: aSymbol ]! !TranscriptStream removeSelector: #contentsProvider!TranscriptStream removeSelector: #isCodeProvider!TranscriptStream removeSelector: #paneMenu:shifted:editorClass:!TranscriptStream removeSelector: #textProvider!MessageNames removeSelector: #selectorListMenuTitle!FileList removeSelector: #fileContentsMenu:shifted:!Debugger removeSelector: #codePaneMenu:shifted:!Debugger removeSelector: #editorClass!Debugger removeSelector: #notifierButtonHeight!Debugger removeSelector: #optionalButtonPairs!Debugger removeSelector: #paneMenu:shifted:editorClass:!Debugger removeSelector: #populateImplementInMenu:!CodeProvider removeSelector: #isCodeProvider!CodeProvider removeSelector: #messageListSelectorTitle!CodeProvider removeSelector: #paneMenu:shifted:editorClass:!TextProvider removeSelector: #contentsProvider!TextProvider removeSelector: #isCodeProvider!TextProvider removeSelector: #textProvider!TextModelMorph class removeSelector: #model:editorClass:textGetter:textSetter:!TextModelMorph class removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:!TextModelMorph class removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:menuGetter:!TextModelMorph class removeSelector: #noShoutModel:editorClass:textGetter:textSetter:!TextModelMorph class removeSelector: #noShoutModel:editorClass:textGetter:textSetter:selectionGetter:!TextModelMorph class removeSelector: #noShoutModel:editorClass:textGetter:textSetter:selectionGetter:menuGetter:!TextModelMorph removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:!TextModelMorph removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:menuGetter:!TextModel class removeSelector: #defaultPaneMenu:shifted:editorClass:!!TextModel class reorganize!('class initialization' initialize)('instance creation' normal open openLabel:)('window color' windowColor)('services')!PluggableTextModel removeSelector: #isCodeProvider!PluggableTextModel removeSelector: #paneMenu:shifted:editorClass:!!PluggableTextModel reorganize!('accessing' actualContents getTextSelector:setTextSelector: textProvider textProvider:)('testing' is: refusesToAccept)('self-updating' updatePaneIfNeeded)('misc' forceRefetch)('pane menu')!TextModel removeSelector: #contentsProvider!TextModel removeSelector: #isCodeProvider!TextModel removeSelector: #paneMenu:shifted:editorClass:!TextModel removeSelector: #textProvider!!FileContentsEditor class reorganize!('menu' paneMenu:shifted:)!!TextEditor class reorganize!('keyboard shortcut tables' initializeBasicCmdKeyShortcuts initializeCmdKeyShortcuts initializeShiftedYellowButtonMenu initializeYellowButtonMenu)('class initialization' abandonChangeText initialize shiftedYellowButtonMenu yellowButtonMenu)('accessing' cmdActions)('menu' paneMenu:shifted:)!TextEditor removeSelector: #paneMenu:shifted:!!TextEditor reorganize!('accessing' currentAttributes currentCharacterStyleOrNil currentParagraphStyle lastFont lastParagraphStyle replace:with:and: replaceSelectionWith: setSearch: string text)('accessing-selection' hasCaret markBlock markBlock: markIndex markIndex: pointBlock pointBlock: pointIndex pointIndex: selection selectionAsStream startBlock startIndex stopBlock stopIndex unselect)('as yet unclassified' totalTextHeight visibleHeight)('attributes' changeEmphasisOrAlignment changeStyle changeTextFont offerColorMenu offerFontMenu)('current selection' recomputeInterval recomputeSelection reverseSelection setViewSelection)('displaying' flash)('editing keys' align: cancel: changeEmphasis: changeLfToCr: chooseColor compareToClipboard: copyHiddenInfo duplicate: enclose: exchange: hiddenInfo inOutdent:delta: indent: makeCapitalized: makeLowercase: makeUppercase: offerColorMenu: offerFontMenu: outdent: swapChars: undo:)('events' disregardNextMouseUp doubleClick: mouseDown: mouseMove: mouseUp:)('initialize-release' changeParagraph: resetState stateArray stateArrayPut:)('menu commands' offerMenuFromEsc:)('menu messages' accept again align cancel changeAlignment chooseAlignment compareToClipboard copySelection cut exchange find findAgain pasteRecent saveContentsInFile setSearchString undo)('model access' model:)('mvc compatibility' storeSelectionInParagraph zapSelectionWith:)('new selection' afterSelectionInsertAndSelect: correctFrom:to:with: insertAndSelect:at: selectFrom:to: selectLine)('nonediting/nontyping keys' cursorEnd: cursorHome: raiseContextMenu: selectCurrentTypeIn: setSearchString:)('parenblinking' blinkParen blinkParenAt: blinkPrevParen: clearParens)('scrolling' scrollBy:)('typing support' addString: backTo: closeTypeIn dispatchOn: doneTyping openTypeIn processKeyStroke: setEmphasisHereFromText setEmphasisHereFromTextForward: startOfTyping)('typing/selecting keys' backWord: changeStyle: doAgainMany: find: findAgain: forwardDelete: search:)('undo support' isDoing isRedoing isUndoing noUndoer undoMessage:forRedo: undoer: undoer:with: undoer:with:with: undoer:with:with:with:)('undoers' undoAgain:andReselect:typedKey: undoAndReselect:redoAndReselect: undoCutCopy: undoReplace)('private' againOnce: againOrSame: againOrSame:many: applyAttribute: beginningOfLine: endOfLine: exchangeWith: getPluggableYellowButtonMenu: indent:fromStream:toStream: isDisjointFrom: moveCursor:forward:event: nullText pageHeight sameColumn:newLine:forward: unapplyAttribute: unapplyAttributesThat:fromWholeParagraph:)!!classDefinition: #SimpleHierarchicalListMorph category: #'Tools-Explorer'!ScrollPane subclass: #SimpleHierarchicalListMorph	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect columns sortingSelector getSelectionSelector setSelectionSelector potentialDropMorph lineColor menuGetter'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Explorer'!!SimpleHierarchicalListMorph reorganize!('accessing' columns columns: lineColor lineColor: roots sortingSelector:)('drawing' drawLinesOn: drawOn: expandedForm highlightSelection notExpandedForm unhighlightSelection)('dropping/grabbing' acceptDroppingMorph:event: potentialDropMorph: resetPotentialDropMorph wantsDroppedMorph:event:)('event handling' handlesKeyboard handlesMouseOverDragging: itemFromPoint: keyStroke: keyboardFocusChange: mouseDown: mouseEnter: mouseEnterDragging: mouseLeaveDragging: mouseMove: mouseUp: startDrag:)('events' expand:to: expandAll expandAll: expandRoots toggleExpandedState:event:)('events-processing' handleMouseMove:)('geometry' extent: scrollDeltaHeight scrollDeltaWidth)('initialization' autoDeselect: currentlyExpanded indentingItemClass initialize list: listItemHeight model:listGetter:indexGetter:indexSetter:menuGetter:keystrokeAction:)('keyboard navigation' arrowKey: getSelectionIndex setSelectionIndex: toggleExpandedState:)('model access' getList)('selection' getCurrentSelectionItem maximumSelection minimumSelection numSelectionsInView selectedMorph: selection: selectionIndex: selectionOneOf: setSelectedMorph:)('updating' update:)('private' addMorphsTo:from:allowSorting:withExpandedItems:atLevel: addSubmorphsAfter:fromCollection:allowSorting: adjustSubmorphPositions insertNewMorphs: noteRemovalOfAll:)('scrolling' hTotalScrollRange vTotalScrollRange)('menu' getMenu:)!PluggableTextMorph class removeSelector: #model:editorClass:textGetter:textSetter:!PluggableTextMorph class removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:!PluggableTextMorph class removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:menuGetter:!PluggableTextMorph class removeSelector: #noShoutModel:editorClass:textGetter:textSetter:!PluggableTextMorph class removeSelector: #noShoutModel:editorClass:textGetter:textSetter:selectionGetter:!PluggableTextMorph class removeSelector: #noShoutModel:editorClass:textGetter:textSetter:selectionGetter:menuGetter:!PluggableTextMorph removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:!PluggableTextMorph removeSelector: #model:editorClass:textGetter:textSetter:selectionGetter:menuGetter:!!classDefinition: #PluggableListMorph category: #'Morphic-Windows'!ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list getListSelector getListSizeSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector handlesBasicKeys potentialDropRow listMorph menuGetter'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!ScrollPane removeSelector: #getMenu:!ScrollPane removeSelector: #menuTitleSelector:!!classDefinition: #ScrollPane category: #'Morphic-Windows'!PluggableMorph subclass: #ScrollPane	instanceVariableNames: 'scrollBar scroller hScrollBar hideScrollBars currentScrollRange drawKeyboardFocusIndicator'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!PluggableButtonMorph class removeSelector: #model:stateGetter:action:labelOrGetter:menuGetter:!PluggableButtonMorph removeSelector: #getMenu:!PluggableButtonMorph removeSelector: #model:stateGetter:action:labelOrGetter:menuGetter:!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector getLabelSelector arguments isPressed mouseIsOver'	classVariableNames: 'ButtonGradient ButtonGradientPressed RoundedCornerBL RoundedCornerBLPressed RoundedCornerBR RoundedCornerBRPressed RoundedCornerTL RoundedCornerTLPressed RoundedCornerTR RoundedCornerTRPressed'	poolDictionaries: ''	category: 'Morphic-Windows'!ObjectExplorer removeSelector: #contentsProvider!ObjectExplorer removeSelector: #isCodeProvider!ObjectExplorer removeSelector: #paneMenu:shifted:editorClass:!ObjectExplorer removeSelector: #textProvider!FillInTheBlankMorph removeSelector: #isCodeProvider!FillInTheBlankMorph removeSelector: #paneMenu:shifted:editorClass:!Editor initialize!