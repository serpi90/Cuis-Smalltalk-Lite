'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 7 September 2010 at 12:13:11 pm'!!Float methodsFor: 'converting' stamp: 'jmv 9/3/2010 18:13'!partValues: aThreeArgumentBlock ifInfinite: aZeroOrOneArgBlock ifNaN: otherZeroOrOneOrTwoArgBlock	"	Float pi hex print	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.	"	| shifty sign exponent mantissa expPart fractionPart |	" Extract the bits of an IEEE double float "	shifty := ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).	" Extract the sign and the biased exponent "	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.	" Extract fractional part "	fractionPart := shifty bitAnd:  16r000FFFFFFFFFFFFF.		" Special cases: infinites and NaN"	expPart = 16r7FF ifTrue: [		^fractionPart = 0			ifTrue: [ aZeroOrOneArgBlock valueWithPossibleArgument: self ]			ifFalse: [ otherZeroOrOneOrTwoArgBlock valueWithPossibleArgument: self and: fractionPart ]].	" Unbias exponent: 16r3FF is bias"	exponent := expPart - 16r3FF.	" Replace omitted leading 1 in fraction if appropriate"	"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa"		expPart = 0		ifTrue: [			mantissa := fractionPart.			exponent _ exponent + 1 ]		ifFalse: [ mantissa := fractionPart bitOr: 16r0010000000000000 ].	"Evaluate the block"	^aThreeArgumentBlock value: sign value: exponent value: mantissa! !!FloatTest methodsFor: 'testing - conversion' stamp: 'jmv 9/7/2010 12:12'!testAsTrueFraction	"	self new testAsTrueFraction	"	| x |	x _ Float pi.	self assert: x asTrueFraction asFloat = x.	x _ 1.0 / 3.0.	self assert: x asTrueFraction asFloat = x.	x _ Float fminNormalized.	self assert: x asTrueFraction asFloat = x.	x _ 0.0 - Float fminDenormalized.	self assert: x asTrueFraction asFloat = x.	x _ Float fminNormalized.	self assert: x asTrueFraction asFloat = x.	x _ 0.0 - Float fminDenormalized.	self assert: x asTrueFraction asFloat = x.	x _ 1.023399999997e-312.	self assert: x asTrueFraction asFloat = x.	x _ Float fmax.	self assert: x asTrueFraction asFloat = x.	x _ 0.0 - Float fmax.	self assert: x asTrueFraction asFloat = x.	x _ 1.0234e308.	self assert: x asTrueFraction asFloat = x.! !