'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 3 November 2010 at 10:36:08 am'!!classDefinition: #Heap category: #'Collections-Sequenceable'!SequenceableCollection subclass: #Heap	instanceVariableNames: 'array tally sortBlock indexUpdateBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!Heap commentStamp: 'nice 9/30/2010 23:22' prior: 0!Class Heap implements a special data structure commonly referred to as 'heap' [ http://en.wikipedia.org/wiki/Heap_%28data_structure%29 ]A Heap is a kind of binary tree stored in a linear array - see details after the instance variables description.Heaps are good at handling priority queues because:1) greatest priority element according to the sort block will be stored in first position and thus accessed in O(1) operations2) worse time for inserting or removing an element is in O(log n) operations, where n is the size of the Heap	Insertion/Removal times are more efficient than above upper bound, provided that:	a) Elements are only removed at the beginning	b) Elements are added with arbitrary sort order.3) there is no need to fully sort the Heap, which makes it more efficient than a SortedCollectionThe heap can be fully sorted by sending the message #fullySort.Worse time for fully sorting the Heap is in O(n log n) operations, but this is rarely used a feature.Remind that the Heap does not fully sort the collection if you don't ask.Thus don't expect #do: and other iterators to enumerate elements according to the sortBlock order.Instance variables:	array		<Array>		The data repository	tally		<Integer>	The number of elements in the heap	sortBlock	<Block|nil>	A two-argument block defining the sort order,							or nil in which case the default sort order is								[:element1 :element2| element1 <= element2]	indexUpdateBlock 	<Block|nil> 							A two-argument block of the form [:data :index | ... ]							which allows an application object to keep track of its							index within the heap.  Useful for quick heap update							when object's sort value changes (for example, when an							object in a priority queue has its priority increased							by an external event, you don't want to have to search							through the whole heap to find the index before fixing							the heap).  No update occurs if nil.									The Heap can be viewed as a binary tree (every node in the tree has at most two children).The root is stored in first slot of internal array.The children are stored in next two slots.The children of children in next four slots.etc...For a node A of index i (1 based), the two children B1 and B2 are thus stored in indices (2*i) and (2*i+1).Of course, the children indices must be less than the tally otherwise they are considered inexistent.The Heap does arrange to preserve the following invariant:For any children B of a node A, A is sorted before B, in other words, (self sort: A before: B) = trueThis implies that the root is always the first element according to sort order.!!Heap methodsFor: 'accessing' stamp: 'md 1/19/2006 09:56'!first	"Return the first element in the receiver"	^array at: 1! !!Heap methodsFor: 'accessing' stamp: 'nice 9/30/2010 23:27'!fullySort	"Fully sort the heap.	This method preserves the heap invariants and can thus be sent safely"	self privateReverseSort.	1 to: tally // 2 do: [:i | array swap: i with: 1 + tally - i]! !!Heap methodsFor: 'accessing' stamp: 'stephane.ducasse 4/13/2009 21:05'!indexUpdateBlock: aBlockOrNil	indexUpdateBlock := aBlockOrNil.! !!Heap methodsFor: 'adding' stamp: 'jcg 3/8/2003 02:07'!add: anObject	"Include newObject as one of the receiver's elements. Answer newObject."	tally = array size ifTrue:[self grow].	array at: (tally := tally + 1) put: anObject.	self updateObjectIndex: tally.	self upHeap: tally.	^anObject! !!Heap methodsFor: 'removing' stamp: 'klub 9/14/2009 19:10'!removeAll	array atAllPut: nil.	tally := 0! !!Heap methodsFor: 'enumerating' stamp: 'nice 8/21/2010 15:40'!collect: aBlock	^self collect: aBlock as: Array! !!Heap methodsFor: 'enumerating' stamp: 'nice 8/21/2010 15:49'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true."	| newCollection |	newCollection := self copyEmpty.	self do:		[:each |		(aBlock value: each)			ifTrue: [newCollection add: each]].	^ newCollection! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeap: anIndex	"Check the heap downwards for correctness starting at anIndex.	 Everything above (i.e. left of) anIndex is ok."	| value k n j |	anIndex = 0 ifTrue:[^self].	n := tally bitShift: -1.	k := anIndex.	value := array at: anIndex.	[k <= n] whileTrue:[		j := k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[ j := j + 1].		"check if position k is ok"		(self sorts: value before: (array at: j)) 			ifTrue:[	"yes -> break loop"					n := k - 1]			ifFalse:[	"no -> make room at j by moving j-th element to k-th position"					array at: k put: (array at: j).					self updateObjectIndex: k.					"and try again with j"					k := j]].	array at: k put: value.	self updateObjectIndex: k.! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeapSingle: anIndex	"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster."	| value k n j |	anIndex = 0 ifTrue:[^self].	n := tally bitShift: -1.	k := anIndex.	value := array at: anIndex.	[k <= n] whileTrue:[		j := k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[	j := j + 1].		array at: k put: (array at: j).		self updateObjectIndex: k.		"and try again with j"		k := j].	array at: k put: value.	self updateObjectIndex: k.	self upHeap: k! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:12'!upHeap: anIndex	"Check the heap upwards for correctness starting at anIndex.	 Everything below anIndex is ok."	| value k kDiv2 tmp |	anIndex = 0 ifTrue:[^self].	k := anIndex.	value := array at: anIndex.	[ (k > 1) and:[self sorts: value before: (tmp := array at: (kDiv2 := k bitShift: -1))] ] 		whileTrue:[			array at: k put: tmp.			self updateObjectIndex: k.			k := kDiv2].	array at: k put: value.	self updateObjectIndex: k.! !!Heap methodsFor: 'private' stamp: 'nice 9/30/2010 23:26'!privateReverseSort	"Arrange to have the array sorted in reverse order.	WARNING: this method breaks the heap invariants. It's up to the sender to restore them afterwards."	| oldTally |	oldTally := tally.	[tally > 1] whileTrue:		[array swap: 1 with: tally.		tally := tally - 1.		self downHeapSingle: 1].	tally := oldTally! !!Heap methodsFor: 'private' stamp: 'jcg 3/8/2003 02:08'!updateObjectIndex: index	"If indexUpdateBlock is not nil, notify the object at index of its new position in the heap array."	indexUpdateBlock ifNotNil: [		indexUpdateBlock value: (array at: index) value: index]! !!Heap methodsFor: 'copying' stamp: 'nice 8/21/2010 15:53'!copyEmpty	"Answer a copy of the receiver without any of the receiver's elements."	^self class sortBlock: sortBlock! !!Heap methodsFor: 'copying' stamp: 'nice 10/5/2009 08:47'!postCopy	super postCopy.	array := array copy! !!classDefinition: #Heap category: #'Collections-Sequenceable'!SequenceableCollection subclass: #Heap	instanceVariableNames: 'array tally sortBlock indexUpdateBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!