'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 13 January 2011 at 11:38:14 pm'!!PNGReadWriter methodsFor: 'chunks' stamp: 'nice 12/26/2009 19:05'!processInterlaced	| z startingCol colIncrement rowIncrement startingRow |	startingCol := #(0 4 0 2 0 1 0 ).	colIncrement := #(8 8 4 4 2 2 1 ).	rowIncrement := #(8 8 8 4 4 2 2 ).	startingRow := #(0 0 4 0 2 0 1 ).	z := ZLibReadStream on: chunk from: 1 to: chunk size.	1 to: 7 do: [:pass |		| cx sc bytesPerPass |		(self doPass: pass)			ifTrue:				[cx := colIncrement at: pass.				sc := startingCol at: pass.				bytesPerPass := width - sc + cx - 1 // cx * bitsPerPixel + 7 // 8.				prevScanline := ByteArray new: bytesPerPass.				thisScanline := ByteArray new: bytesPerScanline.				(startingRow at: pass)					to: height - 1					by: (rowIncrement at: pass)					do: [:y |						| filter temp |						filter := z next.						filtersSeen add: filter.						(filter isNil or: [(filter between: 0 and: 4) not])							ifTrue: [^ self].						thisScanline := z next: bytesPerPass into: thisScanline startingAt: 1.						self filterScanline: filter count: bytesPerPass.						self copyPixels: y at: sc by: cx.						temp := prevScanline.						prevScanline := thisScanline.						thisScanline := temp.					]				]	].	z atEnd ifFalse:[self error:'Unexpected data'].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 1/13/2011 23:37'!copyPixelsGray: y	"Handle non-interlaced grayscale color mode (colorType = 0)"	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This interesting technique (By Andreas Raab) is a bit obscure, but it is so fast that we leave it active"	^self copyPixelsGrayWeirdBitBltHack: y.	"This interesting technique  (By Yoshiki Ohshima) is also instructive"	"true ifTrue: [ ^form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32) ]."	"This Smalltalk version might be easier to understand and is quite fast too."	"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 	is to make use of faster arithmetic bytecodes, but not of slow largeintegers."	"	base _  y * form width * bitsPerChannel//32 +1.	bits _ form bits.	0 to: thisScanline size // 4 - 1 do: [ :i |		| ii |		ii _ i * 4.		word _	           ((thisScanline at: ii+1) *256 + 	           (thisScanline at: ii+2) *256 + 	           ((thisScanline at: ii+3)) bitShift: 8) bitOr: 	           (thisScanline at: ii+4).		bits at: base + i put: word.].	(bytesLeft := thisScanline size bitAnd: 3) = 0 ifFalse: [		word := 0.		thisScanline size - bytesLeft + 1 to: thisScanline size do: [ :ii |			word := word * 256 + (thisScanline at: ii) ].		word := word bitShift: 8 * (4 - bytesLeft).		bits at: base + (thisScanline size // 4) put: word ].	"! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'nice 12/27/2009 03:10'!copyPixelsGray: y at: startX by: incX	"Handle interlaced grayscale color mode (colorType = 0)"	| offset bits blitter pixPerByte shifts b pixel mask pixelNumber |	bitsPerChannel = 16		ifTrue: [			b := BitBlt current bitPokerToForm: form.			startX to: width-1 by: incX do: [ :x |				b pixelAt: x@y put: 255 - (thisScanline at: (x//incX<<1)+1).				].			^ self			].	offset := y*rowSize+1.	bits := form bits.	bitsPerChannel = 8 ifTrue: [		startX to: width-1 by: incX do: [ :x | | w |			w := offset + (x>>2).			b := 3- (x \\ 4) * 8.			pixel := (thisScanline at: x // incX + 1)<<b.			mask := (255<<b) bitInvert32.			bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)		].		^ self	].	bitsPerChannel = 1 ifTrue: [		pixPerByte := 8.		mask := 1.		shifts := #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte := 4.		mask := 3.		shifts := #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte := 2.		mask := 15.		shifts := #(4 0).	].	blitter := BitBlt current bitPokerToForm: form.	pixelNumber := 0.	startX to: width-1 by: incX do: [ :x | | rawByte |		rawByte := thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel := (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber := pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'nice 12/27/2009 03:10'!copyPixelsIndexed: y at: startX by: incX	"Handle interlaced indexed color mode (colorType = 3)"	| offset bits pixPerByte shifts blitter pixel mask pixelNumber |	offset := y*rowSize+1.	bits := form bits.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x | | b w |				w := offset + (x>>2).				b := 3 - (x \\ 4) * 8.				pixel := (thisScanline at: x // incX + 1)<<b.				mask := (255<<b) bitInvert32.				bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)].			^ self ].	bitsPerChannel = 1 ifTrue: [		pixPerByte := 8.		mask := 1.		shifts := #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte := 4.		mask := 3.		shifts := #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte := 2.		mask := 15.		shifts := #(4 0).	].	blitter := BitBlt current bitPokerToForm: form.	pixelNumber := 0.	startX to: width-1 by: incX do: [ :x | | rawByte |		rawByte := thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel := (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber := pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'nk 7/27/2004 17:18'!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits xx loopsToDo |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	loopsToDo := width - startX + incX - 1 // incX.	bitsPerChannel = 8 ifTrue: [		i := (startX // incX * 3) + 1.		xx := startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: xx put: pixel.			i := i + 3.			xx := xx + incX.		]	] ifFalse: [		i := (startX // incX * 6) + 1.		xx := startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: xx put: pixel.			i := i + 6.			xx := xx + incX.		].	].	transparentPixelValue ifNotNil: [		startX to: width-1 by: incX do: [ :x |			(tempBits at: x+1) = transparentPixelValue ifTrue: [				tempBits at: x+1 put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'nk 7/27/2004 17:57'!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i := (startX // incX << 2) + 1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel.			i := i + 4.		]	] ifFalse: [		i := (startX // incX << 3) +1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.			i := i + 8.		].	].	tempForm displayOn: form at: 0@y rule: Form paintAlpha.! !!PNGReadWriter methodsFor: 'writing' stamp: 'BG 3/16/2005 08:26'!writeChunk: crcStream	| bytes length crc debug |	debug := self debugging.	bytes := crcStream originalContents.	length := crcStream position.	crc := self updateCrc: 16rFFFFFFFF from: 1 to: length in: bytes.	crc := crc bitXor: 16rFFFFFFFF.	debug ifTrue: [ Transcript cr;		print: stream position; space;		nextPutAll: (bytes copyFrom: 1 to: 4) asString;		nextPutAll: ' len='; print: length;		nextPutAll: ' crc=0x'; nextPutAll: crc printStringHex  ].	stream nextNumber: 4 put: length-4. "exclude chunk name"	stream next: length putAll: bytes startingAt: 1.	stream nextNumber: 4 put: crc.	debug ifTrue: [ Transcript nextPutAll: ' afterPos='; print: stream position ].	crcStream resetToStart.! !!PNGReadWriter methodsFor: 'writing' stamp: 'nice 1/18/2010 18:08'!writeFileSignature	stream nextPutAll: #[ 16r89 16r50 16r4E  16r47 16r0D 16r0A 16r1A 16r0A ]! !