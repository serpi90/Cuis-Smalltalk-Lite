'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 27 February 2011 at 7:13:38 pm'!!BitBlt methodsFor: 'copying' stamp: 'jmv 2/26/2011 22:36'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	"If required, do a second pass with new rule and colorMap"	| answer prevRule secondPassMap sourceDepth destDepth |	"Slight optimization when there's nothing to do."	clipHeight = 0 ifTrue: [^self].	clipWidth = 0 ifTrue: [^self].	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.	If not, do it simply"	combinationRule = 37 "rgbMul" ifFalse: [		^self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta ].		"We need to do a second pass. The colormap set is for use in the second pass."	secondPassMap _ colorMap.	sourceDepth _ sourceForm depth.	destDepth _ destForm depth.	colorMap _ sourceDepth ~= destDepth		ifTrue: [ Color cachedColormapFrom: sourceDepth to: destDepth ].	answer := self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta.	colorMap := secondPassMap.	secondPassMap ifNotNil: [		prevRule := combinationRule.		combinationRule := 20. "rgbAdd"		self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta.		combinationRule := prevRule ].	^answer! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 2/26/2011 22:37'!drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c	| font |	port colorMap: nil.	font _ fontOrNil ifNil: [StrikeFont default].	font installOn: port foregroundColor: (self shadowColor ifNil:[c]).	"Slight optimization when there's nothing to do."	port clipHeight = 0 ifTrue: [^self].	port clipWidth = 0 ifTrue: [^self].	font displayString: aString on: port 		from: firstIndex to: lastIndex at: (origin + aPoint) kern: font baseKern negated.! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 2/26/2011 22:36'!drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c	| font portRect |	port colorMap: nil.	portRect _ port clipRect.	port clipByX1: bounds left + origin x 		y1: bounds top + origin y 		x2: bounds right + origin x 		y2: bounds bottom + origin y.	"Slight optimization when there's nothing to do."	port clipHeight = 0 ifTrue: [^self].	port clipWidth = 0 ifTrue: [^self].	font _ fontOrNil ifNil: [StrikeFont default].	font installOn: port foregroundColor: (self shadowColor ifNil:[c]).	font displayString: aString asString on: port 		from: firstIndex to: lastIndex at: (bounds topLeft + origin) kern: font baseKern negated.	port clipRect: portRect.! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 2/26/2011 22:37'!drawStringEmbossed: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: aColor	| font portRect insideColor |	port colorMap: nil.	portRect _ port clipRect.	port clipByX1: bounds left + origin x 		y1: bounds top + origin y 		x2: bounds right + origin x 		y2: bounds bottom + origin y.	"Slight optimization when there's nothing to do."	port clipHeight = 0 ifTrue: [^self].	port clipWidth = 0 ifTrue: [^self].	font _ fontOrNil ifNil: [StrikeFont default].	insideColor _ self shadowColor ifNil: [ aColor ].	insideColor = Color black ifFalse: [ | topColor |		topColor _ insideColor alphaMixed: 0.25 with: Color black.		font installOn: port foregroundColor: topColor.		font displayString: aString asString on: port 			from: firstIndex to: lastIndex at: (bounds topLeft + origin) kern: font baseKern negated ].	insideColor = Color white ifFalse: [ | bottomColor |		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.		font installOn: port foregroundColor: bottomColor.		font displayString: aString asString on: port 			from: firstIndex to: lastIndex at: (bounds topLeft + origin + (0@2)) kern: font baseKern negated ].	font installOn: port foregroundColor: insideColor.	font displayString: aString asString on: port 		from: firstIndex to: lastIndex at: (bounds topLeft + origin + (0@1)) kern: font baseKern negated.	port clipRect: portRect.! !!LightWidget methodsFor: 'drawing' stamp: 'jmv 2/26/2011 22:46'!addPossiblyUncoveredAreasIn: aRectangle to: aCollection	"May be overridden by any subclasses with opaque regions"	aCollection add: aRectangle! !!Morph methodsFor: 'drawing' stamp: 'jmv 2/26/2011 22:52'!addPossiblyUncoveredAreasIn: aRectangle to: aCollection	"Answer an array of rectangles encompassing those areas in aRectangle not completely	covered by self.	All areas that might possibly be uncovered must be included."	(self isOrthoRectangularMorph and: [ self isOpaqueMorph ]) ifTrue: [		aRectangle addAreasOutside: bounds to: aCollection.		^self ].	aCollection add: aRectangle! !!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 2/26/2011 22:51'!addAreasOutside: aRectangle to: aCollection	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| yOrigin yCorner |	"Make sure the intersection is non-empty"     (self intersects: aRectangle)		ifFalse: [			aCollection add: self.			^self ].	aRectangle origin y > origin y		ifTrue: [ aCollection add: (origin corner: corner x @ (yOrigin := aRectangle origin y))] 		ifFalse: [ yOrigin _ origin y ].	aRectangle corner y < corner y		ifTrue: [ aCollection add: (origin x @ (yCorner := aRectangle corner y) corner: corner) ]		ifFalse: [ yCorner _ corner y ].	aRectangle origin x > origin x 		ifTrue: [ aCollection add: (origin x @ yOrigin corner: aRectangle origin x @ yCorner) ].	aRectangle corner x < corner x 		ifTrue: [ aCollection add: (aRectangle corner x @ yOrigin corner: corner x @ yCorner) ]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 2/26/2011 22:53'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas |	"Make sure the intersection is non-empty"     (self intersects: aRectangle)		ifFalse: [^Array with: self].	areas := OrderedCollection new.	self addAreasOutside: aRectangle to: areas.	^areas! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 2/26/2011 14:20'!with: otherCollection reverseDo: twoArgBlock 	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	self size to: 1 by: -1 do:		[:index |		twoArgBlock value: (self at: index)				value: (otherCollection at: index)]! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 2/26/2011 22:52'!addPossiblyUncoveredAreasIn: aRectangle to: aCollection	"Answer an array of rectangles encompassing those areas in aRectangle not completely	covered by self. These are the areas that might require further drawing (of morphs below us)	All areas that might possibly be uncovered must be included."	 | r |	self fillStyle mightBeTranslucent ifTrue: [		aCollection add: aRectangle.		^self ].	"Solid rectangle.	This will be the fastest in many cases. So, please disable rounded corners if on slow hardware!!"	Theme current roundWindowCorners ifFalse: [		aRectangle addAreasOutside: bounds to: aCollection.		^self ].	"The solid rectangle does not include the corners.	Report a couple of rows (top and bottom) or columns (left and right) as uncovered areas.	We could also try to be more careful and answer each rounded corner...	Right now, report top and bottom rows as uncovered areas"	r _ Theme current roundedWindowRadius.	aRectangle addAreasOutside: (bounds insetBy: 0@r) to: aCollection.		! !!WorldState methodsFor: 'update cycle' stamp: 'jmv 2/26/2011 23:34'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m doLayoutIfNeeded].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].	"repair world's damage on canvas"	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.	"self handsDo:[:h | h noticeDamageRects: worldDamageRects ]."	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [ :h | h savePatchFrom: canvas ].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [ self forceDamageToScreen: allDamage ]		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'jmv 2/27/2011 19:13'!drawInvalidAreasWorld: aWorld submorphs: submorphs	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: aWorld viewBox.	damageRecorder reset.			currentRectsToRepair _ OrderedCollection new.	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.	morphsToDraw _ OrderedCollection new.	rectsForEachMorph _ OrderedCollection new.	thisMorphRects _ OrderedCollection new.	n _ submorphs size.	i _ 1.	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [		morph _ submorphs at: i.		morph visible ifTrue: [			morphBounds _morph fullDisplayBounds.			reuse _ currentRectsToRepair.			currentRectsToRepair _ newRectsToRepair.			newRectsToRepair _ reuse resetTo: 1.			currentRectsToRepair do: [ :r |				(morphBounds intersects: r)					ifTrue: [						morphClipRect _ morphBounds intersect: r.						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]					ifFalse: [						newRectsToRepair add: r ]].			thisMorphRects ifNotEmpty: [				morphsToDraw add: morph.				rectsForEachMorph add: thisMorphRects.				thisMorphRects _ OrderedCollection new.			]].		i _ i + 1 ].	i > n  ifTrue: [		morphsToDraw add: aWorld.		rectsForEachMorph add: newRectsToRepair ].	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |		"Here we could merge all xrects into just one call... Most likely, that would be slower, though.""		rr _ nil."		xrects do: [ :r |"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."			(canvas copyClipRect: r) fullDrawMorph: m 		]."		(canvas copyClipRect: rr) fullDrawMorph: m "	].		"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance..."	^ initialRectsToRepair! !WorldState removeSelector: #drawWorld:submorphs:invalidAreasOn:!SystemWindow removeSelector: #possiblyUncoveredAreasIn:!Morph removeSelector: #possiblyUncoveredAreasIn:!LightWidget removeSelector: #possiblyUncoveredAreasIn:!