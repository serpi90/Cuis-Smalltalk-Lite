'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 12 December 2011 at 10:17:01 am'!!LightWidget methodsFor: 'geometry' stamp: 'jmv 12/11/2011 15:27'!                             bounds: aRectangle	self redrawNeeded.	bounds _ aRectangle.	self redrawNeeded.	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].! !!LightWidget methodsFor: 'geometry' stamp: 'jmv 12/11/2011 16:08'!       extent: aPoint	bounds extent = aPoint ifTrue: [^ self].	self redrawNeeded.	bounds _ bounds topLeft extent: aPoint.	self someSubmorphPositionOrExtentChanged.	self redrawNeeded! !!LightWidget methodsFor: 'geometry' stamp: 'jmv 12/11/2011 15:28'!    position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [ ^ self ].  "Null change"	self redrawNeeded.	self privateFullMoveBy: delta.	self redrawNeeded.	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !!LightWidget methodsFor: 'layout' stamp: 'jmv 12/11/2011 15:48'!             someSubmorphPositionOrExtentChanged	"In some submorph or in self"	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !!CompositeLW methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/11/2011 15:26'!          removeAllMorphs	| oldMorphs myWorld |	myWorld _ self world.	myWorld ifNotNil: [ self redrawNeeded ].	submorphs do: [ :m | m privateOwner: nil ].	oldMorphs _ submorphs.	submorphs _ EmptyArray.	oldMorphs do: [ :m | self removedMorph: m ].	self someSubmorphPositionOrExtentChanged! !!CompositeLW methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/11/2011 15:27'!               removeMorph: aMorph	"Remove the given morph from my submorphs"	| aWorld |	aMorph owner == self ifFalse:[^self].	aWorld := self world.	aWorld ifNotNil:[		self privateInvalidateMorph: aMorph.	].	self privateRemove: aMorph.	aMorph privateOwner: nil.	self removedMorph: aMorph.	self someSubmorphPositionOrExtentChanged! !!CompositeLW methodsFor: 'private' stamp: 'jmv 12/11/2011 15:47'!                    privateAddMorph: aMorph atIndex: index	| oldIndex myWorld itsWorld oldOwner |	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	myWorld _ self world.	oldOwner _ aMorph owner.	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue:[		"aMorph's position changes within in the submorph chain"		oldIndex < index ifTrue:[			"moving aMorph to back"			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.			submorphs at: index-1 put: aMorph.		] ifFalse:[			"moving aMorph to front"			oldIndex-1 to: index by: -1 do:[:i|				submorphs at: i+1 put: (submorphs at: i)].			submorphs at: index put: aMorph.		].	] ifFalse:[		"adding a new morph"		oldOwner ifNotNil:[			itsWorld _ aMorph world.			itsWorld ifNotNil: [self privateInvalidateMorph: aMorph].			oldOwner privateRemove: aMorph.			oldOwner removedMorph: aMorph.		].		aMorph privateOwner: self.		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].	].	myWorld ifNotNil:[self privateInvalidateMorph: aMorph].	self someSubmorphPositionOrExtentChanged.	oldOwner == self ifFalse: [		self addedMorph: aMorph.		aMorph noteNewOwner: self ].! !!ImageLW methodsFor: 'accessing' stamp: 'jmv 12/11/2011 15:43'!                              form: aForm	form _ aForm.	self generateStretchedForm.	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].	self redrawNeeded! !!ImageLW methodsFor: 'geometry' stamp: 'jmv 12/11/2011 15:43'!                  bounds: aPoint	super bounds: aPoint.	self generateStretchedForm.	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].	self redrawNeeded! !!Morph methodsFor: 'change reporting' stamp: 'jmv 12/11/2011 16:03'!privateInvalidateMorph: aMorph	"Private. Invalidate the given morph after adding or removing.	This method is private because a) we're invalidating the morph 'remotely'	and b) it forces a fullBounds computation which should not be necessary	for a general morph c) the morph may or may not actually invalidate	anything (if it's not in the world nothing will happen) and d) the entire	mechanism should be rewritten."	aMorph layoutSubmorphsAndComputeFullBounds.	aMorph redrawNeeded! !!Morph methodsFor: 'drawing' stamp: 'jmv 12/11/2011 16:03'!                          clipSubmorphs: aBoolean	"Drawing specific. If this property is set, clip the receiver's submorphs to the receiver's clipping bounds."	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.	aBoolean		ifTrue: [ self setProperty: #clipSubmorphs toValue: true ]		ifFalse: [ self removeProperty: #clipSubmorphs ].	self		someSubmorphPositionOrExtentChanged;		layoutSubmorphsAndComputeFullBounds;		redrawNeeded! !!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 15:28'! basicExtent: aPoint	bounds extent = aPoint ifTrue: [^ self].	self redrawNeeded.	bounds _ bounds topLeft extent: aPoint.	self someSubmorphPositionOrExtentChanged.	self redrawNeeded! !!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 16:03'!     position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.	self privateFullMoveBy: delta.	self redrawNeeded	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !!Morph methodsFor: 'layout' stamp: 'jmv 12/11/2011 15:49'!                 computeFullBounds	"Private. Compute the actual full bounds of the receiver"	(submorphs isEmpty or: [ self clipsSubmorphs ]) ifTrue: [ ^bounds ].	^ bounds quickMerge: self submorphBounds! !!Morph methodsFor: 'layout' stamp: 'jmv 12/11/2011 16:03'!   fullBounds	"Return the bounding box of the receiver and all its children. Recompute the layout if necessary."	self layoutSubmorphsAndComputeFullBounds.	^fullBounds! !!Morph methodsFor: 'layout' stamp: 'jmv 12/11/2011 15:54'!                          layoutSubmorphs	"Compute a new layout of submorphs based on the given layout bounds."	"Only specific subclasses do layout."! !!Morph methodsFor: 'layout' stamp: 'jmv 12/11/2011 16:03'!  layoutSubmorphsAndComputeFullBounds	"Return self. Recompute the layout if necessary."	fullBounds ifNotNil: [ ^self ].	"Errors at this point can be critical so make sure we catch 'em all right"	[		self layoutSubmorphs.		fullBounds _ self computeFullBounds.	] on: Exception do: [ :ex |		"This should do it unless you don't screw up the bounds"		fullBounds _ bounds.		ex pass ]! !!Morph methodsFor: 'layout' stamp: 'jmv 12/11/2011 15:48'!                               someSubmorphPositionOrExtentChanged	"In some submorph or in self"	fullBounds ifNil: [ ^self ]. "layout will be recomputed so don't bother"	fullBounds _ nil.	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !!Morph methodsFor: 'layout-properties' stamp: 'jmv 12/11/2011 15:28'!                       layoutSpec: aLayoutSpec	"Layout specific. Set the layout spec describing where the receiver should appear in a proportional layout"	self layoutSpec == aLayoutSpec ifTrue:[^self].	aLayoutSpec morph: self.	self assureExtension layoutSpec: aLayoutSpec.	self someSubmorphPositionOrExtentChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/11/2011 16:03'!          removeAllMorphs	| oldMorphs myWorld |	submorphs isEmpty ifTrue: [ ^self ].	myWorld _ self world.	(fullBounds notNil or: [ myWorld notNil ]) ifTrue: [		self layoutSubmorphsAndComputeFullBounds; redrawNeeded ].	submorphs do: [ :m |		m privateOwner: nil ].	oldMorphs _ submorphs.	submorphs _ #().	oldMorphs do: [ :m |		self removedMorph: m ].	self someSubmorphPositionOrExtentChanged! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/11/2011 16:03'!          removeAllMorphsIn: aCollection	"greatly speeds up the removal of *lots* of submorphs"	| set myWorld |	aCollection isEmpty ifTrue: [ ^self ].	set _ IdentitySet new: aCollection size * 4 // 3.	aCollection do: [ :each | each owner == self ifTrue: [ set add: each]].	set isEmpty ifTrue: [ ^self ].	myWorld _ self world.	(fullBounds notNil or: [ myWorld notNil ]) ifTrue: [		self layoutSubmorphsAndComputeFullBounds; redrawNeeded ].	set do: [ :m | m privateOwner: nil ].	submorphs _ submorphs reject: [ :each | set includes: each].	set do: [ :m | self removedMorph: m ].	self someSubmorphPositionOrExtentChanged! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/11/2011 15:28'!       removeMorph: aMorph	"Remove the given morph from my submorphs"	| aWorld |	aMorph owner == self ifFalse:[^self].	aWorld := self world.	aWorld ifNotNil:[		self privateInvalidateMorph: aMorph.	].	self privateRemove: aMorph.	aMorph privateOwner: nil.	self removedMorph: aMorph.	self someSubmorphPositionOrExtentChanged.! !!Morph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:42'!                         privateAddAllMorphs: aCollection atIndex: index	"Private. Add aCollection of morphs to the receiver"	| myWorld itsWorld otherSubmorphs |	myWorld _ self world.	otherSubmorphs _ submorphs copyWithoutAll: aCollection.	(index between: 0 and: otherSubmorphs size)		ifFalse: [^ self error: 'index out of range'].	index = 0		ifTrue:[	submorphs _ aCollection asArray, otherSubmorphs]		ifFalse:[	index = otherSubmorphs size			ifTrue:[	submorphs _ otherSubmorphs, aCollection]			ifFalse:[	submorphs _ otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].	aCollection do: [:m | | itsOwner |		itsOwner _ m owner.		itsOwner ifNotNil: [			itsWorld _ m world.			(itsWorld == myWorld) ifFalse: [				itsWorld ifNotNil: [self privateInvalidateMorph: m]].			(itsOwner ~~ self) ifTrue: [				m owner privateRemove: m.				m owner removedMorph: m ]].		m privateOwner: self.		myWorld ifNotNil: [self privateInvalidateMorph: m].		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].		itsOwner == self ifFalse: [			self addedMorph: m.			m noteNewOwner: self ].	].	self someSubmorphPositionOrExtentChanged! !!Morph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:28'!                       privateAddMorph: aMorph atIndex: index	| oldIndex myWorld itsWorld oldOwner |	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	myWorld _ self world.	oldOwner _ aMorph owner.	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue:[		"aMorph's position changes within in the submorph chain"		oldIndex < index ifTrue:[			"moving aMorph to back"			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.			submorphs at: index-1 put: aMorph.		] ifFalse:[			"moving aMorph to front"			oldIndex-1 to: index by: -1 do:[:i|				submorphs at: i+1 put: (submorphs at: i)].			submorphs at: index put: aMorph.		].	] ifFalse:[		"adding a new morph"		oldOwner ifNotNil:[			itsWorld _ aMorph world.			itsWorld ifNotNil: [self privateInvalidateMorph: aMorph].			oldOwner privateRemove: aMorph.			oldOwner removedMorph: aMorph.		].		aMorph privateOwner: self.		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].	].	myWorld ifNotNil:[self privateInvalidateMorph: aMorph].	self someSubmorphPositionOrExtentChanged.	oldOwner == self ifFalse: [		self addedMorph: aMorph.		aMorph noteNewOwner: self ].! !!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:27'!                              addHandles	| box |	target isWorldMorph ifTrue: [ ^ self addHandlesForWorldHalos ].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target worldBoundsForHalo.  "update my size"	box _ self basicBox.	target addHandlesTo: self box: box.	self addName.	growingOrRotating _ false.	self someSubmorphPositionOrExtentChanged.	self redrawNeeded! !!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:27'!                addHandlesForWorldHalos	"Add handles for world halos, like the man said"	| box w |	w _ self world ifNil:[target world].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ w bounds insetBy: 9.	target addWorldHandlesTo: self box: box.	self		addNameBeneath: (box insetBy: (0@0 corner: 0@10))		string: (innerTarget printStringLimitedTo: 40).	growingOrRotating _ false.	self someSubmorphPositionOrExtentChanged.	self redrawNeeded! !!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:27'! doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent |self revisar.	evt hand obtainHalo: self."Como podria andar el grow de un morph embebido en otro? andara ahora?"newExtent _ evt position - positionOffset - target bounds topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].	target extent: newExtent.	growHandle position: evt position - (growHandle extent // 2).	self someSubmorphPositionOrExtentChanged! !!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:27'!                     doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |self revisar.	evt hand obtainHalo: self.	degrees _ (evt position - target referencePosition) degrees.	degrees _ degrees - angleOffset degrees.	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	self removeAllHandlesBut: rotHandle.	target rotationDegrees: degrees.	rotHandle position: evt position - (rotHandle extent // 2).	self someSubmorphPositionOrExtentChanged! !!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:27'!                  strokeGrow: evt with: growHandle	| dir |	evt keyValue = 28 ifTrue:[dir _ -1@0].	evt keyValue = 29 ifTrue:[dir _ 1@0].	evt keyValue = 30 ifTrue:[dir _ 0@-1].	evt keyValue = 31 ifTrue:[dir _ 0@1].	dir ifNil:[^self].	evt hand obtainHalo: self.	evt hand newKeyboardFocus: growHandle.	target extent: target extent + dir.	self someSubmorphPositionOrExtentChanged.! !!HandMorph methodsFor: 'layout' stamp: 'jmv 12/11/2011 16:03'!            fullBounds	"Extend my bounds by the shadow offset when carrying morphs."	self layoutSubmorphsAndComputeFullBounds.	^submorphs isEmpty		ifTrue: [ fullBounds ]		ifFalse: [ fullBounds topLeft corner: fullBounds bottomRight + self shadowOffset ]! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:27'!                              updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, and current typing emphasis."	paragraph ifNotNil: [		editor storeSelectionInParagraph.		self fit.		self someSubmorphPositionOrExtentChanged.	].	owner setScrollDeltas! !!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/11/2011 15:54'!              layoutSubmorphs	"Compute a new layout based on the given layout bounds."	submorphs isEmpty ifTrue: [		^fullBounds _ bounds].	direction == #horizontal ifTrue: [		self layoutSubmorphsHorizontallyIn: self layoutBounds ].	direction == #vertical ifTrue: [		self layoutSubmorphsVerticallyIn: self layoutBounds ]! !!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/11/2011 16:03'!                               layoutSubmorphsHorizontallyIn: boundsForLayout	"Compute a new layout based on the given layout bounds."	| usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |	usableWidth _ boundsForLayout width - ((submorphs size + 1) * separation).	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].	availableForPropWidth _ usableWidth - sumOfFixed.	padding ifNil: [	"shrink"		availableForPropWidth = 0 ifFalse: [			self width: self width - availableForPropWidth.			^ self layoutSubmorphsAndComputeFullBounds ]].	normalizationFactor _ self proportionalWidthNormalizationFactor.	availableForPropWidth _ availableForPropWidth * normalizationFactor.	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + separation max: 0) +  boundsForLayout left.	usableHeight _ boundsForLayout height - (2*separation) max: 0.	boundsTop _ boundsForLayout top.		boundsRight _ boundsForLayout right.	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |		m _ submorphs at: index.		w _ widths at: index.		"major direction"		r _ l + w min: boundsRight.		"minor direction"		ls _ m layoutSpec.		h _ (ls heightFor: usableHeight) min: usableHeight.		t _ (usableHeight - h) * ls minorDirectionPadding + separation + boundsTop.		b _ t + h.		"Set bounds and adjust major direction for next step"		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).		w > 0 ifTrue: [			l _ r + separation min: boundsRight ]]! !!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/11/2011 16:03'!                           layoutSubmorphsVerticallyIn: boundsForLayout	"Compute a new layout based on the given layout bounds."	| usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |	usableHeight _ boundsForLayout height - ((submorphs size + 1) * separation).	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].	availableForPropHeight _ usableHeight - sumOfFixed.	padding ifNil: [	"shrink"		availableForPropHeight = 0 ifFalse: [			self height: self height - availableForPropHeight.			^ self layoutSubmorphsAndComputeFullBounds ]].	normalizationFactor _ self proportionalHeightNormalizationFactor.	availableForPropHeight _ availableForPropHeight * normalizationFactor.	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + separation max: 0) +  boundsForLayout top.	usableWidth _ boundsForLayout width - (2*separation) max: 0.	boundsLeft _ boundsForLayout left.		boundsBottom _ boundsForLayout bottom.	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |		m _ submorphs at: index.		h _ heights at: index.		"major direction"		b _ t + h min: boundsBottom.		"minor direction"		ls _ m layoutSpec.		w _ (ls widthFor: usableWidth) min: usableWidth.		l _ (usableWidth - w) * ls minorDirectionPadding + separation + boundsLeft.		r _ l + w.		"Set bounds and adjust major direction for next step"		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).		h > 0 ifTrue: [			t _ b + separation min: boundsBottom ]]! !!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/11/2011 15:56'!       adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |	doNotResizeBelow _ self minPaneWidthForReframe.	i _ submorphs indexOf: aLayoutAdjustMorph.	l _ self submorphs at: i +1.	ls _ l layoutSpec.	lCurrentWidth _ l width max: 1.	"avoid division by zero"	r _ self submorphs at: i - 1.	rs _ r layoutSpec.	rCurrentWidth _ r width max: 1.	"avoid division by zero"	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.	delta _ delta max: doNotResizeBelow - lCurrentWidth.	delta _ delta min: rCurrentWidth - doNotResizeBelow.	delta = 0 ifTrue: [ ^self ].	rNewWidth _ rCurrentWidth - delta.	lNewWidth _ lCurrentWidth + delta.	(ls isProportionalWidth and: [ rs isProportionalWidth ])		ifTrue: [	"If both proportional, update them"			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]		ifFalse: ["If at least one is fixed, update only the fixed"			ls isProportionalWidth ifFalse: [				ls fixedOrMorphWidth: lNewWidth ].			rs isProportionalWidth ifFalse: [				rs fixedOrMorphWidth: rNewWidth ]].	self layoutSubmorphs.	fullBounds _ bounds! !!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/11/2011 15:56'!                 adjustVerticallyBy: aLayoutAdjustMorph at: aPoint	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |	doNotResizeBelow _ self minPaneHeightForReframe.	i _ submorphs indexOf: aLayoutAdjustMorph.	t _ self submorphs at: i +1.	ts _ t layoutSpec.	tCurrentHeight _ t height max: 1.	"avoid division by zero"	b _ self submorphs at: i - 1.	bs _ b layoutSpec.	bCurrentHeight _ b height max: 1.	"avoid division by zero"	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.	delta _ delta max: doNotResizeBelow - tCurrentHeight.	delta _ delta min: bCurrentHeight - doNotResizeBelow.	delta = 0 ifTrue: [ ^self ].	tNewHeight _ tCurrentHeight + delta.	bNewHeight _ bCurrentHeight - delta.	(ts isProportionalHeight and: [ bs isProportionalHeight ])		ifTrue: [	"If both proportional, update them"			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]		ifFalse: ["If at least one is fixed, update only the fixed"			ts isProportionalHeight ifFalse: [				ts fixedOrMorphHeight: tNewHeight ].			bs isProportionalHeight ifFalse: [				bs fixedOrMorphHeight: bNewHeight ]].	self layoutSubmorphs.	fullBounds _ bounds! !!LayoutMorph methodsFor: 'testing' stamp: 'jmv 12/11/2011 15:53'!                   clipsSubmorphs	^true! !!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 15:28'! extent: aPoint	bounds extent = aPoint ifFalse: [		self redrawNeeded.		bounds _ bounds topLeft extent: aPoint.		self buildMagnifiedBackgroundImage.		self someSubmorphPositionOrExtentChanged.		self redrawNeeded ].	worldState ifNotNil: [		worldState viewBox ifNotNil: [			worldState viewBox = bounds ifFalse: [				worldState canvas: nil.				worldState viewBox: bounds ]]]! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/11/2011 15:48'!                  someSubmorphPositionOrExtentChanged	"In some submorph or in self"	super someSubmorphPositionOrExtentChanged.	self updateScrollBarsBounds! !!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 15:28'!            addHandles	| handle newVert tri |	self removeHandles.	handles _ OrderedCollection new.	tri _ Array with: 0@-4 with: 4@3 with: -3@3.	vertices withIndexDo:		[ :vertPt :vertIndex |		handle _ EllipseMorph newBounds: (Rectangle center: vertPt extent: 8@8)				color: Color yellow.		handle on: #mouseMove send: #dragVertex:event:fromHandle:				to: self withValue: vertIndex.		handle on: #mouseUp send: #dropVertex:event:fromHandle:				to: self withValue: vertIndex.		self addMorph: handle.		handles addLast: handle.		(closed or: [vertIndex < vertices size]) ifTrue: [			newVert _ PolygonMorph					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])					color: Color green borderWidth: 1 borderColor: Color black.			newVert on: #mouseDown send: #newVertex:event:fromHandle:					to: self withValue: vertIndex.			self addMorph: newVert.			handles addLast: newVert]].	smoothCurve ifTrue: [self updateHandles; someSubmorphPositionOrExtentChanged].	self redrawNeeded! !!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 15:28'!        computeBounds	| oldBounds delta excludeHandles |	vertices ifNil: [^ self].	self redrawNeeded.	oldBounds _ bounds.	self releaseCachedState.	bounds _ self curveBounds truncated.	self arrowForms do:		[ :f | bounds _ bounds merge: (f offset extent: f extent)].	handles ifNotNil: [self updateHandles].	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [		excludeHandles _ IdentitySet new.		handles ifNotNil: [excludeHandles addAll: handles].		self submorphsDo: [ :each |			(excludeHandles includes: each) ifFalse: [				each position: each position + delta ] ] ].	self someSubmorphPositionOrExtentChanged.	self redrawNeeded.! !!SketchMorph methodsFor: 'accessing' stamp: 'jmv 12/11/2011 15:37'!             form: aForm	"Set the receiver's form"	| oldForm |	oldForm _ originalForm.	originalForm _ aForm.	self basicExtent: originalForm extent.	oldForm ifNotNil: [self position: self position + (oldForm extent - aForm extent // 2)].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 12/11/2011 15:29'!       collapseOrExpand	"Collapse or expand the window, depending on existing state"	isCollapsed		ifTrue: [ self expand ]		ifFalse: [ self collapse].	self someSubmorphPositionOrExtentChanged! !!SystemWindow methodsFor: 'layout' stamp: 'jmv 12/11/2011 15:54'!                           layoutSubmorphs	"Compute a new layout of submorphs based on the given layout bounds."	| bl br h thickness tl tr w cornerExtent |	submorphs isEmpty ifTrue: [		^fullBounds _ bounds].	thickness _ 4.	cornerExtent _ 20.	tl _ bounds topLeft.	tr _ bounds topRight.	bl _ bounds bottomLeft.	br _ bounds bottomRight.	w _ bounds width - cornerExtent - cornerExtent.	h _ bounds height - cornerExtent - cornerExtent.	(adjusters at: #topAdjuster) bounds: (tl + (cornerExtent@0) extent: w@thickness).	(adjusters at: #bottomAdjuster) bounds: (bl+ (cornerExtent @ thickness negated) extent: w@thickness).	(adjusters at: #leftAdjuster) bounds: (tl+ (0@cornerExtent) extent: thickness@h).	(adjusters at: #rightAdjuster) bounds: (tr + (thickness negated@ cornerExtent) extent: thickness@h).	(adjusters at: #topLeftAdjuster) bounds: (tl extent: cornerExtent@cornerExtent).	(adjusters at: #bottomLeftAdjuster) bounds: (bl-(0@cornerExtent) extent: cornerExtent@cornerExtent).	(adjusters at: #topRightAdjuster) bounds: (tr+(cornerExtent negated@0) extent: cornerExtent@cornerExtent).	(adjusters at: #bottomRightAdjuster) bounds: (br-cornerExtent extent: cornerExtent@cornerExtent).	layoutMorph ifNotNil: [		layoutMorph bounds: self layoutBounds ]! !!WorldState methodsFor: 'drawing' stamp: 'jmv 12/11/2011 16:03'!                          displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw allDamage |	submorphs do: [ :m | m layoutSubmorphsAndComputeFullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].	"repair world's damage on canvas"	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	allDamage _ Array streamContents: [ :strm |		strm nextPutAll: worldDamageRects.		handsToDraw do: [ :h | 			h savePatchFrom: canvas appendDamageTo: strm ]].	"draw hands onto world canvas"	handsToDraw reverseDo: [ :h | self drawHand: h ].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [ aWorld flashRects: allDamage ].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [ self forceDamageToScreen: allDamage ]		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].	"restore world canvas under hands"	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].	Display deferUpdates: false; forceDisplayUpdate! !!methodRemoval: SystemWindow #layoutAndComputeFullBounds!SystemWindow removeSelector: #layoutAndComputeFullBounds!!methodRemoval: SketchMorph #extent:!SketchMorph removeSelector: #extent:!!methodRemoval: SketchMorph #layoutChanged!SketchMorph removeSelector: #layoutChanged!!methodRemoval: PluggableScrollPane #layoutChanged!PluggableScrollPane removeSelector: #layoutChanged!!methodRemoval: LayoutMorph #layoutAndComputeFullBounds!LayoutMorph removeSelector: #layoutAndComputeFullBounds!!methodRemoval: Morph #doLayoutIfNeeded!Morph removeSelector: #doLayoutIfNeeded!!methodRemoval: Morph #layoutAndComputeFullBounds!Morph removeSelector: #layoutAndComputeFullBounds!!methodRemoval: Morph #layoutChanged!Morph removeSelector: #layoutChanged!!methodRemoval: ImageLW #layoutChanged!ImageLW removeSelector: #layoutChanged!!methodRemoval: LightWidget #layoutChanged!LightWidget removeSelector: #layoutChanged!