'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 2 May 2011 at 10:08:09 am'!!LightWidget methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:10'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"		self visible ifFalse: [^ self].	(aCanvas isVisible: self fullDisplayBounds) ifFalse:[^self].		self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].	aCanvas clipBy: self bounds during: [ :c | self drawOn: c ].! !!LightWidget methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:06'!shadowForm	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."	| canvas |	canvas _ Display defaultCanvasClass forShadowOver: bounds.	self fullDrawOn: canvas.	^ canvas formWithOffset! !!CompositeLW methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:06'!drawSubmorphsOn: aCanvas 	"Display submorphs back to front"	submorphs isEmpty ifTrue: [^self].	aCanvas clipBy: bounds during: [ :canvas |		submorphs reverseDo: [ :m | m fullDrawOn: canvas ]]! !!CompositeLW methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:09'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"		self visible ifFalse: [^ self].	(aCanvas isVisible: self fullDisplayBounds) ifFalse:[^self].		self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].	aCanvas clipBy: self bounds during: [ :c | self drawOn: c ].	self drawSubmorphsOn: aCanvas! !!Morph methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:07'!drawSubmorphsOn: aCanvas 	"Display submorphs back to front"	submorphs isEmpty ifTrue: [ ^ self ].	self clipsSubmorphs		ifTrue: [			aCanvas				clipBy: self clippingBounds				during: [ :clippedCanvas | 					submorphs reverseDo:						[ :m |  m fullDrawOn: clippedCanvas ] ] ]		ifFalse: [			submorphs reverseDo:				[ :m |  m fullDrawOn: aCanvas ] ]! !!Morph methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:11'!fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"	self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:[^self].		"Needs fullBounds 'in owner' if inside a scroller"	self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].	"Draw receiver itself"	(aCanvas isVisible: bounds) ifTrue: [		aCanvas clipBy: self bounds during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"	self drawSubmorphsOn: aCanvas.	self drawDropHighlightOn: aCanvas.	self drawMouseDownHighlightOn: aCanvas! !!Morph methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:08'!imageForm: depth forRectangle: rect	| canvas |	canvas _ Display defaultCanvasClass depth: depth over: rect.	self fullDrawOn: canvas.	^ canvas formWithOffset! !!Morph methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:11'!ownShadowForm	"Return a form representing the 'shadow' of the receiver, without including submorphs 	regardless of clipping"	| canvas |	canvas _ Display defaultCanvasClass forShadowOver: bounds.	canvas clipBy: self bounds during: [ :c | self drawOn: c ].	^ canvas formWithOffset! !!Morph methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:08'!shadowForm	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."	| bnds canvas |	bnds _ self fullBounds.	canvas _ Display defaultCanvasClass forShadowOver: bnds.	self fullDrawOn: canvas.	^ canvas formWithOffset! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'jmv 5/2/2011 09:59'!mouseDown: evt	| localPt |	localPt _ evt position - bounds topLeft.	self deleteAllBalloons.	clickedTranslucency _ TransparentBox containsPoint: localPt.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt)			ifTrue: [^ evt hand grabMorph: self].	].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	self inhibitDragging ifFalse: [self comeToFront].	sourceHand _ evt hand.	self startStepping.! !!ColorPickerMorph methodsFor: 'geometry testing' stamp: 'jmv 5/2/2011 09:59'!containsPoint: aPoint	^ (bounds containsPoint: aPoint)		or: [ RevertBox containsPoint: aPoint - bounds topLeft ]! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 5/2/2011 09:59'!pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt oldCursor |	aHand _ aMorph isNil		ifTrue: [self world activeHand] 		ifFalse: [ aMorph activeHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullDisplayBounds.	self owner ifNil: [^ self].	oldCursor _ Sensor currentCursor.	ColorPickerMorph eyeDropperCursor show.	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	localPt _World activeHand position - bounds topLeft.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt) ifTrue:			["Click or drag the drag-dot means to anchor as a modeless picker"			^ self anchorAndRunModeless: aHand].	].	(clickedTranslucency _ TransparentBox containsPoint: localPt)		ifTrue: [selectedColor _ originalColor].	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	aHand newMouseFocus: nil;		flushEvents.	oldCursor show.	self delete.		  ! !!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 5/2/2011 10:00'!cartesianOrigin	^ bounds bottomLeft! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 5/2/2011 10:00'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest cpHere |	selectionInterval _ self editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [event anyButtonPressed]) ifTrue: [  "Check for autoscroll"		cpHere _ scroller externalizePosition: event position to: self.		cpHere y <= bounds top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= bounds bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ textMorph bounds: rectToTest in: self.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!TransformMorph methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:08'!drawSubmorphsOn: aCanvas	| clippedCanvas |	clippedCanvas _ aCanvas		copyOffset: self txOffset negated truncated		clipRect: self innerBounds.	submorphs reverseDo: [ :m | m fullDrawOn: clippedCanvas ]! !!WorldState methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:11'!drawHand: aHandMorph	| bw r |	Preferences fastDragWindowForMorphic ifTrue: [		bw _ HandMorph fastDragBorderWidth // 2.		r _ aHandMorph fullDisplayBounds.		canvas frameRectangle: r borderWidth: bw color: Color black.		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.		canvas clipBy: aHandMorph bounds during: [ :c | aHandMorph drawOn: c ]]	ifFalse: [		aHandMorph fullDrawOn: canvas ]! !!WorldState methodsFor: 'drawing' stamp: 'jmv 4/29/2011 16:12'!drawInvalidAreasWorld: aWorld submorphs: submorphs	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."	initialRectsToRepair _ OrderedCollection new.	(damageRecorder invalidRectsFullBounds: aWorld viewBox) do: [ :r |		r ifNotNil: [ initialRectsToRepair addLast: r ]].	damageRecorder reset.	currentRectsToRepair _ OrderedCollection new.	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.	morphsToDraw _ OrderedCollection new.	rectsForEachMorph _ OrderedCollection new.	thisMorphRects _ OrderedCollection new.	n _ submorphs size.	i _ 1.	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [		morph _ submorphs at: i.		morph visible ifTrue: [			morphBounds _morph fullDisplayBounds.			reuse _ currentRectsToRepair.			currentRectsToRepair _ newRectsToRepair.			newRectsToRepair _ reuse removeAll.			currentRectsToRepair do: [ :r |				(morphBounds intersects: r)					ifTrue: [						morphClipRect _ morphBounds intersect: r.						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]					ifFalse: [						newRectsToRepair add: r ]].			thisMorphRects ifNotEmpty: [				morphsToDraw add: morph.				rectsForEachMorph add: thisMorphRects.				thisMorphRects _ OrderedCollection new.			]].		i _ i + 1 ].	i > n  ifTrue: [		newRectsToRepair do: [ :r |			(canvas copyClipRect: r) clipBy: aWorld bounds during: [ :c | aWorld drawOn: c ]]].	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |		"Here we could merge all xrects into just one call... Most likely, that would be slower, though.""		rr _ nil."		xrects do: [ :r |"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."			m fullDrawOn: (canvas copyClipRect: r)		]."		(canvas copyClipRect: rr) fullDrawMorph: m "	].		"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...	(think of vnc over slow networks)"	^ initialRectsToRepair! !Morph removeSelector: #externalizePositionToWorld:!Morph removeSelector: #externalizeScalar:to:!Morph removeSelector: #internalizePositionFromWorld:!Morph removeSelector: #internalizeScalar:from:!Morph removeSelector: #internalizeVector:from:!FormCanvas removeSelector: #drawMorph:!FormCanvas removeSelector: #fullDrawMorph:!