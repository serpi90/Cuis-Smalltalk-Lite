'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 3 December 2010 at 2:41:53 pm'!!classDefinition: #PluggableListMorphOfMany category: #'Morphic-Windows'!PluggableListMorph subclass: #PluggableListMorphOfMany	instanceVariableNames: 'dragOnOrOff getSelectionListSelector setSelectionListSelector dragStartRow '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/3/2010 14:36'!mouseDown: event	| oldIndex oldVal row |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row := self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifTrue: ["No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForSimulatedYellow: self		event: event		dblClkSel: #doubleClick:! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/3/2010 14:40'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |	event position y < self top 		ifTrue: [			scrollBar scrollUp: 1.			row := self rowAtLocation: scroller topLeft + (1 @ 1)]		ifFalse: [			row := event position y > self bottom 				ifTrue: 					[scrollBar scrollDown: 1.					self rowAtLocation: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^self].	"No change if model is locked"	dragOnOrOff ifNil: [			"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff := (self listSelectionAt: row) not].	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [self changeModelSelection: row]		ifFalse: [self changeModelSelection: 0].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		"Select all in between if drag was too fast"	"self listSelectionAt: row put: dragOnOrOff."	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |		self listSelectionAt: r put: dragOnOrOff].		row changed! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/3/2010 14:37'!mouseUp: event	dragOnOrOff _ nil.  "So improperly started drags will have not effect"	dragStartRow _ nil! !!classDefinition: #PluggableListMorphOfMany category: #'Morphic-Windows'!PluggableListMorph subclass: #PluggableListMorphOfMany	instanceVariableNames: 'dragOnOrOff getSelectionListSelector setSelectionListSelector dragStartRow'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!