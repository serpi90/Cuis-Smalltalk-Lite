'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 8 June 2011 at 3:17:03 pm'!!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 6/8/2011 15:10'!model: aTextModel wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result."	wrapFlag _ true.	self basicExtent: width truncated@self height.	self model: aTextModel! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 6/8/2011 15:02'!installEditorToReplace: priorEditor 	"Install an editor for my paragraph. Install also the paragraph if not there.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [ stateArray _ priorEditor stateArray] .	editor _ self editorClass new morph: self.	editor model: model.	paragraph		ifNotNil: [			editor changeParagraph: paragraph.			editor resetState ]		ifNil: [			"...Code here to recreate the paragraph..."			paragraph _ Paragraph new.			paragraph focused: self hasKeyboardFocus.			paragraph setModel: model container: self container.			editor changeParagraph: paragraph.			editor setEmphasisHereFromText.			paragraph composeAll.			wrapFlag ifFalse: [				"Was given huge container at first... now adjust"				paragraph adjustRightX].			self fit.			editor resetState.		].	stateArray ifNotNil: [ editor stateArrayPut: stateArray ].	self selectionChanged.	^editor! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 6/8/2011 14:24'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	"Installs both editor and paragraph."	self installEditorToReplace: editor.	^ paragraph! !!Paragraph methodsFor: 'access' stamp: 'jmv 6/8/2011 14:27'!editor: anEditor	"Can be nil.	But if not nil, must be the same editor used in any TextMorph that references us."	editor _ anEditor! !!Paragraph methodsFor: 'composition' stamp: 'jmv 6/8/2011 14:32'!setModel: aTextModel container: textContainer	model _ aTextModel.	container _ textContainer! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 6/8/2011 14:58'!pointIndex	pointBlock ifNil: [^1].	^ pointBlock stringIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 6/8/2011 14:43'!startIndex	pointBlock ifNil: [^1].	^ self startBlock stringIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 6/8/2011 14:50'!stopIndex	pointBlock ifNil: [^1].	^ self stopBlock stringIndex! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 6/8/2011 15:02'!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	UndoParagraph == paragraph ifTrue: [UndoParagraph _ nil].	paragraph _ aParagraph.	paragraph editor: self! !!Transcripter methodsFor: 'initialization' stamp: 'jmv 6/8/2011 15:05'!initInFrame: rect	frame _ rect insetBy: 2.  "Leave room for border"	para _ Paragraph new.	para		setModel: (TextModel withText: self contents asText)		container: ((frame insetBy: 4) withHeight: 9999).	para composeAll! !!Transcripter methodsFor: 'accessing' stamp: 'jmv 6/8/2011 15:05'!endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue: [		"Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para		setModel: (TextModel withText: c asText)		container: ((frame insetBy: 4) withHeight: 9999).	para composeAll.	d _ para extent y - frame height.	d > 0 ifTrue: [		"Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint:			para compositionRectangle topLeft + (0@(d+StrikeFont default height)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	Display getCanvas		paragraph: para 		bounds: (0@0 extent: Display extent) 		color: Color black! !Paragraph removeSelector: #model:in:!