'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 10 March 2011 at 3:10:16 pm'!!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 3/9/2011 13:39'!keyStroke: evt 	| matchString char asc selectable help |	help _ BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.	char := evt keyCharacter.	asc := char asciiValue.	char = Character cr 		ifTrue: 			[selectedItem ifNotNil: 					[selectedItem hasSubMenu 						ifTrue: 							[evt hand newMouseFocus: selectedItem subMenu.							^evt hand newKeyboardFocus: selectedItem subMenu]						ifFalse: 							["self delete."							^selectedItem invokeWithEvent: evt]].			(selectable := self items) size = 1 				ifTrue: [^selectable first invokeWithEvent: evt].			^self].	asc = 27 		ifTrue: 			["escape key"			self valueOfProperty: #matchString				ifPresentDo: 					[:str | 					str isEmpty 						ifFalse: 							["If filtered, first ESC removes filter"							self setProperty: #matchString toValue: String new.							self selectItem: nil event: evt.							^self displayFiltered: evt]].			"If a stand-alone menu, just delete it"			popUpOwner ifNil: [^self delete].			"If a sub-menu, then deselect, and return focus to outer menu"			self selectItem: nil event: evt.			evt hand newMouseFocus: popUpOwner owner.			^evt hand newKeyboardFocus: popUpOwner owner].	(asc = 28 or: [asc = 29]) 		ifTrue: 			["left or right arrow key"			(selectedItem notNil and: [selectedItem hasSubMenu]) 				ifTrue: 					[evt hand newMouseFocus: selectedItem subMenu.					selectedItem subMenu moveSelectionDown: 1 event: evt.					^evt hand newKeyboardFocus: selectedItem subMenu]].	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: evt].	"up arrow key"	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: evt].	"down arrow key"	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: evt].	"page up key"	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: evt].	"page down key"	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].	matchString := char = Character backspace 				ifTrue: 					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]				ifFalse: [matchString copyWith: evt keyCharacter].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt.	help _ BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.! !!PluggableListMorph methodsFor: 'menu' stamp: 'jmv 3/9/2011 13:38'!getMenu	"Answer the menu for this view"	menuGetter ifNil: [^ nil].	menuGetter numArgs = 0 ifTrue: [		^ model perform: menuGetter ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 3/10/2011 15:09'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu := MenuMorph new defaultTarget: self.	self colorForDebugging: menu.	menu addStayUpIcons.	self fillIn: menu		from: { 				{ 					'restore display (r)'.					{ 						World.						#restoreMorphicDisplay}.					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.				nil}.	Preferences simpleMenus 		ifFalse: 			[self fillIn: menu				from: { 						{ 							'open...'.							{ 								self.								#openWindow}}.						{ 							'windows...'.							{ 								self.								#windowsDo}}.						{ 							'changes...'.							{ 								self.								#changesDo}}}].	self fillIn: menu		from: { 				{ 					'help...'.					{ 						self.						#helpDo}.					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.				{ 					'appearance...'.					{ 						self.						#appearanceDo}.					'put up a menu offering many controls over appearance.'}}.	Preferences simpleMenus 		ifFalse: 			[self fillIn: menu				from: { 						{ 							'do...'.							{ 								Utilities.								#offerCommonRequestsInMorphic}.							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].	self fillIn: menu		from: { 				nil.				{ 					'new morph...'.					{ 						self.						#newMorph}.					'Offers a variety of ways to create new objects'}.				}.	Preferences simpleMenus 		ifFalse: 			[self fillIn: menu				from: { 						{ 							'debug...'.							{ 								self.								#debugDo}.							'a menu of debugging items'}}].	self fillIn: menu		from: { 				nil.				{ 					'save'.					{ 						Smalltalk .						#saveSession}.					'save the current version of the image on disk'}.				{ 					'save as...'.					{ 						Smalltalk .						#saveAs}.					'save the current version of the image on disk under a new name.'}.				{ 					'save as new version'.					{ 						Smalltalk .						#saveAsNewVersion}.					'give the current image a new version-stamped name and save it under that name on disk.'}.				{ 					'save and quit'.					{ 						self.						#saveAndQuit}.					'save the current image on disk, and quit out of Cuis.'}.				{ 					'quit'.					{ 						self.						#quitSession}.					'quit out of Cuis.'}}.	^menu! !!TheWorldMenu methodsFor: 'mechanics' stamp: 'jmv 3/9/2011 13:39'!menu: titleString	"Create a menu with the given title, ready for filling"	| menu |	(menu _ MenuMorph entitled: titleString) 		defaultTarget: self; 		addStayUpIcons.	self colorForDebugging: menu.	^ menu! !PluggableListMorph removeSelector: #commandKeyTypedIntoMenu:!MenuMorph removeSelector: #commandKeyHandler!MenuMorph removeSelector: #commandKeyHandler:!