'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 11 July 2011 at 4:02:51 pm'!!DamageRecorder methodsFor: 'recording' stamp: 'jmv 7/11/2011 15:42'!recordInvalidRect: requestedRect	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle.	jmv: Important. There should be no overlapping rectangles in the list. If there are, translucent morphs might be drawn several times, with visible defects.	WRT performance, the different paths for various intersections seem a bit complicated. I could not find strong evidence of the best way.	Leave it as it is right now."	| newRect mergeRect a indexToReuse |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	indexToReuse _ nil.	newRect _ requestedRect truncated.	invalidRects doWithIndex: [ :rect :index |		rect ifNil: [			indexToReuse ifNil: [ indexToReuse _ index ]]		ifNotNil: [			"No two rectangles should intersect"			(rect intersects: newRect) ifTrue: [				"requestedRect (possibly smaller than newRect) already in. Nothing to do then."				(rect containsRect: requestedRect) ifTrue: [ 					^self ].				"Some rect included in newRect. Remove it and continue, as newRect could still intersect others."				(newRect containsRect: rect) ifTrue: [					invalidRects at: index put: nil.	"Effectively like 'invalidRects remove: rect', but without performance penalty."					indexToReuse ifNil: [ indexToReuse _ index ]].							"Merge rectangles if they overlap significantly"				a _ (rect intersect: newRect) area.				(a > 40					and: ["Avoid combining a vertical and horizontal rects.						  Can make a big diff and we only test when likely."						  a > (newRect area // 4) or: [ a > (rect area // 4)]])				ifTrue: [					"Merge into newRect, as any overlap with forecoming rectangles in the iteration is detected and treated."					"Before modifying newRect, ensure making a copy: we don't want to break rectangles that belong to someone else (i.e. some morph bounds)"					newRect == requestedRect ifTrue: [						newRect _ (rect origin min: newRect origin) corner: (rect corner max: newRect corner) ]					ifFalse: [						newRect							setOrigin: (rect origin min: newRect origin)							corner: (rect corner max: newRect corner) ].					invalidRects at: index put: nil.	"Effectively like 'invalidRects remove: rect', but without performance penalty."					indexToReuse ifNil: [ indexToReuse _ index ]]				ifFalse: [					"Avoid intersections!!"					newRect areasOutside: rect do: [ :nonIntersection |						"We have brand new newRects. Start all over with each of them."						self recordInvalidRect: nonIntersection ].					"newRect no longer needed, then."					^self ]]]].	invalidRects size >= 15 ifTrue: [		"if there are too many separate areas, merge them all"		mergeRect _ Rectangle merging: invalidRects.		self reset.		mergeRect ifNotNil: [			invalidRects addLast: mergeRect ].		indexToReuse _ nil ].	"Ensure making a copy: we don't want to break rectangles that belong to someone else (i.e. some morph bounds)	(note: no need to send #truncated, because if that was needed, we'd already have a truncated copy!!)"	newRect == requestedRect ifTrue: [		newRect _ requestedRect origin corner: requestedRect corner ].	"add the given rectangle to the damage list"	indexToReuse		ifNil: [			invalidRects addLast: newRect ]		ifNotNil: [			invalidRects at: indexToReuse put: newRect ]! !!Rectangle class methodsFor: 'instance creation' stamp: 'jmv 7/11/2011 15:40'!merging: listOfRects 	"A number of callers of merge: should use this method.	Note: ignore possible nils in the argument."	| minX minY maxX maxY |	listOfRects		do: [ :r | 			r ifNotNil: [				minX					ifNil: [						minX _ r topLeft x. minY _ r topLeft y.						maxX _ r bottomRight x. maxY _ r bottomRight y]					ifNotNil: [						minX _ minX min: r topLeft x. minY _ minY min: r topLeft y.						maxX _ maxX max: r bottomRight x. maxY _ maxY max: r bottomRight y]]].	^ minX ifNotNil: [ minX@minY corner: maxX@maxY ]! !!WorldTest methodsFor: 'Running' stamp: 'jmv 7/11/2011 16:02'!testDamageRecorder	"	WorldTest new testDamageRecorder	"	| dr |	dr _ DamageRecorder new.	dr recordInvalidRect: (20@20 extent: 10@10).	dr recordInvalidRect: (30@20 extent: 10@10).	dr recordInvalidRect: (40@20 extent: 10@10).	dr recordInvalidRect: (50@20 extent: 10@10).	dr recordInvalidRect: (60@20 extent: 10@10).	dr recordInvalidRect: (70@20 extent: 10@10).	dr recordInvalidRect: (80@20 extent: 10@10).	dr recordInvalidRect: (90@20 extent: 10@10).	dr recordInvalidRect: (100@20 extent: 10@10).	dr recordInvalidRect: (110@20 extent: 10@10).	dr recordInvalidRect: (120@20 extent: 10@10).	dr recordInvalidRect: (130@20 extent: 10@10).	dr recordInvalidRect: (140@20 extent: 10@10).	dr recordInvalidRect: (150@20 extent: 10@10).	dr recordInvalidRect: (160@20 extent: 10@10).	self shouldnt: [ dr recordInvalidRect: (10@20 extent: 300@300) ] raise: Error.	(dr invalidRectsFullBounds: (10@10 extent: 10@10)) do: [ :r |		self deny: r isNil ]! !!WorldTest reorganize!('as yet unclassified' testDoOneCycleWorksWithDeferredQueue)('Running' testDamageRecorder)!