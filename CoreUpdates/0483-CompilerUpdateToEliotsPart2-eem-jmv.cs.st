'From Cuis 2.3 of 22 March 2010 [latest update: #472] on 7 April 2010 at 10:23:12 am'!!BlockNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:04'!sizeForEvaluatedValue: encoder	^(self sizeExceptLast: encoder)		+ (statements last sizeForBlockValue: encoder)! !!Encoder methodsFor: 'encoding' stamp: 'eem 9/3/2009 10:50'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode := self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [^action value]].	range ifNotNil: [		name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:33'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:32'!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifTrue:		[((caseNode blockAssociationCheck: encoder)		  and: [arguments size = 1			    or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder]]) ifFalse:			[^false].		 caseNode elements do:			[:messageNode|			messageNode receiver noteOptimizedIn: self.			messageNode arguments first noteOptimizedIn: self].		 arguments size = 2 ifTrue:			[arguments last noteOptimizedIn: self].		 ^true].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not]) ifTrue:		[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:31'!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment := encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit := arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:17'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).		 receiver noteOptimizedIn: self.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimizedIn: self.			arguments first noteOptimizedIn: self.			true]! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'jmv 4/7/2010 09:51'!addRemoteTemp: aTempVariableNode encoder: encoder	remoteTemps ifNil: [		remoteTemps _ OrderedCollection new].	(remoteTemps includes: aTempVariableNode) ifTrue:		[self halt].	remoteTemps addLast: aTempVariableNode.	aTempVariableNode referenceScopesAndIndicesDo: [:scopeBlock "<BlockNode>" :location "<Integer>"|		self addReadWithin: scopeBlock at: location].	encoder supportsClosureOpcodes ifFalse: [		encoder encodeLiteral: remoteTemps size.		readNode _ encoder encodeSelector: #at:.		writeNode _ encoder encodeSelector: #at:put:]! !!Scanner methodsFor: 'public access' stamp: 'eem 8/20/2008 20:55'!scanTokens: textOrString 	"Answer an Array that has been tokenized as though the input text, 	textOrString, had appeared between the array delimitors #( and ) in a 	Smalltalk literal expression."	self initScannerForTokenization.	self scan: (ReadStream on: textOrString asString).	self scanLitVec.	^token	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !!Parser methodsFor: 'primitives' stamp: 'jmv 4/7/2010 09:38'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType modifier retType externalName args argType module fn |	descriptorClass _ Smalltalk at: #ExternalFunction ifAbsent: nil.	descriptorClass == nil ifTrue:[^false].	callType _ descriptorClass callingConventionFor: here.	descriptorClass		ifNil: [^ false].	[modifier _ descriptorClass callingConventionModifierFor: token.	 modifier notNil] whileTrue:		[self advance.		 callType _ callType bitOr: modifier].	"Parse return type"	self advance.	retType _ self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName _ here.	(self match: #string) 		ifTrue:[externalName _ externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args _ WriteStream on: Array new.	[here == #')'] whileFalse:[		argType _ self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken: #')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module _ here.		(self match: #string) ifFalse:[^self expected: 'String'].		module _ module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn _ xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	(self matchToken: 'error:')		ifTrue:			[| errorCodeVariable |			 errorCodeVariable _ here.			(hereType == #string			 or: [hereType == #word]) ifFalse:[^self expected: 'error code (a variable or string)'].			 self advance.			 self addPragma: (Pragma keyword: #primitive:error: arguments: (Array with: 120 with: errorCodeVariable)).			 fn ifNotNil: [fn setErrorCodeName: errorCodeVariable]]		ifFalse:			[self addPragma: (Pragma keyword: #primitive: arguments: #(120))].	^true! !!Scanner class methodsFor: 'testing' stamp: 'jmv 4/7/2010 10:12'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i := aSymbol size.	i = 0 ifTrue: [^ false].	ascii := (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type := TypeTable at: ascii ifAbsent: [#xLetter].	type == #xBinary ifTrue:		[^i <= 2		  and: [i = 1 or: [(TypeTable at: (aSymbol at: 2) asciiValue ifAbsent: []) == #xBinary]]].	(type == #xColon or: [type == #verticalBar]) ifTrue:		[^i = 1].	type == #xLetter ifTrue:		[[i > 1] whileTrue:			[ascii := (aSymbol at: i) asciiValue.			ascii = 0 ifTrue: [^false].			type := TypeTable at: ascii ifAbsent: [#xLetter].			(type == #xLetter or: [type == #xDigit or: [type == #xColon]]) ifFalse:				[^false].			i := i - 1].		^true].	^false! !!Scanner class methodsFor: 'class initialization' stamp: 'ar 4/5/2006 01:31'!initialize	| newTable |	newTable := Array new: 256 withAll: #xIllegal. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	1 to: 255		do: [:index |			(Character value: index) isLetter				ifTrue: [newTable at: index put: #xLetter]].	newTable atAll: '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #xUnderscore.	newTable at: $| asciiValue put: #verticalBar.	TypeTable := newTable "bon voyage!!"	"Scanner initialize"! !Scanner initialize!BlockNode removeSelector: #noteOptimized!