'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 18 November 2011 at 10:58:41 pm'!!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 7/29/2008 20:09'!ensureExtentsMapsInitialized	| encoderTempRefs "<Dictionary of: Interval -> <Array of: <String | <Array of: String>>>>" |	blockExtentsToTempRefs ifNotNil: [^self].	blockExtentsToTempRefs := Dictionary new.	startpcsToTempRefs := Dictionary new.	encoderTempRefs := methodNode blockExtentsToTempRefs.	encoderTempRefs keysAndValuesDo:		[:blockExtent :tempVector|		blockExtentsToTempRefs			at: blockExtent			put: (Array streamContents:					[:stream|					tempVector withIndexDo:						[:nameOrSequence :index|						nameOrSequence isString							ifTrue:								[stream nextPut: {nameOrSequence. index}]							ifFalse:								[nameOrSequence withIndexDo:									[:name :indirectIndex|									stream nextPut: { name. { index. indirectIndex }}]]]])]! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 10/7/2011 10:19'!   privateDereference: tempReference in: aContext	"Fetch the temporary with reference tempReference in aContext.	 tempReference can be		integer - direct temp reference		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index		#( outer. temp reference ) - a temp reference in an outer context."	^tempReference isInteger		ifTrue:			[aContext tempAt: tempReference]		ifFalse:			[tempReference first == #outer				ifTrue:					[self privateDereference: tempReference last						in: aContext outerContext]				ifFalse: "If stopped before indirection vectors are created they will be nil. Simply answer nil"					[(aContext tempAt: tempReference first) ifNotNil:						[:indirectionVector|						indirectionVector at: tempReference second]]]! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'jmv 11/18/2011 22:24'!                          privateDereference: tempReference in: aContext put: aValue	"Assign the temporary with reference tempReference in aContext.	 tempReference can be		integer - direct temp reference		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index		#( outer. temp reference ) - a temp reference in an outer context."	^tempReference isInteger		ifTrue:			[aContext tempAt: tempReference put: aValue]		ifFalse:			[tempReference first == #outer				ifTrue:					[self privateDereference: tempReference last						in: aContext outerContext						put: aValue]				ifFalse: "If stopped before indirection vectors are created they will be nil."					[(aContext tempAt: tempReference first)						ifNil: [ self inform: 'Cannot assign remote temp because indirection vector is nil.\Too early in method execution?' withCRs.							nil]						ifNotNil:							[:indirectionVector|							indirectionVector								at: tempReference second								put: aValue]]]! !!FloatTest methodsFor: 'NaN behavior' stamp: 'jmv 11/18/2011 22:54'!         testNaN2	"Two NaN values are always considered to be different.	On an little-endian machine (32 bit Intel), Float nan is 16rFFF80000 16r00000000.	On a big-endian machine (PowerPC), Float nan is 16r7FF80000 16r00000000. Changing	the bit pattern of the first word of a NaN produces another value that is still	considered equal to NaN. This test should work on both little endian and big	endian machines. However, it is not guaranteed to work on future 64 bit versions	of Squeak, for which Float may have different internal representations."	"FloatTest new testNaN2"	| nan1 nan2 |	nan1 := Float nan copy.	nan2 := Float nan copy.	"test two instances of NaN with the same bit pattern"	self deny: nan1 = nan2.	self deny: nan1 == nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1.	"change the bit pattern of nan1"	self assert: nan1 size = 2.	self assert: (nan1 at: 2) = 0.	nan1 at: 1 put: (nan1 at: 1) + 999.	self assert: nan1 isNaN.	self assert: nan2 isNaN.	self deny: (nan1 at: 1) = (nan2 at: 1).	"test two instances of NaN with different bit patterns"	self deny: nan1 = nan2.	self deny: nan1 == nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 11/1/2011 18:09'!           ln	"This function is defined because super ln might overflow."	| res |	self <= 0 ifTrue: [DomainError signal: 'ln is only defined for x > 0'].	"Test self < 1 before converting to float in order to avoid precision loss due to gradual underflow."	numerator < denominator ifTrue: [^self reciprocal ln negated].	res := super ln.	res isFinite ifTrue: [^res].	^numerator ln - denominator ln! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 11/1/2011 18:08'!     log	"This function is defined because super log might overflow."	| res |	self <= 0 ifTrue: [DomainError signal: 'log is only defined for x > 0'].	"Test self < 1 before converting to float in order to avoid precision loss due to gradual underflow."	numerator < denominator ifTrue: [^self reciprocal log negated].	res := super log.	res isFinite ifTrue: [^res].	^numerator log - denominator log! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:06'!                 ln	"This function is defined because super ln might overflow."	| res h |	res := super ln.	res isFinite ifTrue: [^res].	h := self highBit.	^2 ln * h + (self / (1 << h)) asFloat ln! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:05'!         log	"This function is defined because super log might overflow."	| res h |	res := super log.	res isFinite ifTrue: [^res].	h := self highBit.	^2 log * h + (self / (1 << h)) asFloat log! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:06'!   ln	^DomainError signal: 'ln is only defined for x > 0' from: 0! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:06'!  log	^DomainError signal: 'log is only defined for x > 0' from: 0! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 11/18/2011 22:47'!            getSystemAttribute: attributeID  	"Optional. Answer the string for the system attribute with the given   	integer ID. Answer nil if the given attribute is not defined on this   	platform. On platforms that support invoking programs from command   	lines (e.g., Unix), this mechanism can be used to pass command line   	arguments to programs written in Squeak.    	By convention, the first command line argument that is not a VM  	configuration option is considered a 'document' to be filed in. Such a  	document can add methods and classes, can contain a serialized object,  	can include code to be executed, or any combination of these.    	Currently defined attributes include:   	-1000	1000th command line argument that specify VM options  	...  	-1		first command line argument that specify VM options  	0		the full path name for currently executing VM  			(or, on some platforms, just the path name of the VM's directory)   	1		full path name of this image (better use primImageName instead)  	2		a Squeak document to open, if any   	3		first command line argument for Squeak programs  	...  	1000	1000th command line argument for Squeak programs  	1001	this platform's operating system 'Mac OS', 'Win32', 'unix', ...  	1002	operating system version  	1003	this platform's processor type  	1004	vm version  	1005	window system name  	1006	vm build id  	1007	Interpreter class (Cog VM only)  	1008	Cogit class (Cog VM only) 	1009	Platform source version (Cog VM only?)  	1201	max filename length (Mac OS only)  	1202	file last error (Mac OS only)  	10001	hardware details (Win32 only)  	10002	operating system details (Win32 only)  	10003	graphics hardware details (Win32 only)  	"	<primitive: 149>	^ nil! !