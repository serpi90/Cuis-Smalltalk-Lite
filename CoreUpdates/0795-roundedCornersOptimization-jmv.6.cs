'From Cuis 3.0 of 31 January 2011 [latest update: #790] on 16 February 2011 at 11:40:47 am'!!Canvas methodsFor: 'drawing-general' stamp: 'jmv 2/10/2011 15:42'!drawMorph: aMorph	self clipBy: aMorph bounds during: [ :c | aMorph drawOn: c]! !!Canvas methodsFor: 'drawing-general' stamp: 'jmv 2/10/2011 15:41'!fullDrawMorph: aMorph	aMorph fullDrawOn: self! !!Color methodsFor: 'testing' stamp: 'jmv 2/10/2011 21:46'!mightBeTranslucent	"For Colors, answer if actually translucent or not."	^self isOpaque not! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 2/10/2011 21:40'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| f |	self shadowColor ifNotNil: [		^self fillRectangle: aRectangle color: aFillStyle asColor ].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		f _ aFillStyle form.		^self fillRectangle: aRectangle tilingWith: f sourceRect: f boundingBox rule: Form paint ].	self fillRectangle: aRectangle color: aFillStyle asColor! !!LightWidget methodsFor: 'drawing' stamp: 'jmv 2/10/2011 15:58'!possiblyUncoveredAreasIn: aRectangle	"May be overridden by any subclasses with opaque regions"	^ Array with: aRectangle! !!Morph methodsFor: 'drawing' stamp: 'jmv 2/10/2011 16:18'!possiblyUncoveredAreasIn: aRectangle	"Answer an array of rectangles encompassing those areas in aRectangle not completely	covered by self.	All areas that might possibly be uncovered must be included."	(self isOrthoRectangularMorph and: [ self isOpaqueMorph ]) ifTrue: [		^aRectangle areasOutside: bounds ].	^ Array with: aRectangle! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 2/16/2011 11:40'!possiblyUncoveredAreasIn: aRectangle	"Answer an array of rectangles encompassing those areas in aRectangle not completely	covered by self. These are the areas that might require further drawing (of morphs below us)	All areas that might possibly be uncovered must be included."	 | candidate r |	self fillStyle mightBeTranslucent ifTrue: [		^ Array with: aRectangle ].	"Solid rectangle.	This will be the fastest in many cases. So, disable rounded corners if on slow hardware!!"	Theme current roundWindowCorners ifFalse: [		^aRectangle areasOutside: bounds ].	"The solid rectangle does not include the corners.	Report a couple of rows (top and bottom) or columnas (left and right).	We could also try to be more careful and consider each rounded corner.	But it is of no use currently, the answer is only used if it encompasses a single rectangle (see senders).	So, instead, try to answer a single rectangle if possible"	"Try first 2 rows"	r _ Theme current roundedWindowRadius.	candidate _ aRectangle areasOutside: 		(bounds insetBy: 0@r).	candidate size = 1 ifTrue: [ ^ candidate ].	"2 rows failed to find a single rectangle. Try with 2 columns"	^aRectangle areasOutside: 		(bounds insetBy: r@0)! !!SystemWindow methodsFor: 'testing' stamp: 'jmv 2/10/2011 22:09'!isOpaqueMorph	"Not really used, as we also reimplement #possiblyUncoveredAreasIn:"	^(Theme current roundWindowCorners or: [ self fillStyle mightBeTranslucent ]) not! !!WorldState methodsFor: 'update cycle' stamp: 'jmv 2/10/2011 22:54'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect validList |	rectList _ damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"	rectList _ rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].	damageRecorder reset.	n _ submorphs size.	morphs _ OrderedCollection new: n * 2.	rects _ OrderedCollection new: n * 2.	validList _ OrderedCollection new: n * 2.	rectList do: [ :dirtyRect | 		dirtyRect			allAreasOutsideList: validList			do: [ :r | 				"Experimental top-down drawing --				Traverses top to bottom, stopping if the entire area is filled.				If only a single rectangle remains, then continue with the reduced rectangle."				rectToFill _ r.				i _ 1.				[ rectToFill isNil or: [ i > n ]] whileFalse: [					mm _ submorphs at: i.					((mm fullDisplayBounds intersects: r) and: [ mm visible ]) ifTrue: [						morphs addLast: mm.						rects addLast: rectToFill.						"(jmv) it would be nice to be able to use reduced rectangles if they are more than 1..."						remnants := mm possiblyUncoveredAreasIn: rectToFill.						remnants size = 1 ifTrue: [ rectToFill _ remnants first ].						remnants isEmpty ifTrue: [ rectToFill _ nil ]].					i _ i + 1 ].				"Now paint from bottom to top, but using the reduced rectangles."				rectToFill 					ifNotNil: [ aWorld drawOn: (c _ aCanvas copyClipRect: rectToFill)].				[ morphs isEmpty ] whileFalse: [					(rect _ rects removeLast) == rectToFill 						ifFalse: [ c _ aCanvas copyClipRect: (rectToFill _ rect)].					c fullDrawMorph: morphs removeLast ].				morphs reset.				rects reset.				validList add: r]].	^ validList! !Morph removeSelector: #areasRemainingToFill:!LightWidget removeSelector: #areasRemainingToFill:!InfiniteForm removeSelector: #isSolidFill!Color removeSelector: #isSolidFill!Canvas removeSelector: #draw:!Canvas removeSelector: #fullDraw:!