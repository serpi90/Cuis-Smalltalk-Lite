'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 14 November 2011 at 5:13:51 pm'!!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 11/14/2011 16:50'!paragraph: aParagraph bounds: boundsInWorld color: c	| scanner |	self setPaintColor: c.	scanner _ DisplayScanner new 		text: aParagraph paragraphText		foreground: (shadowColor ifNil: [ c ])		ignoreColorChanges: self isShadowDrawing.	scanner setPort: (port clippedBy: boundsInWorld).self flag: #jmvVer."original""	(self copyClipRect: boundsInWorld)""ahora. El clipping lo quiere en coordenadas globales. BoundsInWorld deberia estar en ellas!!""Este clipping es el usado para la seleccion""	(self copyClipRect: (boundsInWorld translateBy: origin negated))""experim"	(self copyClipRect: boundsInWorld)		display: aParagraph 		using: scanner		in: boundsInWorld! !!FormCanvas methodsFor: 'private - drawing text' stamp: 'jmv 11/14/2011 16:48'!       display: aParagraph using: displayScanner in: boundsInWorld	"Send all visible lines to the displayScanner for display"	|  leftInRun line |	leftInRun _ 0.	(aParagraph lineIndexForPoint: 0@0)		to: (aParagraph lineIndexForPoint: boundsInWorld extent)		do: [ :i |			line _ aParagraph lines at: i.			aParagraph displaySelectionInLine: line on: self paragraphTopLeft: boundsInWorld topLeft.			leftInRun _ displayScanner displayLine: line paragraphTopLeft: boundsInWorld topLeft leftInRun: leftInRun ]! !!InnerTextMorph methodsFor: 'classification' stamp: 'jmv 11/14/2011 16:52'!                       is: aSymbol	^ aSymbol == #InnerTextMorph or: [ super is: aSymbol ]! !!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:41'!                   drawOn: aCanvas	"Draw the receiver on a canvas"	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"	aCanvas paragraph: self paragraph bounds: self displayBounds color: color.	"Drawing the paragraph might change the #lastCaretRect, and therefore might	require a second update."	paragraph lastCaretRectNeedsRedraw ifTrue: [		paragraph lastCaretRect ifNotNil: [ :r | self invalidRect: r ]]! !!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:47'!  displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor x1 isBold isItalic x0 h w halfW r |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].	x0 < halfW ifTrue: [		x1 _ x1 - x0 + halfW.		x0 _ halfW ].	r _ bounds right-halfW-1.	r < x1 ifTrue: [		x0 _ x0 + r - x1.		x1 _ r.		].	caretRect _ x0-halfW@ top corner: x1+halfW+1 @ bottom.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 16:47'!                  drawCaretOn: aCanvas	"Essentially copied from #displayInsertionMarkAtX:top:bottom:emphasis:on:"	|  top bottom x |	showCaret ifTrue: [		top _ bounds top.		bottom _ top + self baseFont height.		x _ (self fontToUse widthOfString: contents from: 1 to: editor startIndex-1) + bounds left.		self displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas ]! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/14/2011 16:53'!                             displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas paragraphTopLeft: paragraphTopLeft	| caretColor x1 isBold isItalic x0 h w halfW r newCaretRect |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].	x0-paragraphTopLeft x < halfW ifTrue: [		x1 _ x1 - x0 + halfW+paragraphTopLeft x.		x0 _ halfW+paragraphTopLeft x ].	r _ extentForComposing x-halfW-1.	r < (x1-paragraphTopLeft x) ifTrue: [		x0 _ x0 + r - x1+paragraphTopLeft x.		x1 _ r +paragraphTopLeft x].	lastCaretRectNeedsRedraw _ false.	newCaretRect _ x0-halfW@ top corner: x1+halfW+1 @ (bottom+1).	lastCaretRect ifNotNil: [		lastCaretRect = newCaretRect ifFalse: [			"If we are actually drawing the last position of the text cursor,			but not the current one, request redraw."			((aCanvas isVisible: lastCaretRect) and: [(aCanvas isFullyVisible: newCaretRect) not ])				ifTrue: [					lastCaretRectNeedsRedraw _ true ]]].	lastCaretRect _ newCaretRect.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/14/2011 16:53'!                             displaySelectionInLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft 	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |		self displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft ]! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/14/2011 16:53'!                              displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft	| leftX rightX idx caretFont t b caretAttributes |	startBlock ifNil: [^self].	"No selection"	startBlock = stopBlock 		ifTrue: [			"Only show caret on line where clicked"			startBlock textLine first = line first ifFalse: [				^self ].			leftX _ paragraphTopLeft x + startBlock left.			idx _ startBlock stringIndex.			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].			caretFont _ caretAttributes				ifNil: [ model actualContents fontAt: idx ]				ifNotNil: [ model actualContents fontIfApplying: caretAttributes ].			b _ paragraphTopLeft y + line top + line baseline + caretFont descent-1.			t _ paragraphTopLeft y + line top + line baseline - caretFont ascent.			showCaret ifTrue: [				self					displayInsertionMarkAtX: leftX					top: t					bottom: b					emphasis: caretFont emphasis					on: aCanvas					paragraphTopLeft: paragraphTopLeft ]]		ifFalse: [			"Test entire selection before or after here"			(stopBlock stringIndex < line first 				or: [startBlock stringIndex > (line last + 1)])					ifTrue: [^self].	"No selection on this line"			(stopBlock stringIndex = line first 				and: [stopBlock textLine ~= line])					ifTrue: [^self].	"Selection ends on line above"			(startBlock stringIndex = (line last + 1) 				and: [stopBlock textLine ~= line])					ifTrue: [^self].			lastCaretRect _ nil.			lastCaretRectNeedsRedraw _ false.			leftX _  paragraphTopLeft x + (startBlock stringIndex < line first 				ifTrue: [ line ]				ifFalse: [ startBlock ]) left.			rightX _  paragraphTopLeft x + ((stopBlock stringIndex > (line last + 1) or: [					stopBlock stringIndex = (line last + 1) 						and: [stopBlock textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [stopBlock left]).			aCanvas				fillRectangle: (leftX @ (line top +  paragraphTopLeft y) corner: rightX @ (line bottom +  paragraphTopLeft y))				colorOrInfiniteForm: self selectionColor].	"Selection begins on line below"! !!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 11/14/2011 16:55'! addToScroller: aMorphself flag: #jmvVer."Solo usado para #inATwoWayScrollPane.Cuando todo lo demas ande, hacer andar esto tambien!!poner directamente el morph como scroller? yo creo que si...La verdad, que lo ideal seria usar esto siempre, referenciar al morph de adentro, y que haga esto o algo asi para venir con scroll..."aMorph position = (0@0) ifTrue: [	aMorph position: scroller position +15 ]."Ojo esa cte..."	scroller addMorph: aMorph! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 16:51'!  itemFromPoint: aPoint	"Return the list element (morph) at the given point or nil if outside"	| ptY |	self flag: #jmvVer. "Pensar, creo que en estas si vamos a agregar un morph nuevo para reem al scroller. Sera una nueve clase. ver.	La nueva clase ya esta. Falta aprovecharla mas, mandandole codibo que esta aca...	Hacer esto de forma consistente con los otros pluggable morphs..."	scroller hasSubmorphs ifFalse:[^nil].	(scroller fullBounds containsPoint: aPoint) ifFalse:[^nil].	ptY _ (scroller firstSubmorph internalizePositionToOwner: aPoint from: self) y.	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"	scroller firstSubmorph top > ptY ifTrue:[^nil].	scroller lastSubmorph bottom < ptY ifTrue:[^nil].	"now use binary search"	^scroller 		findSubmorphBinary:[:item|			(item top <= ptY and:[item bottom >= ptY])				ifTrue:[0] "found"				ifFalse:[ (item top + item bottom // 2) > ptY ifTrue:[-1] ifFalse:[1]]]! !TextModelMorph removeSelector: #is:!Paragraph removeSelector: #displayInsertionMarkAtX:top:bottom:emphasis:on:!Paragraph removeSelector: #displaySelectionInLine:on:!Paragraph removeSelector: #displaySelectionInLineNEW:on:paragraphTopLeft:!Paragraph removeSelector: #displaySelectionStartBlock:stopBlock:InLine:on:!Paragraph removeSelector: #displaySelectionStartBlockNEW:stopBlock:InLine:on:paragraphTopLeft:!FormCanvas removeSelector: #copyOffset:clipRect:!FormCanvas removeSelector: #displayNEW:using:in:!FormCanvas removeSelector: #paragraphNEW:bounds:color:!Smalltalk removeClassNamed: #BrowserCommentTextMorph2!Smalltalk removeClassNamed: #LimitedHeightTextMorph2!Smalltalk removeClassNamed: #PluggableListMorph2!Smalltalk removeClassNamed: #PluggableListMorphByItem2!Smalltalk removeClassNamed: #PluggableListMorphOfMany2!Smalltalk removeClassNamed: #PluggableMessageCategoryListMorph2!Smalltalk removeClassNamed: #TextModelMorph2!Smalltalk removeClassNamed: #TransformMorph!