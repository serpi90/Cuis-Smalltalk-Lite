'From Cuis 2.6 of 10 August 2010 [latest update: #540] on 11 August 2010 at 2:33:36 pm'!!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 10:38'!lastModTime	"Return my last modification date/time stamp,	converted to Squeak seconds"	^self dosToSqueakTime: lastModFileDateTime! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 11:08'!setLastModFileDateTimeFrom: aSmalltalkTime	lastModFileDateTime := self squeakToDosTime: aSmalltalkTime! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 10:39'!dosToSqueakTime: dt	"DOS years start at 1980, so add 1980."	| year mon mday hour min sec date time |	year := (( dt bitShift: -25 ) bitAnd: 16r7F ).	mon := (( dt bitShift: -21 ) bitAnd: 16r0F ).	mday := (( dt bitShift: -16 ) bitAnd: 16r1F ).	date := Date newDay: mday month: mon year: year+1980.	hour := (( dt bitShift: -11 ) bitAnd: 16r1F ).	min := (( dt bitShift: -5 ) bitAnd: 16r3F ).	sec := (( dt bitShift: 1 ) bitAnd: 16r3E ).	time := ((( hour * 60 ) + min ) * 60 ) + sec.	^date asSeconds + time	! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 11:00'!squeakToDosTime: secs	| dosTime dateTime |	dateTime := Time dateAndTimeFromSeconds: secs.	dosTime := (dateTime second seconds) bitShift: -1.	dosTime := dosTime + ((dateTime second minutes) bitShift: 5).	dosTime := dosTime + ((dateTime second hours) bitShift: 11).	dosTime := dosTime + ((dateTime first dayOfMonth) bitShift: 16).	dosTime := dosTime + ((dateTime first monthIndex) bitShift: 21).	dosTime := dosTime + (((dateTime first year) - 1980) bitShift: 25).	^dosTime! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 8/10/2010 13:15'!writeDataTo: aStream	"Copy my (possibly inflated or deflated) data to the given stream.	This might do compression, decompression, or straight copying, depending	on the values of compressionMethod and desiredCompressionMethod"	"Note: Do not shortcut this method if uncompressedSize = 0. Even in this case	data may be produced by the compressor (i.e., '' zipped size > 0) and must	be stored in the file or else other utilities will treat the zip file as corrupt."	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])		ifTrue: [ ^self compressDataTo: aStream ].	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])		ifTrue: [ ^self uncompressDataTo: aStream ].	self copyDataTo: aStream.! !