'From Cuis 2.4 of 17 June 2010 [latest update: #509] on 2 July 2010 at 12:30:06 pm'!!classDefinition: #CharacterSet category: #'Kernel-Text'!Collection subclass: #CharacterSet	instanceVariableNames: 'map '	classVariableNames: 'CrLf '	poolDictionaries: ''	category: 'Kernel-Text'!!ProtoObject methodsFor: 'system primitives' stamp: 'mtf 8/15/2008 17:19'!instVarsInclude: anObject"Answers true if anObject is among my named or indexed instance variables, and false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!Behavior methodsFor: 'testing' stamp: 'mtf 6/3/2010 11:03'!sourceMatchesBytecodeAt: selector	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false otherwise. Implemented to detect an error where Monticello did not recompile sources when the class shape changed"	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a method which turned a selector and class into a CompiledMethod, without  installing it into the methodDictionary"	| method trailer methodNode |	method := self compiledMethodAt: selector.	trailer := method trailer.	methodNode := self compilerClass new				compile: (self sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ false].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ (methodNode generate: trailer) = method! !!BlockClosure methodsFor: 'exceptions' stamp: 'brp 12/20/2009 19:32'!on: exc1 do: block1 on: exc2 do: block2	^[		[ self value ]			on: exc1			do: block1 ]		on: exc2		do: block2! !!BlockClosure methodsFor: 'exceptions' stamp: 'brp 12/20/2009 19:34'!on: exc1 do: block1 on: exc2 do: block2 on: exc3 do: block3	^[		[ self value ]			on: exc1			do: block1 ]		on: exc2		do: block2		on: exc3		do: block3! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/1/2010 19:30'!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^((MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc) privRefresh! !!ChangeRecord methodsFor: 'access' stamp: 'jmv 7/2/2010 12:02'!methodClass	| methodClassName methodClass |	type == #method ifFalse: [ ^ nil ].	methodClassName _ class substrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass _ Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!ClassBuilder methodsFor: 'private' stamp: 'ar 6/14/2010 22:06'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		ProtoObject Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext BlockClosure		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'MarcusDenker 3/5/2010 14:33'!methodsInCategory: aName 	"Answer a list of the methods of the receiver that are in category named aName"		| aColl |	aColl := Set withAll: (aName = ClassOrganizer allCategory			ifTrue: [self organization allMethodSelectors]			ifFalse: [self organization listAtCategoryNamed: aName]).	^ aColl asArray sort! !!Collection methodsFor: 'testing' stamp: 'ul 11/11/2009 16:24'!ifEmpty: emptyBlock ifNotEmptyDo: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	"Evaluate the notEmptyBlock with the receiver as its argument"	self isEmpty ifTrue: [ ^emptyBlock value ].	^notEmptyBlock value: self! !!ByteArray methodsFor: 'testing' stamp: 'eem 6/4/2010 17:55'!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^self class == ByteArray! !!CharacterSet class methodsFor: 'accessing' stamp: 'nice 11/16/2009 11:22'!crlf	CrLf ifNil: [CrLf := self with: Character cr with: Character lf].	^CrLf! !!ContextPart methodsFor: 'private-exceptions' stamp: 'mtf 6/3/2010 09:36'!rearmHandlerDuring: aBlock	"Sent to handler (on:do:) contexts only. Makes me re-entrant for the duration of aBlock. Only works in a closure-enabled image"	^ [self tempAt: 3 put: true. aBlock value]		ensure: [self tempAt: 3 put: false]! !!Exception methodsFor: 'handling' stamp: 'mtf 6/3/2010 09:42'!rearmHandlerDuring: aBlock"Make the current error handler re-entrant while it is running aBlock. Only works in a closure-enabled image"	^ handlerContext rearmHandlerDuring: aBlock! !!MessageNames methodsFor: 'search' stamp: 'eem 1/27/2009 10:15'!computeSelectorListFromSearchString	"Compute selector list from search string"	searchString := searchString asString copyWithout: $ . "?dubious?"	selectorList := Cursor wait showWhile:					[| sorted |					sorted := SortedCollection sortBlock:  [:x :y | x asLowercase <= y asLowercase].					(searchString findBetweenSubStrs: ';') do:						[:selPat| | raw n m |						selPat size > 0 ifTrue:							[(selPat first = $" and: [selPat last = $" and: [selPat size > 2]])								ifTrue:									[Symbol hasInterned: (selPat copyFrom: 2 to: selPat size - 1) ifTrue: [:sym| sorted add: sym]]								ifFalse:									[raw := (((n := selPat occurrencesOf: $*) > 0)										    | ((m := selPat occurrencesOf:  $#) > 0)										and: [selPat size > (n + m)])											ifTrue: [Symbol selectorsMatching: selPat]											ifFalse: [Symbol selectorsContaining: selPat].									sorted addAll: raw]]].					sorted asArray].	^selectorList! !!MessageNames methodsFor: 'selector list' stamp: 'jmv 7/2/2010 10:34'!selectorListMenu: aMenu	"Answer the menu associated with the selectorList"	aMenu addList: #(		('senders (n)'				browseSenders		'browse senders of the chosen selector')		('copy selector to clipboard'	copyName			'copy the chosen selector to the clipboard, for subsequent pasting elsewhere')	).	^ aMenu! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 6/18/2010 21:38'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	^(array at: (self scanFor: key)) 		ifNil: [ aBlock value ]		ifNotNil: [ :value | key -> value ]! !!Parser methodsFor: 'error correction' stamp: 'jmv 7/2/2010 10:06'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding _ requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].		"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"	"	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])		ifFalse: [ ^encoder undeclared: proposedVariable ].	"	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	doitFlag		ifTrue: [requestor setViewSelection]		ifFalse: [requestor selectionInterval: requestor selectionInterval].	"Build the menu with alternatives"	action _ UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!String methodsFor: 'accessing' stamp: 'nice 6/11/2010 21:44'!lines	"Answer an array of lines composing this receiver without the line ending delimiters."	^Array new: (self size // 60 max: 16) streamContents: [:lines |		self linesDo: [:aLine | lines nextPut: aLine]]! !!Symbol class methodsFor: 'access' stamp: 'jmv 7/2/2010 10:19'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList _ OrderedCollection new.	(size _ aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii _ aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	aString first isGenerallyValidInIdentifiers ifFalse:		[			aString size = 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList _ selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'eem 5/22/2008 12:56'!selectorsMatching: aStringPattern	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.	 Does return symbols that begin with a capital letter."	| selectorList |	selectorList := OrderedCollection new.	aStringPattern isEmpty ifTrue: [^selectorList].	self allSymbolTablesDo:		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"		[:each | each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]	"Symbol selectorsMatching: 'parse:*'"! !!SystemDictionary methodsFor: 'special objects' stamp: 'ar 6/20/2010 16:20'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it.""	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii])."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: nil. "Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray	! !!SystemDictionary methodsFor: 'vm' stamp: 'ar 6/21/2010 20:25'!isRunningCog	"Returns true if we're running Cog"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 7/2/2010 11:10'!textMarkerForShortReport	^  'Since last view	'! !!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 7/2/2010 11:14'!vmStatisticsReportString	"	(StringHolder new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'	"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := Smalltalk getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr			';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr			';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 7/2/2010 11:12'!vmStatisticsShortString	"Convenience item for access to recent statistics only"	"	(StringHolder new contents: Utilities vmStatisticsShortString) openLabel: 'VM Recent Statistics'	"	^ (ReadStream on: self vmStatisticsReportString) upToAll: 'Since'; upTo: Character cr; upToEnd! !SystemDictionary removeSelector: #selectorsWithAnyImplementorsIn:!MessageNames removeSelector: #showOnlyImplementedSelectors!!classDefinition: #CharacterSet category: #'Kernel-Text'!Collection subclass: #CharacterSet	instanceVariableNames: 'map'	classVariableNames: 'CrLf'	poolDictionaries: ''	category: 'Kernel-Text'!Smalltalk removeClassNamed: #PseudoContext!Smalltalk removeClassNamed: #TranslatedMethod!