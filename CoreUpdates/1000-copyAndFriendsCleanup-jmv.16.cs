'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 20 May 2011 at 4:43:48 pm'!!BalloonMorph commentStamp: 'jmv 5/20/2011 14:37' prior: 0!A balloon with text used for the display of explanatory information.Balloon help is integrated into Morphic as follows:If a Morph has the property #balloonText, then it will respond to #showBalloon by adding a text balloon to the world, and to #deleteBalloon by removing the balloon.Moreover, if mouseOverEnabled is true (see class msg), then the Hand will arrange to cause display of the balloon after the mouse has lingered over the morph for a while, and removal of the balloon when the mouse leaves the bounds of that morph.  In any case, the Hand will attempt to remove any such balloons before handling mouseDown events, or displaying other balloons.!!Object methodsFor: 'object serialization' stamp: 'jmv 5/20/2011 16:03'!storeDataOn: aDataStream	"Store myself on a DataStream.  Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  NOTE: This method must send 'aDataStream beginInstance:size:' and then (nextPut:/nextPutWeak:) its subobjects.  readDataFrom:size: reads back what we write here."	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	"Write fields of a variable length object.  When writing to a dummy 		stream, don't bother to write the bytes"	((aDataStream byteStream class == DummyStream) and: [self class isBits]) ifFalse: [		self class isWeak			ifTrue: [				"For weak classes (for example DependentsArray) write the referenced object only				if referenced from elsewhere in the dumped object graph.				This means, for instance that if we only dump a model, no dependents are stored, 				but if we store a view (i.e. a Morph), it is properly handled as a dependent after the object graph is revived."				1 to: cntIndexedVars do: [ :i |					aDataStream nextPutWeak: (self basicAt: i)]]			ifFalse: [				1 to: cntIndexedVars do: [ :i |					aDataStream nextPut: (self basicAt: i)]]]! !!BlockClosure methodsFor: 'objects from disk' stamp: 'jmv 5/20/2011 14:59'!objectForDataStream: refStrm	"I am about to be written on an object file.  Write a textual reference instead."	^ DiskProxy		global: #Compiler		selector: #evaluate:		args: (Array with: self decompile decompileString)! !!BlockNode methodsFor: 'printing' stamp: 'jmv 5/20/2011 14:58'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ String streamContents: [:strm | self printOn: strm indent: 0]! !!Categorizer methodsFor: 'copying' stamp: 'jmv 5/20/2011 11:22'!postCopy	categoryArray _ categoryArray copy.	categoryStops _ categoryStops copy. 	elementArray _ elementArray copy! !!BasicClassOrganizer methodsFor: 'copying' stamp: 'jmv 5/20/2011 11:24'!postCopy	super postCopy.	"I guess not..."	"subject _ subject copy."	classComment _ classComment copy.	commentStamp _ commentStamp copy! !!ChangeSet methodsFor: 'private' stamp: 'jmv 5/20/2011 14:32'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue: [		stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue: [ "fat definition only needed for changes"		stream nextPut: $!!; nextChunkPut: class definitionPreamble; cr;		nextChunkPut: (self fatDefForClass: class); cr.	] ifFalse: [		(self atClass: class includes: #add) ifTrue: [ "use current definition for add"			stream nextPut: $!!; nextChunkPut: class definitionPreamble; cr;			nextChunkPut: class definition; cr.		].	].	(self atClass: class includes: #comment) ifTrue: [		class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass.		stream cr].! !!Character methodsFor: 'copying' stamp: 'jmv 5/20/2011 10:51'!shallowCopy	"Answer with the receiver because Characters are unique."! !!ClassDescription methodsFor: 'copying' stamp: 'jmv 5/20/2011 11:24'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	self organization: donorClass organization copy! !!Collection methodsFor: 'enumerating' stamp: 'jmv 5/20/2011 14:18'!groupBy: keyBlock having: selectBlock 	"Like in SQL operation - Split the recievers contents into collections of 	elements for which keyBlock returns the same results, and return those 	collections allowed by selectBlock. keyBlock should return an Integer."	| result |	result _ Dictionary new.	self do: [ :e |		(result at: (keyBlock value: e) ifAbsentPut: OrderedCollection new) add: e ].	^ result select: selectBlock! !!Dictionary methodsFor: 'accessing' stamp: 'jmv 5/20/2011 15:01'!keysSortedSafely	"Answer a SortedCollection containing the receiver's keys."	| sortedKeys |	sortedKeys _ OrderedCollection new: self size.	self keysDo: [:each | sortedKeys addLast: each].	sortedKeys sort:		[:x :y |  "Should really be use <obj, string, num> compareSafely..."		((x isString and: [y isString])			or: [x isNumber and: [y isNumber]])			ifTrue: [x < y]			ifFalse: [x class == y class				ifTrue: [x printString < y printString]				ifFalse: [x class name < y class name]]].	^ sortedKeys! !!Form methodsFor: 'bordering' stamp: 'jmv 5/20/2011 11:12'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm _ self copy.	all _ bigForm boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	sharpen ifTrue:		[cornerForm _ Form extent: self extent.		cornerPort _ BitBlt current toForm: cornerForm].	nbrs _ (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!Form methodsFor: 'converting' stamp: 'jmv 5/20/2011 11:12'!copyWithColorsReducedTo: nColors	"Note: this has not been engineered.	There are better solutions in the literature."	| palette colorMap pc closest |	palette _ self reducedPaletteOfSize: nColors.	colorMap _ (1 to: (1 bitShift: depth)) collect:		[:i | pc _ Color colorFromPixelValue: i-1 depth: depth.		closest _ palette detectMin: [:c | c diff: pc].		closest pixelValueForDepth: depth].	^ self copy copyBits: self boundingBox from: self at: 0@0 colorMap: (colorMap as: Bitmap)		! !!Form methodsFor: 'copying' stamp: 'jmv 5/20/2011 16:40'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 copy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'copying' stamp: 'jmv 5/20/2011 11:07'!postCopy	self		 bits: bits copy;		 offset: offset copy! !!Form methodsFor: 'displaying' stamp: 'jmv 5/20/2011 16:41'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f replaceColor: f dominantColor withColor: Color transparent.f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 copy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'encoding' stamp: 'jmv 5/20/2011 11:12'!deltaFrom: previousForm	| newForm |	newForm _ previousForm copy.	(BitBlt 		destForm: newForm 		sourceForm: self 		fillColor: nil 		combinationRule: Form reverse 		destOrigin: 0@0		sourceOrigin: 0@0		extent: self extent 		clipRect: self boundingBox) copyBits.	^newForm! !!Form methodsFor: 'encoding' stamp: 'jmv 5/20/2011 11:13'!deltaFrom: smallerForm at: offsetInMe	| newForm |	newForm _ smallerForm copy.	(BitBlt 		destForm: newForm 		sourceForm: self 		fillColor: nil 		combinationRule: Form reverse 		destOrigin: 0@0		sourceOrigin: offsetInMe		extent: smallerForm extent 		clipRect: newForm boundingBox) copyBits.	^newForm! !!Form methodsFor: 'filling' stamp: 'jmv 5/20/2011 11:13'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all _ self boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt current toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0@0 rule: Form erase.  "Clear any in black"	previousSmear _ smearForm copy.	count _ 1.	[count = 10 and:   "check for no change every 10 smears"		[count _ 1.		previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1@0 rule: Form under.			smearPort copyForm: smearForm to: -1@0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			smearPort copyForm: smearForm to: 0@1 rule: Form under.			smearPort copyForm: smearForm to: 0@-1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			count _ count+1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0@0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!ColorForm methodsFor: 'copying' stamp: 'jmv 5/20/2011 11:09'!postCopy	"Just to make visible the fact that we are sharing the colors... Is it ok to do this?"	super postCopy		colors: colors! !!ColorForm methodsFor: 'postscript generation' stamp: 'jmv 5/20/2011 11:09'!mapTransparencies:transparentIndexes	^self copy mapColors:transparentIndexes to: (transparentIndexes at:1)! !!LightWidget methodsFor: 'copying' stamp: 'jmv 5/20/2011 15:21'!copy	"Answer a copy of the Morph.	Copy is not in the World or any other owner."	^ Object unStream: (ReferenceStream streamedRepresentationOf: self)! !!LightWidget methodsFor: 'copying' stamp: 'jmv 5/20/2011 13:59'!duplicate	"Make and return a duplicate of the receiver"	| newMorph |	newMorph _ self copy.	newMorph arrangeToStartStepping.	^ newMorph! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jmv 5/20/2011 11:14'!noFiltering	"Revert to accepting all MIDI commands on all channels. This undoes any earlier request to filter the incoming MIDI stream."	cmdActionTable _ DefaultMidiTable copy.	ignoreSysEx _ false! !!FileList methodsFor: 'initialization' stamp: 'jmv 5/20/2011 15:05'!initialize	showDirsInFileList _ false.	fileSelectionBlock _ [ :entry :myPattern |		(myPattern = '*' or: [ myPattern match: entry name ]) and: [			"Hide Mac resurce forks and folder service stores"			(entry name = '.DS_Store') not and: [				('._*' match: entry name) not ]]	].	dirSelectionBlock _ [ :dirName | true].! !!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 5/20/2011 15:05'!listForPatterns: anArray	"Make the list be those file names which match the patterns."	| sizePad newList namePad sizeWithCommasPad font |	directory ifNil: [^#()].	(fileSelectionBlock isKindOf: MessageSend) ifTrue: [		fileSelectionBlock arguments: {directory entries}.		newList _ fileSelectionBlock value.		fileSelectionBlock arguments: #().	] ifFalse: [		newList _ Set new.		anArray do: [ :pat |			newList addAll: (directory entries select: [ :entry |				entry isDirectory					ifTrue: [showDirsInFileList]					ifFalse: [fileSelectionBlock value: entry value: pat]]) ].	].	newList _ newList asArray sort: self sortBlock.	font _ Preferences standardListFont.	namePad _ newList inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry first)].	sizePad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry at: 5)]) printString size.	sizeWithCommasPad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry at: 5)]) asStringWithCommas size.	newList _ newList collect: [ :e | self fileNameFormattedFrom: e namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad ].	^ newList! !!Morph methodsFor: 'copying' stamp: 'jmv 5/20/2011 15:21'!copy	"Answer a copy of the Morph.	Copy is not in the World or any other owner."	^ Object unStream: (ReferenceStream streamedRepresentationOf: self)! !!Morph methodsFor: 'copying' stamp: 'jmv 5/20/2011 14:01'!copyForClipboard	"Some subclasses might need specific behavior..."	^self copy! !!Morph methodsFor: 'copying' stamp: 'jmv 5/20/2011 14:00'!duplicate	"Make and return a duplicate of the receiver"	| newMorph |	self okayToDuplicate ifFalse: [^ self].	newMorph _ self copy.	newMorph arrangeToStartStepping.	^ newMorph! !!LazyListMorph methodsFor: 'initialization' stamp: 'jmv 5/20/2011 14:17'!initialize	super initialize.	self color: Color black.	font _ Preferences standardListFont.	listItems _ #().	selectedRow _ nil.	selectedRows _ Set new.	self adjustHeight.! !!LazyListMorph methodsFor: 'list management' stamp: 'jmv 5/20/2011 14:18'!listChanged	"set newList to be the list of strings to display"	listItems _ Array new: self getListSize withAll: nil.	selectedRow _ nil.	selectedRows _ Set new.	self adjustHeight.	self adjustWidth.	self redrawNeeded! !!LazyListMorph methodsFor: 'private' stamp: 'jmv 5/20/2011 14:18'!noSelection	selectedRow _ nil.	selectedRows _ Set new! !!Object class methodsFor: 'instance creation' stamp: 'jmv 5/20/2011 14:06'!unStream: aString	^ ReferenceStream unStream: aString! !!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 5/20/2011 11:09'!mappingWhiteToTransparentFrom: aFormOrCursor	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."	| f map |	aFormOrCursor depth <= 8 ifFalse: [		^ self error: 'argument depth must be 8-bits per pixel or less'].	(aFormOrCursor is: #ColorForm) ifTrue: [		f _ aFormOrCursor copy.		map _ aFormOrCursor colors.	] ifFalse: [		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.		f copyBits: aFormOrCursor boundingBox			from: aFormOrCursor			at: 0@0			clippingBox: aFormOrCursor boundingBox			rule: Form over			fillColor: nil.		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].	map _ map collect: [:c |		c = Color white ifTrue: [Color transparent] ifFalse: [c]].	f colors: map.	^ f! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 5/20/2011 11:12'!maximumUsableArea	| allowedArea |	allowedArea _ Display boundingBox.	allowedArea _ allowedArea intersect: ActiveWorld viewBox.	^allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 5/20/2011 11:12'!maximumUsableAreaInWorld: aWorldOrNil	| allowedArea |	allowedArea _ Display boundingBox.	aWorldOrNil ifNotNil: [allowedArea _ allowedArea intersect: aWorldOrNil viewBox].	^allowedArea! !!SketchMorph methodsFor: 'initialization' stamp: 'jmv 5/20/2011 11:13'!initialize	^ self initializeWith: self class paintingIcon copy! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'jmv 5/20/2011 11:10'!buildChartForm	| chartForm |	chartForm _ ColorChart copy asFormOfDepth: Display depth.	chartForm fill: ((TransparentBox left + 9)@0 extent: 1@9) fillColor: Color lightGray.	chartForm fill: ((TransparentBox right - 10)@0 extent: 1@9) fillColor: Color lightGray.	TransText displayOn: chartForm at: 62@0.	Display depth = 32 ifTrue:		["Set opaque bits for 32-bit display"		chartForm fill: chartForm boundingBox rule: Form under				fillColor: (Color r: 0.0 g: 0.0 b: 0.0 alpha: 1.0)].	chartForm borderWidth: 1.	self form: chartForm.	selectedColor ifNotNil: [self updateAlpha: selectedColor alpha]! !!StreamingMonoSound methodsFor: 'private' stamp: 'jmv 5/20/2011 11:18'!positionCodecTo: desiredSampleIndex	"Position to the closest frame before the given sample index when using a codec. If using the ADPCM codec, try to ensure that it is in sync with the compressed sample stream."	| desiredFrameIndex desiredPosition tmpStream tmpCodec byteBuf bufFrames sampleBuf frameCount n startOffset |	(codec isKindOf: ADPCMCodec) ifFalse: [		"stateless codecs (or relatively stateless ones, like GSM: just jump to frame boundary"		desiredFrameIndex _ desiredSampleIndex // codec samplesPerFrame.		stream position: audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).		codec reset.		^ self].	"compute the desired stream position"	desiredFrameIndex _ desiredSampleIndex // codec samplesPerFrame.	desiredPosition _ audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).	"copy stream and codec"	(stream isKindOf: FileStream)		ifTrue: [tmpStream _ (FileStream readOnlyFileNamed: stream name) binary]		ifFalse: [tmpStream _ "stream deepCopy" stream contents readStream].	"To kill #deepCopy. Not sure if right, though (jmv)"	tmpCodec _ codec copy reset.	"reset the codec and start back about 30 seconds to try to get codec in sync"	startOffset _ ((desiredFrameIndex - 80000) max: 0) * codec bytesPerEncodedFrame.	tmpStream position: audioDataStart + startOffset.	"decode forward to the desired position"	byteBuf _ ByteArray new: (32000 roundTo: codec bytesPerEncodedFrame).	bufFrames _ byteBuf size // codec bytesPerEncodedFrame.	sampleBuf _ SoundBuffer newMonoSampleCount: bufFrames * codec samplesPerFrame.	frameCount _ (desiredPosition - tmpStream position) // codec bytesPerEncodedFrame.	[frameCount > 0] whileTrue: [		n _ bufFrames min: frameCount.		tmpStream next: n * codec bytesPerEncodedFrame into: byteBuf startingAt: 1.		tmpCodec decodeFrames: n from: byteBuf at: 1 into: sampleBuf at: 1.		frameCount _ frameCount - n].	codec _ tmpCodec.	stream position: tmpStream position.	(tmpStream isKindOf: FileStream) ifTrue: [tmpStream close].! !!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 5/20/2011 11:13'!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm |	g _ glyphs copy.	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.	self bonk: g with: bonkForm.	glyphs depth = 1 ifTrue: [		g copyBits: g boundingBox from: g at: (1@0)			clippingBox: g boundingBox rule: Form under fillColor: nil]		ifFalse: [			0 to: g width - 2 do: [ :x | 0 to: g height-1 do: [ :y |				(glyphs colorAt:  x@y) = Color white ifFalse: [					g colorAt: x+1@y put: 						((glyphs colorAt: x+1@y) = Color white 							ifTrue: [glyphs colorAt:  x@y]							ifFalse: [Color black])]]]].	glyphs _ g.	self isSynthetic: true! !!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 5/20/2011 11:13'!makeStruckThroughGlyphs	"Make a struckThrough set of glyphs with same widths"	| g |	g _ glyphs copy.	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).	glyphs _ g.	self isSynthetic: true! !!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 5/20/2011 11:13'!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g |	g _ glyphs copy.	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).	glyphs _ g.	self isSynthetic: true! !!SystemWindow methodsFor: 'top window' stamp: 'jmv 5/20/2011 14:08'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| candidate |	self activateAndSendTopToBack: false.		candidate _ self.	candidate handlesKeyboard ifFalse: [		[			candidate _ candidate nextMorph.			candidate handlesKeyboard not and: [ candidate ~~  self ] ] whileTrue ].	candidate handlesKeyboard ifTrue: [		self world ifNotNil: [ :w | w activeHand newKeyboardFocus: candidate ]]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jmv 5/20/2011 11:15'!awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw3/31/00 JMM added logic to stop multiple redraws"	| p inside lightForm darkForm isLight |	p _ Sensor mousePoint.	inside _ box insetBy: 1.	isLight _ true.	lightForm _ Form fromDisplay: inside.	darkForm _ lightForm copy reverse.	[Sensor anyButtonPressed] whileTrue:		[doBlock1 value.		(box containsPoint: (p _ Sensor mousePoint))			ifTrue: [doBlock2 value.					isLight ifTrue: 						[isLight _ false.						darkForm displayAt: inside origin]]			ifFalse: [isLight ifFalse:						[isLight _ true.						lightForm displayAt: inside origin]]].	(box containsPoint: p)		ifTrue: [lightForm displayAt: inside origin.				^ succBlock value]! !UndefinedObject removeSelector: #deepCopy!UndefinedObject removeSelector: #veryDeepCopyWith:!Text removeSelector: #deepCopy!SystemDictionary removeSelector: #veryDeepCopyWith:!!SystemDictionary reorganize!('accessing' organization)('class names' classNamed: fillCaches flushClassNameCache forgetClass:logged: hasClassNamed: removeClassNamed: renameAndUpdateReferences:as: renameClass:as: renameClassNamed:as:)('dictionary access' associationAtOrAbove:ifAbsent: associationOrUndeclaredAt: at:put: atOrAbove:ifAbsent: atOrBelow:ifAbsent: environmentForCategory: includesKeyOrAbove: scopeFor:from:envtAndPathIfFound:)('housekeeping' browseEqEqSentToSmallIntegerConstants browseObsoleteMethodReferences browseUndeclaredReferences cleanCompactObsoleteClasses cleanOutUndeclared condenseChanges condenseSources forgetDoIts macroBenchmark1 macroBenchmark3 makeInternalRelease obsoleteBehaviors obsoleteClasses obsoleteMethodReferences recompileAllFrom: removeAllLineFeeds removeEmptyMessageCategories removeTextCode testDecompiler testFormatter testFormatter2 verifyChanges)('image, changes name' changeImageNameTo: currentSourcesName defaultSourcesName fullNameForChangesNamed: fullNameForImageNamed: imageName imageName: imagePath localChangesName newSourcesName vmPath)('memory space' bytesLeft bytesLeft: bytesLeftString createStackOverflow garbageCollect garbageCollectMost installLowSpaceWatcher lowSpaceThreshold lowSpaceWatcher lowSpaceWatcherProcess okayToProceedEvenIfSpaceIsLow primBytesLeft primLowSpaceSemaphore: primSignalAtBytesLeft: primitiveGarbageCollect signalLowSpace useUpMemory useUpMemoryWithArrays useUpMemoryWithContexts useUpMemoryWithTinyObjects)('code authors' agreedContributors allContributors contributionsOf: missingAuthorsWithMethods newContributors okContributors relicenseEffortStartDate returnedSignatories)('miscellaneous' cogitClass exitToDebugger extraVMMemory extraVMMemory: getSystemAttribute: getVMParameters handleUserInterrupt interpreterClass listBuiltinModule: listBuiltinModules listLoadedModule: listLoadedModules logError:inContext:to: osVersion platformName platformSubtype primVmFileName setMacFileInfoOn: unloadModule: vmFileName vmParameterAt: vmParameterAt:put: vmVersion)('object serialization' objectForDataStream: storeDataOn:)('printing' printElementsOn:)('profiling' clearProfile dumpProfile profile: startProfiling stopProfiling)('retrieving' allBehaviorsDo: allCallsOn: allCallsOn:and: allClasses allClassesDo: allClassesImplementing: allGlobalRefs allGlobalRefsWithout: allImplementedMessages allImplementedMessagesWithout: allImplementorsOf: allImplementorsOf:localTo: allMethodsInCategory: allMethodsWithSourceString:matchCase: allMethodsWithString: allObjectsDo: allObjectsSelect: allPrimitiveMessages allPrimitiveMethodsInCategories: allSelect: allSelectNoDoits: allSentMessages allSentMessagesWithout: allUnSentMessages allUnSentMessagesIn: allUnSentMessagesWithout: allUnimplementedCalls allUnusedClassesWithout: isThereAReferenceTo: isThereAnImplementorOf: numberOfImplementorsOf: pointersTo: pointersTo:except: pointersToItem:of: poolUsers unimplemented)('shrinking' abandonSources abandonTempNames lastRemoval presumedSentMessages removeAllUnSentMessages removeSelector: removedUnusedClassesAndMethods reportClassAndMethodRemovalsFor: unusedClasses unusedClassesAndMethodsWithout:)('snapshot and quit' add:toList:after: addToShutDownList: addToShutDownList:after: addToStartUpList: addToStartUpList:after: lastQuitLogPosition processShutDownList: processStartUpList: quitPrimitive readDocumentFile removeFromShutDownList: removeFromStartUpList: saveAs saveAsEmbeddedImage saveAsNewVersion saveChangesInFileNamed: saveImageInFileNamed: saveSession send:toClassesNamedIn:with: setGCParameters setPlatformPreferences shutDown snapshot:andQuit: snapshotEmbeddedPrimitive snapshotPrimitive unbindExternalPrimitives)('sources, change log' aboutThisSystem assureStartupStampLogged calcEndianness closeSourceFiles currentChangeSetString datedVersion endianness event: externalizeSources forceChangesToDisk internalizeChangeLog internalizeSources isBigEndian isLittleEndian lastUpdateString logChange: logChange:preamble: openSourceFiles systemInformationString timeStamp: version)('special objects' clearExternalObjects compactClassesArray externalObjects hasSpecialSelector:ifTrueSetByte: recreateSpecialObjectsArray registerExternalObject: specialNargsAt: specialObjectsArray specialSelectorAt: specialSelectorSize specialSelectors unregisterExternalObject:)('copying')('toDeprecate' getFileNameFromUser snapshot:andQuit:embedded:)('ui' confirmRemovalOf:on: inspectGlobals)('browsing' browseAllAccessesTo:from: browseAllCallsOn: browseAllCallsOn:and: browseAllCallsOn:localTo: browseAllCallsOnClass: browseAllImplementorsOf: browseAllImplementorsOf:localTo: browseAllImplementorsOfList: browseAllImplementorsOfList:title: browseAllMethodsInCategory: browseAllObjectReferencesTo:except:ifNone: browseAllSelect: browseAllSelect:name:autoSelect: browseAllStoresInto:from: browseAllUnSentMessages browseAllUnimplementedCalls browseClassCommentsWithString: browseClassesWithNamesContaining:caseSensitive: browseEqSmallConstant browseInstVarDefs: browseInstVarRefs: browseMessageList:name: browseMessageList:name:autoSelect: browseMethodsWithSourceString: browseMethodsWithString: browseMethodsWithString:matchCase: browseMyChanges browseObsoleteReferences browseViewReferencesFromNonViews showMenuOf:withFirstItem:ifChosenDo: showMenuOf:withFirstItem:ifChosenDo:withCaption:)('private' allSymbolsIn:do:)('Compiler swapping' actualCompiledMethodWithNodeClass actualCompilerClass actualDecompilerClass actualEncoderClass actualParserClass actualScannerClass)('Closure measurements' browseMethodsWithClosuresThatAccessOuterTemps browseMethodsWithClosuresThatOnlyReadOuterTemps browseMethodsWithClosuresThatWriteOuterTemps browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise browseMethodsWithEmptyClosures browseMethodsWithMoreThanOneClosure browseMethodsWithOnlyCleanClosures closuresInfoStringForClass:selector: eliotsClosureMeasurements eliotsClosureMeasurements2 eliotsClosureMeasurements2On: eliotsClosureMeasurementsOn:over:)('removing' removeKey:ifAbsent:)('system attributes' flagInterpretedMethods: isRunningCog isRunningCogit processHasThreadIdInstVar: processPreemptionYields processPreemptionYields:)('query' unusedBlocks)('testing' hasBindingThatBeginsWith:)('classes and traits' classNames nonClassNames)!Symbol removeSelector: #veryDeepCopyWith:!String removeSelector: #deepCopy!StrikeFont removeSelector: #veryDeepCopyWith:!SmallInteger removeSelector: #deepCopy!SmallInteger removeSelector: #veryDeepCopyWith:!Point removeSelector: #deepCopy!Point removeSelector: #veryDeepCopyWith:!PluggableButtonMorph removeSelector: #veryDeepFixupWith:!PluggableButtonMorph removeSelector: #veryDeepInner:!PasteUpMorph removeSelector: #veryDeepCopyWith:!!FileList class reorganize!('class initialization' initialize)('file reader registration' itemsForFile: registerFileReader: registeredFileReaderClasses suffixOf: unregisterFileReader:)!!Object class reorganize!('instance creation' initializedInstance newFrom: readFrom: unStream:)('documentation' howToModifyPrimitives whatIsAPrimitive)('object serialization' createFrom:size:version:)('class initialization' flushDependents flushEvents initialize initializeDependentsFields reInitializeDependentsFields)('windowColor' windowColor)!MorphExtension removeSelector: #comeFullyUpOnReload:!MorphExtension removeSelector: #veryDeepInner:!MenuMorph removeSelector: #veryDeepFixupWith:!MenuMorph removeSelector: #veryDeepInner:!MenuItemMorph removeSelector: #veryDeepFixupWith:!MenuItemMorph removeSelector: #veryDeepInner:!HandMorph removeSelector: #veryDeepCopyWith:!HaloMorph removeSelector: #veryDeepFixupWith:!HaloMorph removeSelector: #veryDeepInner:!Morph removeSelector: #deepCopy!Morph removeSelector: #veryDeepCopyWith:!Morph removeSelector: #veryDeepFixupWith:!Morph removeSelector: #veryDeepInner:!FileList removeSelector: #veryDeepFixupWith:!ChangeSorter removeSelector: #veryDeepFixupWith:!ChangeSorter removeSelector: #veryDeepInner:!Browser removeSelector: #veryDeepInner:!Model removeSelector: #objectForDataStream:!Model removeSelector: #veryDeepFixupWith:!Model removeSelector: #veryDeepInner:!!Model reorganize!('dependents' canDiscardEdits hasUnacceptedEdits myDependents myDependents:)!LeafNode removeSelector: #veryDeepFixupWith:!LeafNode removeSelector: #veryDeepInner:!DisplayScreen removeSelector: #usableArea!ColorForm removeSelector: #deepCopy!Form removeSelector: #comeFullyUpOnReload:!Form removeSelector: #deepCopy!Form removeSelector: #veryDeepCopyWith:!Float removeSelector: #deepCopy!Float removeSelector: #veryDeepCopyWith:!EventHandler removeSelector: #veryDeepFixupWith:!EventHandler removeSelector: #veryDeepInner:!CompiledMethod removeSelector: #veryDeepCopyWith:!Color removeSelector: #veryDeepCopyWith:!CharacterBlock removeSelector: #copy!Character removeSelector: #deepCopy!Character removeSelector: #veryDeepCopyWith:!ChangeSet removeSelector: #veryDeepCopyWith:!Boolean removeSelector: #deepCopy!Boolean removeSelector: #veryDeepCopyWith:!BlockNode removeSelector: #decompileText!Behavior removeSelector: #deepCopy!Behavior removeSelector: #veryDeepCopyWith:!ActiveModel removeSelector: #objectForDataStream:!!ActiveModel reorganize!('copying' copy)('accessing' actionMap releaseActionMap updateableActionMap)('dependents access' addDependent: breakDependents dependents removeDependent:)('updating' changed:)!Object removeSelector: #copyAddedStateFrom:!Object removeSelector: #deepCopy!Object removeSelector: #veryDeepCopy!Object removeSelector: #veryDeepCopyUsing:!Object removeSelector: #veryDeepCopyWith:!Object removeSelector: #veryDeepFixupWith:!Object removeSelector: #veryDeepInner:!!Object reorganize!('*tools-browser' browseClassHierarchy)('Breakpoint' break)('accessing' addInstanceVarNamed:withValue: at: at:put: basicAt: basicAt:put: basicSize customizeExplorerContents readFromString: size yourself)('as yet unclassified' revisar)('associating' ->)('binding' bindingOf:)('casing' caseOf: caseOf:otherwise:)('class membership' class isKindOf: isMemberOf: respondsTo:)('comparing' = closeTo: hash literalEqual: ~=)('converting' adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: as: asOrderedCollection asString asStringOrText complexContents mustBeBoolean mustBeBooleanIn: withoutListWrapper)('copying' clone copy copyForClipboard copyFrom: copySameFrom: copyTwoLevel postCopy shallowCopy)('creation' asMorph)('dependents access' addDependent: breakDependents canDiscardEdits dependents hasUnacceptedEdits myDependents myDependents: removeDependent:)('drag and drop' acceptDroppingMorph:event:inMorph:)('error handling' assert: caseError confirm: confirm:orCancel: doesNotUnderstand: error: halt halt: handles: notify:at: notifyWithLabel: primitiveFail primitiveFailed shouldBeImplemented shouldNotImplement subclassResponsibility)('evaluating' value valueWithArguments:)('events-accessing' actionForEvent: actionMap actionSequenceForEvent: actionsDo: hasActionForEvent: setActionSequence:forEvent: updateableActionMap)('events-registering' when:evaluate: when:send:to: when:send:to:with: when:send:to:withArguments:)('events-removing' releaseActionMap removeAction:forEvent: removeActionsForEvent: removeActionsSatisfying: removeActionsSatisfying:forEvent: removeActionsWithReceiver: removeActionsWithReceiver:forEvent:)('events-triggering' triggerEvent: triggerEvent:with: triggerEvent:withArguments:)('finalization' actAsExecutor executor finalizationRegistry finalize retryWithGC:until: toFinalizeSend:to:with:)('flagging' logEntry logExecution logExit)('inspecting' basicInspect inspect inspectWithLabel: inspectorClass)('macpal' currentWorld flash)('message handling' disableCode: perform: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: withArgs:executeMethod:)('object serialization' comeFullyUpOnReload: convertToCurrentVersion:refStream: indexIfCompact objectForDataStream: readDataFrom:size: storeDataOn:)('printing' fullPrintString isLiteral longPrintOn: longPrintOn:limitedTo:indent: longPrintString longPrintStringLimitedTo: nominallyUnsent: print printOn: printString printStringLimitedTo: printWithClosureAnalysisOn: storeOn: storeString stringRepresentation)('system primitives' becomeForward: becomeForward:copyHash: className instVarAt: instVarAt:put: instVarNamed: instVarNamed:put: primitiveChangeClassTo: someObject)('testing' is: isArray isBehavior isBlock isClosure isCollection isFloat isFraction isHeap isInteger isInterval isMethodProperties isNumber isPoint isPseudoContext isString isSymbol isVariableBinding name renameTo: stepAt:in: stepIn: stepTime stepTimeIn: wantsSteps wantsStepsIn:)('translation support' inline: success: var:declareC:)('updating' changed changed: noteSelectionIndex:for: okToChange update: windowIsClosing)('user interface' addModelItemsToWindowMenu: asExplorerString defaultLabelForInspector explore hasContentsInExplorer inform: modelSleep modelWakeUp modelWakeUpIn: notYetImplemented)('viewer' externalName)('private' errorImproperStore errorNonIntegerIndex errorNotIndexable errorSubscriptBounds: primitiveError: species storeAt:inTempFrame:)('nil' notify:)('tracing' explorePointers inboundPointers inboundPointersExcluding: outboundPointers outboundPointersDo:)!Smalltalk removeClassNamed: #DeepCopier!Smalltalk removeClassNamed: #PluggableDictionary!Smalltalk removeClassNamed: #PluggableSet!