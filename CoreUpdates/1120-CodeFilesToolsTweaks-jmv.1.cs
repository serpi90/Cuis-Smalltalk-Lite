'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 2 November 2011 at 10:22:37 pm'!!CodeFile commentStamp: '<historical>' prior: 0!My instances represent a file with Smalltalk code.!!ChangeSorter class methodsFor: 'adding' stamp: 'jmv 11/2/2011 19:47'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet |	oldChanges _ ChangeSet current.	PreviousSet _ oldChanges name. 		"so a Bumper update can find it"	newName _ aName sansPeriodSuffix.	newSet _ self basicNewChangeSet: newName.	[		newSet ifNotNil: [			ChangeSet newChanges: newSet.			aStream fileInAnnouncing: 'Loading ', newName, '...'.			Transcript show: 'File ', aName, ' successfully filed in to change set ', newName; cr].		aStream close	] ensure: [		ChangeSet  newChanges: oldChanges].	^ newSet! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'jmv 11/2/2011 19:03'!installChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fileName stream |	fullName ifNil: [^ Beeper beep].	fileName _ fullName.	(fullName endsWith: '.gz')		ifTrue: [			(self confirm: ('{1}appears to be a compressed file.Do you want to uncompress it?' format: { fullName }))				ifTrue: [					fileName _ GZipReadStream saveContents: fullName.					stream _ FileStream readOnlyFileNamed: fileName ]				ifFalse: [ ^self ]]		ifFalse: [			stream _ FileStream readOnlyFileNamed: fileName.			(fullName endsWith: '.mcz')				ifTrue: [					stream _ stream asUnZippedStream: 'snapshot/source.st'.					stream ascii ]].	self newChangesFromStream: stream named: (FileDirectory localNameFor: fileName)! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'jmv 11/2/2011 19:04'!serviceInstall	"Answer a service for installing a file into a new change set"	^ SimpleServiceEntry 		provider: self 		label: 'install into new change set'		selector: #installChangeSet:		description: 'install the file as a body of code in the image: create a new change set and file-in the selected file into it'		buttonLabel: 'install'! !!ChangeSorter class methodsFor: 'fileIn/Out' stamp: 'jmv 11/2/2011 19:04'!services	^ { self serviceInstall }	! !!CodeFile methodsFor: 'xtras' stamp: 'jmv 11/2/2011 17:59'!allMethodReferences	"Create an answer a Set with method references for all methods in us"	| answer className metaClass |	answer _ Set new.		self classes do: [ :pseudoClass | 		className _ pseudoClass name.		pseudoClass selectors do: [ :selector |			answer add: 				(MethodReference new					setClassSymbol: className					classIsMeta: false					methodSymbol: selector					stringVersion: className, ' ' , selector) ].		pseudoClass hasMetaclass ifTrue: [			metaClass _ pseudoClass metaClass.			metaClass selectors do: [ :selector |				answer add: 					(MethodReference new						setClassSymbol: className						classIsMeta: true						methodSymbol: selector						stringVersion: className, ' class ' , selector) ].				]].	^answer! !!CodeFileBrowser methodsFor: 'fileIn/fileOut' stamp: 'jmv 11/2/2011 22:14'!fileIntoNewChangeSet	| sel ff |	(sel _ self selectedCodeFile) ifNil: [^ Beeper beep].	ff _ StandardFileStream readOnlyFileNamed: sel fullName.	ChangeSorter newChangesFromStream: ff named: sel name! !!CodeFileBrowser methodsFor: 'infoView' stamp: 'jmv 11/2/2011 18:42'!infoFor: aCodeFile	| nClasses newClasses oldClasses |	aCodeFile ifNil: [^''].	nClasses := newClasses := oldClasses := 0.	aCodeFile classes do:[:cls|		nClasses := nClasses + 1.		(Smalltalk includesKey: (cls name asSymbol))			ifTrue: [ oldClasses := oldClasses + 1]			ifFalse: [ newClasses := newClasses + 1]].	^nClasses printString,' classes (', newClasses printString, ' new / ', oldClasses printString, ' modified)'! !!CodeFileBrowser methodsFor: 'infoView' stamp: 'jmv 11/2/2011 18:42'!infoViewContents	| theClass |	editSelection == #newClass ifTrue: [^ self infoFor: self selectedCodeFile].	self selectedClass ifNil: [^ ''].	theClass _ Smalltalk at: self selectedClass name asSymbol ifAbsent: nil.	editSelection == #editClass ifTrue: [		^ theClass			ifNotNil: ['Class exists already in the system']			ifNil: ['New class']].	editSelection == #editMessage ifFalse: [^ ''].	(theClass notNil and: [self metaClassIndicated])		ifTrue: [theClass _ theClass class].	^ (theClass notNil and: [theClass includesSelector: self selectedMessageName])		ifTrue: ['Method already exists' , self extraInfo]		ifFalse: ['New method']! !!FileStream class methodsFor: 'file reader services' stamp: 'jmv 11/2/2011 18:44'!fileReaderServicesForFile: fullName suffix: suffix	"Answer services for the given file"	^ ((self isSourceFileSuffix: suffix) or: [ suffix = 'mcz' ])		ifTrue: [ {self serviceFileIn} ]		ifFalse: [ #() ]! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'jmv 11/2/2011 19:04'!fileReaderServicesForFile: fullName suffix: suffix 	| services |	(suffix = 'gz') | (suffix = '*')		ifFalse: [^ #()].	services _ OrderedCollection new.	(suffix = '*') | (fullName asLowercase endsWith: '.cs.gz')		ifTrue: [			services add: self serviceFileIn.			services add: self serviceInstall ].	services addAll: self services.	^ services! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'jmv 11/2/2011 19:03'!installChangeSet: fullFileName	"FileIn the contents of a gzipped file"	| zipped unzipped |	zipped _ self on: (FileStream readOnlyFileNamed: fullFileName).	unzipped _ ReadStream on: zipped contents asString.	ChangeSorter newChangesFromStream: unzipped named: (FileDirectory localNameFor: fullFileName)! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'jmv 11/2/2011 19:04'!serviceInstall	"Answer a service for filing in an entire file"	^ SimpleServiceEntry		provider: self		label: 'install into new change set'		selector: #installChangeSet:		description: 'install the decompressed contents of the file as a body of code in the image: create a new change set and file-in the selected file into it'		buttonLabel: 'install'! !GZipReadStream class removeSelector: #fileIntoNewChangeSet:!GZipReadStream class removeSelector: #serviceFileIntoNewChangeSet!ChangeSorter class removeSelector: #fileIntoNewChangeSet:!ChangeSorter class removeSelector: #serviceFileIntoNewChangeSet!