'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 9 December 2008 at 4:45:40 pm'!!Duration methodsFor: 'testing' stamp: 'jmv 12/4/2008 14:54'!isZero	^seconds = 0 and: [nanos = 0]! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jmv 12/4/2008 14:53'!remoteCursorReceiver	"Wait for a connection, then display data sent by the client until the client closes the stream. This server process is usually started first (optionally in a forked process), then the sender process is started (optionally on another machine). Note this machine's address, which is printed in the transcript, since the sender process will ask for it."	"[OldSimpleClientSocket remoteCursorReceiver] fork"	| sock response ary oldCursor |	Transcript show: 'starting remote cursor receiver'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'opening connection'; cr.	sock _ OldSimpleClientSocket new.	sock listenOn: 54323.	sock waitForConnectionUntil: (Socket deadlineSecs: 60).	sock isConnected		ifFalse: [			 sock destroy.			Transcript show: 'remote cursor receiver did not receive a connection in 60 seconds; aborting.'.			^ self].	Transcript show: 'connection established'; cr.	oldCursor _ ActiveHand temporaryCursor.	ActiveHand showTemporaryCursor: Cursor normal.	[sock isConnected]		whileTrue: [			sock dataAvailable				ifTrue: [					response _ sock getResponse.					ary _ Compiler evaluate: response.					Sensor processEvent: ary.					ActiveHand temporaryCursor isNil ifTrue: [						ActiveHand showTemporaryCursor: Cursor normal]					]				ifFalse: [					"if no data available, let other processes run for a while"					(Delay forMilliseconds: 60) wait]].	sock destroy.	Transcript show: 'remote cursor receiver done'; cr.	ActiveHand showTemporaryCursor: oldCursor! !!Schedule methodsFor: 'enumerating' stamp: 'jmv 12/8/2008 11:21'!between: aStart and: anEnd do: aBlock
	| element end i startDate |	end _ self end min: anEnd.	element _ self start.
		"Performance optimization. Avoid going through unnecesary days if easy."	startDate _ aStart asDate.	(startDate > element asDate and: [ self everyDayAtSameTimes ]) ifTrue: [		element _ DateAndTime date: startDate time: element asTime ].	i _ 1.	[ element < aStart ] whileTrue: [	
	element _ element + (schedule at: i).
		i _ i + 1.		i > schedule size ifTrue: [i _ 1]].
	i _ 1.
	[ element <= end ] whileTrue: [	
	aBlock value: element.		element _ element + (schedule at: i).
		i _ i + 1.		i > schedule size ifTrue: [i _ 1]]
.! !!Schedule methodsFor: 'private' stamp: 'jmv 12/5/2008 13:25'!everyDayAtSameTimes	"Answer false if unknown"		| count |	count _ (Duration days: 1) / self scheduleDuration.	^count >=1 and: [ count isInteger ]! !!Schedule methodsFor: 'private' stamp: 'jmv 12/5/2008 13:21'!scheduleDuration	^schedule sum! !