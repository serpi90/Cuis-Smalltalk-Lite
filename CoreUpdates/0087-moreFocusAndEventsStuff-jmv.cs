'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 11 November 2008 at 12:35:52 am'!!classDefinition: #OldOneLineEditorMorph category: #'Morphic-Old-Basic'!OldMorph subclass: #OldOneLineEditorMorph	instanceVariableNames: 'font emphasis contents hasFocus editor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Old-Basic'!!classDefinition: #OldUpdatingStringMorph category: #'Morphic-OldWidgets'!OldStringMorph subclass: #OldUpdatingStringMorph	instanceVariableNames: 'target lastValue getSelector putSelector growable stepTime autoAcceptOnFocusLoss minimumWidth maximumWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-OldWidgets'!!EventHandler methodsFor: 'testing' stamp: 'jmv 11/10/2008 12:57'!handlesKeyboard	keyStrokeRecipient ifNotNil: [^ true].	^ false! !!ImageSegment methodsFor: 'testing' stamp: 'jmv 11/10/2008 14:33'!findRogueRootsPrep
	"Part of the tool to track down unwanted pointers into the segment.  Break all owner pointers in submorphs, scripts, and viewers in flaps."

| wld morphs |
wld _ arrayOfRoots detect: [:obj | 
	obj isMorph ifTrue: [obj isWorldMorph] ifFalse: [false]] ifNone: [nil].
wld ifNil: [wld _ arrayOfRoots detect: [:obj | obj isMorph] 
				ifNone: [^ self error: 'can''t find a root morph']].
morphs _ IdentitySet new: 400.
wld allMorphsDo: [ :m |  morphs add: m ].
morphs do: [:mm | 	"break the back pointers"
	mm isInMemory ifTrue: [
	(mm respondsTo: #target) ifTrue: [
		mm nearestOwnerThat: [:ow | ow == mm target 
			ifTrue: [mm target: nil. true]
			ifFalse: [false]]].
	(mm respondsTo: #arguments) ifTrue: [
		mm arguments do: [:arg | arg ifNotNil: [
			mm nearestOwnerThat: [:ow | ow == arg
				ifTrue: [mm arguments at: (mm arguments indexOf: arg) put: nil. true]
				ifFalse: [false]]]]].
	mm eventHandler ifNotNil: ["recipients point back up"
		(morphs includesAllOf: (mm eventHandler allRecipients)) ifTrue: [
			mm eventHandler: nil]].
	"temporary, until using Model for PartsBin"
	(mm isMorphicModel) ifTrue: [
		(mm model isMorphicModel) ifTrue: [
			mm model breakDependents]].
	(mm isTextMorph) ifTrue: [mm setContainer: nil]]].
(Smalltalk includesKey: #Owners) ifTrue: [Smalltalk at: #Owners put: nil].
	"in case findOwnerMap: is commented out"
"self findOwnerMap: morphs."
morphs do: [:mm | 	"break the back pointers"
	mm isInMemory ifTrue: [mm privateOwner: nil]].
"more in extensions?"

! !!LightWidget methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:52'!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	^ false! !!LightWidget methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:52'!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?"		^ false! !!LightWidget methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:52'!handlesMouseOverDragging: evt	"Return true if I want to receive mouseEnterDragging: and mouseLeaveDragging: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient."	"NOTE:  If the hand state matters in these cases, it may be tested by constructs such as		event anyButtonPressed		event hand hasSubmorphs"	^ false! !!LightWidget methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:53'!handlesMouseStillDown: evt	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"	^ false! !!LightWidget methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:53'!mouseMove: evt	"Handle a mouse move event."! !!LightWidget methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:53'!mouseStillDown: evt	"Handle a mouse move event."! !!LightWidget methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:53'!mouseUp: evt	"Handle a mouse up event."! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:02'!handleKeyDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:[^self].	anEvent wasHandled: true.	^self keyDown: anEvent! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:02'!handleKeyUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:[^self].	anEvent wasHandled: true.	^self keyUp: anEvent! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:03'!handleKeystroke: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:[^self].	anEvent wasHandled: true.	^self keyStroke: anEvent! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 12:59'!handlesKeyboard	"Return true if the receiver wishes to handle keyboard"		^ false! !!LightWidget methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 12:53'!keyStroke: anEvent	"Handle a keystroke event. "! !!LightWidget methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 15:50'!gotNavigationFocus	owner ifNotNil: [owner gotNavigationFocus: self].	self" comeToFront; "changed! !!LightWidget methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 13:31'!hasKeyboardFocus	^ActiveHand notNil and: [ActiveHand keyboardFocus == self]! !!LightWidget methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 13:40'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes could change their appearance in some way when they are the current keyboard focus. This default implementation does nothing.		Only morphs that answer true to #handlesKeyboard will ever get keyboard focus!!"! !!LightWidget methodsFor: 'structure' stamp: 'jmv 11/10/2008 23:04'!veryLastLeave	"Answer the last submorph, recursively, i.e. the very last leave of the morph tree"	^self! !!LightWidget methodsFor: 'user interface' stamp: 'jmv 11/10/2008 23:51'!activateWindow	self activateWindowAndSendTopToBack: false! !!LightWidget methodsFor: 'user interface' stamp: 'jmv 11/10/2008 23:50'!activateWindowAndSendTopToBack: aBoolean	| w |	(w _ self ownerThatIsA: OldSystemWindow) ifNotNil: [		w isTopWindow ifFalse: [			w activateAndSendTopToBack: aBoolean]].! !!LightWidget methodsFor: 'iteration of all morphs' stamp: 'jmv 11/10/2008 23:03'!nextMorph	"Iterate over all morphs in the receiver structure (usually all morphs living in the receiver's world).	Do a DFS (Depth First Seach) over the morphs tree"	^self nextMorphPart2! !!LightWidget methodsFor: 'iteration of all morphs' stamp: 'jmv 11/10/2008 23:02'!nextMorphPart2		| next |	owner ifNotNil: [		next _ owner submorphBehind: self.		next ifNotNil: [ ^ next ].				^ owner nextMorphPart2 ].	^ self! !!LightWidget methodsFor: 'iteration of all morphs' stamp: 'jmv 11/10/2008 23:03'!previousMorph	"Iterate over all morphs in the receiver structure (usually all morphs living in the receiver's world),	in 'backward'  direction.	Do a DFS (Depth First Seach) over the morphs tree"		| prev |	owner ifNotNil: [		prev _ owner submorphInFrontOf: self.		prev ifNotNil: [ ^prev veryLastLeave ].		^owner ].	^self veryLastLeave! !!ButtonLW methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 12:58'!handlesKeyboard	^true! !!CheckBoxLW methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 12:58'!handlesKeyboard	^true! !!CompositeLW methodsFor: 'submorphs-accessing' stamp: 'jmv 11/10/2008 23:03'!submorphBehind: aMorph	^submorphs after: aMorph! !!CompositeLW methodsFor: 'submorphs-accessing' stamp: 'jmv 11/10/2008 23:03'!submorphInFrontOf: aMorph	^submorphs before: aMorph! !!CompositeLW methodsFor: 'iteration of all morphs' stamp: 'jmv 11/10/2008 23:02'!nextMorph	"Iterate over all morphs in the receiver structure (usually all morphs living in the receiver's world).	Do a DFS (Depth First Seach) over the morphs tree"		submorphs isEmpty		ifFalse: [ ^submorphs first ].	^self nextMorphPart2! !!CompositeLW methodsFor: 'structure' stamp: 'jmv 11/10/2008 23:04'!veryLastLeave	"Answer the last submorph, recursively, i.e. the very last leave of the morph tree"	^submorphs size = 0		ifTrue: [ self ]		ifFalse: [ submorphs last veryLastLeave ]! !!EntryFieldLW methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:58'!handlesKeyboard	^ true ! !!EntryFieldLW methodsFor: 'drawing' stamp: 'jmv 11/10/2008 13:30'!drawOn: aCanvas	| string leftX w cColor borderWidth  stringBounds font xOffset xExtent selectionBounds orig ext cursorBounds str |	borderWidth _ self borderWidth.	aCanvas frameAndFillRectangle: bounds fillColor: self backgroundColor borderWidth: borderWidth borderColor: self borderColor.	self isValid ifFalse:[aCanvas fillRectangle: bounds  color: (Color red alpha:0.4)]. 	string _ self value.	stringBounds _ self stringPosition extent: bounds extent - (2* borderWidth). 	hideValue ifTrue:[ str _ string collect:[:char| $*]] ifFalse:[ str_ string].	aCanvas drawString: str in: stringBounds font: self font color: color.	self hasSelection		ifTrue:[ 			font _ self font.			xOffset _ 0.			(1 to: selection first - 1) do:[:i| xOffset _  xOffset + (font widthOf: (string at:i))].			xExtent _ 0.			 selection do:[:i|  xExtent _ xExtent + (font widthOf: (string at:i))]. 			selectionBounds _  (stringBounds origin +(xOffset@0) ) extent: (xExtent@ stringBounds extent y).			aCanvas fillRectangle: selectionBounds color: (Color green lighter alpha:0.5)]. 			xOffset _ 0. 	font _ self font.	(string notNil and:[string notEmpty ])		ifTrue:[					cursorPosition _ cursorPosition min: string size+1.				(0 to: cursorPosition -2 ) do:[:i|  xOffset _ xOffset + (font widthOf: (string at:i+1))]].		orig _ self stringPosition + (xOffset@0).	ext _  2@ stringBounds extent y.	cursorBounds _ orig extent: ext.	leftX _ cursorBounds origin x + (cursorBounds extent x / 2).	self hasKeyboardFocus ifTrue: [		w := 4.		cColor :=  self cursorColor.		1 to: w do: [:i | 			aCanvas fillRectangle: ((leftX - w + i - 1) @ (cursorBounds origin y + i - 1)					extent: ((w - i) * 2 + 3) @ 1)				color: cColor.			aCanvas fillRectangle: ((leftX - w + i - 1) @ (cursorBounds origin y + cursorBounds extent y - i) 					extent: ((w - i) * 2 + 3) @ 1)				color: cColor].		aCanvas fillRectangle: cursorBounds color: cColor ]					! !!Model methodsFor: 'keyboard' stamp: 'jmv 11/10/2008 11:37'!arrowKey: aChar from: view	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index.  Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |     keyEvent _ aChar asciiValue.     oldSelection := view getCurrentSelectionIndex.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[self okToChange			ifTrue:				[view changeModelSelection: nextSelection.				"view controller moveMarker"]]			! !!OldMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:40'!handlesKeyboard	"Return true if the receiver wishes to handle keyboard events"		self eventHandler ifNotNil: [^ self eventHandler handlesKeyboard].	^ false! !!OldMorph methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:03'!handleKeyDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:[^self].	anEvent wasHandled: true.	^self keyDown: anEvent! !!OldMorph methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:03'!handleKeyUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:[^self].	anEvent wasHandled: true.	^self keyUp: anEvent! !!OldMorph methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:03'!handleKeystroke: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:[^self].	anEvent wasHandled: true.	^self keyStroke: anEvent! !!OldMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 15:49'!gotNavigationFocus	owner ifNotNil: [owner gotNavigationFocus: self].	self "comeToFront; " changed! !!OldMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 13:31'!hasKeyboardFocus	^ActiveHand notNil and: [ActiveHand keyboardFocus == self]! !!OldMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 13:40'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes should change their appearance in some way when they are the current keyboard focus. This default implementation does nothing.		Only morphs that answer true to #handlesKeyboard will ever get keyboard focus!!"! !!OldMorph methodsFor: 'structure' stamp: 'jmv 11/10/2008 15:13'!veryLastLeave	"Answer the last submorph, recursively, i.e. the very last leave of the morph tree"	^submorphs size = 0		ifTrue: [ self ]		ifFalse: [ submorphs last veryLastLeave ]! !!OldMorph methodsFor: 'submorphs-accessing' stamp: 'jmv 11/10/2008 14:51'!submorphBehind: aMorph	^submorphs after: aMorph! !!OldMorph methodsFor: 'submorphs-accessing' stamp: 'jmv 11/10/2008 14:59'!submorphInFrontOf: aMorph	^submorphs before: aMorph! !!OldMorph methodsFor: 'user interface' stamp: 'jmv 11/10/2008 23:51'!activateWindow	self activateWindowAndSendTopToBack: false! !!OldMorph methodsFor: 'user interface' stamp: 'jmv 11/10/2008 23:51'!activateWindowAndSendTopToBack: aBoolean	| w |	(w _ self ownerThatIsA: OldSystemWindow) ifNotNil: [		w isTopWindow ifFalse: [			w activateAndSendTopToBack: aBoolean]].! !!OldMorph methodsFor: 'iteration of all morphs' stamp: 'jmv 11/10/2008 15:51'!nextMorph	"Iterate over all morphs in the receiver structure (usually all morphs living in the receiver's world).	Do a DFS (Depth First Seach) over the morphs tree"		submorphs isEmpty		ifFalse: [ ^submorphs first ].	^self nextMorphPart2! !!OldMorph methodsFor: 'iteration of all morphs' stamp: 'jmv 11/10/2008 15:51'!nextMorphPart2		| next |	owner ifNotNil: [		next _ owner submorphBehind: self.		next ifNotNil: [ ^ next ].				^ owner nextMorphPart2 ].	^ self	! !!OldMorph methodsFor: 'iteration of all morphs' stamp: 'jmv 11/10/2008 22:55'!previousMorph	"Iterate over all morphs in the receiver structure (usually all morphs living in the receiver's world),	in 'backward'  direction.	Do a DFS (Depth First Seach) over the morphs tree"		| prev |	owner ifNotNil: [		prev _ owner submorphInFrontOf: self.		prev ifNotNil: [ ^prev veryLastLeave ].		^owner ].	^self veryLastLeave! !!OldHaloMorph methodsFor: 'private' stamp: 'jmv 11/10/2008 13:07'!obtainHaloForEvent: evt andRemoveAllHandlesBut: aHandle	"Make sure the event's hand correlates with the receiver, and remove all handles except the given one.  If nil is provided as the handles argument, the result is that all handles are removed.  Note that any pending edits to the name-string in the halo are accepted at this time."	evt hand obtainHalo: self.	self removeAllHandlesBut: aHandle! !!OldHandMorph methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 23:20'!handleEvent: anEvent	| evt ofs k |	owner ifNil:[^self].	evt _ anEvent.	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[	Display fill: (0@0 extent: 450@120) rule: Form over fillColor: Color white.	ofs _ (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	(keyboardFocus printString,		'    ', self navigationFocus printString) displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.	evt isKeyboard ifTrue:[		(evt commandKeyPressed and: [evt isKeystroke]) ifTrue: ["			(navigationFocus notNil and: [ navigationFocus seizesNavigationFocus ]) ifFalse: ["				k _ evt keyValue.				k = 28 ifTrue: [					self keyboardFocusPrevious.					^self mouseOverHandler processMouseOver: lastMouseEvent].				k = 29 ifTrue: [					self keyboardFocusNext.					^self mouseOverHandler processMouseOver: lastMouseEvent].				k = 30 ifTrue: [					self keyboardFocusPrevious.					^self mouseOverHandler processMouseOver: lastMouseEvent].				k = 31 ifTrue: [					self keyboardFocusNext.					^self mouseOverHandler processMouseOver: lastMouseEvent]."			]."		].		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 00:01'!keyboardFocusNext	| firstCandidate candidate |	firstCandidate _ keyboardFocus isNil		ifTrue: [ World submorphs first ]		ifFalse: [ keyboardFocus nextMorph ].		candidate _ firstCandidate.	candidate handlesKeyboard ifFalse: [		[			candidate _ candidate nextMorph.			candidate handlesKeyboard not and: [ candidate ~~ firstCandidate ] ] whileTrue ].	candidate activateWindowAndSendTopToBack: true.	candidate flash.	self newKeyboardFocus: candidate! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/11/2008 00:02'!keyboardFocusPrevious	| firstCandidate candidate |	firstCandidate _ keyboardFocus isNil		ifTrue: [ World ]		ifFalse: [ keyboardFocus previousMorph ].	candidate _ firstCandidate.	candidate handlesKeyboard ifFalse: [		[			candidate _ candidate previousMorph.			candidate handlesKeyboard not and: [ candidate ~~ firstCandidate ] ] whileTrue ].	candidate activateWindow.	candidate flash.	self newKeyboardFocus: candidate! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 8/19/2008 10:35'!navigationFocus: aMorph	| sameAsOld |	sameAsOld _ aMorph == navigationFocus.	self newKeyboardFocus: aMorph.	(sameAsOld not and: [navigationFocus notNil]) ifTrue: [		navigationFocus lostNavigationFocus].	navigationFocus _ (aMorph == World) ifTrue: [nil] ifFalse: [aMorph].	(sameAsOld not and: [navigationFocus notNil]) ifTrue: [		navigationFocus gotNavigationFocus].! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 15:16'!navigationFocusIn	navigationFocus isNil		ifTrue: [			^self navigationFocus:World submorphs first].				"	navigationFocus submorphs isEmpty		ifTrue: [^self].	self navigationFocus: navigationFocus submorphs first.	navigationFocus skipsNavigationFocus ifTrue: [		self navigationFocusNext ]	"	self navigationFocus: navigationFocus nextMorph! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 15:56'!navigationFocusOut	navigationFocus isNil		ifTrue: [^self].			"	self navigationFocus: navigationFocus owner.	(navigationFocus notNil and: [ navigationFocus skipsNavigationFocus ]) ifTrue: [		self navigationFocusNext ]	"		self navigationFocus: navigationFocus previousMorph! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 13:30'!newKeyboardFocus: aMorphOrNil	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	| oldFocus |	oldFocus _ keyboardFocus.	keyboardFocus _ aMorphOrNil.	oldFocus ifNotNil: [oldFocus == aMorphOrNil ifFalse: [oldFocus keyboardFocusChange: false]].	aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true].! !!OldHandMorph methodsFor: 'focus handling' stamp: 'jmv 11/10/2008 13:30'!releaseKeyboardFocus: aMorph	"If the given morph had the keyboard focus before, release it"	keyboardFocus == aMorph ifTrue:[self releaseKeyboardFocus].! !!OldMenuMorph methodsFor: 'drawing' stamp: 'jmv 11/10/2008 13:31'!drawOn: aCanvas	"Draw the menu.  Add keyboard-focus feedback if appropriate"	super drawOn: aCanvas.	(self hasKeyboardFocus and: [self rootMenu hasProperty: #hasUsedKeyboard])		ifTrue:		[aCanvas frameAndFillRectangle: self innerBounds fillColor: Color transparent				borderWidth: 1 borderColor: Preferences keyboardFocusColor]! !!OldMenuMorph methodsFor: 'keyboard control' stamp: 'jmv 11/10/2008 13:00'!handlesKeyboard	"Answer whether the receiver handle keyboard events"	^true! !!OldOneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 11/10/2008 13:27'!selectionColor	| c |	Display depth = 1 ifTrue: [^ Color veryLightGray].	Display depth = 2 ifTrue: [^ Color gray: 0.87].	c := Preferences textHighlightColor.	self hasKeyboardFocus ifFalse: [c := c alphaMixed: 0.2 with: Color veryVeryLightGray].	^ c! !!OldOneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:01'!handlesKeyboard	^true! !!OldOneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:28'!keyboardFocusChange: aBoolean 	aBoolean ifTrue: [		"A hand is wanting to send us characters... Ensure editor."		self editor ].	self changed! !!OldOneLineEditorMorph methodsFor: 'initialization' stamp: 'jmv 11/10/2008 13:28'!initialize	super initialize.	font _ nil.	emphasis _ 0! !!OldOneLineEditorMorph methodsFor: 'testing' stamp: 'jmv 11/10/2008 13:28'!hasCaret	^ self hasKeyboardFocus and: [editor hasCaret]! !!OldPasteUpMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:52'!mouseDown: evt
	"Handle a mouse down event."
	| grabbedMorph handHadHalos handler |
	grabbedMorph _ self morphToGrab: evt.
	grabbedMorph ifNotNil:[
		grabbedMorph isSticky ifTrue:[^self].
		^evt hand grabMorph: grabbedMorph].
	handler _ self eventHandler.	(handler notNil and: [handler handlesMouseDown: evt])		ifTrue: [^handler mouseDown: evt fromMorph: self].		
	handHadHalos _ evt hand halo notNil.
	evt hand halo: nil. "shake off halos"
	evt hand releaseKeyboardFocus. "shake of keyboard foci"
	evt shiftPressed ifTrue:[
		^evt hand 
			waitForClicksOrDrag: self 
			event: evt 
			selectors: { #findWindow:. nil. nil. #dragThroughOnDesktop:}
			threshold: 5].
	self isWorldMorph ifTrue: [
		handHadHalos ifTrue: [^self addAlarm: #invokeWorldMenu: with: evt after: 200].
		^self invokeWorldMenu: evt
	].
	"otherwise, explicitly ignore the event if we're not the world,
	so that we could be picked up if need be"
	self isWorldMorph ifFalse:[evt wasHandled: false].
! !!OldPasteUpMorph methodsFor: 'world menu' stamp: 'jmv 12/24/2004 14:54'!invokeWorldMenu: evt
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	self putUpWorldMenu: evt! !!OldScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/10/2008 13:14'!hIsScrollbarNeeded"Return whether the horz scrollbar is needed"	"Don't do anything with the retractable scrollbar unless we have focus"	retractableScrollBar & hasFocus not ifTrue: [^false].		"Don't show it if we were told not to."	(self valueOfProperty: #noHScrollBarPlease ifAbsent: [false]) ifTrue: [^false].	"Always show it if we were told to"	(self valueOfProperty: #hScrollBarAlways ifAbsent: [false]) ifTrue: [^true].	^self hIsScrollable! !!OldScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/10/2008 13:14'!hideOrShowScrollBar	"Hide or show the scrollbar depending on if the pane is scrolled/scrollable."	"Don't do anything with the retractable scrollbar unless we have focus"	retractableScrollBar & hasFocus not ifTrue: [^self].	"Don't show it if we were told not to."	(self valueOfProperty: #noScrollBarPlease ifAbsent: [false]) ifTrue: [^self].	self vIsScrollable not & self isScrolledFromTop not ifTrue: [self vHideScrollBar].	self vIsScrollable | self isScrolledFromTop ifTrue: [self vShowScrollBar].! !!OldScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/10/2008 13:14'!vIsScrollbarNeeded"Return whether the verticle scrollbar is needed"	"Don't do anything with the retractable scrollbar unless we have focus"	retractableScrollBar & hasFocus not ifTrue: [^false].		"Don't show it if we were told not to."	(self valueOfProperty: #noVScrollBarPlease ifAbsent: [false]) ifTrue: [^false].	"Always show it if we were told to"	(self valueOfProperty: #vScrollBarAlways ifAbsent: [false]) ifTrue: [^true].		^self vIsScrollable! !!OldPluggableListMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:00'!handlesKeyboard	^true! !!OldPluggableListMorph methodsFor: 'events' stamp: 'jmv 11/10/2008 13:32'!mouseDown: evt	| selectors row |	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	selectors _ Array 		with: #click:		with: (doubleClickSelector ifNotNil:[#doubleClick:])		with: nil		with: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil]).	evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10 "pixels".! !!OldPluggableListMorph methodsFor: 'model access' stamp: 'jmv 11/10/2008 11:34'!specialKeyPressed: asciiValue	"A special key with the given ascii-value was pressed; dispatch it"	| oldSelection nextSelection max howManyItemsShowing |	asciiValue = 27 ifTrue: 		[" escape key"		^ ActiveEvent shiftPressed			ifFalse:				[self yellowButtonActivity: false]].	max _ self maximumSelection.	max > 0 ifFalse: [^ self].	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	asciiValue = 31 ifTrue: 		[" down arrow"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].	asciiValue = 30 ifTrue: 		[" up arrow"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].	asciiValue = 1 ifTrue:		[" home"		nextSelection _ 1].	asciiValue = 4 ifTrue:		[" end"		nextSelection _ max].	howManyItemsShowing _ self numSelectionsInView.	asciiValue = 11 ifTrue:		[" page up"		nextSelection _ 1 max: oldSelection - howManyItemsShowing].	asciiValue = 12 ifTrue:		[" page down"		nextSelection _ oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection = nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!OldPluggableTextMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 23:34'!handlesKeyboard	self flag: #jmv.	"This helps not hitting pluggable texts twice during navigation. Only the internal text morph will receive it.	If some problem is found, introduce a new selector, that answers ^self handlesKeyboard in morph (and LW) 	and only in this class it will answer false""	^true" 	^ super handlesKeyboard! !!OldSimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:00'!handlesKeyboard	^true! !!OldStringMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:53'!handlesMouseDown: evt	^ (evt shiftPressed and: [self userEditsAllowed]) 		or: [super handlesMouseDown: evt]! !!OldStringMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:34'!mouseDown: evt	"If the shift key is pressed, make this string the keyboard input focus."	(evt shiftPressed and: [self userEditsAllowed])		ifTrue: [self launchMiniEditor: evt]		ifFalse: [super mouseDown: evt].! !!OldStringMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:31'!userEditsAllowed	"Answer whether user-edits are allowed to this field"	^ self isLocked not! !!OldStringMorph methodsFor: 'initialization' stamp: 'jmv 11/10/2008 13:21'!initWithContents: aString font: aFont emphasis: emphasisCode 	self initialize.		font _ aFont.	emphasis _ emphasisCode.	self contents: aString! !!OldMenuItemMorph methodsFor: 'initialization' stamp: 'jmv 11/10/2008 13:21'!initialize	"initialize the state of the receiver"	super initialize.	""		contents _ ''.	isEnabled _ true.	subMenu _ nil.	isSelected _ false.	target _ nil.	selector _ nil.	arguments _ nil.	font _ Preferences standardMenuFont.	self hResizing: #spaceFill;		 vResizing: #shrinkWrap! !!OldSystemWindow methodsFor: 'top window' stamp: 'jmv 11/11/2008 00:30'!activate
	"Bring me to the front and make me able to respond to mouse and keyboard"
	| candidate |	self activateAndSendTopToBack: false.		candidate _ self.	candidate handlesKeyboard ifFalse: [		[			candidate _ candidate nextMorph.			candidate handlesKeyboard not and: [ candidate ~~  self ] ] whileTrue ].	candidate handlesKeyboard ifTrue: [		candidate flash.		self world primaryHand newKeyboardFocus: candidate ]! !!OldSystemWindow methodsFor: 'top window' stamp: 'jmv 11/10/2008 23:50'!activateAndSendTopToBack: aBoolean
	"Bring me to the front and make me able to respond to mouse and keyboard"

	| oldTop |
	self owner 
		ifNil: [^self	"avoid spurious activate when drop in trash"].
	oldTop := TopWindow.
	TopWindow := self.
	oldTop ifNotNil: [		oldTop passivate.		aBoolean ifTrue: [			oldTop owner addMorphBack: oldTop ]].
	self owner firstSubmorph == self 
		ifFalse: [
			"Bring me (with any flex) to the top if not already"
			self owner addMorphFront: self].
	labelArea ifNotNil:  [
			self setStripeColorsFrom: self paneColorToUse].
	self isCollapsed 
		ifFalse: [
			model modelWakeUpIn: self.
			self positionSubmorphs.
			labelArea ifNil: [self adjustBorderUponActivationWhenLabeless]]! !!OldTextMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:01'!handlesKeyboard	^true! !!OldTextMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:16'!keyboardFocusChange: aBoolean 	"rr 3/21/2004 22:55 : removed the #ifFalse: branch, 	which was responsible of the deselection of text when the 	paragraph lost focus. This way selection works in a more standard 	way, and this permits the menu keyboard control to be really effective"		paragraph isNil ifFalse: [paragraph focused: aBoolean].	aBoolean ifTrue: [		"A hand is wanting to send us characters..."		editor isNil ifTrue: [ self editor	"Forces install"]].	self changed.! !!OldTextMorph methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 13:03'!handleKeystroke: anEvent
	"System level event handling."

	anEvent wasHandled ifTrue:[^self].
	self handlesKeyboard ifFalse:	[^ self].
	anEvent wasHandled: true.
	self keyStroke: anEvent! !!OldStringMorphEditor methodsFor: 'event handling' stamp: 'jmv 11/10/2008 13:15'!keyboardFocusChange: aBoolean	| hadFocus |	hadFocus _ owner hasFocus.	super keyboardFocusChange: aBoolean.	aBoolean ifFalse: [		hadFocus ifTrue: [			owner lostFocusWithoutAccepting; doneWithEdits].		^ self delete]! !!OldUpdatingStringMorph methodsFor: 'copying' stamp: 'jmv 11/10/2008 13:12'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared."	super veryDeepInner: deepCopier.	target _ target.					"Weakly copied"	lastValue _ lastValue veryDeepCopyWith: deepCopier.	getSelector _ getSelector.			"Symbol"	putSelector _ putSelector.		"Symbol"	growable _ growable veryDeepCopyWith: deepCopier.	stepTime _ stepTime veryDeepCopyWith: deepCopier.	minimumWidth _ minimumWidth veryDeepCopyWith: deepCopier.	maximumWidth _ maximumWidth veryDeepCopyWith: deepCopier.! !!OldUpdatingStringMorph methodsFor: 'editing' stamp: 'jmv 11/10/2008 13:09'!lostFocusWithoutAccepting	"The message is sent when the user, having been in an editing episode on the receiver, changes the keyboard focus -- typically by clicking on some editable text somewhere else -- without having accepted the current edits."	self doneWithEdits; acceptContents! !!OldUpdatingStringMorph methodsFor: 'editing' stamp: 'jmv 11/10/2008 12:33'!userEditsAllowed	"Answer whether user-edits are allowed to this field"	^ putSelector notNil and: [ super userEditsAllowed ]! !!OldUpdatingStringMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 14:13'!handlesMouseDown: evt	^self userEditsAllowed		or: [ super handlesMouseDown: evt ]! !!OldUpdatingStringMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2008 14:08'!mouseDown: evt	"The mouse went down over the receiver.  If appropriate, launch a mini-editor so that the user can commence text-editing here"	self userEditsAllowed		ifTrue: [			(owner respondsTo: #parseNode)				ifTrue: 	"leave space for editing"					[minimumWidth _ (49 max: minimumWidth)].			self launchMiniEditor: evt]		ifFalse: [super mouseDown: evt].! !!OldUpdatingStringMorph methodsFor: 'initialization' stamp: 'jmv 11/10/2008 13:12'!initialize	"Initialie the receiver to have default values in its instance 	variables "	super initialize.	target _ getSelector _ putSelector _ nil.	growable _ true.	stepTime _ 50.	minimumWidth _ 8.	maximumWidth _ 300! !!OldNameStringInHalo methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:39'!userEditsAllowed	"pretty silly anyway"	^false! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 11/10/2008 14:51'!after: target	"Answer the element after target.  Raise an error if target is not	in the receiver, but answer nil if there are no elements after it."	^ self after: target ifNone: []! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 11/10/2008 15:03'!after: target ifNone: exceptionBlock	"Answer the element after target.  Answer the result of evaluating	the exceptionBlock if there are no elements after it."	| index |	index _ self indexOf: target.	^ index == 0		ifTrue: [self errorNotFound: target]		ifFalse: [index = self size 			ifTrue: [exceptionBlock value]			ifFalse: [self at: index + 1]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 11/10/2008 15:03'!before: target	"Answer the receiver's element immediately before target. Raise an	error if target is not an element of the receiver, 	but answer nil if there are no elements before it (i.e. it is the first element)."	^ self before: target ifNone: []! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 11/10/2008 15:03'!before: target ifNone: exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if there are no elements before it."	| index |	index _ self indexOf: target.	^ index == 0		ifTrue: [self errorNotFound: target]		ifFalse: [index == 1 			ifTrue: [exceptionBlock value]			ifFalse: [self at: index - 1]]! !!SliderLW methodsFor: 'events-processing' stamp: 'jmv 11/10/2008 12:58'!handlesKeyboard	^true! !!TextEditor methodsFor: 'menu commands' stamp: 'jmv 11/10/2008 11:34'!offerMenuFromEsc: characterStream 	"The escape key was hit while the receiver has the keyboard focus; take action"	^ ActiveEvent shiftPressed		ifFalse:			[self raiseContextMenu: characterStream]! !!TextEntryFieldLW methodsFor: 'event handling' stamp: 'jmv 11/10/2008 12:58'!handlesKeyboard	^ true! !TextEntryFieldLW removeSelector: #handlesKeyboard:!TextEntryFieldLW removeSelector: #wantsKeyboardFocusFor:!TextEditor removeSelector: #escapeToDesktop:!SliderLW removeSelector: #handlesKeyboard:!SequenceableCollection removeSelector: #after:ifAbsent:!SequenceableCollection removeSelector: #before:ifAbsent:!SequenceableCollection removeSelector: #errorLastObject:!OldUpdatingStringMorph removeSelector: #autoAcceptOnFocusLoss!OldUpdatingStringMorph removeSelector: #autoAcceptOnFocusLoss:!OldUpdatingStringMorph removeSelector: #handlerForMouseDown:!OldUpdatingStringMorph removeSelector: #setToAllowTextEdit!OldUpdatingStringMorph removeSelector: #wouldAcceptKeyboardFocus!!classDefinition: #OldUpdatingStringMorph category: #'Morphic-OldWidgets'!OldStringMorph subclass: #OldUpdatingStringMorph	instanceVariableNames: 'target lastValue getSelector putSelector growable stepTime minimumWidth maximumWidth'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-OldWidgets'!!OldUpdatingStringMorph reorganize!('accessing' contents: fitContents getSelector getSelector: growable growable: maximumWidth minimumWidth minimumWidth: putSelector putSelector: target target: valueFromContents)('copying' veryDeepFixupWith: veryDeepInner:)('editing' acceptContents acceptValue: addCustomMenuItems:hand: doneWithEdits lostFocusWithoutAccepting setFontSize setFontStyle toggleGrowability userEditsAllowed)('event handling' handlesMouseDown: mouseDown:)('initialization' initialize)('stepping' stepTime: updateContentsFrom:)('stepping and presenter' step)('target access' acceptValueFromTarget: checkTarget informTarget readFromTarget)('testing' stepTime)!OldTheWorldMenu removeSelector: #commandKeyTypedIntoMenu:!OldTextMorphForEditView removeSelector: #wouldAcceptKeyboardFocusUponTab!OldTextMorph removeSelector: #handlesKeyboard:!OldTextMorph removeSelector: #hasFocus!OldTextMorph removeSelector: #wouldAcceptKeyboardFocusUponTab!OldStringMorph removeSelector: #wantsKeyboardFocusOnShiftClick!OldStringMorph removeSelector: #wouldAcceptKeyboardFocus!OldSimpleHierarchicalListMorph removeSelector: #handlesKeyboard:!OldPluggableTextMorph removeSelector: #handlesKeyboard:!OldPluggableListMorph removeSelector: #handlesKeyboard:!OldScrollPane removeSelector: #hasFocus!OldPasteUpMorph removeSelector: #commandKeySelectors!OldPasteUpMorph removeSelector: #defaultDesktopCommandKeyTriplets!OldPasteUpMorph removeSelector: #dispatchCommandKeyInWorld:event:!OldPasteUpMorph removeSelector: #handlesKeyboard:!OldPasteUpMorph removeSelector: #initializeDesktopCommandKeySelectors!OldPasteUpMorph removeSelector: #keyStroke:!OldPasteUpMorph removeSelector: #keyboardNavigationHandler!OldPasteUpMorph removeSelector: #keystrokeInWorld:!OldPasteUpMorph removeSelector: #putUpWorldMenuFromEscapeKey!OldPasteUpMorph removeSelector: #wantsKeyboardFocusFor:!OldOneLineEditorMorph removeSelector: #handlesKeyboard:!OldOneLineEditorMorph removeSelector: #hasFocus!!classDefinition: #OldOneLineEditorMorph category: #'Morphic-Old-Basic'!OldMorph subclass: #OldOneLineEditorMorph	instanceVariableNames: 'font emphasis contents editor'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Old-Basic'!OldMenuMorph removeSelector: #handlesKeyboard:!OldHaloMorph removeSelector: #acceptNameEdit!OldHaloMorph removeSelector: #delete!OldHaloMorph removeSelector: #wantsKeyboardFocusFor:!OldAlignmentMorph removeSelector: #wantsKeyboardFocusFor:!OldMorph removeSelector: #allMorphsAndBookPagesInto:!OldMorph removeSelector: #allNonSubmorphMorphs!OldMorph removeSelector: #handlesKeyboard:!OldMorph removeSelector: #hasFocus!OldMorph removeSelector: #pasteUpMorphHandlingTabAmongFields!OldMorph removeSelector: #wantsKeyboardFocusFor:!OldMorph removeSelector: #wouldAcceptKeyboardFocus!OldMorph removeSelector: #wouldAcceptKeyboardFocusUponTab!EntryFieldLW removeSelector: #handlesKeyboard:!EntryFieldLW removeSelector: #wantsKeyboardFocusFor:!CheckBoxLW removeSelector: #handlesKeyboard:!ButtonLW removeSelector: #handlesKeyboard:!LightWidget removeSelector: #eventHandler!LightWidget removeSelector: #handlesKeyboard:!EventHandler removeSelector: #handlesKeyboard:!