'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 9 November 2011 at 5:46:10 pm'!!FormCanvas commentStamp: '<historical>' prior: 0!                    origin is aPoint, and it is expressed relative to the form. Usually, the form doesn't cover the whole World, and origin is negative. For instance, if we just want to draw the part of the World in (100@100 extent: 50@50) to another form, then fom extent = 50@50, and origin = -100@-100.clipRect is relative to the form. For instance, if we only need to draw the part in (110@110 extent: 20@20) to the form above, then clipRect is (10@10 extent: 20@20)All public protocol and drawing services is relative to World. The idea is that we only care about origin/form when we set them. Afterwards, we don't need to care about them. All the operations are done as if the whole World was drawn on Display.Note that when shadowDrawing is true, shadowStipple may be either a color, for a solid shadow of the given color, or it may be a stipple used to simulate gray shading when the display cannot support alpha blending.!!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 11/9/2011 17:13'!   displayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft	| paragraphEnd count pattern |	paragraphStyle ifNotNil: [		(textLine isFirstLine and: [ paragraphStyle isListStyle ]) ifTrue: [			pattern _ paragraphStyle listBulletPattern.			"Count how many paragraphs before this one already used the pattern"			count _ 0.			paragraphEnd _ textLine first-1.			[			paragraphEnd > 0 and: [ ((text paragraphStyleOrNilAt: paragraphEnd) ifNotNil: [ :ps | ps listBulletPattern ]) = pattern ]] whileTrue: [				count _ count + 1.				paragraphEnd _ text string endOfParagraphBefore: paragraphEnd ].			"Our number in the list, is one more than the count of previous contiguous paragraphs with this pattern"			self				displayBulletParagraphTopLeft: paragraphTopLeft				number: count + 1]]! !!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 11/9/2011 17:13'!                    displayBulletParagraphTopLeft: paragraphTopLeft number: bulletNumber	| pattern i c j s bullet bulletPos bulletSize prefix |	pattern _ paragraphStyle listBulletPattern.	bullet _ pattern.	(i _ pattern indexOf: $%) > 0		ifTrue: [ bullet _ bulletNumber asString]		ifFalse: [			(i _ pattern indexOf: $z) > 0				ifTrue: [ bullet _ (Character value: 96 + bulletNumber) asString ]				ifFalse: [					(i _ pattern indexOf: $Z) > 0						ifTrue: [ bullet _ (Character value: 64 + bulletNumber) asString ]]].	prefix _ 0.	i > 0 ifTrue: [		c _ pattern at: i.		j _ i.		s _ pattern size.		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].		j _ j - 1.		bulletSize _ j-i+1.		prefix _ bulletSize - bullet size max: 0.		bullet size > bulletSize ifTrue: [			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].	bulletPos _ paragraphStyle firstIndent + paragraphTopLeft x + ((font widthOf: $9) * prefix)@destY.	font displayString: bullet on: bitBlt from: 1 to: bullet size at: bulletPos kern: kern! !!DisplayScanner methodsFor: 'scanning' stamp: 'jmv 11/9/2011 17:12'!             displayLine: textLine paragraphTopLeft: paragraphTopLeft leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos priorFont |	line _ textLine.	morphicOffset _ paragraphTopLeft.	lineY _ line top + paragraphTopLeft y.	lineHeight _ line lineHeight.	rightMargin _ line rightMargin + paragraphTopLeft x.	lastIndex _ line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin _ (line leftMarginForAlignment: alignment) + paragraphTopLeft x.	destX _ runX _ leftMargin.	destY _ lineY + line baseline - font ascent.	textLine isEmptyLine ifTrue: [		textLine paragraphStyle ifNotNil: [ :ps |			ps = paragraphStyle ifFalse: [				""				foregroundColor _ paragraphColor.				priorFont _ font.				self setActualFont: ps font.				ps color ifNotNil: [ :color | self textColor: color ].				alignment _ ps alignment.				paragraphStyle _ ps.				priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].				destX _ destX - font descentKern.				kern _ 0 - font baseKern.				spaceWidth _ font widthOf: Character space.				xTable _ font xTable.				map _ font characterToGlyphMap.				stopConditions _ DefaultStopConditions.				font installOn: bitBlt foregroundColor: foregroundColor.				text ifNotNil:[destY _ lineY + line baseline - font ascent]				""			]		].		self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft.		^leftInRun ].	self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paragraphTopLeft.	lastIndex _ line first.	leftInRun <= 0		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	string _ text string.	self placeEmbeddedObject.	[ done ] whileFalse: [		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self			scanCharactersFrom: lastIndex to: runStopIndex			in: string rightX: rightMargin stopConditions: stopConditions			kern: kern.		lastIndex >= startIndex ifTrue: [			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern ].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition ].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 11/9/2011 17:46'!        paragraph: aParagraph bounds: boundsInWorld color: c	| scanner |	self setPaintColor: c.	scanner _ DisplayScanner new 		text: aParagraph paragraphText		foreground: (shadowColor ifNil: [ c ])		ignoreColorChanges: self isShadowDrawing."Lo que pasa es que el origen esta mal puesto. Eso aun no lo arregle!!ver #copyOffset:clipRect:Esto deberia ser parte ya de lo que arregle la otra vez para matar el TransformMorph... Quizas sea ya el momento de revivir eso.""origin = (0@0) ifFalse: [	form print.	origin print ].""Porque los bounds son del world ahora"	"original"	"scanner setPort: (port clippedBy: (boundsInWorld translateBy: origin))."	"ahora. El clippingRect est es el usado para el texto"	scanner setPort: (port clippedBy: (boundsInWorld))."original""	(self copyClipRect: bounds)""ahora. El clipping lo quiere en coordenadas globales. BoundsInWorld deberia estar en ellas!!""Este clipping es el usado para la seleccion"	(self copyClipRect: (boundsInWorld translateBy: origin negated))"experim""	(self copyClipRect: boundsInWorld)"		display: aParagraph 		using: scanner		in: boundsInWorld! !!FormCanvas methodsFor: 'private - drawing text' stamp: 'jmv 11/9/2011 17:11'!       display: aParagraph using: displayScanner in: boundsInWorld	"Send all visible lines to the displayScanner for display"	|  leftInRun line |	leftInRun _ 0.	(aParagraph lineIndexForPoint: 0@0)		to: (aParagraph lineIndexForPoint: boundsInWorld extent)		do: [ :i |			line _ aParagraph lines at: i.			aParagraph displaySelectionInLine: line on: self.			leftInRun _ displayScanner displayLine: line paragraphTopLeft: boundsInWorld topLeft leftInRun: leftInRun ]! !!Morph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:23'!                imageForm	^ self imageForm: Display depth forRectangle: self fullDisplayBounds! !!BareTextMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:30'!       drawOn: aCanvas	"Draw the receiver on a canvas"	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"	aCanvas paragraph: self paragraph bounds: self displayBounds color: color.	"Drawing the paragraph might change the #lastCaretRect, and therefor might	require a second update."	paragraph lastCaretRectNeedsRedraw ifTrue: [		paragraph lastCaretRect ifNotNil: [ :r | self invalidRect: r ]]! !!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 16:38'!        drawOn: aCanvas	aCanvas roundRect: bounds color: self color radius: 2.	aCanvas		paragraph: paragraph		bounds: (self displayBounds insetBy: 4)		color: Color black! !!Transcripter methodsFor: 'accessing' stamp: 'jmv 11/9/2011 16:38'!               endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue: [		"Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para		setModel: (TextModel withText: c asText)		extentForComposing: frame width-8 @9999.	para composeAll.	d _ para extent y - frame height.	d > 0 ifTrue: [		"Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint:			0@0 + (0@(d+StrikeFont default height)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	Display getCanvas		paragraph: para		bounds: (4@4 extent: Display extent)		color: Color black! !Paragraph removeSelector: #displayOn:using:at:canvasOrigin:!!Paragraph reorganize!('access' editor: extent focused focused: lastCaretRect lastCaretRectNeedsRedraw numberOfLines paragraphText showCaret showCaret: usedExtent)('composition' composeAll composeLinesFrom:to:delta:into:priorLines:atY: recomposeFrom:to:delta: setModel:extentForComposing:)('display' displayInsertionMarkAtX:top:bottom:emphasis:on: displaySelectionInLine:on: displaySelectionStartBlock:stopBlock:InLine:on: selectionColor)('editing' clickAt:)('selection' addSelectionRectsFrom:to:to: characterBlockAtPoint: characterBlockForIndex: containsPoint: defaultCharacterBlock selectionRects selectionRectsFrom:to: selectionStartBlocks:selectionStopBlocks:)('private' fastFindFirstLineSuchThat: indentationOfLineIndex:ifBlank: lastLine lineIndexFor: lineIndexForPoint: lines)('initialization' initialize)!DisplayScanner removeSelector: #displayBulletIfAppropriateFor:offset:!DisplayScanner removeSelector: #displayBulletOffset:number:!DisplayScanner removeSelector: #displayLine:offset:leftInRun:!