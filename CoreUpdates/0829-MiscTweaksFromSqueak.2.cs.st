'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 28 February 2011 at 7:13:51 pm'!!MethodDictionary commentStamp: 'jmv 2/28/2011 18:08' prior: 0!I am a special dictionary holding methods. I am just like a normal Dictionary, except that I am implemented differently.  Each Class has an instance of MethodDictionary to hold the correspondence between selectors (names of methods) and methods themselves.In a normal Dictionary, the instance variable 'array' holds an array of Associations.  Since there are thousands of methods in the system, these Associations waste space.  Each MethodDictionary is a variable object, with the list of keys (selector Symbols) in the variable part of the instance.  The variable 'array' holds the values, which are CompiledMethods.I also maintain the following invariant: (self basicAt: index) isNil = (array at: index) isNil.!!Decompiler methodsFor: 'private' stamp: 'jmv 2/28/2011 19:09'!interpretNextInstructionFor: client	| code varNames |"Change false here will trace all state in Transcript."true ifTrue: [^ super interpretNextInstructionFor: client].	varNames := self class allInstVarNames.	code := (self method at: pc) radix: 16.	Transcript cr; cr; print: pc; space;		nextPutAll: '<' , code, '>'.	8 to: varNames size do:		[:i | i <= 10 ifTrue: [Transcript cr]				ifFalse: [Transcript space; space].		Transcript nextPutAll: (varNames at: i);				nextPutAll: ': '; print: (self instVarAt: i)].	Transcript endEntry.	^ super interpretNextInstructionFor: client! !!FloatArray methodsFor: 'arithmetic' stamp: 'jmv 2/28/2011 18:58'!dot: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	<primitive: 'primitiveDotProduct' module: 'FloatArrayPlugin'>	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result := 0.0.	1 to: self size do:[:i|		result := result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!MethodDictionary methodsFor: 'accessing' stamp: 'jmv 2/28/2011 18:07'!includesKey: aSymbol	"This override assumes that instVarsInclude: uses a fast primitive"	aSymbol ifNil: [^ false].	^ self instVarsInclude: aSymbol! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 2/28/2011 18:19'!copyPixelsGray: y	"Handle non-interlaced grayscale color mode (colorType = 0)"	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This interesting technique (By Andreas Raab) is a bit obscure, but it is so fast that we leave it active"	^self copyPixelsGrayWeirdBitBltHack: y.	"This interesting technique  (By Yoshiki Ohshima) is also instructive"	"true ifTrue: [ ^form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32) ]."	"This Smalltalk version might be easier to understand and is quite fast too."	"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 	is to make use of faster arithmetic bytecodes, but not of slow largeintegers."	"	base _ y * (form width * bitsPerChannel + 31 // 32) + 1.	bits _ form bits.	0 to: thisScanline size // 4 - 1 do: [ :i |		| ii |		ii _ i * 4.		word _	           ((thisScanline at: ii+1) *256 + 	           (thisScanline at: ii+2) *256 + 	           ((thisScanline at: ii+3)) bitShift: 8) bitOr: 	           (thisScanline at: ii+4).		bits at: base + i put: word.].	(bytesLeft := thisScanline size bitAnd: 3) = 0 ifFalse: [		word := 0.		thisScanline size - bytesLeft + 1 to: thisScanline size do: [ :ii |			word := word * 256 + (thisScanline at: ii) ].		word := word bitShift: 8 * (4 - bytesLeft).		bits at: base + (thisScanline size // 4) put: word ].	"! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 2/28/2011 18:59'!cogitClass	^self getSystemAttribute: 1008! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 2/28/2011 18:58'!getSystemAttribute: attributeID 	"Optional. Answer the string for the system attribute with the given 	integer ID. Answer nil if the given attribute is not defined on this 	platform. On platforms that support invoking programs from command 	lines (e.g., Unix), this mechanism can be used to pass command line 	arguments to programs written in Squeak.	By convention, the first command line argument that is not a VM	configuration option is considered a 'document' to be filed in. Such a	document can add methods and classes, can contain a serialized object,	can include code to be executed, or any combination of these.	Currently defined attributes include: 	-1000	1000th command line argument that specify VM options	...	-1		first command line argument that specify VM options	0		the full path name for currently executing VM			(or, on some platforms, just the path name of the VM's directory) 	1		full path name of this image (better use primImageName instead)	2		a Squeak document to open, if any 	3		first command line argument for Squeak programs	...	1000	1000th command line argument for Squeak programs	1001	this platform's operating system 'Mac OS', 'Win32', 'unix', ...	1002	operating system version	1003	this platform's processor type	1004	vm version	1005	window system name	1006	vm build id	1007	Interpreter class (Cog VM only)	1008	Cogit class (Cog VM only)	1201	max filename length (Mac OS only)	1202	file last error (Mac OS only)	10001	hardware details (Win32 only)	10002	operating system details (Win32 only)	10003	graphics hardware details (Win32 only)	"	<primitive: 149>	^ nil! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 2/28/2011 18:59'!interpreterClass	^self getSystemAttribute: 1007! !