'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 14 October 2011 at 7:43:06 pm'!!Pragma commentStamp: 'fbs 5/8/2011 18:21' prior: 0!I represent an occurrence of a pragma in a compiled method.  A pragma is a literal message pattern that occurs between angle brackets at the start of a method after any temporaries.  A common example is the primitive pragma:	<primitive: 123 errorCode: 'errorCode'>but one can add one's own and use them as metadata attached to a method.  Because pragmas are messages one can browse senders and implementors and perform them.  One can query a method for its pragmas by sending it the pragmas message, which answers an Array of instances of me, one for each pragma in the method.I can provide information about the defining class, method, its selector, as well as the information about the pragma keyword and its arguments. See the two 'accessing' protocols for details. 'accessing-method' provides information about the method the pragma is found in, while 'accessing-pragma' is about the pragma itself.Instances are retrieved using one of the pragma search methods of the 'finding' protocol on the class side.To browse all methods with pragmas in the system evaluate	SystemNavigation default browseAllSelect: [:m| m pragmas notEmpty]and to browse all nonprimitive methods with pragmas evaluate	SystemNavigation default browseAllSelect: [:m| m primitive isZero and: [m pragmas notEmpty]]!!IntegerTest methodsFor: 'testing - arithmetic' stamp: 'nice 6/4/2011 20:46'!testRaisedToModulo	#(301 2047) do: [:m |		1 to: m - 1 by: (m // 30) do: [:x |			11 to: m - 1 by: (m // 40) do: [:y |				self assert: (x raisedTo: y) \\ m = (x raisedTo: y modulo: m)]]].	self assert: (8951195 raisedTo: 7742931 modulo: 15485863) = 15485862.! !!Number methodsFor: 'converting' stamp: 'jmv 10/14/2011 15:52'!adaptToComplex: rcvr andSend: selector	"If I am involved in arithmetic with a Complex number, convert me to a Complex number."	^ rcvr perform: selector with: self asComplex! !!Number methodsFor: 'converting' stamp: 'jmv 10/14/2011 15:53'!asComplex	"Answer a Complex number that represents value of the the receiver."	^ Complex real: self imaginary: 0! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'jmv 10/14/2011 18:02'!mightBeASquare	"In base 16, a square number can end only with 0,1,4 or 9 and	- in case 0, only 0,1,4,9 can precede it,	- in case 4, only even numbers can precede it.	See http://en.wikipedia.org/wiki/Square_number	So, in hex, the last byte must be one of:		00		10		40		90		x1		e4		x9	where x is any hex digit and e is any even digit		Also, the receiver must be an aven power of two.	This needs additional testing in the 00 suffix,	as it implied in all the other conditions"	| lsb |	lsb _ self digitAt: 1.	^(lsb = 0 and: [ self lowBit odd ])		"00 (and even power of 2)"		or: [ lsb = 16r40					"40"		or: [ (lsb bitAnd: 16r7) = 1			"any|1 or any|9"		or: [ (lsb bitAnd: 16r1F) = 4			"even|4"		or: [ (lsb bitAnd: 16r7F) = 16 ]]]]	"10 or 90"! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'jmv 10/14/2011 19:42'!sqrtFloor	"Return the integer part of the square root of self"	| powerOfTwo |	(powerOfTwo _ self lowBit - 1 // 2) > 1		ifFalse: [ ^ super sqrtFloor ].	^ (self bitShift: -2 * powerOfTwo) sqrtFloor bitShift: powerOfTwo! !!Pragma methodsFor: 'comparing' stamp: 'eem 10/4/2011 10:41'!= anObject 	^self class == anObject class	  and: [keyword == anObject keyword	  and: [arguments = anObject arguments]]! !!Pragma methodsFor: 'comparing' stamp: 'eem 10/4/2011 10:41'!hash	^keyword hash + arguments hash! !Integer removeSelector: #adaptToComplex:andSend:!Integer removeSelector: #asComplex!Fraction removeSelector: #adaptToComplex:andSend:!Fraction removeSelector: #asComplex!Float removeSelector: #adaptToComplex:andSend:!Float removeSelector: #asComplex!