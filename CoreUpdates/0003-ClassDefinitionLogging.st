'From Squeak3.7 of ''4 September 2004'' [latest update: #5989] on 7 April 2008 at 7:17:59 pm'!!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/6/2008 00:43'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^ReadStream		on: (paragraph string copyFrom: self startIndex to: self stopIndex - 1)! !!ChangeList methodsFor: 'scanning' stamp: 'jmv 4/6/2008 16:09'!scanFile: aFile from: startPosition to: stopPosition	| itemPosition item prevChar |	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.'Scanning ', aFile localName, '...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar _ file next].		(file peekFor: $!!)		ifTrue:			[(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [self scanCategory]]		ifFalse:			[itemPosition _ file position.			item _ file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 160)]]]].	listSelections _ Array new: list size withAll: false! !!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 4/6/2008 02:08'!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."	| methodClass s aSelector |	Cursor read showWhile:		[(methodClass _ self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil.			(aSelector _ self methodSelector) ifNotNil:				[Utilities noteMethodSubmission: aSelector forClass: methodClass]].		(type == #doIt) ifTrue:			[((s _ self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]].		(type == #classDefinition) ifTrue: [			Compiler evaluate: self string].		(type == #classComment) ifTrue:			[ | cls | (cls _ Smalltalk at: class asSymbol) comment: self text stamp: stamp.			Utilities noteMethodSubmission: #Comment forClass: cls ]]! !!Class methodsFor: 'instance variables' stamp: 'jmv 4/6/2008 23:10'!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."		| answer |	answer _ ClassBuilder new		name: self name		inEnvironment: self environment		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: self instanceVariablesString, ' ', aString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/6/2008 23:11'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	"File a description of the receiver on aFileStream. If the boolean 	argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the 	source code."	aFileStream command: 'H3'.		aFileStream nextPut: $!!; nextChunkPut: self definitionPreamble; cr.		aFileStream nextChunkPut: self definition.		aFileStream command: '/H3'.	self organization		putCommentOnFile: aFileStream		numbered: fileIndex		moveSource: moveSource		forClass: self.	self organization categories do: 		[:heading |		self fileOutCategory: heading			on: aFileStream			moveSource: moveSource			toFile: fileIndex]! !!Class methodsFor: 'instance variables' stamp: 'jmv 4/6/2008 23:11'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString answer |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString _ ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString _ newInstVarString , ' ' , varName].	answer _ ClassBuilder new		name: self name		inEnvironment: self environment		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: newInstVarString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Class methodsFor: 'subclass creation' stamp: 'jmv 4/6/2008 23:11'!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."		| answer |	answer _ ClassBuilder new		superclass: self		subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Class methodsFor: 'subclass creation' stamp: 'jmv 4/6/2008 23:11'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."		| answer |	answer _ ClassBuilder new		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Class methodsFor: 'subclass creation' stamp: 'jmv 4/6/2008 23:11'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."		| answer |	answer _ ClassBuilder new		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Class methodsFor: 'subclass creation' stamp: 'jmv 4/6/2008 23:11'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	| answer |	answer _ ClassBuilder new		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Class methodsFor: 'subclass creation' stamp: 'jmv 4/6/2008 23:12'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	| answer |	answer _ ClassBuilder new		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!ClassDescription methodsFor: 'compiling' stamp: 'jmv 4/6/2008 23:12'!moveInstVarNamed: instVarName to: anotherClass after: prevInstVarName	"Move the given instance variable to another class."	| answer |	self == anotherClass ifFalse:[		self notify:'Warning:' asText allBold,' moving ', instVarName printString,' from ', self name,' to ', anotherClass name,' will not be recorded in the change set correctly.Proceed to do it anyways.'].	answer _ ClassBuilder new		moveInstVarNamed: instVarName 		from: self 		to: anotherClass 		after: prevInstVarName.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!Metaclass methodsFor: 'initialize-release' stamp: 'jmv 4/6/2008 23:12'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| answer |	answer _ ClassBuilder new		class: self		instanceVariableNames: instVarString.			Smalltalk		logChange: answer definition 		preamble: answer definitionPreamble.	^answer! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 4/6/2008 16:54'!logChange: aStringOrText preamble: preamble	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'can''t log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile _ SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextPut: $!!; nextChunkPut: preamble; cr.	changesFile nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/7/2008 00:12'!definitionPreamble	^'classDefinition: ', self name printString, ' category: ', self category printString! !!ChangeList methodsFor: 'viewing access' stamp: 'jmv 4/6/2008 23:40'!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	|  aChange aClass  name |	listIndex = 0		ifTrue: [^ ''].	aChange _ changeList at: listIndex.	((aChange type == #method 			and: [(aClass _ aChange methodClass) notNil]) 			and: [aClass includesSelector: aChange methodSelector]) ifTrue: [		^Utilities 			methodDiffFor: aChange text 			class: aClass 			selector: aChange methodSelector 			prettyDiffs: self showingPrettyDiffs].	(aChange type == #classDefinition and: [			name _ aChange methodClassName.			Smalltalk includesKey: name]) ifTrue: [		aClass _ Smalltalk at: name.		aChange isMetaClassChange ifTrue: [ aClass _ aClass class ].		^(TextDiffBuilder from: aClass definition to: aChange text) buildDisplayPatch].	^(changeList at: listIndex) text! !!ChangeList methodsFor: 'scanning' stamp: 'jmv 4/7/2008 18:52'!scanCategory	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp isComment anIndex def isMeta name record |	itemPosition _ file position.	item _ file nextChunk.	isComment _ (item includesSubString: 'commentStamp:').	(isComment or: [item includesSubString: 'methodsFor:'] or: [item includesSubString: 'classDefinition:']) ifFalse: [		"Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 160)].	tokens _ Scanner new scanTokens: item.	tokens size >= 3 ifTrue: [		stamp _ ''.		anIndex _ tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp _ tokens at: (anIndex + 1)].		tokens first == #classDefinition:			ifTrue: [				itemPosition _ file position.				isMeta _ tokens second includesSubString: ' class'.				name _ isMeta ifTrue: [tokens second substrings first] ifFalse: [tokens second].				def _ file nextChunk.				record _ ChangeRecord new file: file position: itemPosition type: #classDefinition					class: name asSymbol category: tokens last meta: isMeta stamp: nil.				self addItem: record text: 'classDefinition: ', def.				^file skipStyleChunk].				tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].	tokens second == #commentStamp:		ifTrue:			[stamp _ tokens third.			self addItem:					(ChangeRecord new file: file position: file position type: #classComment									class: tokens first category: nil meta: false stamp: stamp)					text: 'class comment for ' , tokens first, 						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).			file nextChunk.			^ file skipStyleChunk]! !!ChangeList methodsFor: 'viewing access' stamp: 'jmv 4/6/2008 23:34'!annotation	"Answer the string to be shown in an annotation pane.  Make plain that the annotation is associated with the current in-image version of the code, not of the selected disk-based version, and if the corresponding method is missing from the in-image version, mention that fact."	| annot change aClass ann1 ann2 |	change _ self currentChange.	(change notNil and: [change type == #classDefinition]) ifTrue: [		ann1 _ (Smalltalk includesKey: change methodClassName) ifTrue: ['Existing '] ifFalse: ['New '].		ann2 _ change isMetaClassChange ifTrue: ['metaclass']ifFalse: ['class'].		^ann1, ann2	].		annot _ super annotation.	annot asString = '------' ifTrue: [^ annot].	^ (change notNil and: [change methodSelector notNil])		ifFalse:			[annot]		ifTrue:			[((aClass _ change methodClass) isNil or: [(aClass includesSelector: change methodSelector) not])				ifTrue:					[change methodClassName, ' >> ', change methodSelector, ' is not present in the current image.']				ifFalse:					['current version: ', annot]]! !!ChangeRecord methodsFor: 'access' stamp: 'jmv 4/7/2008 19:09'!fileOutOn: aFileStream	"File the receiver out on the given file stream"	| aString |	type == #method		ifTrue:			[aFileStream cr; nextPut: $!!.			aString _  class asString							, (meta ifTrue: [' class methodsFor: ']									ifFalse: [' methodsFor: '])							, category asString printString.			stamp ifNotNil:				[aString _ aString, ' stamp: ''', stamp, ''''].			aFileStream nextChunkPut: aString.			aFileStream cr].	type == #preamble ifTrue: [aFileStream nextPut: $!!].	type == #classComment		ifTrue:			[aFileStream nextPut: $!!.			aFileStream nextChunkPut: class asString, ' commentStamp: ', stamp storeString.			aFileStream cr].			type == #classDefinition ifTrue: [		aFileStream nextPut: $!!.		aFileStream nextChunkPut: 			'classDefinition: ', 			(self isMetaClassChange ifTrue: [self methodClassName, ' class'] ifFalse: [self methodClassName]) printString,			' category: ', self category printString.		aFileStream cr		].	aFileStream nextChunkPut: self string.		type == #method ifTrue: [aFileStream nextChunkPut: ' '; cr].	type == #classComment ifTrue: [aFileStream cr].	aFileStream cr! !