'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 28 May 2011 at 12:16:48 am'!!classDefinition: #Paragraph category: #'System-Text'!Object subclass: #Paragraph	instanceVariableNames: 'model container lines positionWhenComposed maxRightX selectionStart selectionStop focused editor showCaret caretRect selectionStartBlocks selectionStopBlocks '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!BareTextMorph methodsFor: 'private' stamp: 'jmv 5/27/2011 16:11'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	"release editor too"	editor ifNotNil: [		self selectionChanged.		editor _ nil].	paragraph ifNotNil: [		paragraph selectionStartBlocks: {} selectionStopBlocks: {}.	"most likely not needed"		paragraph _ nil]! !!Paragraph methodsFor: 'display' stamp: 'jmv 5/27/2011 16:06'!displaySelectionInLine: line on: aCanvas	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |		self displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas ]! !!Paragraph methodsFor: 'display' stamp: 'jmv 5/27/2011 16:04'!displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas	| leftX rightX idx caretFont t b caretAttributes |	startBlock ifNil: [^self].	"No selection"	startBlock = stopBlock 		ifTrue: [			"Only show caret on line where clicked"			startBlock textLine ~= line ifTrue: [ ^self ].			leftX _ startBlock left.			idx _ startBlock stringIndex.			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].			caretFont _ caretAttributes				ifNil: [ self text fontAt: idx ]				ifNotNil: [ self text fontIfApplying: caretAttributes ].			b _ line top + line baseline + caretFont descent.			t _ line top + line baseline - caretFont ascent.			self showCaret ifTrue: [				self					displayInsertionMarkAtX: leftX					top: t					bottom: b					emphasis: caretFont emphasis					on: aCanvas ]]		ifFalse: [			"Test entire selection before or after here"			(stopBlock stringIndex < line first 				or: [startBlock stringIndex > (line last + 1)])					ifTrue: [^self].	"No selection on this line"			(stopBlock stringIndex = line first 				and: [stopBlock textLine ~= line])					ifTrue: [^self].	"Selection ends on line above"			(startBlock stringIndex = (line last + 1) 				and: [stopBlock textLine ~= line])					ifTrue: [^self].			caretRect _ nil.			leftX _ (startBlock stringIndex < line first 				ifTrue: [ line ]				ifFalse: [ startBlock ]) left.			rightX _ (stopBlock stringIndex > (line last + 1) or: [					stopBlock stringIndex = (line last + 1) 						and: [stopBlock textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [stopBlock left].			aCanvas				fillRectangle: (leftX @ line top corner: rightX @ line bottom)				colorOrInfiniteForm: self selectionColor].	"Selection begins on line below"! !!Paragraph methodsFor: 'selection' stamp: 'jmv 5/27/2011 15:44'!addSelectionRectsFrom: characterBlock1 to: characterBlock2 to: aStream	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue: [		w _ 6.		^ aStream nextPut: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexFor: cb1 stringIndex.	line2 _ self lineIndexFor: cb2 stringIndex.	line1 = line2 ifTrue: [		^ aStream nextPut: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [ :i |		| line |		line _ lines at: i.		(line left = rects last left and: [ line right = rects last right ])			ifTrue: [ "new line has same margins as old one -- merge them, so that the caller gets as few rectangles as possible"					| lastRect |					lastRect _ rects removeLast.					rects add: (lastRect bottom: line bottom) ]			ifFalse: [ "differing margins; cannot merge"					rects add: line rectangle ] ].	aStream nextPutAll: rects.	aStream nextPut: ((lines at: line2) topLeft corner: cb2 bottomLeft)! !!Paragraph methodsFor: 'selection' stamp: 'jmv 5/27/2011 15:51'!selectionRects	"Return an array of rectangles representing the selection regions."	^ Array streamContents: [ :strm |		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |			self addSelectionRectsFrom: startBlock to: stopBlock to: strm ]]! !!Paragraph methodsFor: 'selection' stamp: 'jmv 5/28/2011 00:15'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	^ Array streamContents: [ :strm |		self addSelectionRectsFrom: characterBlock1 to: characterBlock2 to: strm ]! !!Paragraph methodsFor: 'selection' stamp: 'jmv 5/27/2011 16:11'!selectionStartBlocks: startBlocks selectionStopBlocks: stopBlockBlocks	selectionStartBlocks _ startBlocks.	selectionStopBlocks _ stopBlockBlocks.! !!Paragraph methodsFor: 'initialization' stamp: 'jmv 5/27/2011 16:00'!initialize	focused _ false.	showCaret _ false.	positionWhenComposed _ 0@0.	selectionStartBlocks _ {}.	selectionStopBlocks _ {}! !!TextEditor methodsFor: 'mvc compatibility' stamp: 'jmv 5/27/2011 16:11'!storeSelectionInParagraph	"for proper display of selected text"	paragraph selectionStartBlocks: { self startBlock } selectionStopBlocks: { self stopBlock }! !Paragraph removeSelector: #selectionStart:selectionStop:!!classDefinition: #Paragraph category: #'System-Text'!Object subclass: #Paragraph	instanceVariableNames: 'model container lines positionWhenComposed maxRightX selectionStartBlocks selectionStopBlocks focused editor showCaret caretRect'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!