'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 4 December 2010 at 11:36:31 pm'!!TextModel methodsFor: 'initialize-release' stamp: 'jmv 12/4/2010 20:18'!openInMorphicWindowLabeled: labelString wrap: aBoolean	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: ((TextModelMorph 		textModel: self		textGetter: #actualContents 		textSetter: nil		selectionGetter: nil)			wrapFlag: aBoolean)				frame: (0@0 corner: 1@1).	^ window openInWorld! !!TextModel methodsFor: 'self-updating' stamp: 'jmv 12/4/2010 22:45'!updatePaneIfNeeded	"Nothing to do here"! !!TextModel methodsFor: 'misc' stamp: 'jmv 12/4/2010 22:29'!refetch	"Nothing here"! !!PluggableTextModel methodsFor: 'accessing' stamp: 'jmv 12/4/2010 22:30'!actualContents	actualContents ifNil: [ self refetch ].	^actualContents! !!PluggableTextModel methodsFor: 'self-updating' stamp: 'jmv 12/4/2010 22:45'!updatePaneIfNeeded	textProvider updatePaneIfNeeded! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 12/4/2010 22:29'!refetch	actualContents _ getTextSelector		ifNil: [ Text new ]		ifNotNil: [			Text				initialFont: Preferences standardCodeFont				stringOrText: (textProvider perform: getTextSelector) ]! !!SyntaxError class methodsFor: 'instance creation' stamp: 'jmv 12/4/2010 20:17'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph 			model: aSyntaxError 			listGetter: #list			indexGetter: #listIndex 			indexSetter: nil 			menuGetter: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (TextModelMorph 			textModel: aSyntaxError			textGetter: #actualContents			textSetter: #contents:notifying: 			selectionGetter: #contentsSelection)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 12/4/2010 22:30'!model: newModel selectionGetter: getSelectionSel	editorClass _ newModel editorClass.	getTextSelector _ newModel textGetter.	setTextSelector _ newModel textSetter.	getSelectionSelector _ getSelectionSel.	self model: newModel.	model refetch.	self maybeStyle.		self setSelection: self getSelection! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 12/4/2010 22:30'!textModel: newModel textGetter: textGetter textSetter: textSetter selectionGetter: getSelectionSel	editorClass _ newModel editorClass.	getTextSelector _ textGetter.	setTextSelector _ textSetter.	getSelectionSelector _ getSelectionSel.	self model: newModel.	model refetch.	self maybeStyle.		self setSelection: self getSelection! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 12/4/2010 23:13'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	textToAccept := textMorph text.	ok := setTextSelector isNil or: [					setTextSelector numArgs = 2 						ifTrue: [							self textProvider								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [ self textProvider perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: [			model refetch.			self maybeStyle.			self hasUnacceptedEdits: false ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 12/4/2010 23:12'!cancel	model refetch.	self maybeStyle.	self setSelection: self getSelection! !!TextModelMorph methodsFor: 'transcript' stamp: 'jmv 12/4/2010 20:27'!appendEntry	"Append the text in the model's writeStream to the editable text. "	textMorph text size > model textProvider characterLimit ifTrue: [		"Knock off first half of text"		self selectInvisiblyFrom: 1 to: textMorph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: textMorph text size + 1 to: textMorph text size.	self replaceSelectionWith: model textProvider contents asText.	"modelItextProvider IS a TranscriptStream"	self selectInvisiblyFrom: textMorph text size + 1 to: textMorph text size! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 12/4/2010 22:30'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: [			model refetch.			self maybeStyle.			"Some day, it would be nice to keep objects and update them			instead of throwing them away all the time for no good reason..."			textMorph releaseParagraph.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: self textProvider autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ]! !!TextModelMorph methodsFor: 'testing' stamp: 'jmv 12/4/2010 22:58'!is: aSymbol	^ aSymbol == #TextModelMorph or: [ super is: aSymbol ]! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 12/4/2010 20:20'!textModel: aTextModel textGetter: textGetter textSetter: textSetter selectionGetter: getSelectionSel	|  answer styler |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ aTextModel respondsTo: #shoutAboutToStyle:]) ifTrue: [		styler _ SHTextStylerST80 new.		styler view: answer.		answer styler: styler ].	answer		textModel: aTextModel		textGetter: textGetter		textSetter: textSetter		selectionGetter: getSelectionSel.	^answer! !!TextProvider methodsFor: 'contents' stamp: 'jmv 12/4/2010 22:32'!acceptedContents	^ Text		initialFont: Preferences standardCodeFont		stringOrText: self acceptedStringOrText! !!TextProvider methodsFor: 'contents' stamp: 'jmv 12/4/2010 22:36'!acceptedContentsChanged	self changed: #acceptedContents! !!TextProvider methodsFor: 'contents' stamp: 'jmv 12/4/2010 22:33'!acceptedStringOrText	^self subclassResponsibility! !!TextProvider methodsFor: 'services' stamp: 'jmv 12/4/2010 22:46'!offerMenuFrom: menuRetriever shifted: aBoolean 	"Pop up, in morphic or mvc as the case may be, a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.			self 				perform: menuRetriever				with: aMenu				with: aBoolean.			aMenu popUpInWorld! !!TextProvider methodsFor: 'services' stamp: 'jmv 12/4/2010 22:39'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	^(self respondsTo: selector)		ifTrue: [ self perform: selector ]		ifFalse: [ otherTarget perform: selector ]! !!TextProvider methodsFor: 'accessing' stamp: 'jmv 12/4/2010 22:40'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!TextProvider methodsFor: 'accessing' stamp: 'jmv 12/4/2010 22:41'!editorClass	^TextEditor! !!Debugger methodsFor: 'initialize' stamp: 'jmv 12/4/2010 23:09'!customButtonSpecs	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."	| list |	list := #(('Proceed'	proceed				'close the debugger and proceed.')		('Restart'		restart				'reset this context to its start.')		('Into'			send				'step Into message sends')		('Over'			doStep				'step Over message sends')		('Through'		stepIntoBlock		'step into a block')		('Full Stack'		fullStack			'show full stack')		('Where'		where				'select current pc range')).	Preferences restartAlsoProceeds ifTrue:		[list := list collect: [:each |			each second == #restart				ifTrue: [each copy at: 3 put: 'proceed from the beginning of this context.'; yourself]				ifFalse: [each]]].	^ list! !!TranscriptStream methodsFor: 'initialization' stamp: 'jmv 12/4/2010 23:06'!open	self openAsMorph! !!Workspace methodsFor: 'menu commands' stamp: 'jmv 12/4/2010 23:14'!addModelItemsToWindowMenu: aMenu	"Add model-related items to the supplied window menu"	aMenu addLine.	aMenu		add: 'reset variables'		target: self		action: #initializeBindings.	aMenu		addUpdating: #mustDeclareVariableWording		target: self		action: #toggleVariableDeclarationMode.	aMenu		addUpdating: #toggleStylingLabel		target: self		action: #toggleStyling! !!Workspace methodsFor: '*Shout-Styling' stamp: 'jmv 12/4/2010 23:29'!toggleStyling	shouldStyle _ self shouldStyle not.	actualContents _ actualContents asString asText.	self changed: #actualContents! !Workspace removeSelector: #appendContentsOfFile!Workspace removeSelector: #saveContentsInFile!Inspector removeSelector: #acceptedContents!Inspector removeSelector: #acceptedContentsChanged!Inspector removeSelector: #clearUserEditFlag!Inspector removeSelector: #contentsSelection!Inspector removeSelector: #okToChange!Inspector removeSelector: #perform:orSendTo:!FileList removeSelector: #acceptedContents!FileList removeSelector: #acceptedContentsChanged!FileList removeSelector: #clearUserEditFlag!FileList removeSelector: #contentsSelection!FileList removeSelector: #offerMenuFrom:shifted:!FileList removeSelector: #okToChange!FileList removeSelector: #perform:orSendTo:!Debugger removeSelector: #getSelectedText!Debugger removeSelector: #getTextMorphWithSelection!Debugger removeSelector: #tally!CodeProvider removeSelector: #acceptedContents!CodeProvider removeSelector: #clearUserEditFlag!CodeProvider removeSelector: #contentsSelection!CodeProvider removeSelector: #offerMenuFrom:shifted:!CodeProvider removeSelector: #okToChange!CodeProvider removeSelector: #perform:orSendTo:!TextModelMorph class removeSelector: #model:textGetter:textSetter:selectionGetter:!TextModelMorph removeSelector: #getTextSelector!TextModelMorph removeSelector: #model:textGetter:textSetter:selectionGetter:!PluggableTextModel removeSelector: #forceRefetch!TextModel removeSelector: #forceRefetch!TextModel removeSelector: #offerMenuFrom:shifted:!!ObjectExplorer reorganize!('accessing' doItContext doItReceiver editorClass explorerFor: getList object parentObject selector)('menus' chasePointers defsOfSelection explorePointers exploreSelection explorerKey:from: genericMenu: inspectSelection objectReferencesToSelection referencesToSelection selectedClass)('user interface' initialExtent openBrowser: openExplorerFor:)('error handling' doesNotUnderstand:)('monitoring' monitor: monitorList shouldGetStepsFrom: step stopMonitoring)('misc')('TextModel protocol')!!FillInTheBlankMorph reorganize!('accessing' response response: selectionInterval)('event handling' handlesMouseDown: mouseDown:)('geometry' extent:)('initialization' createAcceptButton createCancelButton createQueryTextMorph: createTextPaneExtent:acceptBoolean: defaultColor delete editorClass initialize responseUponCancel: setDefaultParameters setQuery:initialAnswer:answerExtent:acceptOnCR: setQuery:initialAnswer:answerHeight:acceptOnCR: updateColor)('invoking' getUserResponse morphicLayerNumber)('menu' accept cancel)!Smalltalk removeClassNamed: #PluggableTextMorph!Smalltalk removeClassNamed: #TextMorphForEditView!