'From Cuis 2.0 of 12 February 2010 [latest update: #418] on 23 February 2010 at 2:41:56 pm'!!classDefinition: #ChangeSet category: #'Tools-Changes'!Object subclass: #ChangeSet	instanceVariableNames: 'name preamble postscript revertable isolationSet isolatedProject changeRecords structures superclasses '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #ClassChangeRecord category: #'Tools-Changes'!Object subclass: #ClassChangeRecord	instanceVariableNames: 'inForce revertable changeTypes priorDefinition thisName priorName thisOrganization priorOrganization thisComment priorComment thisMD priorMD methodChanges '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #BalloonMorph category: #'Morphic-Widgets'!PolygonMorph subclass: #BalloonMorph	instanceVariableNames: 'target offsetFromTarget balloonOwner '	classVariableNames: 'BalloonColor BalloonFont '	poolDictionaries: ''	category: 'Morphic-Widgets'!!ReferenceStream commentStamp: 'jmv 2/22/2010 23:53' prior: 0!This is a way of serializing a tree of objects into disk file. A ReferenceStream can storeone or more objects in a persistent form, including sharing and cycles.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.ReferenceStreams can now write "weak" references. nextPutWeak:writes a "weak" reference to an object, which refers to that object*if* it also gets written to the stream by a normal nextPut:.A ReferenceStream should be treated as a read-stream *or* as a write-stream, *not* as a read/write-stream. The reference-remembering mechanism would probably do bad things if you tried to read and write from the same ReferenceStream.[TBD] Should we override "close" to do (self forgetReferences)?Instance variables references -- an IdentityDictionary mapping objects already written	to their byteStream positions. If asked to write any object a	second time, we just write a reference to its stream position.	This handles shared objects and reference cycles between objects.	To implement "weak references" (for Aliases), the references	dictionary also maps objects not (yet?) written to a Collection	of byteStream positions with hopeful weak-references to it. If	asked to definitely write one of these objects, we'll fixup those	weak references. objects -- an IdentityDictionary mapping relative byte stream positions to	objects already read in. If asked to follow a reference, we	return the object already read.	This handles shared objects and reference cycles between objects. currentReference -- the current reference position. Positon relative to the 	start of object data in this file.  (Allows user to cut and paste smalltalk 	code from the front of the file without effecting the reference values.)  	This variable is used to help install each new object in "objects" as soon	as it's created, **before** we start reading its contents, in	case any of its content objects reference it. fwdRefEnds -- A weak reference can be a forward reference, which	requires advance-reading the referrent. When we later come to the	object, we must get its value from "objects" and not re-read it so	refs to it don't become refs to copies. fwdRefEnds remembers the	ending byte stream position of advance-read objects. skipping -- true if <what?>If the object is referenced before it is done being created, it might get created twice.  Just store the object the moment it is created in the 'objects' dictionary.  If at the end, comeFullyUpOnReload returns a different object, some refs will have the temporary object (this is an unlikely case).  At the moment, no implementor of comeFullyUpOnReload returns a different object except DiskProxy, and that is OK.!!ChangeSet methodsFor: 'initialize-release' stamp: 'jmv 2/23/2010 00:11'!initialize 	"Initialize the receiver to be empty."	name ifNil:		[^ self error: 'All changeSets must be registered, as in ChangeSorter newChangeSet'].	self clear.! !!ChangeSet methodsFor: 'change logging' stamp: 'jmv 2/23/2010 00:09'!addClass: class 	"Include indication that a new class was created."	class wantsChangeSetLogging ifFalse: [^ self].	self atClass: class add: #new.	self atClass: class add: #change.	self addCoherency: class name! !!ChangeSet methodsFor: 'change logging' stamp: 'jmv 2/23/2010 00:10'!changeClass: class from: oldClass	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."	class wantsChangeSetLogging ifFalse: [^ self].	class isMeta 		ifFalse: [self atClass: class add: #change]	"normal"		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass				is not recorded, even though it was added.  A further change is				really just part of the original add."			ifFalse: [self atClass: class add: #change]].	self addCoherency: class name.	(self changeRecorderFor: class) notePriorDefinition: oldClass.	self noteClassStructure: oldClass! !!ChangeSet methodsFor: 'change logging' stamp: 'jmv 2/23/2010 00:10'!noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil	class wantsChangeSetLogging ifFalse: [^ self].	(self changeRecorderFor: class)		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil! !!ChangeSet methodsFor: 'change logging' stamp: 'jmv 2/23/2010 00:09'!removeSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info	"Include indication that a method has been forgotten.	info is a pair of the source code pointer and message category	for the method that was removed."	class wantsChangeSetLogging ifFalse: [^ self].	(self changeRecorderFor: class)		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info! !!ChangeSet methodsFor: 'change logging' stamp: 'jmv 2/23/2010 00:10'!renameClass: class as: newName 	"Include indication that a class has been renamed."	| recorder |	(recorder _ self changeRecorderFor: class)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: class name.	self noteClassStructure: class.	recorder _ changeRecords at: class class name ifAbsent: [^ nil].	changeRecords at: (newName, ' class') put: recorder.	changeRecords removeKey: class class name.	recorder noteNewName: newName , ' class'! !!ChangeSet methodsFor: 'private' stamp: 'jmv 2/23/2010 00:11'!changeRecorderFor: class	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	"Later this will init the changeRecords so according to whether they should be revertable."	^ changeRecords at: cname			ifAbsent: [^ changeRecords at: cname							put: (ClassChangeRecord new initFor: cname revertable: false)]! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'jmv 2/23/2010 00:12'!noteChangeType: changeSymbol fromClass: class	(changeSymbol = #new or: [changeSymbol = #add]) ifTrue:		[changeTypes add: #add.		changeTypes remove: #change ifAbsent: [].		^ self].	changeSymbol = #change ifTrue:		[(changeTypes includes: #add) ifTrue: [^ self].		^ changeTypes add: changeSymbol].	changeSymbol == #addedThenRemoved ifTrue:		[^ self].  "An entire class was added but then removed"	changeSymbol = #comment ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #reorganize ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #rename ifTrue:		[^ changeTypes add: changeSymbol].	(changeSymbol beginsWith: 'oldName: ') ifTrue:		["Must only be used when assimilating other changeSets"		(changeTypes includes: #add) ifTrue: [^ self].		priorName _ changeSymbol copyFrom: 'oldName: ' size + 1 to: changeSymbol size.		^ changeTypes add: #rename].	changeSymbol = #remove ifTrue:		[(changeTypes includes: #add)			ifTrue: [changeTypes add: #addedThenRemoved]			ifFalse: [changeTypes add: #remove].		^ changeTypes removeAllFoundIn: #(add change comment reorganize)].	self error: 'Unrecognized changeType'! !!ClassChangeRecord methodsFor: 'initialization' stamp: 'jmv 2/23/2010 00:12'!initFor: className revertable: isRevertable	inForce _ isRevertable.	changeTypes _ IdentitySet new.	methodChanges _ IdentityDictionary new.	priorName _ thisName _ className! !!ChangeSet class methodsFor: 'current changeset' stamp: 'jmv 2/23/2010 00:09'!newChanges: aChangeSet	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	SystemChangeNotifier uniqueInstance removeActionsWithReceiver: current.	current _ aChangeSet.	SystemChangeNotifier uniqueInstance notify: aChangeSet ofAllSystemChangesUsing: #event:! !!CodeHolder methodsFor: 'message list' stamp: 'jmv 2/22/2010 23:40'!validateMessageSource: sourceString forSelector: aSelector	"Check whether there is evidence that method source is invalid"	(self selectedClass compilerClass == Object compilerClass 			and: [(sourceString asString findString: aSelector keywords first ) ~= 1])		ifTrue: [			self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.'].! !!FileDirectory class methodsFor: 'system start up' stamp: 'jmv 2/22/2010 23:34'!openSources: fullSourcesName forImage: imageName "We first do a check to see if a compressed version ofthe sources file is present.Open the .sources file read-only after searching in:a) the directory where the VM livesb) the directory where the image came fromc) the DefaultDirectory (which is likely the same as b unless the SecurityManager has changed it)."	| sources fd sourcesName |	sourcesName _ FileDirectory localNameFor: fullSourcesName.	"look for the sources file or an alias to it in the VM's directory"	fd _ FileDirectory on: Smalltalk vmPath.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil: [^ sources].	"look for the sources file or an alias to it in the image directory"	fd _ FileDirectory on: (FileDirectory dirPathFor: imageName).	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	sources ifNotNil: [^ sources].	"look for the sources in the current directory"	fd _ DefaultDirectory.	(fd fileExists: sourcesName)		ifTrue: [sources _ fd readOnlyFileNamed: sourcesName].	"sources may still be nil here"	^sources! !!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/22/2010 23:22'!showBalloon: msgString hand: aHand	"Pop up a balloon containing the given string,	first removing any existing BalloonMorphs in the world."	| w balloon h |	(w _ self world) ifNil: [^ self].	h _ aHand.	h ifNil:[		h _ w activeHand].	balloon _ BalloonMorph string: msgString for: self balloonHelpAligner.	balloon popUpForHand: h.! !Utilities class removeSelector: #doesNotUnderstand:!Utilities class removeSelector: #evaluate:in:to:!Utilities class removeSelector: #fileOutChanges!TheWorldMenu class removeSelector: #unregisterOpenCommandWithReceiver:!TheWorldMenu removeSelector: #myMenuColor!TheWorldMenu removeSelector: #newGlobalFlapString!TheWorldMenu removeSelector: #soundEnablingString!TheWorldMenu removeSelector: #toggleFlapSuppressionInProject!SystemDictionary removeSelector: #compressSources!String removeSelector: #compressWithTable:!SoundBuffer class removeSelector: #startUpFrom:!ShortRunArray class removeSelector: #startUpFrom:!ShortIntegerArray class removeSelector: #startUpFrom:!ReadWriteStream removeSelector: #fileOutChanges!ProjectX class removeSelector: #maybeForkInterruptX!MorphicEvent class removeSelector: #convertObsolete:!MorphicEvent class removeSelector: #readFromObsolete:!MorphicEvent removeSelector: #convertOctober2000:using:!MorphicEvent removeSelector: #setHand:!MorphicEvent removeSelector: #setTimeStamp:!BalloonMorph class removeSelector: #setBalloonColorTo:!BalloonMorph removeSelector: #balloonOwner!BalloonMorph removeSelector: #popUpFor:hand:!!classDefinition: #BalloonMorph category: #'Morphic-Widgets'!PolygonMorph subclass: #BalloonMorph	instanceVariableNames: 'target offsetFromTarget'	classVariableNames: 'BalloonColor BalloonFont'	poolDictionaries: ''	category: 'Morphic-Widgets'!Form class removeSelector: #fromBMPFile:!Form class removeSelector: #fromBMPFileNamed:!Dictionary removeSelector: #associationDeclareAt:!ColorForm removeSelector: #asFormWithSingleTransparentColors!Color removeSelector: #changeColorIn:event:!ArrayedCollection removeSelector: #copyGrownBy:!ArrayedCollection removeSelector: #swapBytesFrom:to:!Collection removeSelector: #addIfNotPresent:!Collection removeSelector: #gather:!ChangeSorter class removeSelector: #belongsInMyInitials:!ChangeSorter class removeSelector: #buildAggregateChangeSet!ChangeSorter class removeSelector: #removeEmptyUnnamedChangeSets!Character class removeSelector: #alphabet!ChangeSet class removeSelector: #noChanges!Categorizer class removeSelector: #sortAllCategories!BorderStyle class removeSelector: #color:width:!BMPReadWriter class removeSelector: #displayAllFrom:!BMPReadWriter class removeSelector: #readAllFrom:!Class removeSelector: #canFindWithoutEnvironment:!ClassDescription removeSelector: #categoryFromUserWithPrompt:!ClassDescription removeSelector: #compileInobtrusively:classified:!ClassDescription removeSelector: #compileProgrammatically:classified:!ClassDescription removeSelector: #compileUnlogged:classified:notifying:!ClassDescription removeSelector: #letUserReclassify:!ClassDescription removeSelector: #removeSelectorUnlogged:!ClassChangeRecord removeSelector: #forgetClassRemoval!ClassChangeRecord removeSelector: #invokePhase1!ClassChangeRecord removeSelector: #invokePhase2!ClassChangeRecord removeSelector: #revokePhase1!ClassChangeRecord removeSelector: #revokePhase2!ClassChangeRecord removeSelector: #zapHistory!!classDefinition: #ClassChangeRecord category: #'Tools-Changes'!Object subclass: #ClassChangeRecord	instanceVariableNames: 'inForce changeTypes priorDefinition thisName priorName methodChanges'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!Character removeSelector: #isSafeForHTTP!ChangeSetCategory removeSelector: #fillAggregateChangeSet!ChangeSetCategory removeSelector: #membershipSelector:!ChangeSet removeSelector: #beIsolationSetFor:!ChangeSet removeSelector: #browseMessagesWithPriorVersions!ChangeSet removeSelector: #chooseSubjectPrefixForEmail!ChangeSet removeSelector: #invoke!ChangeSet removeSelector: #isolatedProject!ChangeSet removeSelector: #isolationSet:!ChangeSet removeSelector: #revoke!ChangeSet removeSelector: #zapHistory!!classDefinition: #ChangeSet category: #'Tools-Changes'!Object subclass: #ChangeSet	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!BasicClassOrganizer removeSelector: #moveChangedCommentToFile:numbered:!Categorizer removeSelector: #isEmptyCategoryNamed:!BlockContext removeSelector: #doWhileFalse:!BlockContext removeSelector: #doWhileTrue:!BlockClosure removeSelector: #doWhileFalse:!BlockClosure removeSelector: #doWhileTrue:!Behavior removeSelector: #allSelectorsUnderstood!Behavior removeSelector: #compressedSourceCodeAt:!Behavior removeSelector: #formalHeaderPartsFor:!Behavior removeSelector: #nonObsoleteClass!Behavior removeSelector: #removeSelectorSimply:!Behavior removeSelector: #scopeHas:ifTrue:!Behavior removeSelector: #selectSubclasses:!Behavior removeSelector: #selectorsWithArgs:!Behavior removeSelector: #startUpFrom:!Behavior removeSelector: #subclassInstVarNames!Object removeSelector: #beep!Object removeSelector: #deprecated:explanation:!Object removeSelector: #deprecatedExplanation:!Smalltalk removeClassNamed: #CompressedSourceStream!Smalltalk removeClassNamed: #ScrollingToolHolder!