'From Cuis 1.0 of 4 September 2009 [latest update: #290] on 29 September 2009 at 5:06:07 pm'!!ParseNode methodsFor: 'private' stamp: 'jmv 9/29/2009 15:35'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string"		aStream nextPutAll: aString! !!BlockNode methodsFor: 'printing' stamp: 'jmv 9/29/2009 16:09'!printArgumentsOn: aStream indent: level	arguments size = 0		ifTrue: [ ^aStream crtab: level ].	arguments do: [:arg |		aStream			withStyleFor: #blockArgument			do: [				aStream					nextPutAll: ':';					nextPutAll: arg key;					space ]].	aStream nextPutAll: '| '.	aStream crtab: level! !!BlockNode methodsFor: 'printing' stamp: 'jmv 9/29/2009 15:44'!printOn: aStream indent: level	"statements size <= 1 ifFalse: [aStream crtab: level]."	aStream nextPutAll: '[ '.	self printArgumentsOn: aStream indent: level.	self printTemporariesOn: aStream indent: level.	self printStatementsOn: aStream indent: level.	aStream nextPutAll: ' ]'! !!CascadeNode methodsFor: 'printing' stamp: 'jmv 9/29/2009 17:04'!printOn: aStream indent: level precedence: p 	p > 0 ifTrue: [ aStream nextPut: $( ].	messages first printReceiver: receiver on: aStream indent: level.	messages first precedence >= 2 ifTrue: [ aStream crtab: level + 1 ].	1 to: messages size do: [ :i | 		(messages at: i) printOn: aStream indent: level.		i < messages size ifTrue: [			aStream nextPut: $;.			messages first precedence >= 2 ifTrue: [ aStream crtab: level + 1 ]			]].	p > 0 ifTrue: [ aStream nextPut: $) ]! !!MessageNode methodsFor: 'printing' stamp: 'jmv 9/29/2009 17:05'!printKeywords: key arguments: args on: aStream indent: level prefix: isPrefix	| keywords indent arg kwd doCrTab |	args size = 0 ifTrue: [		aStream peekLast isSeparator  ifFalse: [ aStream space ].		aStream nextPutAll: key. ^ self].	keywords _ key keywords.	doCrTab _ args size > 2 or:		[{receiver} , args			inject: false			into: [:was :thisArg |				was or: [(thisArg isKindOf: BlockNode)					or: [(thisArg isKindOf: MessageNode) and: [thisArg precedence >= 3]]]]].	1 to: (args size min: keywords size) do: [ :i | 		arg _ args at: i.  kwd _ keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [				aStream peekLast isSeparator ifFalse: [ aStream space ].				indent _ 0].		aStream nextPutAll: kwd; space.		arg 			printOn: aStream			indent: level + 1 + indent			precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).	]! !!MessageNode methodsFor: 'printing' stamp: 'jmv 9/29/2009 16:26'!printOn: aStream indent: level	| leadingKeyword |"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	(special > 0)		ifTrue: [self perform: self macroPrinter with: aStream with: level]		ifFalse: [selector key first = $:				ifTrue: [					leadingKeyword _ selector key keywords first.					aStream nextPutAll: leadingKeyword ; space.					self printReceiver: receiver on: aStream indent: level.					self						printKeywords: (selector key allButFirst: leadingKeyword size + 1)						arguments: arguments						on: aStream indent: level ]				ifFalse: [					self printReceiver: receiver on: aStream indent: level.					self printKeywords: selector key arguments: arguments on: aStream indent: level]]! !