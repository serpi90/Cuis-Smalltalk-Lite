'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 26 April 2011 at 4:08:40 pm'!!Morph methodsFor: 'initialization' stamp: 'FernandoOlivero 4/20/2011 13:17'!openInHand	"Attach the receiver to the current hand in the current morphic world"	World activeHand attachMorph: self! !!CodeWindow methodsFor: 'menu commands' stamp: 'FernandoOlivero 4/20/2011 13:17'!makeSampleInstance	| aClass nonMetaClass anInstance |	(aClass _ model selectedClassOrMetaClass) ifNil: [^ self].	nonMetaClass _ aClass theNonMetaClass.	anInstance _ nonMetaClass initializedInstance.	(anInstance isNil and: [nonMetaClass ~~ UndefinedObject]) ifTrue: 		[^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	(anInstance is: #Morph)		ifTrue: [ anInstance openInHand ]		ifFalse: [ anInstance inspectWithLabel: 'An instance of ', nonMetaClass name ]! !!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 4/26/2011 16:02'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.	positionOffset _ dragHandle referencePosition - (target externalizePositionFromOwner: target position to: owner)! !!MagnifierMorph methodsFor: 'menu' stamp: 'FernandoOlivero 4/20/2011 13:30'!chooseMagnification: evt	| handle origin aHand currentMag |	currentMag _ magnification.	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].	origin _ aHand position y.	handle _ HandleMorph new forEachPointDo:		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].	aHand attachMorph: handle.	handle startStepping.	self redrawNeeded. ! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 4/26/2011 16:00'!sourcePoint	"If we are being dragged use our center, otherwise use pointer position"	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])		ifTrue: [ bounds center ]		ifFalse: [ self world activeHand position ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'FernandoOlivero 4/20/2011 13:46'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' ) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					World activeHand  newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !WorldState removeSelector: #activeHand!PasteUpMorph removeSelector: #activeHand!Morph removeSelector: #startDrag:with:!Object removeSelector: #currentHand!