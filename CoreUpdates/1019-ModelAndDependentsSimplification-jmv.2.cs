'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 1 June 2011 at 4:48:17 pm'!!Morph methodsFor: 'as yet unclassified' stamp: 'jmv 6/1/2011 14:24'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	submorphs do: [ :m | m canDiscardEdits ifFalse: [ ^false ]].	^ true! !!Morph methodsFor: 'as yet unclassified' stamp: 'jmv 6/1/2011 15:46'!disregardUnacceptedEdits	"Return true if this view either has no text changes or does not care."	submorphs do: [ :m | m disregardUnacceptedEdits ].	^ true! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 6/1/2011 14:26'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	(SystemWindow windowsIn: self satisfying: [:w | w canDiscardEdits])		do: [:w | w delete]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 6/1/2011 14:26'!findDirtyBrowsers: evt 	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu := MenuMorph new.	(SystemWindow windowsIn: self		satisfying: [:w | (w model isKindOf: Browser) and: [w canDiscardEdits not]]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #activate].	menu submorphs notEmpty ifTrue: [menu popUpInWorld: self]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 6/1/2011 14:26'!findDirtyWindows: evt 	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu := MenuMorph new.	(SystemWindow windowsIn: self		satisfying: [:w | w canDiscardEdits not]) do: 				[:w | 				menu 					add: w label					target: w					action: #activate].	menu submorphs notEmpty ifTrue: [menu popUpInWorld: self]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 6/1/2011 14:33'!findWindow: evt 	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."	| menu expanded collapsed nakedMorphs |	menu := MenuMorph new.	expanded := SystemWindow windowsIn: self				satisfying: [:w | w isCollapsed not].	collapsed := SystemWindow windowsIn: self				satisfying: [:w | w isCollapsed].	nakedMorphs := self submorphsSatisfying: [:m | (m is: #SystemWindow) not].	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) 		ifTrue: [^Beeper beep].	(expanded 		asArray sort: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #activateAndForceLabelToShow.				w canDiscardEdits ifFalse: [menu lastItem color: Color red]].	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) 		ifFalse: [menu addLine].	(collapsed 		asArray sort: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) 			do: 				[:w | 				menu 					add: w label					target: w					action: #collapseOrExpand.				w canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asArray sort: 			[:w1 :w2 | 			w1 nameForFindWindowFeature 				caseInsensitiveLessOrEqual: w2 nameForFindWindowFeature]) 		do: 			[:w | 			menu 				add: w nameForFindWindowFeature				target: w				action: #comeToFrontAndAddHalo].	menu addTitle: 'find window'.	menu popUpInWorld: self! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 6/1/2011 14:58'!mouseUp: event	"The mouse came up within the list; take appropriate action"	| row |	row _ self rowAtLocation: event position.	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"	"No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])		ifTrue: [self changeModelSelection: 0]		ifFalse: [self changeModelSelection: row].	Cursor normal show.! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 6/1/2011 14:57'!keyboardSearch: aChar 	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	milliSeconds _ Time millisecondClockValue.	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"		lastKeystrokes _ ''].	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.	lastKeystrokeTime _ milliSeconds.	nextSelectionList _ OrderedCollection newFrom: (self getList copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self getList copyFrom: 1 to: oldSelection).	"Get rid of blanks and style used in some lists"	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]				ifNone: [^ self flash"match not found"].	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	nextSelection _ self getList findFirst: [:a | a == nextSelectionText].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 6/1/2011 15:14'!arrowKey: aChar	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."	| keyEvent oldSelection nextSelection max min howMany answer w |	answer _ false.	keyEvent _ aChar asciiValue.	oldSelection _ self getCurrentSelectionIndex.	nextSelection _ oldSelection.	max _ self maximumSelection.	min _ self minimumSelection.	howMany _ self numSelectionsInView.	"get this exactly??"	keyEvent = 31 ifTrue: [		"down-arrow; move down one, wrapping to top if needed"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [ nextSelection _ 1 ]].	keyEvent = 30 ifTrue: [		"up arrow; move up one, wrapping to bottom if needed"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [ nextSelection _ max ]].	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"	nextSelection = oldSelection ifFalse: [		w _ self ownerThatIsA: SystemWindow.		(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"			self changeModelSelection: nextSelection.			answer _ true ]].	^answer! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 6/1/2011 14:59'!mouseDown: event	| oldIndex oldVal row w |	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row _ self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	w _ self ownerThatIsA: SystemWindow.	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForSimulatedMouseButton2: self		event: event		dblClkSel: #doubleClick:! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 6/1/2011 15:00'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |	event position y < bounds top 		ifTrue: [			scrollBar scrollUp: 1.			row _ self rowAtLocation: scroller bounds topLeft + (1 @ 1)]		ifFalse: [			row _ event position y > bounds bottom 				ifTrue: [					scrollBar scrollDown: 1.					self rowAtLocation: scroller bounds bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	"No change if model is locked"	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	dragOnOrOff ifNil: [			"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff _ (self listSelectionAt: row) not].	"Set meaning for subsequent dragging of selection"	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [ self changeModelSelection: row ]		ifFalse: [ self changeModelSelection: 0 ].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].		"Select all in between if drag was too fast"	"self listSelectionAt: row put: dragOnOrOff."	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |		self listSelectionAt: r put: dragOnOrOff]! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 6/1/2011 15:00'!mouseUp: event 	| aMorph |	aMorph := self itemFromPoint: event position.	aMorph ifNil: [^self].	aMorph highlightedForMouseDown ifFalse: [^self].	aMorph highlightForMouseDown: false.	"No change if model is locked"	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].	Cursor normal show! !!SystemDictionary methodsFor: 'toDeprecate' stamp: 'jmv 6/1/2011 14:16'!snapshot: save andQuit: quit embedded: embeddedFlag 	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil: 			[msg := String streamContents: 							[:s | 							s								nextPutAll: '----';								nextPutAll: (save 											ifTrue: [quit ifTrue: ['QUIT'] ifFalse: ['SNAPSHOT']]											ifFalse: [quit ifTrue: ['QUIT/NOSAVE'] ifFalse: ['NOP']]);								nextPutAll: '----';								print: Date dateAndTimeNow;								space;								nextPutAll: (FileDirectory default localNameFor: self imageName);								nextPutAll: ' priorSource: ';								print: LastQuitLogPosition].			self assureStartupStampLogged.			save 				ifTrue: 					[LastQuitLogPosition _ ((SourceFiles at: 2)								setToEnd;								position)].			self logChange: msg.			Transcript				cr;				show: msg].	self processShutDownList: quit.	Cursor write show.	save 		ifTrue: 			[resuming := embeddedFlag 						ifTrue: [self snapshotEmbeddedPrimitive]						ifFalse: [self snapshotPrimitive].	"<-- PC frozen here on image file"			]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	self setGCParameters.	resuming == true ifTrue: [self clearExternalObjects].	self processStartUpList: resuming == true.	resuming == true 		ifTrue: [			self setPlatformPreferences.			self readDocumentFile].	"Now it's time to raise an error"	resuming		ifNil: [ self error: 'Failed to write image file (disk full?)'].	^resuming! !!SystemWindow methodsFor: 'open/close' stamp: 'jmv 6/1/2011 15:00'!delete	| thisWorld |	self okToChange ifFalse: [^self].	thisWorld _ self world.	super delete.	model _ nil.	SystemWindow noteTopWindowIn: thisWorld! !!SystemWindow methodsFor: 'top window' stamp: 'jmv 6/1/2011 14:15'!activateAndSendTopToBack: aBoolean	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop |	self owner 		ifNil: [^self	"avoid spurious activate when drop in trash"].	oldTop _TopWindow.	TopWindow _ self.	oldTop ifNotNil: [		oldTop passivate.		aBoolean ifTrue: [			oldTop owner addMorphBack: oldTop ]].	self owner firstSubmorph == self 		ifFalse: [			"Bring me (with any flex) to the top if not already"			self owner addMorphFront: self].	self redrawNeeded! !!SystemWindow methodsFor: 'user interface' stamp: 'jmv 6/1/2011 15:47'!okToChange	| answer |	self canDiscardEdits ifTrue: [^true].	answer _ self confirm:'Changes have not been saved.Is it OK to cancel those changes?'.	answer ifTrue: [ self disregardUnacceptedEdits ].	^answer! !!BrowserWindow methodsFor: 'commands' stamp: 'jmv 6/1/2011 14:54'!findClass	"Search for a class by name."	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |	self okToChange ifFalse: [ ^self flash ].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self flash].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ model potentialClassNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self flash].	exactMatch _ classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].	index = 0 ifTrue: [^ self flash].	foundClass _ Smalltalk at: (classNames at: index) asSymbol. 	model selectCategoryForClass: foundClass.	model selectClass: foundClass! !!FileContentsBrowserWindow methodsFor: 'commands' stamp: 'jmv 6/1/2011 15:11'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self flash].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	classNames addAll: model selectedPackage classes keys.	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size = 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.		(model selectedPackage classes includesKey: (classNames at: index)) ifTrue:[			foundClass := model selectedPackage classes at: (classNames at: index).			foundPackage := model selectedPackage].	foundClass ifNotNil: [	 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundPackage packageName asSymbol).		model classListIndex: (model classList indexOf: foundClass name) ]! !!TextModelMorph methodsFor: 'dependents access' stamp: 'jmv 6/1/2011 16:45'!disregardUnacceptedEdits	^ self hasUnacceptedEdits: false! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 6/1/2011 15:33'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						hasUnacceptedEdits							ifTrue: [								bc _ Color red]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Theme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 6/1/2011 15:37'!accept	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' ) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					World activeHand  newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 6/1/2011 16:48'!update: aSymbol	super update: aSymbol.	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents ifTrue: [		"Some day, it would be nice to keep objects and update them		instead of throwing them away all the time for no good reason..."		textMorph releaseParagraph.		self formatAndStyleIfNeeded.		^self].	aSymbol == #acceptedContents ifTrue: [		hasUnacceptedEdits ifTrue: [			self hasEditingConflicts: true.				^self redrawNeeded ].		model refetch.		^self].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self].	aSymbol == #initialSelection ifTrue: [		^self setSelection: model getSelection].	aSymbol == #autoSelect ifTrue: [		self handleEdit: [			TextEditor abandonChangeText.	"no replacement!!"			self editor				setSearch: model autoSelectString;				againOrSame: true many: true ]].	"Quite ugly"	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #shoutStyle ifTrue: [		self stylerStyled.		^self redrawNeeded ].! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 6/1/2011 15:08'!removeClass	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."	| message  className classToRemove result |	classToRemove _ self selectedClassOrMetaClass ifNil: [Beeper beep. ^ false].	classToRemove _ classToRemove theNonMetaClass.	className _ classToRemove name.	message _ 'Are you certain that youwant to REMOVE the class ', className, 'from the system?'.	(result _ self confirm: message)		ifTrue: 			[classToRemove subclasses size > 0				ifTrue: [(self confirm: 'class has subclasses: ' , message)					ifFalse: [^ false]].			classToRemove removeFromSystem.			self changed: #classList.			true].	^ result! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/1/2011 15:09'!toggleDiffing	"Toggle whether diffs should be shown in the code pane.  If any kind of diffs were being shown, stop showing diffs.  If no kind of diffs were being shown, start showing whatever kind of diffs are called for by default."	self showDiffs: self showingAnyKindOfDiffs not! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/1/2011 15:09'!toggleLineDiffing	"Toggle whether regular-diffing should be shown in the code pane"	self showLineDiffs: self showingLineDiffs not! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/1/2011 15:09'!togglePlainSource	"Toggle whether plain source shown in the code pane"	self showingPlainSource		ifTrue: [			self contentsSymbol: #documentation]		ifFalse: [			self contentsSymbol: #source]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/1/2011 15:09'!togglePrettyLineDiffing	"Toggle whether pretty-diffing should be shown in the code pane"	self showPrettyLineDiffs: self showingPrettyLineDiffs not! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/1/2011 15:10'!togglePrettyPrint	"Toggle whether pretty-print is in effectin the code pane"	self showingPrettyPrint		ifTrue: [			self contentsSymbol: #source]		ifFalse: [			self contentsSymbol: #prettyPrint]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/1/2011 15:10'!togglePrettyWordDiffing	"Toggle whether pretty-diffing should be shown in the code pane"	self showPrettyWordDiffs: self showingPrettyWordDiffs not! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/1/2011 15:10'!toggleWordDiffing	"Toggle whether regular-diffing should be shown in the code pane"	self showWordDiffs: self showingWordDiffs not! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 6/1/2011 15:34'!updateListsAndCodeIn: aWindow	aWindow canDiscardEdits ifTrue: [		aWindow updatablePanes do: [:aPane | aPane verifyContents]].	self updatePaneIfNeeded! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 6/1/2011 15:32'!updatePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue: [			self acceptedContentsChanged]! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 6/1/2011 15:09'!showByteCodes: aBoolean	"Get into or out of bytecode-showoing mode"	aBoolean		ifTrue: [			self contentsSymbol: #byteCodes]		ifFalse: [			contentsSymbol == #byteCodes ifTrue: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 6/1/2011 15:09'!toggleDecompile	"Toggle the setting of the showingDecompile flag, unless there are unsubmitted edits that the user declines to discard"	self showDecompile: self showingDecompile not! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 6/1/2011 15:10'!toggleShowDocumentation	"Toggle the setting of the showingDocumentation flag, unless there are unsubmitted edits that the user declines to discard"	self showDocumentation: self showingDocumentation not! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 6/1/2011 15:08'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self revertToPreviousVersion.	self removeFromCurrentChanges.	self acceptedContentsChanged! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 6/1/2011 15:09'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords |	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ Beeper beep].	changeRecords second fileIn.	self acceptedContentsChanged! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/1/2011 15:05'!copyClass	| originalClass originalName copysName |	classListIndex = 0 ifTrue: [^ self].	originalClass := self selectedClass.	originalName := originalClass name.	copysName _ self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName _ copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk includesKey: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	Cursor wait 		showWhile: [			| newDefinition newMetaDefinition newClass |			newDefinition := originalClass definition				copyReplaceAll: originalName printString				with: copysName printString.			newClass _ Smalltalk actualCompilerClass evaluate: newDefinition logged: true.			newMetaDefinition := originalClass class definition				copyReplaceAll: originalClass class name				with: newClass class name.			Smalltalk actualCompilerClass evaluate: newMetaDefinition logged: true.			newClass copyAllCategoriesFrom: originalClass.			newClass class copyAllCategoriesFrom: originalClass class.			originalClass hasComment ifTrue: [				newClass comment: originalClass comment ] ].	self classListIndex: 0.	self changed: #classList! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/1/2011 15:05'!editClass	"Retrieve the description of the class definition."	classListIndex = 0 ifTrue: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #editClass.	self acceptedContentsChanged.	self changed: #classCommentText.! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/1/2011 15:05'!editComment	"Retrieve the description of the class comment."	classListIndex = 0 ifTrue: [^ self].	self messageCategoryListIndex: 0.	metaClassIndicated _ false.	self editSelection: #editComment.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self acceptedContentsChanged! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/1/2011 15:05'!hierarchy	"Display the inheritance hierarchy of the receiver's selected class."	classListIndex = 0 ifTrue: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #hierarchy.	self changed: #editComment.	self acceptedContentsChanged.	^ self! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/1/2011 15:05'!makeNewSubclass	self selectedClassOrMetaClass ifNil: [^ self].	self editSelection: #newClass.	self acceptedContentsChanged! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/1/2011 15:05'!plusButtonHit	"Cycle among definition, comment, and hierachy"	editSelection == #editComment		ifTrue: [self hierarchy. ^ self].	editSelection == #hierarchy		ifTrue: [self editSelection: #editClass.			classListIndex = 0 ifTrue: [^ self].			self changed: #editComment.			self acceptedContentsChanged.			^ self].	self editComment! !!Browser methodsFor: 'class functions' stamp: 'jmv 6/1/2011 15:06'!renameClass	| oldName newName obs |	classListIndex = 0 ifTrue: [^ self].	oldName _ self selectedClass name.	newName _ self request: 'Please type new class name' initialAnswer: oldName.	newName = '' ifTrue: [^ self].  " Cancel returns '' "	newName _ newName asSymbol.	newName = oldName ifTrue: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	self selectedClass rename: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).	obs _ Smalltalk allCallsOn: (Smalltalk associationAt: newName).	obs isEmpty ifFalse: [		Smalltalk 			browseMessageList: obs			name: 'Obsolete References to ' , oldName			autoSelect: oldName	].! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/1/2011 15:04'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines menuIndex oldIndex newName |	classListIndex = 0 ifTrue: [^ self].	labels _ OrderedCollection with: 'new...'.	reject _ Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |		cls = Object ifFalse: [			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asArray sort.				reject addAll: cats]]].	newName _ (labels size = 1 or: [		menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: 'Add Category'.		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex _ messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: (messageCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedMessageCategoryName]).	self changed: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [self classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/1/2011 15:04'!alphabetizeMessageCategories	classListIndex = 0 ifTrue: [^ false].	self classOrMetaClassOrganizer sortCategories.	self changed: #clearUserEdits.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/1/2011 15:05'!editMessageCategories	"Indicate to the receiver and its dependents that the message categories of 	the selected class have been changed."	classListIndex ~= 0		ifTrue: [			self messageCategoryListIndex: 0.			self editSelection: #editMessageCategories.			self changed: #editMessageCategories.			self acceptedContentsChanged ]! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/1/2011 15:05'!removeEmptyCategories	self selectedClassOrMetaClass organization removeEmptyCategories.	self changed: #messageCategoryList! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/1/2011 15:05'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?'])		ifTrue: 			[self selectedClassOrMetaClass removeCategory: messageCategoryName.			self messageCategoryListIndex: 0.			self changed: #classSelectionChanged].	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/1/2011 15:06'!renameCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	classListIndex = 0 ifTrue: [^ self].	(oldIndex _ messageCategoryListIndex) = 0 ifTrue: [^ self].	oldName _ self selectedMessageCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	newName = oldName ifTrue: [^ self].	self classOrMetaClassOrganizer		renameCategory: oldName		toBe: newName.	self classListIndex: classListIndex.	self messageCategoryListIndex: oldIndex.	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'jmv 6/1/2011 15:06'!showHomeCategory	"Show the home category of the selected method.  This is only really useful if one is in a tool that supports the showing of categories.  Thus, it's good in browsers and hierarchy browsers but not in message-list browsers"	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil: [		self selectOriginalCategoryForCurrentMethod.		self selectedMessageName: aSelector]! !!Browser methodsFor: 'message functions' stamp: 'jmv 6/1/2011 15:05'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	messageName _ self selectedMessageName.	confirmation _ Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation = 2		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:04'!addSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex newName |	oldIndex _ systemCategoryListIndex.	newName _ self		request: 'Please type new category name'		initialAnswer: 'Category-Name'.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	systemOrganizer		addCategory: newName		before: (systemCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedSystemCategoryName]).	self systemCategoryListIndex:		(oldIndex = 0			ifTrue: [self systemCategoryList size]			ifFalse: [oldIndex]).	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:04'!alphabetizeSystemCategories	systemOrganizer sortCategories.	self systemCategoryListIndex: 0.	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:05'!editSystemCategories	"Retrieve the description of the class categories of the system organizer."	self systemCategoryListIndex: 0.	self editSelection: #editSystemCategories.	self changed: #editSystemCategories.	self acceptedContentsChanged! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:05'!moveSystemCategoryBottom	systemCategoryListIndex = 0 ifTrue: [^ self].	self systemCategoryListIndex:		(systemOrganizer moveCategoryBottom: self selectedSystemCategoryName).	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:05'!moveSystemCategoryDown	systemCategoryListIndex = 0 ifTrue: [^ self].	self systemCategoryListIndex: 		(systemOrganizer moveCategoryDown: self selectedSystemCategoryName).	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:05'!moveSystemCategoryTop	systemCategoryListIndex = 0 ifTrue: [^ self].	systemOrganizer moveCategoryTop: self selectedSystemCategoryName.	self systemCategoryListIndex: 1.	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:05'!moveSystemCategoryUp	systemCategoryListIndex = 0 ifTrue: [^ self].	self systemCategoryListIndex: 		(systemOrganizer moveCategoryUp: self selectedSystemCategoryName).	self changed: #systemCategoryList! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:06'!removeSystemCategory	"If a class category is selected, create a Confirmer so the user can 	verify that the currently selected class category and all of its classes 	should be removed from the system. If so, remove it."	systemCategoryListIndex = 0 ifTrue: [^ self].	(self classList size = 0		or: [self confirm: 'Are you sure you want toremove this system category and all its classes?'])		ifTrue: 		[systemOrganizer removeSystemCategory: self selectedSystemCategoryName.		self systemCategoryListIndex: 0.		self changed: #systemCategoryList]! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:06'!renameSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	(oldIndex _ systemCategoryListIndex) = 0		ifTrue: [^ self].  "no selection"	oldName _ self selectedSystemCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	oldName = newName ifTrue: [^ self].	systemOrganizer		renameCategory: oldName		toBe: newName.	self systemCategoryListIndex: oldIndex.	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'jmv 6/1/2011 15:06'!updateSystemCategories	"The class categories were changed in another browser. The receiver must 	reorganize its lists based on these changes."	self changed: #systemCategoryList! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 6/1/2011 15:10'!addPreamble	myChangeSet assurePreambleExists.	currentClassName _ nil.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 6/1/2011 14:11'!fileOut	"File out the current change set."	myChangeSet fileOut! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 6/1/2011 15:08'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	aSet _ self class newChangeSet.	aSet ifNotNil: [		self update.		(changeSetCategory includesChangeSet: aSet) ifTrue:			[self showChangeSet: aSet].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 6/1/2011 15:08'!remove	"Completely destroy my change set.  Check if it's OK first"	self removePrompting: true.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 6/1/2011 15:08'!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	self checkThatSidesDiffer: [^ self].	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply choose "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(self confirm: message) ifFalse: [^ self].	(myChangeSet hasPreamble or: [myChangeSet hasPostscript]) ifTrue:		[(self confirm: 'Caution!!  This change set has a preamble ora postscript or both.  If you submerge it intothe other side, these will be lost.Do you really want to go ahead with this?') ifFalse: [^ self]].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 6/1/2011 15:07'!copyClassToOther	"Place these changes in the other changeSet also"	| otherSorter otherChangeSet |	self checkThatSidesDiffer: [^ self].	currentClassName ifNil: [^ Beeper beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	otherSorter showChangeSet: otherChangeSet.! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 6/1/2011 14:11'!fileOutClass	"this is a hack!!!! makes a new change set, called the class name, adds author initials to try to make a unique change set name, files it out and removes it. kfr 16 june 2000" 	| aSet |	"File out the selected class set."     aSet _ self class newChangeSet: currentClassName.	aSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	aSet fileOut.	self class removeChangeSet: aSet! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 6/1/2011 15:07'!forgetClass	"Remove all mention of this class from the changeSet"	currentClassName ifNotNil: [		myChangeSet removeClassChanges: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 6/1/2011 15:07'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	self checkThatSidesDiffer: [^ self].	currentClassName ifNil: [^ Beeper beep].	self copyClassToOther.	self forgetClass! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 6/1/2011 15:07'!forget	"Drop this method from the changeSet"	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 6/1/2011 15:08'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^ self].	currentSelector ifNotNil: [		other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 6/1/2011 15:08'!removeMessage	"Remove the selected msg from the system. Real work done by the 	parent, a ChangeSorter"	| confirmation sel |	currentSelector		ifNotNil: [			confirmation _ Smalltalk				confirmRemovalOf: (sel _ self selectedMessageName)				on: self selectedClassOrMetaClass.			confirmation = 3				ifTrue: [^ self].			self selectedClassOrMetaClass removeSelector: sel.			self update.			confirmation = 2				ifTrue: [Smalltalk browseAllCallsOn: sel]]! !!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 6/1/2011 15:08'!toggleDiffing	"Toggle whether diffs should be shown in the code pane"	super toggleDiffing.	self acceptedContentsChanged.	self update! !!Debugger methodsFor: 'context stack (message list)' stamp: 'jmv 6/1/2011 15:10'!fullyExpandStack	"Expand the stack to include all of it, rather than the first four or five	contexts."	self newStack: contextStackTop contextStack.	self changed: #contextStackList! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 6/1/2011 15:10'!doStep	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext newContext |	self checkContextSelection.	currentContext _ self selectedContext.	newContext _ interruptedProcess completeStep: currentContext.	newContext == currentContext ifTrue: [		newContext _ interruptedProcess stepToSendOrReturn].	self contextStackIndex > 1		ifTrue: [self resetContext: newContext]		ifFalse: [newContext == currentContext				ifTrue: [self changed: #contentsSelection.						self updateInspectors]				ifFalse: [self resetContext: newContext]].! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 6/1/2011 15:10'!proceed	"Proceed from the interrupted state of the currently selected context."	self checkContextSelection.	self resumeProcess! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 6/1/2011 15:10'!restart	"Proceed from the initial state of the currently selected context. The 	argument is a controller on a view of the receiver. That view is closed."	"Closing now depends on a preference #restartAlsoProceeds - hmm 9/7/2001 16:46"	| ctxt |	self checkContextSelection.	ctxt _ interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext ifTrue: [		interruptedProcess restartTop; stepToSendOrReturn].	self resetContext: ctxt! !!Debugger methodsFor: 'context stack menu' stamp: 'jmv 6/1/2011 15:10'!send	"Send the selected message in the accessed method, and take control in 	the method invoked to allow further step or send."	self checkContextSelection.	interruptedProcess step: self selectedContext.	self resetContext: interruptedProcess stepToSendOrReturn.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/1/2011 15:11'!removeMessage	| messageName |	messageListIndex = 0		ifTrue: [^ self].	messageName _ self selectedMessageName.	(self selectedClass confirmRemovalOf: messageName)		ifFalse: [^ false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.	"In case organization not cached"	self changed: #messageList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/1/2011 15:11'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/1/2011 15:11'!removeUnmodifiedCategories	| theClass |	theClass _ self selectedClass.	theClass ifNil: [^self].	Cursor wait showWhile: [		theClass removeUnmodifiedMethods: theClass selectors.		theClass metaClass removeUnmodifiedMethods: theClass metaClass selectors].	self messageCategoryListIndex: 0.	self changed: #messageCategoryList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/1/2011 15:11'!removeUnmodifiedClasses	thePackage classes copy do: [ :theClass |		Cursor wait showWhile: [ theClass removeAllUnmodified ].		theClass hasChanges ifFalse: [ thePackage removeClass: theClass ]].	self classListIndex: 0.	self changed: #classList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 6/1/2011 15:11'!removeUnmodifiedMethods	| theClass cat |	theClass := self selectedClassOrMetaClass.	theClass ifNil: [ ^self].	cat := self selectedMessageCategoryName.	cat ifNil: [ ^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).	].	self messageListIndex: 0.	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'class list' stamp: 'jmv 6/1/2011 15:11'!renameClass	| oldName newName |	classListIndex = 0 ifTrue: [^ self].	oldName _ self selectedClass name.	newName _ (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: self selectedSystemCategoryName.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).! !!FileList methodsFor: 'file list' stamp: 'jmv 6/1/2011 15:12'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					name first = $^						ifTrue: [self directory: nil]						ifFalse: [self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := #needToGetBrief.	self changed: #fileListIndex.	self acceptedContentsChanged.	self changed: #updateButtonRow! !!FileList methodsFor: 'file menu action' stamp: 'jmv 6/1/2011 15:12'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	(response := FillInTheBlank						request: ('New {1} Name?' format: {aString})						initialAnswer: ('{1}Name' format: {aString}))		isEmpty ifTrue: [^ self].	newName := response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index := list indexOf: newName.	index = 0 ifTrue: [ending := ') ',newName.		index := list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file menu action' stamp: 'jmv 6/1/2011 15:12'!get	"Get contents of file again, it may have changed. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		brevityState == #briefHex			ifTrue: [brevityState _ #needToGetFullHex]			ifFalse: [brevityState _ #needToGetFull].		self acceptedContentsChanged ]! !!FileList methodsFor: 'file menu action' stamp: 'jmv 6/1/2011 15:12'!renameFile	"Rename the currently selected file"	| newName response |	listIndex = 0 ifTrue: [^ self].	(response _ FillInTheBlank request: 'NewFileName?' 					initialAnswer: fileName)		isEmpty ifTrue: [^ self].	newName _ response asFileName.	newName = fileName ifTrue: [^ self].	directory rename: fileName toBe: newName.	self updateFileList.	listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = newName].	listIndex > 0 ifTrue: [fileName _ newName].	self changed: #fileListIndex.! !!FileList methodsFor: 'initialization' stamp: 'jmv 6/1/2011 15:12'!directory: dir	"Set the path of the volume to be displayed."	self modelSleep.	directory _ dir.	sortMode ifNil: [		sortMode _ #date.		sortAscending _ false ].	self changed: #relabel.	self pattern: pattern! !!Inspector methodsFor: 'updating' stamp: 'jmv 6/1/2011 14:32'!updateListsAndCodeIn: aWindow	aWindow canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!MessageSet methodsFor: 'message list' stamp: 'jmv 6/1/2011 15:12'!addItem: classAndMethod	"Append a classAndMethod string to the list.  Select the new item."	messageList add: classAndMethod.	self changed: #messageList.	self messageListIndex: messageList size.! !!MessageSet methodsFor: 'message functions' stamp: 'jmv 6/1/2011 15:12'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	messageName _ self selectedMessageName.	confirmation _ Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self deleteFromMessageList: self selection.	self reformulateList.	confirmation = 2		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !!RecentMessageSet methodsFor: 'update' stamp: 'jmv 6/1/2011 14:33'!updateListsAndCodeIn: aWindow	| recentFromUtilities |	"RAA 20 june 2000 - a recent change to how messages were displayed in the list caused them not to match what was stored in Utilities. This caused the recent submissions to be continuously updated. The hack below fixed that problem"	self flag: #mref.	"in second pass, use simpler test"	aWindow canDiscardEdits ifFalse: [^ self].	recentFromUtilities _ Utilities mostRecentlySubmittedMessage,' '.	(messageList first asStringOrText asString beginsWith: recentFromUtilities)		ifFalse: [			self reformulateList]		ifTrue: [			self updatePaneIfNeeded]! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 6/1/2011 14:27'!cleanUpWorld	(SelectionMenu confirm:'This will remove all windows except thosecontaining unsubmitted text edits, and willalso remove all non-window morphs (otherthan flaps) found on the desktop.  Are yousure you want to do this?')		ifFalse: [^ self].	myWorld allNonFlapRelatedSubmorphs do:		[:m | m delete].	(SystemWindow windowsIn: myWorld satisfying: [:w | w canDiscardEdits])		do: [:w | w delete]! !Inspector removeSelector: #modelWakeUpIn:!ChangeSorter removeSelector: #modelWakeUp!CodeProvider removeSelector: #modelWakeUp!CodeProvider removeSelector: #modelWakeUpIn:!TextProvider removeSelector: #okToChange!TextProvider removeSelector: #updatePaneIfNeeded!TextModelMorph removeSelector: #hasUnacceptedEdits!TextModelMorph removeSelector: #promptForCancel!PluggableTextModel removeSelector: #updatePaneIfNeeded!TextModel removeSelector: #clearUserEditFlag!TextModel removeSelector: #updatePaneIfNeeded!SystemWindow class removeSelector: #wakeUpTopWindowUponStartup!BareTextMorph removeSelector: #hasUnacceptedEdits!Morph removeSelector: #actionMap!Morph removeSelector: #hasUnacceptedEdits!Morph removeSelector: #releaseActionMap!Morph removeSelector: #updateableActionMap!DualChangeSorter removeSelector: #modelWakeUp!DualChangeSorter removeSelector: #okToChange!Model removeSelector: #canDiscardEdits!Model removeSelector: #hasUnacceptedEdits!Object removeSelector: #canDiscardEdits!Object removeSelector: #hasUnacceptedEdits!Object removeSelector: #modelWakeUp!Object removeSelector: #modelWakeUpIn:!Object removeSelector: #okToChange!