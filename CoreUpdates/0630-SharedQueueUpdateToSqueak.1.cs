'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 3 November 2010 at 11:14:11 am'!!SharedQueue methodsFor: 'accessing' stamp: 'bf 2/11/2006 15:17'!flush	"Throw out all pending contents"	accessProtect critical: [		"nil out flushed slots --bf 02/11/2006"		contentsArray from: readPosition to: writePosition-1 put: nil.		readPosition := 1.		writePosition := 1.		"Reset the read synchronization semaphore"		readSynch initSignals].! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:24'!flushAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."	^accessProtect critical: [		| value newReadPos |		newReadPos := writePosition.		writePosition-1 to: readPosition by: -1 do:			[:i | value := contentsArray at: i.			contentsArray at: i put: nil.			(aBlock value: value) ifTrue: [				"We take an element out of the queue, and therefore, we need to decrement 				the readSynch signals"				readSynch wait.			] ifFalse: [				newReadPos := newReadPos - 1.				contentsArray at: newReadPos put: value]].		readPosition := newReadPos.		value]! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:25'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	readSynch wait.	^accessProtect		critical: [			| value |			readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value := nil]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1].			value].! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:25'!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	^accessProtect critical: [		| value |		readPosition >= writePosition ifTrue: [			value := nil		] ifFalse: [			value := contentsArray at: readPosition.			contentsArray at: readPosition put: nil.			readPosition := readPosition + 1		].		readPosition >= writePosition ifTrue: [readSynch initSignals].		value	].! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:26'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."	^accessProtect critical: [		| value readPos |		value := nil.		readPos := readPosition.		[readPos < writePosition and: [value isNil]] whileTrue: [			value := contentsArray at: readPos.			readPos := readPos + 1.			(aBlock value: value) ifTrue: [				readPosition to: readPos - 1 do: [ :j |					contentsArray at: j put: nil.				].				readPosition := readPos.			] ifFalse: [				value := nil.			].		].		readPosition >= writePosition ifTrue: [readSynch initSignals].		value.	]."===q := SharedQueue new.1 to: 10 do: [ :i | q nextPut: i].c := OrderedCollection new.[	v := q nextOrNilSuchThat: [ :e | e odd].	v notNil] whileTrue: [	c add: {v. q size}].{c. q} explore==="! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:34'!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, return nil"	^accessProtect		critical: [			| value |			readPosition >= writePosition					ifTrue: [readPosition := 1.							writePosition := 1.							value := nil]					ifFalse: [value := contentsArray at: readPosition].			value].! !!SharedQueue methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: size	contentsArray := Array new: size.	readPosition := 1.	writePosition := 1.	accessProtect := Semaphore forMutualExclusion.	readSynch := Semaphore new! !!SharedQueue methodsFor: 'private' stamp: 'ul 10/18/2010 02:35'!makeRoomAtEnd	| contentsSize |	contentsSize := writePosition - readPosition.	contentsSize * 2 > contentsArray size		ifTrue: [			"grow"			contentsArray := (contentsArray class new: contentsArray size * 2)				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition;				yourself ]		ifFalse: [			(contentsArray size > 10 and: [ contentsSize * 4 <= contentsArray size ])				ifTrue: [					"shrink"					contentsArray := (contentsArray class new: (contentsSize * 2 max: 10))						replaceFrom: 1						to: contentsSize						with: contentsArray						startingAt: readPosition;						yourself ]				ifFalse: [					"just move the elements to the front"					contentsArray						replaceFrom: 1						to: contentsSize						with: contentsArray						startingAt: readPosition.					contentsArray						from: contentsSize + 1						to: contentsArray size						put: nil ] ].	readPosition := 1.	writePosition := contentsSize + 1! !!SharedQueue methodsFor: 'copying' stamp: 'nice 10/5/2009 09:01'!postCopy	super postCopy.	contentsArray := contentsArray copy.	accessProtect := Semaphore forMutualExclusion.	readSynch := Semaphore new! !!SharedQueue class methodsFor: 'instance creation' stamp: 'nice 4/4/2006 22:10'!new: anInteger 	^super new initialize: anInteger! !SharedQueue removeSelector: #init:!