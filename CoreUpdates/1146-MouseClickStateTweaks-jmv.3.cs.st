'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 18 November 2011 at 8:56:39 am'!!HandMorph methodsFor: 'double click support' stamp: 'jmv 11/18/2011 08:52'!                    dontWaitForDoubleClick	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	mouseClickState _ nil.! !!HandMorph methodsFor: 'events-processing' stamp: 'jmv 11/18/2011 08:50'!      handleEvent: anEvent	| evt |	owner ifNil: [ ^ self ].	evt _ anEvent.	evt isMouseOver ifTrue: [ ^ self sendMouseEvent: evt ].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.		evt isWindowEvent ifTrue: [		self sendEvent: evt.		^ self mouseOverHandler processMouseOver: lastMouseEvent ].	evt isKeyboard ifTrue: [		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^ self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue: [		self sendEvent: evt.		^ self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue: [		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent _ evt.			lastMouseEventTime _ Time millisecondClockValue].	"Check for pending drag or double click operations."	mouseClickState ifNotNil: [		(mouseClickState handleEvent: evt from: self) ifTrue: [			"Possibly dispatched #click: or something. Do not further process this event."			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].	evt isMove ifTrue: [		self position: evt position.		self sendMouseEvent: evt.	] ifFalse: [		"Issue a synthetic move event if we're not at the position of the event"		evt position = self position ifFalse: [ self moveToEvent: evt ].		"Drop submorphs on button events"		self hasSubmorphs			ifTrue: [ self dropMorphs: evt ]			ifFalse: [ self sendMouseEvent: evt ].	].	self mouseOverHandler processMouseOver: lastMouseEvent! !!HandMorph methodsFor: 'initialization' stamp: 'jmv 11/18/2011 08:52'!              initForEvents	mouseOverHandler _ nil.	lastMouseEvent _ MouseEvent new setType: #mouseMove position: 0@0 buttons: 0 hand: self.	lastMouseEventTime _ Time millisecondClockValue.	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.	self dontWaitForDoubleClick! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 11/18/2011 08:55'!                    handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| timedOut distance |	timedOut _ (evt timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.	distance _ (evt position - lastClickDown position) r.	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."	evt isMouseDown ifTrue: [		lastClickDown _ evt.		buttonDownCount _ buttonDownCount + 1 ].	evt isMouseUp ifTrue: [		buttonUpCount _ buttonUpCount + 1 ].	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [			aHand dontWaitForDoubleClick.			clickClient mouseButton2Activity.			^ false ].		"If we have already moved, then it won't be a double or triple click... why wait?"		distance > 0 ifTrue: [			aHand dontWaitForDoubleClick.			self click.			^ false ]].	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [		aHand dontWaitForDoubleClick.		^ false ].	"Simple click."	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [		self click ].	"Click & hold"	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [		self clickAndAHalf ].	"Double click."	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [		self doubleClick ].	"Triple click"	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [		self tripleClick ].	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"	^ evt isMouseDown! !HandMorph removeSelector: #resetClickState!