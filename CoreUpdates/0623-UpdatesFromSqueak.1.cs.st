'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 2 November 2010 at 1:29:31 pm'!!FileDirectory methodsFor: 'file directory' stamp: 'bf 9/5/2010 00:02'!assureExistence	"Make sure the current directory exists. If necessary, create all parts in between"	self exists ifFalse: [ 		self containingDirectory			assureExistence;			createDirectory: self localName]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/7/2010 14:56'!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange limitIsAssignedTo |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^false]]		ifFalse: [increment := encoder encodeLiteral: 1].	(limit := arguments at: 1) isVariableReference ifTrue:		[limitIsAssignedTo := false.		 arguments last nodesDo:			[:node|			(node isAssignmentNode and: [node variable = limit]) ifTrue:				[limitIsAssignedTo := true]].		 limitIsAssignedTo ifTrue:			[^false]].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!RecategorizedEvent class methodsFor: 'instance creation' stamp: 'jmv 11/2/2010 12:34'!selector: aSelector method: aMethod protocol: prot class: aClass oldProtocol: oldName	^ (self method: aMethod protocol: prot class: aClass)		 itemSelector: aSelector;		 oldCategory: oldName;		 yourself.! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ul 9/12/2010 04:34'!indexOf: anElement startingAt: start	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer 0."	^self indexOf: anElement startingAt: start ifAbsent: 0! !!ByteArray methodsFor: 'accessing' stamp: 'jmv 11/2/2010 13:06'!indexOf: anInteger startingAt: start	(anInteger isInteger and: [		anInteger >= 0 and: [		anInteger <= 255 ] ]) ifFalse: [ ^0 ].	^String indexOfAscii: anInteger inString: self startingAt: start! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 9/12/2010 03:25'!allSymbolTablesDo: aBlock after: aSymbol	(NewSymbols includes: aSymbol) 		ifTrue: [			NewSymbols do: aBlock after: aSymbol.			SymbolTable do: aBlock after: aSymbol ]		ifFalse: [			SymbolTable do: aBlock after: aSymbol.			NewSymbols do: aBlock after: aSymbol ]	! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'jmv 11/2/2010 12:34'!selector: selector recategorizedFrom: oldCategory to: newCategory inClass: aClass	self trigger: (RecategorizedEvent 				selector: selector				method: (aClass compiledMethodAt: selector ifAbsent: nil)				protocol: newCategory				class: aClass				oldProtocol: oldCategory)! !!ZipArchive class methodsFor: 'constants' stamp: 'jmv 11/2/2010 12:40'!findEndOfCentralDirectoryFrom: stream	"Seek in the given stream to the end, then read backwards until we find the	signature of the central directory record. Leave the file positioned right	before the signature.	Answers the file position of the EOCD, or 0 if not found."	| data fileLength seekOffset pos maxOffset |	stream setToEnd.	fileLength _ stream position.	"If the file length is less than 18 for the EOCD length plus 4 for the signature, we have a problem"	fileLength < 22 ifTrue: [^ self error: 'file is too short'].		seekOffset _ 0.	pos _ 0.	data _ String new: 4100.	maxOffset _ 40960 min: fileLength.	"limit search range to 40K"	[		seekOffset _ (seekOffset + 4096) min: fileLength.		stream position: fileLength - seekOffset.		data _ stream next: (4100 min: seekOffset) into: data startingAt: 1.		pos _ self			lastIndexOfPKSignature: EndOfCentralDirectorySignature			in: data.		pos = 0 and: [seekOffset < maxOffset]	] whileTrue.	^ pos > 0		ifTrue: [ | newPos | stream position: (newPos _ (stream position + pos - seekOffset - 1)). newPos]		ifFalse: [0]! !!ZipArchive class methodsFor: 'constants' stamp: 'ar 9/6/2010 15:28'!lastIndexOfPKSignature: aSignature in: data	"Answer the last index in data where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(data size - 3) to: 1 by: -1 do: [ :i |		(((data at: i) = a)			and: [ ((data at: i + 1) = b)				and: [ ((data at: i + 2) = c)					and: [ ((data at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!ZipDirectoryMember methodsFor: 'private' stamp: 'cmm 9/16/2010 18:59'!writeDataTo: aStream       "Write nothing. Directories have no contents to write."! !String removeSelector: #lastIndexOfPKSignature:!FileDirectory removeSelector: #assureExistenceOfPath:!