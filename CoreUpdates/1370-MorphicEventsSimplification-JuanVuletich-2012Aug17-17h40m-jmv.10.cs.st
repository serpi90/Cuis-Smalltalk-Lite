'From Cuis 4.0 of 21 April 2012 [latest update: #1369] on 17 August 2012 at 8:16:24 pm'!
!classDefinition: #UserInputEvent category: #'Morphic-Events'!
MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'type buttons position handler wasHandled '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!classDefinition: #MouseButtonEvent category: #'Morphic-Events'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:31'!
processKeyboardSensorEvent: evt
	"process a keyboard event, updating InputSensor state"
	| charCode pressCode |
	"Never update keyboardBuffer if we have an eventQueue active"
	mouseButtons _ (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).
	eventQueue ifNotNil:[^self]. 
	charCode _ evt at: 3.
	charCode ifNil: [^self]. "extra characters not handled in MVC"
	pressCode _ evt at: 4.
	pressCode = EventSensor eventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"
	"mix in modifiers"
	charCode _ charCode bitOr: ((evt at: 5) bitShift: 8).
	keyboardBuffer nextPut: charCode.! !

!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:31'!
processMouseSensorEvent: evt
	"process a mouse event, updating InputSensor state"
	| modifiers buttons mapped |
	mousePosition _ (evt at: 3) @ (evt at: 4).
	buttons _ evt at: 5.
	modifiers _ evt at: 6.
	mapped _ self mapButtons: buttons modifiers: modifiers.
	mouseButtons _ mapped bitOr: (modifiers bitShift: 3).! !

!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:31'!
processSensorEvent: evt
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: ((evt at: 5) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		(evt at: 6) = 0 ifTrue: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].

	self queueEvent: evt.

	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !


!Form methodsFor: 'scaling, rotation' stamp: 'jmv 8/17/2012 19:08'!
flippedBy: direction centerAt: aPoint
	"Return a copy of the receiver flipped either #vertical or #horizontal."
	| newForm quad |
	newForm _ self class extent: self extent depth: depth.
	quad _ self boundingBox innerCorners.
	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])
		collect: [:i | quad at: i].
	(WarpBlt current toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
	newForm offset: (self offset flippedBy: direction centerAt: aPoint).
	^ newForm
"
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p | [Sensor anyButtonPressed] whileFalse:
	[f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 _ f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p]
"
! !


!ColorForm methodsFor: 'scaling, rotation' stamp: 'jmv 8/17/2012 19:08'!
flippedBy: direction centerAt: aPoint
	| oldColors newForm |
	oldColors _ colors.
	self colors: nil.
	newForm _ super flippedBy: direction centerAt: aPoint.
	self colors: oldColors.
	newForm colors: oldColors.
	^newForm ! !


!Morph methodsFor: 'events-processing' stamp: 'jmv 8/17/2012 15:57'!
dispatchEvent: aMorphicEvent
	"This is the central entry for dispatching events in morphic. Given some event, find the right receiver and let him handle it."

	^ (self rejectsEvent: aMorphicEvent)
		ifTrue: [ #rejected ]
		ifFalse: [ aMorphicEvent dispatchWith: self ]! !


!HaloMorph class methodsFor: 'instance protocol testing' stamp: 'jmv 8/17/2012 17:50'!
gatherProtocols
	"See comment at #is:"

	^super gatherProtocols, #(HaloMorph)! !


!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 15:59'!
dispatchWith: aMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^aMorph handleEvent: self ].
	^ #rejected! !


!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 15:58'!
dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: self.
	self wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: self eventPosition event: self ].
	inside ifTrue: [ ^aMorph handleEvent: self ].
	^#rejected! !


!PasteUpMorph methodsFor: 'events-processing' stamp: 'jmv 8/17/2012 15:57'!
dispatchEvent: anEvent
	"Reimplemented to install the receiver as the new ActiveWorld if it is one"
	| priorWorld result |
	self isWorldMorph ifFalse: [
		^super dispatchEvent: anEvent ].
	priorWorld _ ActiveWorld.
	ActiveWorld _ self.
	result _ super dispatchEvent: anEvent.
	ActiveWorld _ priorWorld.
	^result! !


!Point methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:10'!
scaledBy: factor 
	"Answer a Point scaled by factor (an instance of Point)."

	^(factor x * x) @ (factor y * y)! !

!Point methodsFor: 'transforming' stamp: 'jmv 8/17/2012 18:46'!
translatedBy: delta 
	"Answer a Point translated by delta (an instance of Point)."

	^(delta x + x) @ (delta y + y)! !


!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 18:53'!
aligned: aPoint1 with: aPoint2
	"Answer a Rectangle that is a translated by aPoint2 - aPoint1."

	^self translatedBy: aPoint2 - aPoint1! !

!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:09'!
flippedBy: direction centerAt: aPoint 
	"Return a copy flipped #vertical or #horizontal, about aPoint."
	| futureOrigin futureCorner |
	direction == #horizontal
		ifTrue:
			[futureOrigin := self topRight.
			futureCorner := self bottomLeft]
		ifFalse: [direction == #vertical
			ifTrue:
				[futureOrigin := self bottomLeft.
				futureCorner := self topRight]
			ifFalse: [self error: 'unrecognizable direction']].
	^ (futureOrigin flippedBy: direction centerAt: aPoint)
		corner: (futureCorner flippedBy: direction centerAt: aPoint)! !

!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:10'!
scaledBy: scale 
	"Answer a Rectangle scaled by scale, a Point or a scalar."

	^Rectangle origin: origin * scale corner: corner * scale! !

!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 18:47'!
translatedBy: factor 
	"Answer a Rectangle translated by factor, a Point or a scalar."

	^Rectangle origin: origin + factor corner: corner + factor! !


!UserInputEvent methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:02'!
ztranslateBy: delta
	"add delta to cursorPoint, and return the new event"
	self flag: #ya.
	position _ position + delta.! !

!UserInputEvent methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:02'!
ztranslatedBy: delta
	"add delta to cursorPoint, and return the new event"
	self flag: #ya.
	^self shallowCopy ztranslateBy: delta! !


!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 18:23'!
dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| globalPt aMorphHandlesIt handledByInner lastHandler answer |

	"Only for MouseDown"
	self isMouseDown
		ifFalse: [ ^super dispatchWith: aMorph ].

	"Try to get out quickly"
	globalPt _ self eventPosition.
	(aMorph morphFullBoundsInWorld containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isPlayfieldLike or: [ self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: self eventPosition event: self ])
		ifTrue:[
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ aMorph handleEvent: self ].
			answer _ self ]
		ifFalse: [
			"Mouse was not on aMorph nor any of its children"
			answer _ #rejected ].

	eventHandler _ lastHandler.
	^answer! !

!MouseButtonEvent methodsFor: 'initialize' stamp: 'jmv 8/17/2012 16:48'!
resetHandlerFields
	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"
	self flag: #jmvVer. "All this stuff of copying events to reset this data is pretty ugly."
	super resetHandlerFields.
	eventHandler _ nil! !


!MouseMoveEvent methodsFor: 'transforming' stamp: 'jmv 8/17/2012 19:02'!
ztranslateBy: delta
	"add delta to cursorPoint, and return the new event"
	self flag: #ya.
	super ztranslateBy: delta.
	startPoint _ startPoint + delta.! !


!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 8/17/2012 15:43'!
dispatchWith: aMorph
	"Host window events do not have a position and are only dispatched to the World"
	aMorph isWorldMorph ifFalse: [ ^#rejected ].
	self wasHandled ifTrue: [ ^self ].
	^aMorph handleEvent: self! !


!BitBlt class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor mouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor mouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					(newBuffRect areasOutside: buffRect) do:
						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				prevP _ p]]]! !


!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: i g: i b: i range: 255)].
	^ f
! !

!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w _ Display width // colorList size.
	r _ 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		Display fill: r fillColor: c.
		r _ r translatedBy: w@0].
! !

!Color class methodsFor: 'color from user' stamp: 'jmv 8/17/2012 18:48'!
fromUser
	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."
	"Note: Since the color chart is cached, you may need to do 'ColorChart _ nil' after changing the oldColorPaletteForDepth:extent: method."
	"Color fromUser"

	| d startPt save tr oldColor c here s |
	d _ Display depth.
	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 
		ifTrue: [ColorChart _ self oldColorPaletteForDepth: d extent: (2 * 144)@80].
	Sensor mousePoint y < Display center y 
		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]
		ifFalse: [startPt _ 0@0].

	save _ Form fromDisplay: (startPt extent: ColorChart extent).
	ColorChart displayAt: startPt.
	tr _ ColorChart extent - (50@19) corner: ColorChart extent.
	tr _ tr translatedBy: startPt.

	oldColor _ nil.
	[Sensor anyButtonPressed] whileFalse: [
		c _ Display colorAt: (here _ Sensor mousePoint).
		(tr containsPoint: here)
			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]
			ifTrue: [
				c _ Color transparent.
				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].
		c = oldColor ifFalse: [
			Display fillWhite: (20@61 + startPt extent: 135@19).
			c isTransparent
				ifTrue: [s _ 'transparent']
				ifFalse: [s _ c shortPrintString.
						s _ s copyFrom: 7 to: s size - 1].
			s displayAt: 20@61 + startPt.
			oldColor _ c]].
	save displayAt: startPt.
	Sensor waitNoButton.
	^ c
! !


!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 8/17/2012 15:30'!
fetchMoreEvents
	"Fetch more events from the VM"
	| eventBuffer type |

	"Reset input semaphore so clients can wait for the next events after this one."
	inputSemaphore isSignaled
		ifTrue: [
			hasInputSemaphore _ true.
			inputSemaphore initSignals ].

	"Remember the last time that I checked for events."
	lastEventPoll _ Time millisecondClockValue.

	eventBuffer _ Array new: 8.
	[
		self primGetNextEvent: eventBuffer.
		type _ eventBuffer at: 1.
		type = EventSensor eventTypeNone ]
			whileFalse: [ self processSensorEvent: eventBuffer ]! !


!Form methodsFor: 'scaling, rotation' stamp: 'jmv 8/17/2012 18:54'!
rotateBy: deg smoothing: cellSize
	"Rotate the receiver by the indicated number of degrees."
	"rot is the destination form, bit enough for any angle."
	| side rot warp r1 pts p center |
	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.
	rot _ Form extent: side@side depth: self depth.
	center _ rot extent // 2.

	"Now compute the sin and cos constants for the rotation angle." 
	warp _ (WarpBlt current toForm: rot)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: rot);
		cellSize: cellSize;  "installs a new colormap if cellSize > 1"
		combinationRule: Form over.
	r1 _ rot boundingBox aligned: center with: self boundingBox center.

	pts _ r1 innerCorners collect: [ :pt |
		p _ pt - r1 center.
		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @
		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].
	warp copyQuad: pts toRect: rot boundingBox.
	^ rot
"
 | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
		rotateBy: (a _ a+5) smoothing: 2) display].
f display
"! !

!Form methodsFor: 'transitions' stamp: 'jmv 8/17/2012 18:49'!
pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt current toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceDisplayUpdate].

	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceDisplayUpdate.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !

!Form methodsFor: 'transitions' stamp: 'jmv 8/17/2012 18:49'!
wipeImage: otherImage at: topLeft delta: delta clippingBox: clipBox

	| wipeRect bb nSteps |
	bb _ otherImage boundingBox.
	wipeRect _ delta x = 0
		ifTrue:
		[delta y = 0 ifTrue: [nSteps _ 1. bb "allow 0@0"] ifFalse: [
		nSteps _ bb height//delta y abs + 1.  "Vertical movement"
		delta y > 0
			ifTrue: [bb topLeft extent: bb width@delta y]
			ifFalse: [bb bottomLeft+delta extent: bb width@delta y negated]]]
		ifFalse:
		[nSteps _ bb width//delta x abs + 1.  "Horizontal movement"
		delta x > 0
			ifTrue: [bb topLeft extent: delta x@bb height]
			ifFalse: [bb topRight+delta extent: delta x negated@bb height]].
	^ self wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex:
		[:i | i <= nSteps
			ifTrue: [wipeRect translatedBy: (delta* (i-1))]
			ifFalse: [nil]]! !


!FormCanvas methodsFor: 'accessing' stamp: 'jmv 8/17/2012 18:49'!
clipRect
	"Return the currently active clipping rectangle"
	^ clipRect translatedBy: origin negated! !

!FormCanvas methodsFor: 'copying' stamp: 'jmv 8/17/2012 18:49'!
copyClipRect: aRectangle
	^ self copyOrigin: origin clipRect: (aRectangle translatedBy: origin)
! !

!FormCanvas methodsFor: 'drawing-ovals' stamp: 'jmv 8/17/2012 18:49'!
fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	"draw the border of the oval"
	rect _ (r translatedBy: origin) truncated.
	(borderWidth = 0 or: [borderColor isTransparent]) ifFalse:[
		self setPaintColor: borderColor.
		port frameOval: rect borderWidth: borderWidth].
	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillOval: (rect insetBy: borderWidth)].
! !

!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/17/2012 18:50'!
frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor
	| rect |
	rect _ r translatedBy: origin.
	"draw the border of the rectangle"
	borderColor isTransparent ifFalse:[
		self setPaintColor: borderColor.
		port frameRect: rect borderWidth: borderWidth ].

	"fill the inside"
	fillColor isTransparent ifFalse: [
		self setPaintColor: fillColor.
		port fillRect: (rect insetBy: borderWidth) offset: origin ]! !

!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 8/17/2012 18:50'!
frameRectangle: r borderWidth: borderWidth color: borderColor
	"
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red
	"
	| rect |
	rect _ r translatedBy: origin.
	self setPaintColor: borderColor.
	port
		frameRect: rect
		borderWidth: borderWidth.! !

!FormCanvas methodsFor: 'private' stamp: 'jmv 8/17/2012 18:50'!
fillRectangle: aRectangle tilingWith: aForm sourceRect: patternBox rule: aCombinationRule
	"We assume that aForm is part of an InfiniteForm"
	| additionalOffset rInPortTerms clippedPort targetTopLeft clipOffset ex 
	targetBox savedMap top left |

	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.
	something better is needed, but not now"

	ex _ patternBox extent.
	additionalOffset _ 0@0.
	rInPortTerms _ aRectangle translatedBy: origin.
	clippedPort _ port clippedBy: rInPortTerms.
	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.
	clipOffset _ rInPortTerms topLeft - targetTopLeft.
	additionalOffset _ (clipOffset \\ ex) - ex.

	"do it iteratively"
	targetBox _ clippedPort clipRect.
	savedMap _ clippedPort colorMap.
	clippedPort sourceForm: aForm;
		fillColor: nil;
		combinationRule: aCombinationRule;
		sourceRect: patternBox;
		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).
	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.
	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.

	left to: (targetBox right - 1) by: patternBox width do: [:x |
		top to: (targetBox bottom - 1) by: patternBox height do: [:y |
			clippedPort destOrigin: x@y; copyBits]].
	clippedPort colorMap: savedMap! !

!FormCanvas methodsFor: 'private' stamp: 'jmv 8/17/2012 18:50'!
frameRectangle: r borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor
	"
	Display getCanvas
		frameRectangle: (10@10 extent: 300@200)
		borderWidth: 20
		topLeftColor: Color green
		bottomRightColor: Color red
	Display getCanvas fillRectangle: (10@10 extent: 300@200) color: Color white
	"
	| rect w h |
	self setPaintColor: topLeftColor.
	rect _ r translatedBy: origin.

	port frameRectTopLeft: rect borderWidth: borderWidth.

	borderWidth isNumber
		ifTrue: [w _ h _ borderWidth]
		ifFalse: [w _ borderWidth x.   h _ borderWidth y].
	self setPaintColor: bottomRightColor.
	port 
		 frameRectRight: rect width: w;
		 frameRectBottom: rect height: h! !


!Morph methodsFor: 'events-processing' stamp: 'jmv 8/17/2012 15:51'!
rejectsEvent: anEvent
	"Return true to reject the given event. Rejecting an event means neither the receiver nor any of it's submorphs will be given any chance to handle it."

	^ self isLocked or: [ self visible not ]! !

!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 8/17/2012 16:21'!
transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(formerHaloOwner ~~ self) 
			ifTrue: [ ^self addHalo: event from: formerHaloOwner ]].

	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		^self dispatchEvent: event copy resetHandlerFields.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: event eventPosition) 
			ifTrue: [ ^m transferHalo: event from: formerHaloOwner ].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w dispatchEvent: event copy resetHandlerFields! !


!HandMorph methodsFor: 'drawing' stamp: 'jmv 8/17/2012 18:50'!
savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| ownBnds fullBnds bw |
	ownBnds _ self morphBoundsInWorld.
	fullBnds _ self morphFullBoundsInWorld.
	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: (fullBnds translatedBy: aCanvas origin)
		into: savedPatch.
	savedPatch offset: fullBnds topLeft.
	Preferences fastDragWindowForMorphic ifTrue: [
		bw _ HandMorph fastDragBorderWidth.
		aStream nextPut: ownBnds.
		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].
		(fullBnds areasOutside: (fullBnds insetBy: bw)) do: [ :r |
			aStream nextPut: r ].
		prevFullBounds ifNotNil: [
			(prevFullBounds areasOutside: (prevFullBounds insetBy: bw)) do: [ :r |
				aStream nextPut: r ]]]
	ifFalse: [
		prevFullBounds ifNil: [
			aStream nextPut: fullBnds ]
		ifNotNil: [
			aStream nextPut: (fullBnds merge: prevFullBounds)]].
	prevBounds _ ownBnds.
	prevFullBounds _ fullBnds! !

!HandMorph methodsFor: 'paste buffer' stamp: 'jmv 8/17/2012 18:54'!
pasteMorph

	| pastee |
	pastee _ Clipboard retrieveMorph.
	pastee ifNil: [^ self inform: 'Nothing to paste.'].
	self attachMorph: pastee.
	pastee aligned: pastee referencePosition with: self morphPosition
! !

!HandMorph methodsFor: 'private events' stamp: 'jmv 8/17/2012 15:58'!
sendEvent: anEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	^owner dispatchEvent: anEvent! !


!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 8/17/2012 18:51'!
drawToggleOn: aCanvas in: aRectangle

	| aForm centeringOffset |
	complexContents hasContents ifFalse: [^self].
	aForm _ isExpanded 
		ifTrue: [container expandedForm]
		ifFalse: [container notExpandedForm].
	centeringOffset _ ((aRectangle height - aForm extent y) / 2.0) rounded.
	^aCanvas 
		image: aForm 
		at: (aRectangle topLeft translatedBy: 0 @ centeringOffset).
! !


!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 8/17/2012 18:51'!
debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"
	| tl |
	tl _ self morphPositionInWorld.
	self paragraph lines do: [ :line |
		aCanvas
			frameRectangle: (line rectangle translatedBy: tl)
			borderWidth: 1
			color: Color brown ]
! !

!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43'!
clickAndHalf: evt
	self handleInteraction: [
		editor clickAndHalf: (evt ztranslatedBy: self morphPositionInWorld negated) ].
	owner scrollSelectionIntoView! !

!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43'!
doubleClickAndHalf: evt
	self handleInteraction: [
		editor doubleClickAndHalf: (evt ztranslatedBy: self morphPositionInWorld negated) ].
	owner scrollSelectionIntoView! !

!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43'!
mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^event hand newKeyboardFocus: self].

	super mouseDown: event.

	self handleInteraction: [editor mouseDown: (event ztranslatedBy: self morphPositionInWorld negated)].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:
		tripleClkSel: nil! !

!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43'!
mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt ztranslatedBy: self morphPositionInWorld negated)].
	(evt eventPosition y - owner morphPositionInWorld y between: 0 and: owner morphExtentInWorld y) ifFalse: [
		owner scrollSelectionIntoView ]! !

!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 8/17/2012 18:43'!
mouseUp: evt
	super mouseUp: evt.
	self pauseBlinking.
	self handleInteraction: [editor mouseUp: (evt ztranslatedBy: self morphPositionInWorld negated)].
	owner scrollSelectionIntoView! !

!InnerTextMorph methodsFor: 'selection' stamp: 'jmv 8/17/2012 18:51'!
selectionRects
	"Paragraph assumes its topLeft is 0@0. We don't"
	| tl |
	tl _ self morphPositionInWorld.
	^self paragraph selectionRects collect: [ :r | r translatedBy: tl ]! !


!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 8/17/2012 18:52'!
sourceRectFrom: aPoint
	^ (aPoint extent: srcExtent) translatedBy: (srcExtent // -2) + 1.
! !


!MenuMorph methodsFor: 'events' stamp: 'jmv 8/17/2012 15:58'!
handleFocusEvent: evt
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	self dispatchEvent: evt.

	"Need to handle keyboard input if we have the focus."
	evt isKeyboard ifTrue: [^ self handleEvent: evt].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(evt isMouseOver or:[evt isMouse not]) ifTrue:[^self].
	"What remains are mouse buttons and moves"
	evt isMove ifFalse:[^self handleEvent: evt]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: evt) ifTrue:[^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: evt) ifTrue:[^self]].! !


!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 8/17/2012 18:52'!
flashRects: rectangleList
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."
	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."

	| blt screenRect |
	blt _ (BitBlt current toForm: Display)
		sourceForm: nil;
		sourceOrigin: 0@0;
		clipRect: self viewBox;
		combinationRule: Form reverse.
	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect; forceDisplayUpdate.
		(Delay forMilliseconds: 250) wait.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect; forceDisplayUpdate].
! !


!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 8/17/2012 18:54'!
defaultAction

	| delta textFrame barFrame outerFrame result range width w1 f h textWidth textForm innerBarFrame |
	f _ StrikeFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.
	
	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
			
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ 0@0 extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + (0@2).
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal 
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [		
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		w1 _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		textForm displayAt: textFrame topLeft.
		Display fillBlack: barFrame.
		Display fillWhite: innerBarFrame.
		Display fillGray: (barFrame topLeft + (2@2) extent: w1@17) ].
	World fullRepaintNeeded.
	self resume: result! !


!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2012 18:54'!
openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self morphBoundsInWorld: (0@0 extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	self aligned: self morphBoundsInWorld center with: Display boundingBox center.
	aWorld startSteppingSubmorphsOf: self.! !


!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 8/17/2012 18:55'!
strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 
	"This method implements a staggered window placement policy that I (di) like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible."

	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |
	allowedArea := (self maximumUsableAreaInWorld: aWorld) 
				insetBy: (self scrollBarSetback @ self screenTopSetback extent: 0 @ 0).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame := 0 @ 0 extent: initialExtent.
	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400"
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not]) 
						collect: [:w | w morphBoundsInWorld].
	0 to: maxLevel
		do: 
			[:level | 
			1 to: 4
				do: [:ci | 
					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.
					corner := allowedArea perform: cornerSel.
					"The extra grid//2 in delta helps to keep title tabs distinct"
					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).
					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"
					putativeCorner := corner + delta.
					free := true.
					otherFrames 
						do: [:w | free := free & ((w perform: cornerSel) ~= putativeCorner)].
					free 
						ifTrue: 
							[^(initialFrame aligned: (initialFrame perform: cornerSel)
								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].
	"If all else fails..."
	^(self scrollBarSetback @ self screenTopSetback 
		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !


!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 8/17/2012 18:55'!
translatedToBeWithin: aRectangle
	"Answer a copy of the receiver that does not extend beyond aRectangle.  7/8/96 sw"

	^ self translatedBy: (self amountToTranslateWithin: aRectangle)! !

!Rectangle methodsFor: 'transforming' stamp: 'jmv 8/17/2012 15:30'!
newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor anyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor anyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ World activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent.
	^ rect! !


!Sonogram methodsFor: 'all' stamp: 'jmv 8/17/2012 18:56'!
plotColumn: dataArray

	| chm1 i normVal r |
	columnForm unhibernate.
	chm1 _ columnForm height - 1.
	0 to: chm1 do: [ :y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self invalidRect: (r translatedBy: self morphPosition)! !


!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 8/17/2012 18:56'!
scrollSelectionIntoView
	"Scroll my text into view if necessary and return true, else return false"

	| rectToTest |
	rectToTest _ self editor pointBlock translatedBy: self textMorph morphPositionInWorld.
	self scrollToShow: rectToTest! !


!UserInputEvent methodsFor: 'initialize' stamp: 'jmv 8/17/2012 16:48'!
resetHandlerFields
	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"
	self flag: #jmvVer. "All this stuff of copying events to reset this data is pretty ugly."
	wasHandled _ false.! !


!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isKeyDown
	^ type == #keyDown! !

!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isKeyUp
	^ type == #keyUp! !

!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isKeystroke
	^ type == #keystroke! !


!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isMouseDown
	^ type == #mouseDown! !

!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isMouseEnter
	^ type == #mouseEnter! !

!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isMouseLeave
	^ type == #mouseLeave! !

!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isMouseMove
	^ type == #mouseMove! !

!MouseEvent methodsFor: 'testing' stamp: 'jmv 8/17/2012 16:44'!
isMouseUp
	^ type == #mouseUp! !


!WarpBlt class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:57'!
test12   "Display restoreAfter: [WarpBlt test12]"
	"Just like test1, but comparing smooth to non-smooth warps"
	| warp pts r1 p0 p ext warp2 |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 _ Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 _ Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp _ (self toForm: Display)
		cellSize: 2;  "installs a colormap"
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	warp2 _ (self toForm: Display)
		clipRect: ((0@0 extent: r1 extent*5) translatedBy: 250@0);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor mousePoint.
		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].
		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).
		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translatedBy: 250@0).
		]! !

!WarpBlt class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:57'!
test5   "Display restoreAfter: [WarpBlt test5]"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 _ Rectangle fromUser.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 _ Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp _ (self toForm: Display)
		cellSize: 1;
		sourceForm: Display;
		cellSize: 2;  "installs a colormap"
		combinationRule: Form over.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor mousePoint.
		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].
		warp copyQuad: pts toRect: (r1 translatedBy: r1 width@0)]! !

!WarpBlt class methodsFor: 'form rotation' stamp: 'jmv 8/17/2012 19:11'!
rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize
	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."

	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |
	srcRect _ srcForm boundingBox.
	center _ srcRect center.
	radians _ angleInDegrees degreesToRadians.
	dstOrigin _ dstCorner _ center.
	srcRect corners do: [:corner |
		"find the limits of a rectangle that just encloses the rotated
		 original; in general, this rectangle will be larger than the
		 original (e.g., consider a square rotated by 45 degrees)"
		p _ ((corner - center) scaledBy: scalePoint) + center.
		p _ (p inverseRotateBy: radians about: center) rounded.
		dstOrigin _ dstOrigin min: p.
		dstCorner _ dstCorner max: p].

	"rotate the enclosing rectangle back to get the source quadrilateral"
	dstRect _ dstOrigin corner: dstCorner.
	inverseScale _ (1.0 / scalePoint x)@(1.0 / scalePoint y).
	quad _ dstRect innerCorners collect: [:corner |
		p _ corner inverseRotateBy: radians negated about: center.
		((p - center) scaledBy: inverseScale) + center].

	"make a Form to hold the result and do the rotation"
	warpSrc _ srcForm.
	(srcForm is: #ColorForm)
		ifTrue: [
			cellSize > 1 | true "ar 12/27/2001: Always enable - else sketches won't work"
				ifTrue: [
					warpSrc _ Form extent: srcForm extent depth: 16.
					srcForm displayOn: warpSrc.
					dstForm _ Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"
				ifFalse: [
					dstForm _ srcForm class extent: dstRect extent depth: srcForm depth]]
		ifFalse: [
			dstForm _ srcForm class extent: dstRect extent depth: srcForm depth].

	(WarpBlt toForm: dstForm)
		sourceForm: warpSrc;
		colorMap: (warpSrc colormapIfNeededFor: dstForm);
		cellSize: cellSize;  "installs a new colormap if cellSize > 1"
		combinationRule: Form paint;
		copyQuad: quad toRect: dstForm boundingBox.

	(dstForm is: #ColorForm) ifTrue: [ dstForm colors: srcForm colors copy ].
	newCenter _ (center inverseRotateBy: radians about: aPoint) truncated.
	^ Array with: dstForm with: dstRect origin + (newCenter - center)
! !

!methodRemoval: MouseMoveEvent #translateBy:!
MouseMoveEvent removeSelector: #translateBy:!
!classDefinition: #MouseButtonEvent category: #'Morphic-Events'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!methodRemoval: UserInputEvent #handler!
UserInputEvent removeSelector: #handler!
!methodRemoval: UserInputEvent #handler:!
UserInputEvent removeSelector: #handler:!
!methodRemoval: UserInputEvent #translateBy:!
UserInputEvent removeSelector: #translateBy:!
!methodRemoval: UserInputEvent #translatedBy:!
UserInputEvent removeSelector: #translatedBy:!
!classDefinition: #UserInputEvent category: #'Morphic-Events'!
MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'type buttons position wasHandled'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!methodRemoval: Rectangle #align:with:!
Rectangle removeSelector: #align:with:!
!methodRemoval: Rectangle #flipBy:centerAt:!
Rectangle removeSelector: #flipBy:centerAt:!
!methodRemoval: Rectangle #scaleBy:!
Rectangle removeSelector: #scaleBy:!
!methodRemoval: Rectangle #translateBy:!
Rectangle removeSelector: #translateBy:!
!methodRemoval: Point #scaleBy:!
Point removeSelector: #scaleBy:!
!methodRemoval: Point #translateBy:!
Point removeSelector: #translateBy:!
!methodRemoval: PasteUpMorph #processEvent:using:!
PasteUpMorph removeSelector: #processEvent:using:!

!HaloMorph class reorganize!
('class initialization' initialize)
('accessing - icons' haloCollapseIcon haloColorIcon haloDebugIcon haloDismissIcon haloDragIcon haloDuplicateIcon haloFontEmphasisIcon haloFontSizeIcon haloGrabIcon haloHelpIcon haloMenuIcon haloRotateIcon haloScaleIcon)
('instance protocol testing' gatherProtocols)
!

!methodRemoval: HaloMorph #handlerForMouseButton3Down:!
HaloMorph removeSelector: #handlerForMouseButton3Down:!
!methodRemoval: HaloMorph #isHandlerForMouseButton3Down:!
HaloMorph removeSelector: #isHandlerForMouseButton3Down:!
!methodRemoval: Morph #align:with:!
Morph removeSelector: #align:with:!
!methodRemoval: Morph #defaultEventDispatcher!
Morph removeSelector: #defaultEventDispatcher!
!methodRemoval: Morph #handlerForMouseButton3Down:!
Morph removeSelector: #handlerForMouseButton3Down:!
!methodRemoval: Morph #handlerForMouseDown:!
Morph removeSelector: #handlerForMouseDown:!
!methodRemoval: Morph #is:!
Morph removeSelector: #is:!
!methodRemoval: Morph #isHandlerForMouseButton3Down:!
Morph removeSelector: #isHandlerForMouseButton3Down:!
!methodRemoval: Morph #mouseDownPriority!
Morph removeSelector: #mouseDownPriority!
!methodRemoval: Morph #processEvent:!
Morph removeSelector: #processEvent:!
!methodRemoval: Morph #processEvent:using:!
Morph removeSelector: #processEvent:using:!
!methodRemoval: Morph #wantsHaloFromClick!
Morph removeSelector: #wantsHaloFromClick!
!methodRemoval: ColorForm #flipBy:centerAt:!
ColorForm removeSelector: #flipBy:centerAt:!
!methodRemoval: Form #flipBy:centerAt:!
Form removeSelector: #flipBy:centerAt:!
!methodRemoval: EventSensor #processEvent:!
EventSensor removeSelector: #processEvent:!
!methodRemoval: EventSensor #processKeyboardEvent:!
EventSensor removeSelector: #processKeyboardEvent:!
!methodRemoval: EventSensor #processMouseEvent:!
EventSensor removeSelector: #processMouseEvent:!
!methodRemoval: DisplayObject class #writeCollection:onFileNamed:!
DisplayObject class removeSelector: #writeCollection:onFileNamed:!
!methodRemoval: DisplayObject #align:with:!
DisplayObject removeSelector: #align:with:!
!methodRemoval: DisplayObject #displayOnPort:!
DisplayObject removeSelector: #displayOnPort:!
!methodRemoval: DisplayObject #followCursor!
DisplayObject removeSelector: #followCursor!
!methodRemoval: DisplayObject #relativeRectangle!
DisplayObject removeSelector: #relativeRectangle!
!methodRemoval: DisplayObject #scaleBy:!
DisplayObject removeSelector: #scaleBy:!
!methodRemoval: DisplayObject #translateBy:!
DisplayObject removeSelector: #translateBy:!
!methodRemoval: DisplayObject #translatedBy:!
DisplayObject removeSelector: #translatedBy:!

!DisplayObject reorganize!
('accessing' extent height offset offset: width)
('truncation and round off' rounded)
('display box access' boundingBox center computeBoundingBox)
('displaying-generic' displayAt: displayOn: displayOn:at: displayOn:at:clippingBox: displayOn:at:clippingBox:rule:fillColor: displayOn:at:rule: displayOnPort:at:rule:)
('displaying-Display' display follow:while: follow:while:bitsBehind:startingLoc: slideFrom:to:nSteps: slideFrom:to:nSteps:delay: slideFrom:to:nSteps:delay:andStay: slideWithFirstFrom:to:nSteps:delay:)
('fileIn/Out' writeOnFileNamed: writeUncompressedOnFileNamed:)
!

!classRemoval: #MorphicEventDispatcher!
Smalltalk removeClassNamed: #MorphicEventDispatcher!
