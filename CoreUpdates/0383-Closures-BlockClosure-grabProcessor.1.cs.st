'From Cuis 1.0 of 28 November 2009 [latest update: #337] on 30 December 2009 at 1:23:24 pm'!!BlockClosure methodsFor: 'private' stamp: 'jmv 12/30/2009 13:22'!grabProcessor	"Grab the CPU above most application processes and evaluate.	Return to usual proprity after that."	^self grabProcessorFor: nil onTimeout: nil! !!BlockClosure methodsFor: 'private' stamp: 'jmv 12/30/2009 13:22'!grabProcessorFor: milliseconds onTimeout: timeoutBlock	"Evaluate the receiver (block), without the possibility of preemption by regular priority processes.	If not finished after milliseconds, restore original priority and evaluate timeoutBlock.	Use with care!!"	"Based on #valueUnpreemptively"		| activeProcess oldPriority result done |	activeProcess _ Processor activeProcess.	oldPriority _ activeProcess priority.	done _ false.		activeProcess priority: Processor highIOPriority + Processor lowIOPriority // 2.	milliseconds notNil ifTrue: [		[			(Delay forMilliseconds: milliseconds) wait.			done ifFalse: [				activeProcess					suspend;					priority: oldPriority;					resume.				timeoutBlock value ]		] forkAt: Processor highIOPriority ].	result _ self ensure: [		done _ true.		activeProcess priority: oldPriority].		"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!BlockClosure methodsFor: 'private' stamp: 'jmv 12/30/2009 13:22'!grabProcessorOnlyFor: milliseconds	"Grab the CPU above most application processes and evaluate, but only for some milliseconds.	Return to usual prority after that and finish evaluation if incomplete."	^self grabProcessorFor: milliseconds onTimeout: []! !