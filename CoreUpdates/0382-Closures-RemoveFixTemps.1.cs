'From Cuis 1.0 of 28 November 2009 [latest update: #337] on 30 December 2009 at 11:50:50 am'!!FileList2 methodsFor: 'initialize-release' stamp: 'jmv 12/30/2009 11:24'!initialize	showDirsInFileList _ false.	fileSelectionBlock _ [ :entry :myPattern |		entry isDirectory ifTrue: [			showDirsInFileList		] ifFalse: [			myPattern = '*' or: [myPattern match: entry name]		]	].	dirSelectionBlock _ [ :dirName | true].! !!FileList2 class methodsFor: 'morphic ui' stamp: 'jmv 12/30/2009 11:25'!morphicViewFileSelectorForSuffixes: aList 	"Answer a morphic file-selector tool for the given suffix list"	| dir aFileList window fixedSize midLine gap |	dir := FileDirectory default.	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList okayAndCancelServices.	aList ifNotNil: 			[aFileList 				fileSelectionBlock: 					[:entry :myPattern | 					entry isDirectory 						ifTrue: [false]						ifFalse: [							aList includes: (FileDirectory extensionFor: entry name asLowercase)]] 							].	window := AlignmentMorph proportional				color: Color lightBlue;				borderColor: Color blue;				extent: 600 @ 400.	window setProperty: #fileListModel toValue: aFileList.	aFileList modalView: window.	midLine := 0.4.	fixedSize := 25.	gap := 5.	self addFullPanesTo: window		from: {				{ 					self textRow: 'Please select a file' translated.					0 @ 0 corner: 1 @ 0.					0 @ 4 corner: 0 @ fixedSize}.				{ 					aFileList optionalButtonRow.					0 @ 0 corner: 1 @ 0.					0 @ fixedSize corner: 0 @ (fixedSize * 2)}.				{ 					aFileList morphicDirectoryTreePane.					0 @ 0 corner: midLine @ 1.					gap @ (fixedSize * 2) corner: gap negated @ 0}.				{ 					aFileList morphicFileListPane.					midLine @ 0 corner: 1 @ 1.					gap @ (fixedSize * 2) corner: gap negated @ 0}}.	aFileList postOpen.	^window! !!Heap methodsFor: 'accessing' stamp: 'jmv 12/30/2009 11:25'!sortBlock: aBlock	sortBlock _ aBlock.	self reSort! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'jmv 12/30/2009 11:25'!limitingBlock: aBlock	"The limitingBlock is evaluated with a line to check if this line terminates the stream"	limitingBlock _ aBlock.	self updatePosition! !!PluggableDictionary methodsFor: 'accessing' stamp: 'jmv 12/30/2009 11:27'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ PluggableSet new: self size.	self equalBlock ifNotNil: [ aSet equalBlock: self equalBlock ].	self hashBlock ifNotNil: [ aSet hashBlock: self hashBlock ].	self keysDo: [ :key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'copying' stamp: 'jmv 12/30/2009 11:32'!postCopyBlocks	"I believe this should not be needed anymore with BlockClosures"	"	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy	"! !!PluggableSet methodsFor: 'copying' stamp: 'jmv 12/30/2009 11:33'!postCopyBlocks	"I believe this should not be needed anymore with BlockClosures"	"	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy	"! !!ScorePlayer methodsFor: 'volume' stamp: 'jmv 12/30/2009 11:33'!adjustVolumeTo: vol overMSecs: mSecs	| normalizedVolume incr block |	normalizedVolume _ (vol asFloat min: 1.0) max: 0.0.	incr _ (self overallVolume - normalizedVolume) / mSecs * 50.0.	block _ normalizedVolume > 0.0		ifTrue: [			[[(normalizedVolume - self overallVolume) abs > 0.01] whileTrue: [self overallVolume: self overallVolume - incr. (Delay forMilliseconds: 50) wait]]]		ifFalse: [			[[self overallVolume > 0.0] whileTrue: [self overallVolume: self overallVolume - incr. (Delay forMilliseconds: 50) wait]. self pause]].	block fork! !!SelectionMorph methodsFor: 'drag and drop' stamp: 'jmv 12/30/2009 11:33'!justDroppedInto: newOwner event: evt	selectedItems isEmpty ifTrue:		["Hand just clicked down to draw out a new selection"		^ self extendByHand: evt hand].	dupLoc ifNotNil: [dupDelta _ self position - dupLoc].	selectedItems reverseDo: [:m | 		WorldState addDeferredUIMessage:			[m referencePosition: (newOwner localPointToGlobal: m referencePosition).			newOwner handleDropMorph:				(DropEvent new setPosition: evt cursorPoint contents: m hand: evt hand)]].	selectedItems _ nil.	self removeHalo; delete.	evt wasHandled: true! !!SortedCollection methodsFor: 'accessing' stamp: 'jmv 12/30/2009 11:36'!sortBlock: aBlock 	"Make the argument, aBlock, be the criterion for ordering elements of the 	receiver."	sortBlock _ aBlock.	self size > 0 ifTrue: [ self reSort ]! !!Switch methodsFor: 'action' stamp: 'jmv 12/30/2009 11:37'!offAction: anAction 	"Set the off action of the receiver to anAction."	offAction _ anAction! !!Switch methodsFor: 'action' stamp: 'jmv 12/30/2009 11:37'!onAction: anAction 	"Set the on action of the receiver to anAction."	onAction _ anAction! !!TextDiffBuilder methodsFor: 'private' stamp: 'jmv 12/30/2009 11:37'!pointEqualBlock	^[ :a :b | a x = b x and: [a y = b y]]! !!TextDiffBuilder methodsFor: 'private' stamp: 'jmv 12/30/2009 11:37'!pointHashBlock	^[:pt| (pt x bitShift: 12) + pt y]! !!TextDiffBuilder methodsFor: 'private' stamp: 'jmv 12/30/2009 11:37'!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize _ string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[ stringSize < 3 				ifTrue:[(string at: 1) asInteger +						((string at: string size) asInteger bitShift: 8)]				ifFalse:[	(string at: 1) asInteger +						((string at: stringSize // 3 + 1) asInteger bitShift: 4) +						((string at: stringSize // 2 + 1) asInteger bitShift: 8) +						((string at: stringSize * 2 // 3 + 1) asInteger bitShift: 12) +						((string at: stringSize) asInteger bitShift: 16)]]]! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'jmv 12/30/2009 11:37'!openMenuIn: aBlock 	| alternatives labels actions lines caption choice |	alternatives := parser possibleVariablesFor: name.	labels := OrderedCollection new.	actions := OrderedCollection new.	lines := OrderedCollection new.	name first isLowercase 		ifTrue: 			[labels add: 'declare temp'.			actions add: [parser declareTempAndPaste: name].			labels add: 'declare instance'.			actions add: [parser declareInstVar: name]]		ifFalse: 			[labels add: 'define new class'.			actions add: [parser defineClass: name].			labels add: 'declare global'.			actions add: [parser declareGlobal: name].			parser canDeclareClassVariable 				ifTrue: 					[labels add: 'declare class variable'.					actions add: [parser declareClassVar: name]]].	lines add: labels size.	alternatives do: 		[:each | 		labels add: each.		actions add: [parser substituteVariable: each atInterval: interval]].	lines add: labels size.	labels add: 'cancel'.	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !BlockContext removeSelector: #fixTemps!BlockClosure removeSelector: #fixTemps!