'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 1 March 2011 at 5:31:18 pm'!!classDefinition: #MenuMorph category: #'Morphic-Menus'!BorderedMorph subclass: #MenuMorph	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph '	classVariableNames: 'CloseIcon PushPinIcon '	poolDictionaries: ''	category: 'Morphic-Menus'!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector isPressed mouseIsOver icon magnifiedIcon '	classVariableNames: 'ButtonGradient ButtonGradientPressed RoundedCornerBL RoundedCornerBLPressed RoundedCornerBR RoundedCornerBRPressed RoundedCornerTL RoundedCornerTLPressed RoundedCornerTR RoundedCornerTRPressed '	poolDictionaries: ''	category: 'Morphic-Windows'!!CodeProvider methodsFor: 'controls' stamp: 'jmv 3/1/2011 16:50'!decorateForInheritance	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."	| aColor aButton flags buttonColor |	(aButton _ self inheritanceButton) ifNil: [^ self].	((currentCompiledMethod isKindOf: CompiledMethod) and: [Preferences decorateBrowserButtons])		ifFalse: [ ^aButton color: self class windowColor ].	"This table duplicates the old logic, but adds two new colors for the cases where there is a superclass definition, but this method doesn't call it."	flags _ 0.	self isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].	currentCompiledMethod sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].	self isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].	buttonColor _ Theme current buttonColorFrom: self class windowColor.	aColor _ {		"This is NOTan override. There is no super implementation."		buttonColor.							"no sends to super. there is not override in any subclass"		Color tan.							"no sends to super. there is an override in some subclass"		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"		"This is an override. There is some super implementation"		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"		Color green muchLighter.			"doesn't have sub; has super and callsl it"		Color blue muchLighter.			"has sub; has super and callsl it"	} at: flags + 1.	aButton color: aColor! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 3/1/2011 16:38'!lineDiffButton	"Return a checkbox that lets the user decide whether regular diffs should be shown or not"	^ (PluggableButtonMorph		model: self		stateGetter: #showingLineDiffs		action: #toggleLineDiffing)			label: 'lineDiffs';			 setBalloonText: 'Show code differences from the previous version, line by line.'! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 3/1/2011 16:39'!prettyLineDiffButton	"Return a checkbox that lets the user decide whether prettyDiffs should be shown or not"	| button |	button _ PluggableButtonMorph		model: self		stateGetter: #showingPrettyLineDiffs		action: #togglePrettyLineDiffing.	button label: 'linePrettyDiffs'.	(self isKindOf: VersionsBrowser)		ifTrue: [ button setBalloonText: 'Show pretty-printed code differences from the previous version, line by line.' ]		ifFalse: [ button setBalloonText: 'Show pretty-printed code differences between the file-based method and the in-memory version, line by line.' ].	^button! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 3/1/2011 16:40'!prettyWordDiffButton	"Return a checkbox that lets the user decide whether prettyDiffs should be shown or not"	| button |	button _ PluggableButtonMorph		model: self		stateGetter: #showingPrettyWordDiffs		action: #togglePrettyWordDiffing.	button label: 'wordPrettyDiffs'.	(self isKindOf: VersionsBrowser)		ifTrue: [ button setBalloonText: 'Show pretty-printed code differences from the previous version, word by word.' ]		ifFalse: [ button setBalloonText: 'Show pretty-printed code differences between the file-based method and the in-memory version, word by word.' ].	^button! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 3/1/2011 16:41'!wordDiffButton	"Return a checkbox that lets the user decide whether regular diffs should be shown or not"	^ (PluggableButtonMorph		model: self		stateGetter: #showingWordDiffs		action: #toggleWordDiffing)			label: 'lineDiffs';			 setBalloonText: 'Show code differences from the previous version, word by word.'! !!MenuMorph methodsFor: 'construction' stamp: 'jmv 3/1/2011 16:25'!addStayUpIcons	| closeBox pinBox w |	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])		ifTrue: [		 	self removeProperty: #needsStayUpIcons.			^self ].	titleMorph ifNil: [		"Title not yet there. Flag ourself, so this method is called again when adding title."		self setProperty: #needsStayUpIcons toValue: true.		^ self].	closeBox _ PluggableButtonMorph model: self action: #delete.	closeBox icon: SystemWindow closeIcon.	pinBox _ PluggableButtonMorph model: self action: #stayUp.	pinBox icon: self class pushPinIcon.	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph width ] ifFalse: [ 0 ]) + 42.	self addMorphFront: 		(LayoutMorph newRow			height: (titleMorph height max: 19);			width: w;	"Make room for buttons"			color: Color transparent;			addMorph: closeBox fixedWidth: 20;			addMorph: titleMorph proportionalWidth: 1;			addMorph: pinBox fixedWidth: 20).	self setProperty: #hasStayUpIcons toValue: true.	self removeProperty: #needsStayUpIcons! !!MenuMorph methodsFor: 'menu' stamp: 'jmv 3/1/2011 16:27'!removeStayUpBox	| box |	submorphs isEmpty ifTrue: [^self].	(submorphs first is: #LayoutMorph) ifFalse: [^self].	box _ submorphs first submorphs first.	(box isKindOf: PluggableButtonMorph) 		ifTrue: [ box hide ]! !!MenuMorph class methodsFor: 'as yet unclassified' stamp: 'jmv 3/1/2011 16:27'!initialize	PushPinIcon _ nil! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 3/1/2011 17:22'!icon: aForm	icon _ aForm.	magnifiedIcon _ nil! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'jmv 3/1/2011 17:31'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model _ model.		Weakly copied""getStateSelector _ getStateSelector.		a Symbol""actionSelector _ actionSelector.		a Symbol""getLabelSelector _ getLabelSelector.		a Symbol""getMenuSelector _ getMenuSelector.		a Symbol"isPressed _ isPressed.mouseIsOver _ mouseIsOver.icon _ icon.magnifiedIcon _ magnifiedIcon! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/1/2011 16:17'!drawEmbossedLabelOn: aCanvas	| availableW center colorForLabel f l labelMargin targetSize w x y |	label ifNotNil: [		colorForLabel _ Theme current buttonLabel.		self isPressed			ifFalse: [				self mouseIsOver					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].		f _ self fontToUse.		center _ bounds center.		labelMargin _ 7.		w _ f widthOfString: label.		availableW _ bounds width-labelMargin-labelMargin.		availableW >= w			ifTrue: [				l _ label ]			ifFalse: [				x _ bounds left + labelMargin.				targetSize _ label size * availableW // w.				l _ label squeezedTo: targetSize.				(f widthOfString: l) > availableW ifTrue: [					targetSize _ targetSize - 1.					l _ label squeezedTo: targetSize ]].				w _ f widthOfString: l.		x _ center x - (w // 2).		y _ center y - (f height // 2).		aCanvas			drawStringEmbossed: l			in: (x@y extent: bounds extent - (labelMargin*2-2@4))			font: f			color: colorForLabel ]! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/1/2011 17:29'!drawInconOn: aCanvas	| f b |	f _ self isPressed		ifTrue: [ 0.75 ]		ifFalse: [			self mouseIsOver				ifTrue: [ 1.0 ]				ifFalse: [ 0.83 ]].	magnifiedIcon ifNil: [		b _ bounds extent x max: bounds extent y.		magnifiedIcon _ icon.		b < icon extent x ifTrue: [			magnifiedIcon _ icon magnifyTo: b@b ].		b /  icon extent x > 1.7			ifTrue: [					b _ b * 3 // 4.				magnifiedIcon _ icon magnifyTo: b @ b]].	aCanvas		image: magnifiedIcon		multipliedBy: Color white * f		at: bounds center - (magnifiedIcon extent //2)! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/1/2011 16:05'!drawOn: aCanvas	icon ifNotNil: [ ^self drawInconOn: aCanvas ].	Theme current roundButtons		ifTrue: [ self drawRoundGradientLookOn: aCanvas ]		ifFalse: [ self draw3DLookOn: aCanvas ]! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/1/2011 16:01'!drawRoundGradientLookOn: aCanvas	| r colorForButton rect colorForButtonGradient lh height left top width bottomLeftForm bottomRightForm gradientForm topLeftForm topRightForm |	rect _ bounds insetBy: 2@3.	self isPressed		ifFalse: [			self mouseIsOver				ifTrue: [						colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9.					Theme current useButtonGradient						ifTrue: [ colorForButtonGradient _ colorForButton * Theme current buttonGradientBottomFactor ]						ifFalse: [ colorForButtonGradient _ colorForButton * Theme current buttonGradientTopFactor ].					gradientForm _ self class buttonGradient.					topLeftForm _ self class roundedCornerTL.					topRightForm _ self class roundedCornerTR.					bottomLeftForm _ self class roundedCornerBL.					bottomRightForm _ self class roundedCornerBR ]				ifFalse: [					colorForButton _ color.					Theme current useButtonGradient						ifTrue: [ colorForButtonGradient _ colorForButton * Theme current buttonGradientBottomFactor ]						ifFalse: [ colorForButtonGradient _ colorForButton * Theme current buttonGradientTopFactor ].					gradientForm _ self class buttonGradient.					topLeftForm _ self class roundedCornerTL.					topRightForm _ self class roundedCornerTR.					bottomLeftForm _ self class roundedCornerBL.					bottomRightForm _ self class roundedCornerBR ]]		ifTrue: [			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1.			Theme current useButtonGradient				ifTrue: [ colorForButtonGradient _ colorForButton * Theme current buttonGradientTopFactor ]				ifFalse: [ colorForButtonGradient _ colorForButton * Theme current buttonGradientBottomFactor ].			gradientForm _ self class buttonGradientPressed.			topLeftForm _ self class roundedCornerTLPressed.			topRightForm _ self class roundedCornerTRPressed.			bottomLeftForm _ self class roundedCornerBLPressed.			bottomRightForm _ self class roundedCornerBRPressed ].	colorForButton ifNotNil: [		lh _ gradientForm form height.		r _ topLeftForm width.		left _ rect left + r.		top _ rect top.		width _ rect width - r-r.		height _ rect height -r min: lh.		aCanvas fillRectangle: (left@top extent: width@height)  infiniteForm: gradientForm multipliedBy: colorForButton.		aCanvas image: topLeftForm multipliedBy: colorForButton in: (rect topLeft extent: r@height).		aCanvas image: topRightForm multipliedBy: colorForButton in: (rect topRight - (r@0)extent: r@height).		aCanvas fillRectangle: (rect origin + (0@height) extent: rect width@(rect height-height-r)) fillStyle: colorForButtonGradient.		aCanvas image: bottomLeftForm multipliedBy: colorForButton at: rect bottomLeft - (0@r).		aCanvas image: bottomRightForm multipliedBy: colorForButton at: rect bottomRight - (r@r) .		aCanvas fillRectangle: (rect bottomLeft+(r@ r negated) corner:  rect bottomRight - (r@0) ) fillStyle: colorForButtonGradient ].				self drawEmbossedLabelOn: aCanvas! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 3/1/2011 16:05'!mouseUp: evt	isPressed _ false.	mouseIsOver _ false.	(self containsPoint: evt cursorPoint)		ifTrue: [ self performAction ].	self changed.! !!PluggableButtonMorph methodsFor: 'updating' stamp: 'jmv 3/1/2011 16:03'!update: aParameter "	getLabelSelector ifNotNil: [		aParameter == getLabelSelector ifTrue: [			self label: (model perform: getLabelSelector)]]."	self changed! !!PluggableButtonMorph methodsFor: 'testing' stamp: 'jmv 3/1/2011 17:28'!isOpaqueMorph	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)	but is not an opaque rectangle covering bounds MUST answer false to this message"	^false! !!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 3/1/2011 17:25'!extent: aPoint	super extent: aPoint.	magnifiedIcon _ nil.	self changed! !!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jmv 3/1/2011 15:00'!model: anObject action: actionSel	^ self new		model: anObject		stateGetter: nil		action: actionSel		label: nil! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/1/2011 15:03'!createCloseBox	^(PluggableButtonMorph		model: self action: #closeBoxHit)		extent: self boxExtent;		icon: self class closeIcon;		setBalloonText: 'close this window'! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/1/2011 15:04'!createCollapseBox	^(PluggableButtonMorph		model: self action: #collapseOrExpand)		extent: self boxExtent;		icon: self class collapseIcon;		setBalloonText: 'collapse this window'! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/1/2011 15:04'!createExpandBox	^(PluggableButtonMorph		model: self action: #expandBoxHit)		extent: self boxExtent;		icon: self class expandIcon;		setBalloonText: 'expand to full screen'! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/1/2011 15:04'!createMenuBox	^(PluggableButtonMorph		model: self action: #offerWindowMenu)		extent: self boxExtent;		icon: self class menuIcon;		setBalloonText: 'window menu'! !!Theme methodsFor: 'other options' stamp: 'jmv 3/1/2011 15:59'!useButtonGradient	^false! !!Theme class methodsFor: 'as yet unclassified' stamp: 'jmv 3/1/2011 16:42'!currentTheme: aTheme	CurrentTheme := aTheme new.	SHTextStylerST80 initialize.	World color: CurrentTheme background.	SystemWindow initialize.	PluggableButtonMorph initialize.	World restoreMorphicDisplay.		^ CurrentTheme! !SystemWindow removeSelector: #createBox!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font icon getStateSelector actionSelector isPressed mouseIsOver magnifiedIcon'	classVariableNames: 'ButtonGradient ButtonGradientPressed RoundedCornerBL RoundedCornerBLPressed RoundedCornerBR RoundedCornerBRPressed RoundedCornerTL RoundedCornerTLPressed RoundedCornerTR RoundedCornerTRPressed'	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableButtonMorph reorganize!('accessing' action: actionSelector adoptWidgetsColor: icon: label: label:font: performAction)('arguments')('copying' veryDeepFixupWith: veryDeepInner:)('drawing' clipsSubmorphs draw3DLookOn: drawEmbossedLabelOn: drawInconOn: drawOn: drawRoundGradientLookOn: fontToUse)('event handling' handlesMouseDown: handlesMouseOver: mouseDown: mouseEnter: mouseLeave: mouseUp:)('initialization' defaultBorderColor defaultBorderWidth defaultColor initialize)('initialize-release' model:stateGetter:action:label:)('updating' update:)('private' getModelState mouseButton2Activity)('testing' isOpaqueMorph isPressed mouseIsOver)('geometry' extent:)!MenuMorph class removeSelector: #closeIcon!MenuMorph initialize!!classDefinition: #MenuMorph category: #'Morphic-Menus'!BorderedMorph subclass: #MenuMorph	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph'	classVariableNames: 'PushPinIcon'	poolDictionaries: ''	category: 'Morphic-Menus'!Smalltalk removeClassNamed: #IconicButton!Smalltalk removeClassNamed: #SimpleButtonMorph!Smalltalk removeClassNamed: #ThreePhaseButtonMorph!Smalltalk removeClassNamed: #UpdatingThreePhaseButtonMorph!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."SystemWindow initialize.PluggableButtonMorph initialize.!