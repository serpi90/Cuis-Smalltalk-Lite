'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 18 April 2011 at 3:23:36 pm'!!classDefinition: #InspectorWindow category: #'Morphic-Tools'!SystemWindow subclass: #InspectorWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Tools'!!classDefinition: #ObjectExplorerWindow category: #'Morphic-Tools'!SystemWindow subclass: #ObjectExplorerWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Tools'!!Object methodsFor: 'user interface' stamp: 'jmv 4/17/2011 22:08'!explore	ObjectExplorerWindow		open: (ObjectExplorer new rootObject: self)		label: nil! !!Object methodsFor: 'tracing' stamp: 'jmv 4/17/2011 22:09'!explorePointers	ObjectExplorerWindow		open: (PointerExplorer new rootObject: self)		label: nil! !!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'jmv 4/17/2011 18:40'!scanFrom: aStream 	"File in methods from the stream, aStream."	| methodText |	[methodText _ aStream nextChunkText.	 methodText size > 0]		whileTrue:		[class compile: methodText classified: category			withStamp: changeStamp			notifying: nil]! !!ClassDescription methodsFor: 'compiling' stamp: 'jmv 4/17/2011 18:41'!compile: code classified: heading 	"Compile the argument, code, as source code in the context of the 	receiver and install the result in the receiver's method dictionary under 	the classification indicated by the second argument, heading. nil is to be 	notified if an error occurs. The argument code is either a string or an 	object that converts to a string or a PositionableStream on an object that 	converts to a string."	^self		compile: code		classified: heading		notifying: nil! !!Compiler methodsFor: 'private' stamp: 'jmv 4/17/2011 18:44'!interactive	"this version of the method is necessary to load code from MC else the interactive mode is one. 	This method is really bad since it links the compiler package with the Tools	one. The solution would be to have a real SyntaxError exception belonging to the 	compiler package and not a subclass of StringHolder - sd Nov 2005"	"the code submitted by PlusTools is ideally the one that should be used	interactive	      ^requestor ~~ nil "	^ requestor notNil! !!Inspector methodsFor: 'menu commands' stamp: 'jmv 4/17/2011 22:12'!exploreObjectPointers	self selection explorePointers! !!Inspector methodsFor: 'menu commands' stamp: 'jmv 4/17/2011 22:12'!fieldListMenu	"Arm the supplied menu with items for the field-list of the receiver"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpIcons.	aMenu addList: #(		('inspect (i)'						inspectSelection)		('explore (I)'					exploreSelection)).	self addCollectionItemsTo: aMenu.	aMenu addList: #(		-		('method refs to this inst var'		referencesToSelection)		('methods storing into this inst var'	defsOfSelection)		('objects pointing to this value'		objectReferencesToSelection)		('explore pointers'					exploreObjectPointers)		-		('browse full (b)'					browseMethodFull)		('browse hierarchy (h)'				classHierarchy)		('browse protocol (p)'				browseFullProtocol)		-		('inst var refs...'						browseInstVarRefs)		('inst var defs...'					browseInstVarDefs)		('class var refs...'					classVarRefs)		('class variables'					browseClassVariables)		('class refs (N)'						browseClassRefs)		-		('copy name (c)'					copyName)				('basic inspect'						inspectBasic)).	^ aMenu! !!Inspector class methodsFor: 'instance creation' stamp: 'jmv 4/17/2011 21:57'!openOn: anObject	^ self openOn: anObject withLabel: nil! !!Inspector class methodsFor: 'instance creation' stamp: 'jmv 4/17/2011 21:56'!openOn: anObject withLabel: label	InspectorWindow open: (self inspect: anObject) label: label! !!LightWidget methodsFor: 'debug and other' stamp: 'jmv 4/17/2011 22:02'!buildDebugMenu: aHand 	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpIcons.	self isKnownFailing		ifTrue: [			aMenu add: 'start drawing again' action: #resumeAfterDrawError.			aMenu addLine].	(self hasProperty: #errorOnStep) 		ifTrue: [			aMenu add: 'start stepping again' action: #resumeAfterStepError.			aMenu addLine].	aMenu add: 'inspect morph' action: #inspect.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	aMenu 		add: 'explore morph'		target: self		selector: #explore.	aMenu addLine.	aMenu 		add: 'browse morph class'		target: self		selector: #browseHierarchy.	aMenu addLine.	aMenu		add: 'edit balloon help' action: #editBalloonHelpText.	^aMenu! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 4/17/2011 22:21'!spyAllOn: aBlock	"Spy on all the processes in the system		[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]		"	| node result |	node _ self new.	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.	SystemWindow		editText: (TextModel withText: (String streamContents: [:s | node report: s]))		label: 'Spy Results'		wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 4/17/2011 22:22'!spyOn: aBlock reportOtherProcesses: aBoolean	"	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true	"	| node result |	node _ self new.	node reportOtherProcesses: aBoolean.	result _ node spyEvery: self defaultPollPeriod on: aBlock.	SystemWindow		editText: (TextModel withText: (String streamContents: [:s | node report: s]))		label: 'Spy Results'		wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 4/17/2011 22:22'!spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean	"	Spy on aProcess for a certain amount of time	| p1 p2 |  	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.	p1 resume.	p2 resume.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true	"	| node |	node _ self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	SystemWindow		editText: (TextModel withText: (String streamContents: [:s | node report: s]))		label: 'Spy Results'		wrap: false! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 4/17/2011 22:24'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [ :current |			current == prev ifFalse: [ "call or return"				prev sender ifNotNil: [ "call only"					(receiver == nil or: [ current receiver == receiver ])						ifTrue: [ tallies tally: current by: 1 ]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	SystemWindow		editText: (TextModel withText: (String streamContents: [ :s |			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ]]))		label: 'Spy Results'		wrap: false! !!Morph methodsFor: 'debug and other' stamp: 'jmv 4/17/2011 22:02'!buildDebugMenu: aHand 	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpIcons.	self isKnownFailing		ifTrue: [			aMenu add: 'start drawing again' action: #resumeAfterDrawError.			aMenu addLine].	(self hasProperty: #errorOnStep) 		ifTrue: [			aMenu add: 'start stepping again' action: #resumeAfterStepError.			aMenu addLine].	aMenu add: 'inspect morph' action: #inspect.	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.	self hasModel 		ifTrue: [			aMenu 				add: 'inspect model'				target: self model				action: #inspect].	aMenu 		add: 'explore morph'		target: self		selector: #explore.	aMenu addLine.	aMenu 		add: 'browse morph class'		target: self		selector: #browseHierarchy.	self hasModel 		ifTrue: [			aMenu 				add: 'browse model class'				target: self model				selector: #browseHierarchy].	aMenu addLine.	aMenu		add: 'edit balloon help' action: #editBalloonHelpText.	^aMenu! !!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 4/17/2011 18:56'!buttonToTriggerIn: aFileList for: service	"Answer a button that will trigger the receiver service in a file list"	| aButton |	service argumentProvider: aFileList.	aButton := PluggableButtonMorph 				model: service				stateGetter: nil				action: #performService.	aButton label: service buttonLabel.	aButton color: (Theme current buttonColorFrom:Theme current fileList).	aButton setBalloonText: service description.	^aButton! !!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 4/17/2011 18:57'!updateButtonRow: row	"Dynamically update the contents of the button row, if any."	| buttons |	row removeAllMorphs.	buttons _ OrderedCollection new.	model universalButtonServices do: [ :service |		buttons add: (self buttonToTriggerIn: model for: service) ].	model dynamicButtonServices do: [ :service | 		buttons add: (self buttonToTriggerIn: model for: service).		service addDependent: model].	row addMorphs: buttons! !!HaloMorph methodsFor: 'private' stamp: 'jmv 4/17/2011 22:01'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	self world displayWorld.	evt shiftPressed ifTrue: [		self delete.		^ innerTarget inspect].	menu _ innerTarget buildDebugMenu: evt hand.	menu addTitle: (innerTarget externalName truncateWithElipsisTo: 40).	menu popUpInWorld: self world! !!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 4/17/2011 21:57'!buildMorphicWindow	" Inspector openAsMorphOn: SystemOrganization "	| contentsText list upperRow evaluatorText |	list _ PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: model 			listGetter: #fieldList			indexGetter: #selectionIndex			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu			keystrokeAction: #inspectorKey:from:.	contentsText _ TextModelMorph			textProvider: model			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection.	evaluatorText _ (TextModelMorph textProvider: model)			askBeforeDiscardingEdits: false.	upperRow _ LayoutMorph newRow.	upperRow		addMorph: list proportionalWidth: 0.3;		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.	self layoutMorph		addMorph: upperRow proportionalHeight: 0.7;		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.	self setLabel: model object defaultLabelForInspector.	self setUpdatablePanesFrom: #(fieldList)! !!ObjectExplorer methodsFor: 'accessing' stamp: 'jmv 4/17/2011 22:04'!rootObject	^rootObject! !!ObjectExplorer methodsFor: 'accessing' stamp: 'jmv 4/17/2011 22:06'!rootObject: anObject	rootObject _ anObject! !!ObjectExplorer methodsFor: 'menus' stamp: 'jmv 4/17/2011 22:12'!exploreObjectPointers	self object explorePointers! !!ObjectExplorer methodsFor: 'menus' stamp: 'jmv 4/17/2011 22:13'!genericMenu	"Borrow a menu from my inspector"	| insideObject parentObject aMenu |	aMenu := MenuMorph new defaultTarget: self.	currentSelection		ifNil: [			aMenu				add: '*nothing selected*'				target: self				selector: #yourself]		ifNotNil: [			insideObject _ self object.			parentObject _ self parentObject.			inspector				ifNil: [inspector _ Inspector new].			inspector inspect: parentObject;				 object: insideObject.			aMenu _ inspector fieldListMenu.			aMenu defaultTarget: inspector.			aMenu items				do: [:i | (#(#inspectSelection #exploreSelection #referencesToSelection #defsOfSelection #objectReferencesToSelection #exploreObjectPointers) includes: i selector)						ifTrue: [i target: self]].			aMenu addLine;				add: 'monitor changes'				target: self				selector: #monitor:				argument: currentSelection].	monitorList isEmptyOrNil		ifFalse: [aMenu addLine;				add: 'stop monitoring all'				target: self				selector: #stopMonitoring].	^ aMenu! !!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 4/17/2011 22:05'!buildMorphicWindow	| listMorph textMorph |	.listMorph _ SimpleHierarchicalListMorph 			model: model			listGetter: #getList			indexGetter: #getCurrentSelection			indexSetter: #noteNewSelection:			menuGetter: #genericMenu			keystrokeAction: #explorerKey:from:.	listMorph autoDeselect: false.	textMorph _ (TextModelMorph textProvider: model)			askBeforeDiscardingEdits: false.	self layoutMorph		addMorph: listMorph proportionalHeight: 0.8;		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.	self setLabel: (model rootObject printStringLimitedTo: 64)! !!Parser methodsFor: 'error handling' stamp: 'jmv 4/17/2011 18:44'!interactive	"Answer true if compilation is interactive"	^ requestor notNil! !!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 4/17/2011 18:52'!processListKey: aKey from: aView 	^ aKey caseOf: {		[$i] -> [self inspectProcess].		[$I] -> [self exploreProcess].		[$P] -> [self inspectPointers].		[$t] -> [self terminateProcess].		[$r] -> [self resumeProcess].		[$s] -> [self suspendProcess].		[$d] -> [self debugProcess].		[$p] -> [self changePriority].		[$m] -> [self messageTally].		[$f] -> [self findContext].		[$g] -> [self nextContext].		[$a] -> [self toggleAutoUpdate].		[$u] -> [self updateProcessList].		[$S] -> [self signalSemaphore].		[$k] -> [self moreStack]}		 otherwise: [self arrowKey: aKey from: aView]! !!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 4/17/2011 18:53'!processListMenu	| pw menu |	menu := MenuMorph new defaultTarget: self.	selectedProcess		ifNotNil: [| nameAndRules | 			nameAndRules _ self nameAndRulesForSelectedProcess.			menu addList: {{'inspect (i)'. #inspectProcess}. {'explore (I)'. #exploreProcess}. {'inspect Pointers (P)'. #inspectPointers}}.			nameAndRules second				ifTrue: [menu add: 'terminate (t)' action: #terminateProcess.					selectedProcess isSuspended						ifTrue: [menu add: 'resume (r)' action: #resumeProcess]						ifFalse: [menu add: 'suspend (s)' action: #suspendProcess]].			nameAndRules third				ifTrue: [menu addList: {{'change priority (p)'. #changePriority}. {'debug (d)'. #debugProcess}}].			menu addList: {{'profile messages (m)'. #messageTally}}.			(selectedProcess suspendingList isKindOf: Semaphore)				ifTrue: [menu add: 'signal Semaphore (S)' action: #signalSemaphore].			menu add: 'full stack (k)' action: #moreStack.			menu addLine].	menu addList: {{'find context... (f)'. #findContext}. {'find again (g)'. #nextContext}}.	menu addLine.	menu		add: (self isAutoUpdating				ifTrue: ['turn off auto-update (a)']				ifFalse: ['turn on auto-update (a)'])		action: #toggleAutoUpdate.	menu add: 'update list (u)' action: #updateProcessList.	pw _ Smalltalk at: #CPUWatcher ifAbsent: nil.	pw ifNotNil: [		menu addLine.		pw isMonitoring				ifTrue: [ menu add: 'stop CPUWatcher' action: #stopCPUWatcher ]				ifFalse: [ menu add: 'start CPUWatcher' action: #startCPUWatcher  ]	].	^ menu! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'jmv 4/17/2011 18:56'!argumentProvider: o	argumentProvider _ o! !!SyntaxErrorNotification methodsFor: 'exceptionDescription' stamp: 'jmv 4/17/2011 18:49'!defaultAction	"Handle a syntax error"	| |true ifTrue: [ ^super defaultAction ]."	notifier :=  SyntaxError new		setClass: self errorClass		code: self errorCode		debugger: (Debugger context: self signalerContext)		doitFlag: self doitFlag.	notifier category: self category.	SyntaxError open: notifier.	"! !!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 4/17/2011 22:29'!browseViewReferencesFromNonViews	"	Smalltalk browseViewReferencesFromNonViews	"	| aList aLiteral aCollection |	aCollection _ OrderedCollection new.	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)""	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |""	PluggableMorph withAllSubclassesDo: [ :view |"	MenuMorph withAllSubclassesDo: [ :view |				aLiteral _ view name.				"tweak to linclude refs to SysWindow subhierarchy or not"		(view includesBehavior: SystemWindow) "		& false"		ifFalse: [					Smalltalk allBehaviorsDo: [ :class |				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [					aList _ class						whichSelectorsReferTo: aLiteral						special: false						byte: nil.					aList do: [ :sel |						sel == #DoIt ifFalse: [							"For special selectors, look for the literal in the source code.							Otherwise, for example, searching for senders of #== will include senders of #ifNil:"							((class sourceCodeAt: sel) findString: aLiteral) > 0  ifTrue: [								aCollection add:									(MethodReference new										setStandardClass: class										methodSymbol: sel) ]]]]]]].	Smalltalk		browseMessageList: aCollection asSet asArray sort		name: 'References to Views from non-Views'		autoSelect: ''.! !!SystemWindow class methodsFor: 'instance creation' stamp: 'jmv 4/17/2011 22:19'!editText: aTextModel label: labelString wrap: aBoolean	| window |	window _ SystemWindow new model: aTextModel.	window setLabel: labelString.	window layoutMorph		addMorph: ((TextModelMorph withModel: aTextModel)			wrapFlag: aBoolean)		proportionalHeight: 1.	^ window openInWorld! !!SystemWindow class methodsFor: 'instance creation' stamp: 'jmv 4/17/2011 21:59'!open: model label: aString	|  window |	window _ self new.	window		model: model;		buildMorphicWindow.	aString ifNotNil: [ window setLabel: aString ].	window		openInWorld! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 4/17/2011 22:25'!openLabel: aString 	"Create a standard system view of the model, me, and open it."	SystemWindow editText: self label: aString wrap: true! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 4/17/2011 22:20'!openTextEditor	SystemWindow editText: TextModel new label: 'Text Editor' wrap: true! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 4/17/2011 22:21'!openWorkspace	SystemWindow editText: Workspace new label: 'Workspace' wrap: true! !TextModel removeSelector: #openAsMorphLabel:!TextModel removeSelector: #openInMorphicWindowLabeled:wrap:!TextModel removeSelector: #openLabel:wrap:!SimpleServiceEntry removeSelector: #buttonToTriggerIn:!ProcessBrowser removeSelector: #chasePointers!ObjectExplorer removeSelector: #chasePointers!ObjectExplorer removeSelector: #explorePointers!ObjectExplorer removeSelector: #explorerFor:!ObjectExplorer removeSelector: #openExplorerFor:!Morph removeSelector: #inspectInMorphic:!LightWidget removeSelector: #inspectInMorphic:!Inspector class removeSelector: #inMorphicWindowOn:!Inspector class removeSelector: #inMorphicWindowOn:label:!Inspector removeSelector: #chasePointers!Inspector removeSelector: #explorePointers!Object removeSelector: #chasePointers!Smalltalk removeClassNamed: #PointerFinder!Smalltalk removeClassNamed: #SyntaxError!