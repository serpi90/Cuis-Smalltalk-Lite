'From Cuis 2.0 of 24 February 2010 [latest update: #440] on 16 March 2010 at 7:10:17 pm'!!BitBlt methodsFor: 'private' stamp: 'jmv 3/16/2010 19:10'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor	| lastSourceDepth targetColor sourceDepth destDepth |	sourceForm ifNotNil: [ lastSourceDepth _ sourceForm depth ].	sourceForm _ aStrikeFont glyphs.	sourceDepth _ sourceForm depth.	destDepth _ destForm depth.	"Ignore any halftone pattern since we use a color map approach here"	halftoneForm _ nil.	sourceY _ 0.	height _ aStrikeFont height.	sourceDepth = 1 ifTrue: [		self combinationRule: Form paint.		(colorMap isNil or: [ lastSourceDepth ~= sourceDepth ]) ifTrue: [			"Set up color map for a different source depth (color font)"			"Uses caching for reasonable efficiency			Warning: We are not considering that destDepth could change too, requiring a new colormap			This seems not to cause any problems..."			colorMap _ self cachedFontColormapFrom1BitTo: destDepth.			colorMap at: 1 put: (destForm pixelValueFor: Color transparent)].		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]		ifFalse: [		(Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ Preferences subPixelRenderColorFonts ]]) ifTrue: [			destDepth > 8 ifTrue: [				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"				self combinationRule: 37.		"rgbMul"				colorMap _ (foregroundColor ~= Color black or: [						destDepth = 32 and: [ destForm ~~ Display or: [Preferences properDisplayAlphaForFonts] ]]) ifTrue: [					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)					See #displayString:from:to:at:strikeFont:kern:"					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 					and we need to add to the alpha channel"					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]			ifFalse: [				self combinationRule: 25.		"Paint"				targetColor _ foregroundColor = Color black ifFalse: [ foregroundColor ].				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]		ifFalse: [			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]].! !!Color methodsFor: 'equality' stamp: 'jmv 3/16/2010 19:00'!= aColor	"Return true if the receiver equals the given color. This method handles TranslucentColors, too."	self == aColor ifTrue: [^true].	(aColor is: #Color) ifFalse: [^ false].	^ aColor privateRGB = rgb and:		[aColor privateAlpha = self privateAlpha]! !!Preferences class methodsFor: 'fonts' stamp: 'jmv 3/16/2010 18:54'!properDisplayAlphaForFonts	^ self		valueOfFlag: #properDisplayAlphaForFonts		ifAbsent: [false]! !