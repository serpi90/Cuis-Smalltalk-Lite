'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 27 September 2010 at 11:38:48 am'!!Point commentStamp: 'jmv 9/27/2010 11:22' prior: 0!I represent an x-y pair of numbers usually designating a location on the screen.When dealing with display coordinates, the y axis is usually considered to increase downwards. However, the standard math convention is to consider it increasing upwards. Points don't need to know about this. In the first case, theta increases clockwise. I the second case, it increases counter-clockwise, also the standard math convention.Any method that doesn't follow this (because it assumes one specific convention) include this fact in the selector and in a comment.!!Point methodsFor: 'polar coordinates' stamp: 'jmv 9/27/2010 11:36'!degrees	"Answer the angle the receiver makes with origin in radians.	If coordinates are in Display convention (y increases downwards), angles increase clockwise.	If coordinates are in math convention (y increases upwards), angles increase counter-clockwise "	^self theta radiansToDegrees! !!Point methodsFor: 'polar coordinates' stamp: 'jmv 9/27/2010 11:35'!theta	"Answer the angle the receiver makes with origin in radians.	If coordinates are in Display convention (y increases downwards), angles increase clockwise.	If coordinates are in math convention (y increases upwards), angles increase counter-clockwise "	| tan theta |	^x = 0		ifTrue: [			y >= 0				ifTrue: [ 1.570796326794897 	"90.0 degreesToRadians"]				ifFalse: [ 4.71238898038469	"270.0 degreesToRadians"]]		ifFalse: [			tan _ y asFloat / x asFloat.			theta _ tan arcTan.			x >= 0				ifTrue: [					y >= 0						ifTrue: [ theta ]						ifFalse: [							6.283185307179586 "360.0 degreesToRadians"							+ theta ]]				ifFalse: [					3.141592653589793 "180.0 degreesToRadians"					+ theta ]]! !!Point methodsFor: 'transforming' stamp: 'jmv 9/27/2010 11:21'!inverseRotateBy: angle about: center	"This method considers angle to be in standard math convention (counter clock wise) while at the same time it considers the points to be in display convention (y axis increases downwards)"	| p r theta |	p _ self - center.	r _ p r.	theta _ angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @	  (center y asFloat - (r * theta sin))! !!Point methodsFor: 'transforming' stamp: 'jmv 5/11/2010 16:26'!rotateBy: angle	| r theta |	r _ self r.	theta _ self theta +  angle asFloat.	^ (r * theta cos) @ (r * theta sin)! !!PolygonMorph methodsFor: 'halo control' stamp: 'jmv 9/27/2010 11:22'!rotationDegrees: degrees 	| center |	center _ self center.	self setVertices: (vertices collect: [ :v |		v inverseRotateBy: (degrees - self forwardDirection) degreesToRadians negated about: center ]).	self forwardDirection: degrees! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 9/27/2010 09:55'!strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 	"This method implements a staggered window placement policy that I (di) like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible."	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea := (self maximumUsableAreaInWorld: aWorld) 				insetBy: (self scrollBarSetback @ self screenTopSetback extent: 0 @ 0).	"Number to be staggered at each corner (less on small screens)"	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame := 0 @ 0 extent: initialExtent.	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400"	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not]) 						collect: [:w | w displayBounds].	0 to: maxLevel		do: 			[:level | 			1 to: 4				do: 					[:ci | 					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.					corner := allowedArea perform: cornerSel.					"The extra grid//2 in delta helps to keep title tabs distinct"					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"					putativeCorner := corner + delta.					free := true.					otherFrames 						do: [:w | free := free & ((w perform: cornerSel) ~= putativeCorner)].					free 						ifTrue: 							[^(initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].	"If all else fails..."	^(self scrollBarSetback @ self screenTopSetback 		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 9/27/2010 11:22'!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 9/27/2010 11:22'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 250@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 250@0).		]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 9/27/2010 11:22'!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt inverseRotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 9/27/2010 11:22'!test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt inverseRotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples' stamp: 'jmv 9/27/2010 11:23'!test5   "Display restoreAfter: [WarpBlt test5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt inverseRotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]! !!WarpBlt class methodsFor: 'form rotation' stamp: 'jmv 9/27/2010 11:23'!rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |	srcRect _ srcForm boundingBox.	center _ srcRect center.	radians _ angleInDegrees degreesToRadians.	dstOrigin _ dstCorner _ center.	srcRect corners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p _ ((corner - center) scaleBy: scalePoint) + center.		p _ (p inverseRotateBy: radians about: center) rounded.		dstOrigin _ dstOrigin min: p.		dstCorner _ dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect _ dstOrigin corner: dstCorner.	inverseScale _ (1.0 / scalePoint x)@(1.0 / scalePoint y).	quad _ dstRect innerCorners collect: [:corner |		p _ corner inverseRotateBy: radians negated about: center.		((p - center) scaleBy: inverseScale) + center].	"make a Form to hold the result and do the rotation"	warpSrc _ srcForm.	(srcForm is: #ColorForm)		ifTrue: [			cellSize > 1 | true "ar 12/27/2001: Always enable - else sketches won't work"				ifTrue: [					warpSrc _ Form extent: srcForm extent depth: 16.					srcForm displayOn: warpSrc.					dstForm _ Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"				ifFalse: [					dstForm _ srcForm class extent: dstRect extent depth: srcForm depth]]		ifFalse: [			dstForm _ srcForm class extent: dstRect extent depth: srcForm depth].	(WarpBlt toForm: dstForm)		sourceForm: warpSrc;		colorMap: (warpSrc colormapIfNeededFor: dstForm);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint;		copyQuad: quad toRect: dstForm boundingBox.	(dstForm is: #ColorForm) ifTrue: [ dstForm colors: srcForm colors copy ].	newCenter _ (center inverseRotateBy: radians about: aPoint) truncated.	^ Array with: dstForm with: dstRect origin + (newCenter - center)! !Rectangle removeSelector: #rotateBy:centerAt:!Rectangle removeSelector: #scaleFrom:to:!Point removeSelector: #bearingToPoint:!Point removeSelector: #octantOf:!Point removeSelector: #rotateBy:about:!Point removeSelector: #rotateBy:centerAt:!Point removeSelector: #scaleFrom:to:!