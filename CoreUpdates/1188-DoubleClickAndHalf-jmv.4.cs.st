'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 29 December 2011 at 1:32:30 pm'!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickSelector clickAndHalfSelector dblClickSelector tripleClickSelector sendMouseButton2Activity buttonDownCount buttonUpCount clickDone clickAndHalfDone doubleClickDone lastClickDown dblClickAndHalfSelector doubleClickAndHalfDone '	classVariableNames: 'DoubleClickTimeout '	poolDictionaries: ''	category: 'Morphic-Kernel'!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialWordSelStart initialWordSelStop initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection '	classVariableNames: 'ChangeText FindText '	poolDictionaries: ''	category: 'System-Text'!!HandMorph methodsFor: 'double click support' stamp: 'jmv 12/29/2011 11:43'!                      dontWaitForMoreClicks	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	mouseClickState _ nil.! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 12/29/2011 12:00'!    waitForClicksOrDrag: aMorph event: evt clkSel: clkSel dblClkSel: dblClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _		MouseClickState new			client: aMorph			click: clkSel			clickAndHalfSelector: nil 			dblClick: dblClkSel			dblClickAndHalf: nil			tripleClick: nil			event: evt			sendMouseButton2Activity: false! !!HandMorph methodsFor: 'double click support' stamp: 'jmv 12/29/2011 12:00'!                     waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 	mouseClickState _		MouseClickState new			client: aMorph			click: clkSel			clickAndHalfSelector: clkNHalfSel			dblClick: dblClkSel			dblClickAndHalf: dblClkNHalfSel			tripleClick: tripleClkSel			event: evt			sendMouseButton2Activity: Preferences tapAndHoldEmulatesButton2! !!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2011 11:43'!                         initForEvents	mouseOverHandler _ nil.	lastMouseEvent _ MouseEvent new setType: #mouseMove position: 0@0 buttons: 0 hand: self.	lastMouseEventTime _ Time millisecondClockValue.	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.	self dontWaitForMoreClicks! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:19'!               doubleClickAndHalf: evt	self handleInteraction: [		editor doubleClickAndHalf: (evt translatedBy: bounds topLeft negated) ].	owner scrollSelectionIntoView: evt.! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:55'!             mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: (event translatedBy: bounds topLeft negated)].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: #clickAndHalf:		dblClkSel: nil		dblClkNHalfSel: #doubleClickAndHalf:		tripleClkSel: nil! !!MouseClickState methodsFor: 'initialize' stamp: 'jmv 12/29/2011 11:59'!                  client: aMorph click: aClickSelector clickAndHalfSelector: aClickAndHalfSelector dblClick: aDblClickSelector dblClickAndHalf: aDblClickAndHalfSelector tripleClick: aTripleClickSelector event: firstClickEvent sendMouseButton2Activity: aBoolean	clickClient _ aMorph.	clickSelector _ aClickSelector.	clickAndHalfSelector _ aClickAndHalfSelector.	dblClickSelector _ aDblClickSelector.	dblClickAndHalfSelector _ aDblClickAndHalfSelector.	tripleClickSelector _ aTripleClickSelector.	sendMouseButton2Activity _ aBoolean.	buttonDownCount _ 1.	buttonUpCount _ 0.	clickDone _ false.	clickAndHalfDone _ false.	doubleClickDone _ false.	doubleClickAndHalfDone _ false.	lastClickDown _ firstClickEvent! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 12/29/2011 13:18'!                       doubleClickAndHalf	doubleClickAndHalfDone ifFalse: [		dblClickAndHalfSelector ifNotNil: [			"Focus was lost at buttonUp. Set it again."			lastClickDown hand newMouseFocus: clickClient event: lastClickDown.			clickClient perform: dblClickAndHalfSelector with: lastClickDown ].		doubleClickAndHalfDone _ true ]! !!MouseClickState methodsFor: 'actions' stamp: 'jmv 12/29/2011 13:04'!                          handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| timedOut distance |	timedOut _ (evt timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.	distance _ (evt position - lastClickDown position) r.	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."	evt isMouseDown ifTrue: [		lastClickDown _ evt.		buttonDownCount _ buttonDownCount + 1 ].	evt isMouseUp ifTrue: [		buttonUpCount _ buttonUpCount + 1 ].	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [			aHand dontWaitForMoreClicks.			clickClient mouseButton2Activity.			^ false ].		"If we have already moved, then it won't be a double or triple click... why wait?"		distance > 0 ifTrue: [			aHand dontWaitForMoreClicks.			self click.			^ false ]].	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [		aHand dontWaitForMoreClicks.		^ false ].	"Simple click."	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [		self click ].	"Click & hold"	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [		self clickAndAHalf ].	"Double click."	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [		self doubleClick ].	"Double click & hold."	(buttonDownCount = 3 and: [ buttonUpCount = 2]) ifTrue: [		self doubleClickAndHalf ].	"Triple click"	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [		self tripleClick ].	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"	^ evt isMouseDown! !!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:01'!       mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event hand newKeyboardFocus: self.	self handleInteraction: [		editor mouseDown: event index: (self characterIndexAtPoint: event position) ].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: #clickAndHalf:		dblClkSel: nil		dblClkNHalfSel: nil		tripleClkSel: nil! !!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:01'!      mouseDown: event	"Handle a mouse down event."	| grabbedMorph |	grabbedMorph _ self morphToGrab: event.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		^event hand grabMorph: grabbedMorph].	event mouseButton2Pressed ifTrue: [^self mouseButton2Activity].	super mouseDown: event.	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: event		clkSel: #click:		clkNHalf: nil		dblClkSel: #doubleClick:		dblClkNHalfSel: nil		tripleClkSel: nil! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:02'!  mouseDown: event	event mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].	isPressed _ true.	self redrawNeeded.	actWhen == #buttonDown ifTrue: [		self performAction ].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: nil		dblClkSel: #doubleClick:		dblClkNHalfSel: nil		tripleClkSel: nil! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 12/29/2011 13:31'!  doubleClickAndHalf: evt	"Some subclasses might do something"! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:55'!             mouseDown: event	event mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	scroller mouseDown: event.	event hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: nil		dblClkSel: #doubleClick:		dblClkNHalfSel: #doubleClickAndHalf:		tripleClkSel: nil! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:01'!            mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and: [ aMorph inToggleArea: evt position ])		ifTrue: [ ^self toggleExpandedState: aMorph event: evt ]. 	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [ ^ self mouseButton2Activity ].	aMorph ifNil: [ ^super mouseDown: evt ].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: evt 		clkSel: #click:		clkNHalf: nil		dblClkSel: nil		dblClkNHalfSel: nil		tripleClkSel: nil! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/29/2011 12:02'!                  mouseDown: evt	| row |	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: evt		clkSel: #click:		clkNHalf: nil		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])		dblClkNHalfSel: nil		tripleClkSel: nil! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/29/2011 12:02'!   mouseDown: event	| oldIndex oldVal row w |	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row _ self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	w _ self ownerThatIsA: SystemWindow.	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		clkNHalf: nil		dblClkSel: #doubleClick:		dblClkNHalfSel: nil		tripleClkSel: nil! !!String methodsFor: 'paragraph support' stamp: 'jmv 12/29/2011 13:22'!                           encompassParagraph: anInterval	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.	Answer starts at the position following a cr (or eventually 1) and ends at a cr (or eventually at self size).	Look also for null characters. Never include null characters in the answer.	See also #encompassLine:"	| left rightCr rightNull |	left _ (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	rightCr _ (self indexOf: Character cr startingAt: (anInterval last-1 max: anInterval first) ifAbsent: [self size]).	rightNull _ (self indexOf: Character null startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.	^left to: (rightCr min: rightNull)! !!TextEditor methodsFor: 'events' stamp: 'jmv 12/29/2011 13:16'!      clickAndHalf: evt	self selectWord.	doWordSelection _ true.	doParagraphSelection _ false.	initialSelectionStart _ self startBlock.	initialSelectionStop _ self stopBlock! !!TextEditor methodsFor: 'events' stamp: 'jmv 12/29/2011 13:16'!             doubleClickAndHalf: evt	| here b interval |	b _ paragraph characterBlockAtPoint: evt position.	here _ b stringIndex.	interval _ self privateCurrentString encompassParagraph: (here to: here).	self selectFrom: interval first to: interval last.	doWordSelection _ false.	doParagraphSelection _ true.	initialSelectionStart _ self startBlock.	initialSelectionStop _ self stopBlock! !!TextEditor methodsFor: 'events' stamp: 'jmv 12/29/2011 13:16'!                          mouseDown: evt 	| clickPoint b |	initialSelectionStart _ nil.	initialSelectionStop _ nil.	doWordSelection _ false.	doParagraphSelection _ false.	"Multiple selection of text.	Windows uses Control, Mac uses Command (i.e. commandAlt)	On the Mac, command-button1 is translated to command-button3 by the VM. do:		Preferences disable: #commandClickOpensHalo	to disable this behavior and make command-button1 work for multiple selection. "	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [		self selectionInterval size > 0 ifTrue: [			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]	ifFalse: [		selectionStartBlocks _ #().		selectionStopBlocks _ #() ].	clickPoint _ evt position.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint) ifTrue: [		markBlock _ b.		pointBlock _ b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			(self markIndex = b stringIndex and: [ self pointIndex = b stringIndex ])				ifTrue: [					markBlock _ b.					pointBlock _ b ]				ifFalse: [					markBlock _ b.					pointBlock _ b.						self setEmphasisHereFromText ]]! !!TextEditor methodsFor: 'events' stamp: 'jmv 12/29/2011 13:31'!                              mouseMove: evt	"Change the selection in response to mouse-down drag"	| b interval i1 i2 |	doWordSelection ifTrue: [		pointBlock _ (paragraph characterBlockAtPoint: (evt position)).		self selectWordLeftDelimiters: '' rightDelimiters: ''.		markBlock _ self startBlock min: initialSelectionStart.		pointBlock _ self stopBlock max: initialSelectionStop.		self storeSelectionInParagraph.		^self ].	doParagraphSelection ifTrue: [		b _ paragraph characterBlockAtPoint: evt position.		i1 _ b stringIndex min: initialSelectionStart stringIndex.		i2 _ b stringIndex max: initialSelectionStop stringIndex.		interval _ self privateCurrentString encompassParagraph: (i1 to: i2).		self selectFrom: interval first to: interval last.		markBlock _ self startBlock min: initialSelectionStart.		pointBlock _ self stopBlock max: initialSelectionStop.		self storeSelectionInParagraph.		^self ].	pointBlock _ (paragraph characterBlockAtPoint: (evt position)).	self storeSelectionInParagraph! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 12/29/2011 13:16'!              initialize	selectionStartBlocks _ #().	selectionStopBlocks _ #().	initialSelectionStart _ nil.	initialSelectionStop _ nil.	doWordSelection _ false.	doParagraphSelection _ false! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 12/29/2011 11:48'!                              find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: FindText.	"Set focus on our text morph, so that cmd-g does the search again"	morph world activeHand newKeyboardFocus: morph.	reply size = 0 ifTrue: [		^ self].	self setSearch: reply.	ChangeText _ FindText.  "Implies no replacement to againOnce: method"	(self findAndReplaceMany: false)		ifFalse: [ self flash ]."	morph installEditorToReplace: self"! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 12/29/2011 11:49'!  findAgain	"Find the text-to-find again.  1/24/96 sw"	(self findAndReplaceMany: false)		ifFalse: [ self flash ].! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/29/2011 11:48'!       findAndReplaceMany: doMany	"Subroutine of search: and again.  Use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	"jmvnote: We currently have no command for search&replace, but it is really easy to add, and this method supports it. See ChangeText"	"This is a user command, and generates undo"	|  indexStream |	"Find and Change, recording start indices in the array"	indexStream _ WriteStream on: (Array new: 20). "an array to store change locs"	selectionStartBlocks _ OrderedCollection new.	selectionStopBlocks _ OrderedCollection new.	[(self findAndReplaceOnce: indexStream) & doMany] whileTrue. "<-- this does the work"	"Last find was also stored in markBlock / pointBlock"	selectionStartBlocks notEmpty ifTrue: [		selectionStartBlocks removeLast.		selectionStopBlocks removeLast ].	"Answer whether something was found"	^indexStream notEmpty! !!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 12/29/2011 13:31'!                    doubleClickAndHalf: event	self textMorph doubleClickAndHalf: event! !!methodRemoval: TextModelMorph #tripleClick:!TextModelMorph removeSelector: #tripleClick:!!methodRemoval: TextEditor #tripleClick:!TextEditor removeSelector: #tripleClick:!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection'	classVariableNames: 'ChangeText FindText'	poolDictionaries: ''	category: 'System-Text'!!methodRemoval: PluggableScrollPane #tripleClick:!PluggableScrollPane removeSelector: #tripleClick:!!methodRemoval: MouseClickState #client:click:clickAndHalfSelector:dblClick:tripleClick:event:sendMouseButton2Activity:!MouseClickState removeSelector: #client:click:clickAndHalfSelector:dblClick:tripleClick:event:sendMouseButton2Activity:!!classDefinition: #MouseClickState category: #'Morphic-Kernel'!Object subclass: #MouseClickState	instanceVariableNames: 'clickClient clickSelector clickAndHalfSelector dblClickSelector tripleClickSelector sendMouseButton2Activity buttonDownCount buttonUpCount clickDone clickAndHalfDone doubleClickDone lastClickDown dblClickAndHalfSelector doubleClickAndHalfDone'	classVariableNames: 'DoubleClickTimeout'	poolDictionaries: ''	category: 'Morphic-Kernel'!!methodRemoval: InnerTextMorph #tripleClick:!InnerTextMorph removeSelector: #tripleClick:!!methodRemoval: HandMorph #dontWaitForDoubleClick!HandMorph removeSelector: #dontWaitForDoubleClick!!methodRemoval: HandMorph #waitForClicksOrDragOrSimulatedMouseButton2:event:clkSel:clkNHalf:dblClkSel:tripleClkSel:!HandMorph removeSelector: #waitForClicksOrDragOrSimulatedMouseButton2:event:clkSel:clkNHalf:dblClkSel:tripleClkSel:!