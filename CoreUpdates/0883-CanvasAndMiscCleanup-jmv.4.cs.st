'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 17 March 2011 at 10:33:59 pm'!!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'jmv 3/17/2011 22:02'!testTempCountForBlockAt: startPc in: method	"Compute the number of local temporaries in a block.	 If the block begins with a sequence of push: nil bytecodes then some of	 These could be initializing local temps.  We can only reliably disambuguate	 them from other uses of nil by parsing the stack and seeing what the offset	 of the stack pointer is at the end of the block.There are short-cuts.  The only	 one we take here is		- if there is no sequence of push nils there can be no local temps"	| symbolicLines line prior thePc |	symbolicLines := Dictionary new.	method symbolicLinesDo:		[:pc :lineForPC| symbolicLines at: pc put: lineForPC].	stackPointer := 0.	scanner := InstructionStream new method: method pc: startPc.	scanner interpretNextInstructionFor: self.	blockEnd isNil ifTrue:		[self error: 'pc is not that of a block'].	scanner nextByte = Encoder pushNilCode ifTrue:		[joinOffsets := Dictionary new.		 [scanner pc < blockEnd] whileTrue:			[line := symbolicLines at: scanner pc.			 prior := stackPointer.			 thePc := scanner pc.			 scanner interpretNextInstructionFor: self.			 Transcript cr; print: prior; nextPutAll: '->'; print: stackPointer;  tab; print: thePc; tab; nextPutAll: line]].	^stackPointer! !!Clipboard methodsFor: 'accessing' stamp: 'jmv 3/17/2011 22:26'!retrieveMorph	"Answer a Morph or nil."	| answer |		answer _ self retrieveObject.		"If clipboard contents is already a Text or String, answer it."	(answer is: #Morph) ifTrue: [		^ answer ].	"If clipboard contains a Form, prepare a Morph including it."	(answer is: #Form) ifTrue: [		^ ImageMorph new image: answer ].	"If clipboard contents is already a Text or String, answer it."	(answer isString or: [ answer is: #Text ]) ifTrue: [		^ (TextModelMorph withText: answer asText)			embeddedInMorphicWindowLabeled: 'Text editor' ].		"No useful contents"	^nil! !!ContextPart class methodsFor: 'examples' stamp: 'jmv 3/17/2011 22:02'!trace: aBlock on: aStream		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls to a file."	| prev |	prev _ aBlock.	^ thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			current == prev				ifFalse:					[prev sender ifNil:						[aStream space; nextPut: $^.						self carefullyPrint: current top on: aStream].					aStream cr.					(current depthBelow: aBlock) timesRepeat: [aStream space].					self carefullyPrint: current receiver on: aStream.					aStream space; nextPutAll: current selector.					prev _ current]]! !!FormCanvas methodsFor: 'accessing' stamp: 'jmv 3/17/2011 22:03'!contentsOfArea: aRectangle into: aForm	| bb |	bb _ BitBlt toForm: aForm.	bb sourceForm: form; combinationRule: Form over;		sourceX: (aRectangle left + origin x); sourceY: (aRectangle top + origin y);		width: aRectangle width; height: aRectangle height;		copyBits.	^aForm! !!FormCanvas methodsFor: 'drawing' stamp: 'jmv 3/17/2011 21:59'!line: pt1 to: pt2 width: width color: color1 dashLength: s1 secondColor: color2 secondDashLength: s2 startingOffset: startingOffset 	"Draw a line using the given width, colors and dash lengths.	Originally written by Stephan Rudlof; tweaked by Dan Ingalls	to use startingOffset for sliding offset as in 'ants' animations.	Returns the sum of the starting offset and the length of this line."	| dist deltaBig colors nextPhase segmentOffset phase segmentLength startPoint distDone endPoint segLens |	dist := pt1 dist: pt2.	dist = 0 ifTrue: [^startingOffset].	s1 = 0 & (s2 = 0) ifTrue: [^startingOffset].	deltaBig := pt2 - pt1.	colors := { 				color1.				color2}.	segLens := { 				s1 asFloat.				s2 asFloat}.	nextPhase := { 				2.				1}.	"Figure out what phase we are in and how far, given startingOffset."	segmentOffset := startingOffset \\ (s1 + s2).	segmentLength := segmentOffset < s1 		ifTrue: 			[phase := 1.			s1 - segmentOffset]		ifFalse: 			[phase := 2.			 s1 + s2 - segmentOffset].	startPoint := pt1.	distDone := 0.0.	[distDone < dist] whileTrue: 			[segmentLength := segmentLength min: dist - distDone.			endPoint := startPoint + (deltaBig * segmentLength / dist).			self 				line: startPoint truncated				to: endPoint truncated				width: width				color: (colors at: phase).			distDone := distDone + segmentLength.			phase := nextPhase at: phase.			startPoint := endPoint.			segmentLength := segLens at: phase].	^startingOffset + dist! !!FormCanvas methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:03'!paragraph: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner _ (port clippedBy: (bounds translateBy: origin))		displayScannerFor: para		foreground: (shadowColor ifNil: [ c ])		ignoreColorChanges: self isShadowDrawing.	para		displayOn: (self copyClipRect: bounds)		using: scanner		at: origin+ bounds topLeft! !!FormCanvas methodsFor: 'drawing-general' stamp: 'jmv 3/17/2011 21:58'!drawMorph: aMorph	self clipBy: aMorph bounds during: [ :c | aMorph drawOn: c]! !!FormCanvas methodsFor: 'drawing-general' stamp: 'jmv 3/17/2011 21:59'!fullDrawMorph: aMorph	aMorph fullDrawOn: self! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 3/17/2011 22:23'!image: aForm at: aPoint	"Draw a translucent image using the best available way of representing translucency."	self image: aForm		at: aPoint		sourceRect: aForm boundingBox! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 3/17/2011 22:21'!image: aForm at: aPoint sourceRect: sourceRect	"Draw a translucent image using the best available way of representing translucency.	Note: This will be fixed in the future."	self isShadowDrawing ifTrue: [		^self stencil: aForm at: aPoint sourceRect: sourceRect color: shadowColor ].	(self depth < 32 or: [ aForm mightBeTranslucent not]) 		ifTrue: [			"Rule Form paint treats pixels with a value of zero as transparent"			^self image: aForm at: aPoint sourceRect: sourceRect rule: Form paint].	self image: aForm		at: aPoint		sourceRect: sourceRect		rule: Form blend! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 3/17/2011 22:23'!image: aForm multipliedBy: aColor at: aPoint	"Multiply aForm and aColor, then blend over destination.	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel	Display getCanvas image: (SystemWindow roundedCornerTR: 20)multipliedBy: Color red at: 20@20	"	AccessProtect critical: [		self buildAuxWith: aForm multipliedWith: aColor.		self image: AuxForm at: aPoint sourceRect: aForm boundingBox ]! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 3/17/2011 21:59'!stencil: stencilForm at: aPoint color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	^self stencil: stencilForm		at: aPoint		sourceRect: stencilForm boundingBox		color: aColor! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/17/2011 21:58'!fillRectangle: r color: c	"Fill the rectangle using the given color"	^self 		frameAndFillRectangle: r		fillColor: c		borderWidth: 0		borderColor: Color transparent! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/17/2011 22:03'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| f |	self isShadowDrawing ifTrue: [		^self fillRectangle: aRectangle color: shadowColor ].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		f _ aFillStyle form.		^self fillRectangle: aRectangle tilingWith: f sourceRect: f boundingBox rule: Form paint ].	self fillRectangle: aRectangle color: aFillStyle asColor! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/17/2011 21:58'!fillRectangle: r fillStyle: aFillStyle borderWidth: bw borderStyleSymbol: aSymbol	"	Display getCanvas		fillRectangle: (10@10 extent: 300@200)		fillStyle: (SystemWindow titleGradient: 24)		borderWidth: 5		borderStyleSymbol: #raised	"	"Nicer. does frame with translucent black or white. Downside: requires proper color.	Some buttons are actually transparent (should be fixed!!), and there is a trick to grab some	opaque owner's color. And this is needed because (for instance) SystemWindow does NOT paint the inside with its color, but that color is needed to paint separators and button area. Something better is needed!!!!!!!!!!"	"	self fillRectangle: r fillStyle: aFillStyle.	self frameRectangle: r borderWidth: bw borderStyleSymbol: aSymbol	"		| c |	c _ aFillStyle asColor.	self fillRectangle: (r insetBy: bw) fillStyle: aFillStyle.	self frameRectangle: r color: c borderWidth: bw borderStyleSymbol: aSymbol! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/17/2011 21:59'!fillRectangle: r fillStyle: aFillStyle borderWidth: bw borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder	"Pretty ugly.#fillRectangle:fillStyle:borderWidth:borderStyleSymbol:  is much better but has trouble with silly transparent morphs	"		self fillRectangle: (r insetBy: bw) fillStyle: aFillStyle.	self frameRectangle: r color: baseColorForBorder borderWidth: bw borderStyleSymbol: aSymbol! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/17/2011 21:59'!frameRectangle: r color: c	self frameRectangle: r width: 1 color: c! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/17/2011 21:59'!frameRectangle: r color: aColor borderWidth: bw borderStyleSymbol: aSymbol	"	Display getCanvas		frameRectangle: (10@10 extent: 300@200)		color: Color green		borderWidth: 2		borderStyleSymbol: #raised	Display getCanvas fillRectangle: (10@10 extent: 300@200) color: Color white	"	aSymbol == #raised ifTrue: [		^ self			frameRectangle: r			borderWidth: bw			topLeftColor: aColor quiteWhiter			bottomRightColor: aColor quiteBlacker ].	aSymbol == #inset ifTrue: [		^ self			frameRectangle: r			borderWidth: bw			topLeftColor: aColor quiteBlacker			bottomRightColor: aColor quiteWhiter ].		"Unrecognized border style. Draw some border..."	self frameRectangle: r width: bw color: aColor! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/17/2011 21:58'!drawString: s at: pt font: aFont color: aColor	^ self drawString: s from: 1 to: s size at: pt font: aFont color: aColor! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/17/2011 22:03'!drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c	| font |	port colorMap: nil.	font _ fontOrNil ifNil: [StrikeFont default].	font installOn: port foregroundColor: (shadowColor ifNil: [ c ]).	"Slight optimization when there's nothing to do."	port clipHeight = 0 ifTrue: [^self].	port clipWidth = 0 ifTrue: [^self].	font		displayString: aString		on: port		from: firstIndex to: lastIndex at: (origin + aPoint)		kern: font baseKern negated! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/17/2011 22:03'!drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c	| font portRect |	port colorMap: nil.	portRect _ port clipRect.	port clipByX1: bounds left + origin x 		y1: bounds top + origin y 		x2: bounds right + origin x 		y2: bounds bottom + origin y.	"Slight optimization when there's nothing to do."	port clipHeight = 0 ifTrue: [^self].	port clipWidth = 0 ifTrue: [^self].	font _ fontOrNil ifNil: [StrikeFont default].	font installOn: port foregroundColor: (shadowColor ifNil: [ c ]).	font displayString: aString asString on: port 		from: firstIndex to: lastIndex at: (bounds topLeft + origin) kern: font baseKern negated.	port clipRect: portRect! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/17/2011 21:58'!drawString: s in: boundsRect font: fontOrNil color: c	^self drawString: s from: 1 to: s size in: boundsRect font: fontOrNil color: c! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/17/2011 22:03'!drawStringEmbossed: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: aColor	| font portRect insideColor |	port colorMap: nil.	portRect _ port clipRect.	port clipByX1: bounds left + origin x 		y1: bounds top + origin y 		x2: bounds right + origin x 		y2: bounds bottom + origin y.	"Slight optimization when there's nothing to do."	port clipHeight = 0 ifTrue: [^self].	port clipWidth = 0 ifTrue: [^self].	font _ fontOrNil ifNil: [StrikeFont default].	insideColor _ shadowColor ifNil: [ aColor ].	insideColor = Color black ifFalse: [ | topColor |		topColor _ insideColor alphaMixed: 0.25 with: Color black.		font installOn: port foregroundColor: topColor.		font displayString: aString asString on: port 			from: firstIndex to: lastIndex at: (bounds topLeft + origin) kern: font baseKern negated ].	insideColor = Color white ifFalse: [ | bottomColor |		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.		font installOn: port foregroundColor: bottomColor.		font displayString: aString asString on: port 			from: firstIndex to: lastIndex at: (bounds topLeft + origin + (0@2)) kern: font baseKern negated ].	font installOn: port foregroundColor: insideColor.	font displayString: aString asString on: port 		from: firstIndex to: lastIndex at: (bounds topLeft + origin + (0@1)) kern: font baseKern negated.	port clipRect: portRect! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/17/2011 21:58'!drawStringEmbossed: s in: boundsRect font: fontOrNil color: c	^self drawStringEmbossed: s from: 1 to: s size in: boundsRect font: fontOrNil color: c! !!FormCanvas methodsFor: 'initialization' stamp: 'jmv 3/17/2011 22:04'!reset	origin := 0@0.							"origin of the top-left corner of this cavas"	clipRect := (0@0 corner: form extent).	"default clipping rectangle"	shadowColor _ nil! !!FormCanvas methodsFor: 'testing' stamp: 'jmv 3/17/2011 21:58'!drawsOnDisplay	^form == Display! !!FormCanvas methodsFor: 'testing' stamp: 'jmv 3/17/2011 22:03'!isShadowDrawing	^ shadowColor notNil! !!FormCanvas methodsFor: 'private' stamp: 'jmv 3/17/2011 22:03'!setFillColor: aColor	"Install a new color used for filling."	| screen patternWord fillColor |	fillColor _ shadowColor ifNil: [ aColor ].	fillColor ifNil: [ fillColor _ Color transparent].	(fillColor is: #Color) ifFalse:[		(fillColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: fillColor; combinationRule: Form over].	"Okay, so fillColor really *is* a color"	port sourceForm: nil.	fillColor isOpaque ifTrue: [		port combinationRule: Form over.		port fillPattern: fillColor.		self depth = 8 ifTrue:[			"In 8 bit depth it's usually a good idea to use a stipple pattern"			port fillColor: (form balancedPatternFor: fillColor)].		^self].	self depth > 8 ifTrue:[		"BitBlt setup for alpha masked transfer"		port fillPattern: fillColor.		self depth = 16			ifTrue:[port alphaBits: fillColor privateAlpha; combinationRule: 30]			ifFalse:[port combinationRule: Form blend].		^self].	"Can't represent actual transparency -- use stipple pattern"	screen _ Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord _ form pixelWordFor: fillColor.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint! !!FormCanvas methodsFor: 'private' stamp: 'jmv 3/17/2011 22:03'!setPaintColor: aColor	"Install a new color used for filling."	| paintColor screen patternWord |	paintColor _ shadowColor ifNil: [ aColor ].	paintColor ifNil: [ paintColor _ Color transparent].	(paintColor is: #Color) ifFalse:[		(paintColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: paintColor; combinationRule: Form paint].	"Okay, so paintColor really *is* a color"	port sourceForm: nil.	(paintColor isOpaque) ifTrue: [		port fillPattern: paintColor.		port combinationRule: Form paint.		self depth = 8 ifTrue:[			port fillColor: (form balancedPatternFor: paintColor)].		^self].	self depth > 8 ifTrue:[		"BitBlt setup for alpha mapped transfer"		port fillPattern: paintColor.		self depth = 16			ifTrue:[port alphaBits: paintColor privateAlpha; combinationRule: 31]			ifFalse:[port combinationRule: Form blend].		^self].	"Can't represent actual transparency -- use stipple pattern"	screen _ Color translucentMaskFor: paintColor alpha depth: self depth.	patternWord _ form pixelWordFor: paintColor.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint! !!HoleLW methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:04'!drawOn: aCanvas 	aCanvas drawsOnDisplay		ifTrue: [			(BitBlt current toForm: Display)				clipRect: aCanvas clipRect;				copy: bounds				from: 0@0 in: nil				fillColor: Color transparent rule: Form over]		ifFalse: [aCanvas fillRectangle: bounds color: Color blue]! !!ImageLW methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:25'!drawOn: aCanvas 	| f |	f _ self formToDraw.	f ifNotNil: [		aCanvas image: f at: bounds topLeft ]! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:22'!drawOn: aCanvas 	"Draw the hand itself (i.e., the cursor)."	 aCanvas image: (temporaryCursor ifNil: [NormalCursor]) at: bounds topLeft.	self hasUserInformation 		ifTrue: [			aCanvas 				drawString: userInitials				at: self cursorBounds topRight + (0 @ 4)				font: nil				color: color.			self userPicture ifNotNil: [ :userPic |				aCanvas image: userPic at: self cursorBounds topRight + (0 @ 24)]]! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:25'!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged := false.	savedPatch ifNotNil: [			aCanvas image: savedPatch at: savedPatch offset.			self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"			submorphs notEmpty ifTrue: [^self].			temporaryCursor ifNotNil: [^self].			"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."			super				invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset)				from: self.			Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].	"show hardware cursor"			savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:04'!savePatchFrom: aCanvas 	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| damageRect myBnds |	damageRect := myBnds := self fullDisplayBounds.	savedPatch ifNotNil: [		damageRect := myBnds merge: (savedPatch offset extent: savedPatch extent)].	(savedPatch isNil or: [savedPatch extent ~= myBnds extent]) 		ifTrue: [			"allocate new patch form if needed"			savedPatch := Form extent: myBnds extent depth: aCanvas depth ].	aCanvas		contentsOfArea: (myBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: myBnds topLeft.	^damageRect! !!ImageMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:28'!drawOn: aCanvas	aCanvas image: image at: self innerBounds origin! !!ImageMorph methodsFor: 'initialization' stamp: 'jmv 3/17/2011 22:30'!initialize	super initialize.	self image: DefaultForm.! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:22'!drawToggleOn: aCanvas in: aRectangle	| aForm centeringOffset |	complexContents hasContents ifFalse: [^self].	aForm _ isExpanded 		ifTrue: [container expandedForm]		ifFalse: [container notExpandedForm].	centeringOffset _ ((aRectangle height - aForm extent y) / 2.0) rounded.	^aCanvas 		image: aForm 		at: (aRectangle topLeft translateBy: 0 @ centeringOffset).! !!MagnifierMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:22'!drawOn: aCanvas	RecursionLock == self ifFalse: [		super drawOn: aCanvas.		"border and fill"		aCanvas isShadowDrawing ifFalse: [			"Optimize because #magnifiedForm is expensive"			aCanvas image: self magnifiedForm at: self innerBounds origin]]! !!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:23'!drawOn: aCanvas 	| stringColor stringBounds leftEdge |	stringColor := color.	isSelected & isEnabled		ifTrue: [			aCanvas fillRectangle: bounds color: Theme current menuHighlight].	leftEdge := 0.	self hasIcon		ifTrue: [| iconForm | 			iconForm := isEnabled ifTrue:[self icon] ifFalse:[self icon asGrayScale].			aCanvas image: iconForm at: self left @ (self top + (self height - iconForm height // 2)).			leftEdge := iconForm width + 2].	self hasMarker		ifTrue: [ leftEdge := leftEdge + self submorphBounds width + 8 ].	stringBounds := bounds left: bounds left + leftEdge.	aCanvas		drawString: contents		in: stringBounds		font: self fontToUse		color: stringColor.	subMenu		ifNotNil: [aCanvas image: SubMenuMarker at: self right - 8 @ (self top + self bottom - SubMenuMarker height // 2)]! !!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:32'!drawOn: aCanvas	"draw background image."	backgroundImage		ifNotNil: [			"self clipsSubmorphs ifTrue: [				aCanvas clipBy: self clippingBounds					during: [ :canvas | canvas image: backgroundImage multipliedBy: color at: bounds topLeft ]]				ifFalse: [ aCanvas image: backgroundImage multipliedBy: color at: bounds topLeft ]"			self clipsSubmorphs ifTrue: [				aCanvas clipBy: self clippingBounds					during: [ :canvas | canvas image: backgroundImage at: bounds topLeft ]]				ifFalse: [ aCanvas image: backgroundImage at: bounds topLeft ]]		ifNil: [			"draw background fill"			(self isWorldMorph and: [aCanvas drawsOnDisplay] and: [(color := self fillStyle) class == TranslucentColor])				ifTrue: [					"Special case so a translucent background on the Display allows you to see through the main Squeak Window.					Requires proper handling of translucent Display in the VM.					Seems to work only on Linux when using a composing window manager."					(BitBlt current toForm: Display)						clipRect: aCanvas clipRect;						copy: bounds						from: 0@0 in: nil						fillColor: color rule: Form over]				ifFalse: [ super drawOn: aCanvas ]]! !!PolygonMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:23'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue: [		self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft-1 ].	lineColor _ borderColor. 	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo: [ :p1 :p2 |		p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue: [			(borderWidth > 3 and: [borderColor is: #Color])			ifTrue: [brush ifNil: [						brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil: [		self arrowForms do: [ :f |			f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'jmv 3/17/2011 22:04'!dumpTallyOnTranscript: tally	"tally is from ProcessorScheduler>>tallyCPUUsageFor:	Dumps lines with percentage of time, hash of process, and a friendly name"	self dumpTally: tally on: Transcript! !!ScrollbarButton methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:22'!drawOn: aCanvas	super drawOn: aCanvas.	aCanvas image: image at: self position! !!SketchMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:23'!drawOn: aCanvas	aCanvas image: originalForm at: bounds origin! !!TestCase methodsFor: 'Running' stamp: 'jmv 3/17/2011 22:04'!logFailure: aString	self isLogging ifTrue: [		self failureLog 			cr; 			nextPutAll: aString ]! !!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 3/17/2011 22:25'!drawOn: aCanvas	"	Transcript		showOnDisplay: true;		bounds: bounds;		displayOn: aCanvas form.	"	Transcript		showOnDisplay: true;		bounds: (0@0 extent: bounds extent);		displayOn: form;		bounds: bounds.	aCanvas image: form at: bounds origin! !!Utilities class methodsFor: 'closure support' stamp: 'jmv 3/17/2011 22:04'!compileUsingClosures	"Utilities compileUsingClosures"	"Recompile the system and do some minimal clean-ups"	| classes compilationErrors |	Preferences setPreference: #allowBlockArgumentAssignment toValue: false.	compilationErrors := Set new.	classes := Smalltalk forgetDoIts allClasses reject: [:c| c name == #GeniePlugin].	'Recompiling The System' displayProgressAt: Sensor cursorPoint		from: 0 to: classes size during:[:bar |			classes withIndexDo:[:c :i|				bar value: i.				{ c. c class } do:[:b|					"Transcript cr; print: b; endEntry."					b selectors "asArray sort" do: [ :s | 						"Transcript cr; show: b asString, '>>', s."						[b recompile: s from: b] on: Error do:[:ex|							Transcript								cr; nextPutAll: 'COMPILATION ERROR: ';								print: b; nextPutAll: '>>'; nextPutAll: s.							compilationErrors add: (MethodReference class: b selector: s)]]]]].	compilationErrors notEmpty ifTrue:[		Smalltalk			browseMessageList: compilationErrors asArray sort			name: 'Compilation Errors' ]! !!WorldState methodsFor: 'canvas' stamp: 'jmv 3/17/2011 22:04'!assuredNonDisplayCanvas	(canvas isNil or: [		canvas drawsOnDisplay or: [		(canvas extent ~= viewBox extent) or: [		canvas form depth ~= Display depth]]])			ifTrue: [				"allocate a new offscreen canvas the size of the window"				self canvas: (Display defaultCanvasClass extent: viewBox extent depth: Display depth)].	^ self canvas! !!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/17/2011 22:04'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m doLayoutIfNeeded].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [ self assuredNonDisplayCanvas ].	"repair world's damage on canvas"	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.	"self handsDo:[:h | h noticeDamageRects: worldDamageRects ]."	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [ :h | h savePatchFrom: canvas ].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [ self forceDamageToScreen: allDamage ]		ifFalse: [ canvas showAt: aWorld viewBox origin invalidRects: allDamage ].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate! !!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/17/2011 22:04'!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	] ifFalse: [  "this world is inside an MVC window"		self revisar.		self halt.	].	^ true! !Transcript class removeSelector: #flush!ImageMorph removeSelector: #addCustomMenuItems:hand:!ImageMorph removeSelector: #changeOpacity!ImageMorph removeSelector: #isOpaqueMorph!ImageMorph removeSelector: #opacityString!ImageMorph removeSelector: #opaque!ImageMorph removeSelector: #opaque:!!classDefinition: #ImageMorph category: #'Morphic-Basic'!Morph subclass: #ImageMorph	instanceVariableNames: 'image'	classVariableNames: 'DefaultForm'	poolDictionaries: ''	category: 'Morphic-Basic'!!ImageMorph reorganize!('accessing' borderWidth: color: form image:)('drawing' drawOn:)('geometry' extent:)('initialization' initialize)('menu commands' grabFromScreen readFromFile)!Morph removeSelector: #shadowColor!Morph removeSelector: #shadowColor:!GrafPort removeSelector: #contentsOfArea:into:!GrafPort removeSelector: #image:at:sourceRect:rule:alpha:!FormCanvas class removeSelector: #extent:!FormCanvas class removeSelector: #test1!FormCanvas class removeSelector: #test2!FormCanvas class removeSelector: #test3!FormCanvas removeSelector: #allocateForm:!FormCanvas removeSelector: #copyOffset:!FormCanvas removeSelector: #drawImage:at:!FormCanvas removeSelector: #drawImage:at:sourceRect:!FormCanvas removeSelector: #fillColor:!FormCanvas removeSelector: #finish!FormCanvas removeSelector: #flushDisplay!FormCanvas removeSelector: #forceToScreen:!FormCanvas removeSelector: #frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor:!FormCanvas removeSelector: #image:at:sourceRect:rule:alpha:!FormCanvas removeSelector: #image:multipliedBy:in:!FormCanvas removeSelector: #paintImage:at:!FormCanvas removeSelector: #paintImage:at:sourceRect:!FormCanvas removeSelector: #point:color:!FormCanvas removeSelector: #setClearColor:!FormCanvas removeSelector: #shadowColor!FormCanvas removeSelector: #showAt:!FormCanvas removeSelector: #translucentImage:at:!FormCanvas removeSelector: #translucentImage:at:sourceRect:!FormCanvas removeSelector: #translucentImage:multipliedBy:at:!FormCanvas removeSelector: #warpFrom:toRect:!!classDefinition: #FormCanvas category: #'Morphic-Support'!Object subclass: #FormCanvas	instanceVariableNames: 'origin clipRect form port shadowColor'	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'	poolDictionaries: ''	category: 'Morphic-Support'!!FormCanvas reorganize!('accessing' clipRect contentsOfArea:into: depth extent form formWithOffset origin shadowColor:)('copying' copy copyClipRect: copyOffset:clipRect: copyOrigin:clipRect:)('drawing' line:to:brushForm: line:to:width:color: line:to:width:color:dashLength:secondColor:secondDashLength:startingOffset: paragraph:bounds:color:)('drawing-general' drawMorph: fullDrawMorph:)('drawing-images' image:at: image:at:sourceRect: image:multipliedBy:at: stencil:at:color: stencil:at:sourceRect:color:)('drawing-ovals' fillOval:color:borderWidth:borderColor:)('drawing-rectangles' fillRectangle:color: fillRectangle:fillStyle: fillRectangle:fillStyle:borderWidth:borderStyleSymbol: fillRectangle:fillStyle:borderWidth:borderStyleSymbol:baseColorForBorder: fillRectangle:infiniteForm:multipliedBy: fillRectangle:tilingWith:sourceRect:rule: frameAndFillRectangle:fillColor:borderWidth:borderColor: frameRectangle:borderWidth:topLeftColor:bottomRightColor: frameRectangle:color: frameRectangle:color:borderWidth:borderStyleSymbol: frameRectangle:width:color:)('drawing-roundedRectangles' roundRect:color:radius: roundRect:color:radius:gradientTop:gradientBottom:gradientHeight: windowFrame:color:radius:border:labelHeight:gradientTop:gradientBottom:insideColor:)('drawing-support' clipBy:during:)('drawing-text' drawString:at:font:color: drawString:from:to:at:font:color: drawString:from:to:in:font:color: drawString:in:font:color: drawStringEmbossed:from:to:in:font:color: drawStringEmbossed:in:font:color:)('initialization' reset)('other' showAt:invalidRects:)('printing' printOn:)('testing' drawsOnDisplay isShadowDrawing isVisible:)('private' buildAuxWith:multipliedWith: image:at:sourceRect:rule: portClass resetGrafPort setFillColor: setForm: setOrigin: setOrigin:clipRect: setPaintColor:)!Form removeSelector: #allocateForm:!Form removeSelector: #contentsOfArea:!Form removeSelector: #contentsOfArea:into:!Form removeSelector: #finish!Form removeSelector: #flush!Form removeSelector: #stencil!Smalltalk removeClassNamed: #Canvas!Smalltalk removeClassNamed: #TraslucentImageLW!