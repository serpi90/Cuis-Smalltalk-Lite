'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 14 April 2011 at 4:17:32 pm'!!classDefinition: #ScrollbarButton category: #'Morphic-Support'!BorderedMorph subclass: #ScrollbarButton	instanceVariableNames: 'image '	classVariableNames: 'Arrows Box CurrentSize '	poolDictionaries: ''	category: 'Morphic-Support'!!Morph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 15:05'!height: aNumber	self extent: bounds width@aNumber asInteger.! !!Morph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 15:05'!width: aNumber	self extent: aNumber asInteger@bounds height.! !!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/14/2011 14:38'!referencePosition	"Return the current reference position of the receiver"	"a rather ugly way to say #center . At least, we avoid false polymorphism"	^bounds center! !!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/14/2011 14:38'!referencePosition: aPoint	"a rather ugly way to say #center: . Just for consistency with #referencePosition"	self position: aPoint - (bounds extent // 2)! !!BareTextMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 14:57'!extent: aPoint	| newExtent priorEditor |	priorEditor _ editor.	"Resist changing the extent if no wordwrap.. this should be checked."	wrapFlag ifFalse: [ ^ self ].	newExtent _ aPoint truncated max: self minimumExtent.		"No change of wrap width"	newExtent x = bounds extent x ifTrue: [ ^ self ].	"invalidate the paragraph cache"	self releaseParagraph.		super extent: newExtent.	priorEditor		ifNil: [			"since the width has changed..." 			self fit ]		ifNotNil: [ self installEditorToReplace: priorEditor ].! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 14:52'!fit	"Adjust my bounds to fit the text.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para |	newExtent := (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).	newExtent ~= bounds extent 		ifTrue: [			para := paragraph.	"Save para (layoutChanged smashes it)"			self basicExtent: newExtent.			paragraph := para].	"These statements should be pushed back into senders"	self paragraph positionWhenComposed: bounds topLeft.	self redrawNeeded.	"Too conservative: only paragraph composition							should cause invalidation."	editView innerHeight: newExtent y! !!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 4/14/2011 14:57'!drawOn: aCanvas	aCanvas		image: (self class circleForm: bounds extent)		multipliedBy: (color alpha: 0.57)		at: bounds topLeft.! !!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 4/14/2011 14:37'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	| |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.	positionOffset _ dragHandle referencePosition - (target externalizePositionFromOwner: target position to: owner)! !!HaloMorph methodsFor: 'event handling' stamp: 'jmv 4/14/2011 14:09'!mouseMove: evt	"Drag our target around"	| thePoint |	thePoint _ target internalizePositionToOwner: (evt position - positionOffset) from: owner.	target position: thePoint! !!HaloMorph methodsFor: 'events' stamp: 'jmv 4/14/2011 14:06'!dragTarget: event	"Begin dragging the target"	| thePoint |	thePoint _ target internalizePositionToOwner: event position - positionOffset from: owner.	target position: thePoint.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'updating' stamp: 'jmv 4/14/2011 15:04'!redrawNeeded	"Quicker to invalidate handles individually if target is large (especially the world)"	bounds extent > (200@200)		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [					"Invalidate 4 outer strips first, thus subsuming separate damage."					(self fullDisplayBounds areasOutside: target bounds) do:						[ :r | self invalidRect: r ]].				self submorphsDo: [:m | m redrawNeeded]]		ifFalse: [ super redrawNeeded ]! !!HaloMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 13:47'!addHandle: handleSpec on: eventName send: selector to: recipient 	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle aPoint iconName colorToUse aMorph |	aPoint := self 				positionIn: haloBox				horizontalPlacement: handleSpec horizontalPlacement				verticalPlacement: handleSpec verticalPlacement.	handle := HaloHandleMorph 				newBounds: (Rectangle center: aPoint extent: HandleSize asPoint)				color: (colorToUse := Color colorFrom: handleSpec color).	self addMorph: handle.	(iconName := handleSpec iconSymbol) ifNotNil: [			| form |			form := Icons at: iconName ifAbsent: [self class perform: iconName].			form ifNotNil: [				aMorph _ ImageMorph new					image: form;					color: colorToUse makeForegroundColor;					lock.				aMorph position: aPoint - (form extent // 2).				handle addMorphFront: aMorph.				]].	handle 		on: #mouseUp		send: #endInteraction		to: self.	handle 		on: eventName		send: selector		to: recipient.	handle 		setBalloonText: (target balloonHelpTextForHandle: handle).	^handle! !!HaloMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 10:52'!basicBox	| aBox minSide anExtent w |	minSide _ 4 * self handleSize.	anExtent _ ((self width + self handleSize + 8) max: minSide) @				((self height + self handleSize + 8) max: minSide).	aBox _ Rectangle center: bounds center extent: anExtent.	w _ self world ifNil: [ target outermostWorldMorph ].	^ w		ifNil:			[ aBox ]		ifNotNil:			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !!HaloMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 14:07'!doDrag: evt with: dragHandle	| thePoint |	evt hand obtainHalo: self.	thePoint _ target internalizePositionToOwner: evt position - positionOffset from: owner.	target position: thePoint! !!HaloMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 14:58'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent |self revisar.	evt hand obtainHalo: self."Como podria andar el grow de un morph embebido en otro? andara ahora?"newExtent _ evt cursorPoint - positionOffset - target bounds topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].	target extent: newExtent.	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged! !!HandMorph methodsFor: 'paste buffer' stamp: 'jmv 4/14/2011 14:39'!pasteMorph	| pastee |	pastee _ Clipboard retrieveMorph.	pastee ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: pastee.	pastee align: pastee referencePosition with: self position! !!HandleMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 4/14/2011 14:31'!justDroppedInto: aMorph event: anEvent	"So that when the hand drops me (into the world) I go away"	lastPointBlock ifNotNil: [lastPointBlock value: bounds center].	self flag: #arNote. "Probably unnecessary"	anEvent hand releaseKeyboardFocus: self.	self redrawNeeded.	self delete! !!HandleMorph methodsFor: 'stepping and presenter' stamp: 'jmv 4/14/2011 14:31'!step	pointBlock value: bounds center! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:24'!bottom	^bounds bottom! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:24'!left	^bounds left! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:24'!right	^bounds right! !!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:24'!top	^bounds top! !!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 4/14/2011 14:31'!adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |	doNotResizeBelow _ self minPaneWidthForReframe.	i _ submorphs indexOf: aLayoutAdjustMorph.	l _ self submorphs at: i +1.	ls _ l layoutSpec.	lCurrentWidth _ l width max: 1.	"avoid division by zero"	r _ self submorphs at: i - 1.	rs _ r layoutSpec.	rCurrentWidth _ r width max: 1.	"avoid division by zero"	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.	delta _ delta max: doNotResizeBelow - lCurrentWidth.	delta _ delta min: rCurrentWidth - doNotResizeBelow.	delta = 0 ifTrue: [ ^self ].	rNewWidth _ rCurrentWidth - delta.	lNewWidth _ lCurrentWidth + delta.	(ls isProportionalWidth and: [ rs isProportionalWidth ])		ifTrue: [	"If both proportional, update them"			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]		ifFalse: ["If at least one is fixed, update only the fixed"			ls isProportionalWidth ifFalse: [				ls fixedOrMorphWidth: lNewWidth ].			rs isProportionalWidth ifFalse: [				rs fixedOrMorphWidth: rNewWidth ]].	self layoutAndComputeFullBounds! !!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 4/14/2011 14:31'!adjustVerticallyBy: aLayoutAdjustMorph at: aPoint	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |	doNotResizeBelow _ self minPaneHeightForReframe.	i _ submorphs indexOf: aLayoutAdjustMorph.	t _ self submorphs at: i +1.	ts _ t layoutSpec.	tCurrentHeight _ t height max: 1.	"avoid division by zero"	b _ self submorphs at: i - 1.	bs _ b layoutSpec.	bCurrentHeight _ b height max: 1.	"avoid division by zero"	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.	delta _ delta max: doNotResizeBelow - tCurrentHeight.	delta _ delta min: bCurrentHeight - doNotResizeBelow.	delta = 0 ifTrue: [ ^self ].	tNewHeight _ tCurrentHeight + delta.	bNewHeight _ bCurrentHeight - delta.	(ts isProportionalHeight and: [ bs isProportionalHeight ])		ifTrue: [	"If both proportional, update them"			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]		ifFalse: ["If at least one is fixed, update only the fixed"			ts isProportionalHeight ifFalse: [				ts fixedOrMorphHeight: tNewHeight ].			bs isProportionalHeight ifFalse: [				bs fixedOrMorphHeight: bNewHeight ]].	self layoutAndComputeFullBounds! !!LazyListMorph methodsFor: 'list management' stamp: 'jmv 4/14/2011 14:21'!drawBoundsForRow: row	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"	| topLeft drawBounds |	topLeft _ bounds left @ (bounds top + ((row - 1) * (font height))).	drawBounds _ topLeft extent: bounds width @ font height.	^drawBounds! !!LazyListMorph methodsFor: 'list management' stamp: 'jmv 4/14/2011 10:43'!rowAtLocation: aPoint	"return the number of the row at aPoint"	| y y0 |	y0 _ bounds top.	y _ aPoint y.	y < y0 ifTrue: [ ^ 1 ].	^((y - y0 // (font height)) + 1) min: listItems size max: 0! !!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 14:40'!borderWidth: anInteger	"Grow outwards preserving innerBounds"	| c |  	c _ self referencePosition.	super borderWidth: anInteger.	super extent: self defaultExtent.	self referencePosition: c.! !!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 4/14/2011 14:58'!chooseMagnification	| result |	result _ (SelectionMenu selections: #(1.5 2 4 8))		startUpWithCaption: 'Choose magnification(currently ', magnification printString, ')'.	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].	magnification _ result.	self extent: bounds extent. "round to new magnification"	self redrawNeeded. "redraw even if extent wasn't changed"! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 4/14/2011 14:41'!magnification: aNumber	| c |  	magnification _ aNumber min: 8 max: 0.5.	magnification _ magnification roundTo:		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).	srcExtent _ srcExtent min: (512@512) // magnification. "to prevent accidents"	c _ self referencePosition.	super extent: self defaultExtent.	self referencePosition: c.! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 4/14/2011 11:20'!sourcePoint	"If we are being dragged use our center, otherwise use pointer position"	^(trackPointer not or: [owner notNil and: [owner is: #HandMorph]])		ifTrue: [bounds center]		ifFalse: [self currentHand position]! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 4/14/2011 11:07'!contents: aString withMarkers: aBool inverse: inverse 	"Set the menu item entry. If aBool is true, parse aString for embedded markers."	| markerIndex marker |	self contentString: nil.	"get rid of old"	aBool ifFalse: [^super contents: aString].	self removeAllMorphs.	"get rid of old markers if updating"	self hasIcon ifTrue: [ self icon: nil ].	(aString notEmpty and: [aString first = $<]) 		ifFalse: [^super contents: aString].	markerIndex := aString indexOf: $>.	markerIndex = 0 ifTrue: [^super contents: aString].	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 		ifFalse: [^super contents: aString].	self contentString: aString.	"remember actual string"	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 				ifTrue: [self onImage]				ifFalse: [self offImage].	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).	"And set the marker"	marker := ImageMorph new image: marker.	marker position: bounds left @ (bounds top + 2).	self addMorphFront: marker! !!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 4/14/2011 10:51'!drawOn: aCanvas 	| stringColor stringBounds leftEdge |	stringColor := color.	isSelected & isEnabled		ifTrue: [			aCanvas fillRectangle: bounds colorOrInfiniteForm: Theme current menuHighlight].	leftEdge := 0.	self hasIcon		ifTrue: [| iconForm | 			iconForm := isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ].			aCanvas image: iconForm at: bounds left @ (bounds top + (bounds height - iconForm height // 2)).			leftEdge := iconForm width + 2].	self hasMarker		ifTrue: [ leftEdge := leftEdge + self submorphBounds width + 8 ].	stringBounds := bounds left: bounds left + leftEdge.	aCanvas		drawString: contents		in: stringBounds		font: self fontToUse		color: stringColor.	subMenu		ifNotNil: [ aCanvas image: SubMenuMarker at: bounds right - 8 @ (bounds top + bounds bottom - SubMenuMarker height // 2) ]! !!MenuMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 14:10'!adjustSubmorphsLayout	"Enlarge the width of submorphs as needed	so all of them are have the same width, and no less than #minWidth.	Also adjust their vertical position.	Finally, set our own extent."		| w p tl |		submorphs isEmpty ifTrue: [ ^self ].	w _ submorphs inject: 0 into: [ :prev :each |		prev max: (			(each respondsTo: #minItemWidth)				ifTrue: [each minItemWidth]				ifFalse: [each width])].	tl _ bounds topLeft.	p _ tl + 5.	submorphs do: [ :m |		m width: w.		m position: p.		p _ m bounds bottomLeft + (0@2) ].		self extent: submorphs last bounds bottomRight - tl + 5! !!MenuMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 10:36'!positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld	"Note: items may not be laid out yet (I found them all to be at 0@0),  	so we have to add up heights of items above the selected item."	| i yOffset sub delta |	self adjustSubmorphsLayout.	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	"If it doesn't fit, show it to the left, not to the right of the hand."	bounds right > aWorld world bounds right		ifTrue:			[self moveRight: aPoint x + 1].	"Make sure that the menu fits in the world."	delta _ bounds amountToTranslateWithin:		(aWorld world bounds withHeight: ((aWorld world bounds height - 18) max: (ActiveHand position y) + 1)).	delta = (0 @ 0) ifFalse: [self position: self position + delta]! !!MenuMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:29'!moveRight: aNumber	self position: ((aNumber - bounds width) @ bounds top)! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 4/14/2011 14:11'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| w titleString |	titleString _ titleMorph submorphs first.	self visible: false.	w _ ActiveWorld.	aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		titleString contents: string.		titleMorph width: titleString width + 8.		self position: Sensor cursorPoint.		self adjustSubmorphsLayout.		self redrawNeeded.		w displayWorld		 "show myself"	]. 	self delete.	w displayWorld! !!PolygonMorph methodsFor: 'editing' stamp: 'jmv 4/14/2011 14:23'!dragVertex: ix event: evt fromHandle: handle	| p |	p _ evt cursorPoint.	handle referencePosition: p.	self verticesAt: ix put: p.! !!PolygonMorph methodsFor: 'editing' stamp: 'jmv 4/14/2011 14:56'!updateHandles	| newVert oldVert midPts nextVertIx tweens |	smoothCurve		ifTrue: [			handles first referencePosition: vertices first.			handles last referencePosition: vertices last.			midPts _ OrderedCollection new.			nextVertIx _ 2.			tweens _ OrderedCollection new.			self				lineSegmentsDo: [:p1 :p2 | 					tweens addLast: p2 asIntegerPoint.					p2							= (vertices atWrap: nextVertIx)						ifTrue: ["Found endPoint."							midPts addLast: (tweens at: tweens size // 2)									+ (tweens at: tweens size + 1 // 2) // 2.							tweens _ OrderedCollection new.							nextVertIx _ nextVertIx + 1]].			midPts				withIndexDo: [:midPt :vertIndex | (closed							or: [vertIndex < vertices size])						ifTrue: [newVert _ handles at: vertIndex * 2.							newVert referencePosition: midPt ]]]		ifFalse: [vertices				withIndexDo: [:vertPt :vertIndex | 					oldVert _ handles at: vertIndex * 2 - 1.					oldVert referencePosition: vertPt.					(closed							or: [vertIndex < vertices size])						ifTrue: [newVert _ handles at: vertIndex * 2.							newVert position: vertPt									+ (vertices atWrap: vertIndex + 1) - newVert bounds extent // 2 + (1 @ -1)]]]! !!PolygonMorph methodsFor: 'halo control' stamp: 'jmv 4/14/2011 10:53'!rotationDegrees: degrees 	| center |	center _ bounds center.	self setVertices: (vertices collect: [ :v |		v inverseRotateBy: (degrees - self forwardDirection) degreesToRadians negated about: center ]).	self forwardDirection: degrees! !!BalloonMorph methodsFor: 'menus' stamp: 'jmv 4/14/2011 14:36'!adjustedCenter	"This horizontal adjustment is needed because we want the interior TextMorph to be centered within the visual balloon rather than simply within the BalloonMorph's bounding box.  Without this, balloon-help text would be a bit off-center"	^ self referencePosition + (offsetFromTarget x sign * (5 @ 0))! !!BalloonMorph class methodsFor: 'instance creation' stamp: 'jmv 4/14/2011 14:34'!string: str for: morph corner: cornerName 	"Make up and return a balloon for morph. Find the quadrant that 	clips the text the least, using cornerName as a tie-breaker. tk 9/12/97"	| tm vertices instance |	tm _ self getTextMorph: str for: morph.	vertices _ self getVertices: tm displayBounds.	vertices _ self				getBestLocation: vertices				for: morph				corner: cornerName.	instance _ self new		color: morph balloonColor;		 setVertices: vertices;		 addMorph: tm;		 setTarget: morph.	tm referencePosition: instance adjustedCenter.	^instance! !!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/14/2011 10:31'!left	^ bounds left! !!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/14/2011 15:02'!sliderExtent	^slider bounds extent! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/14/2011 14:43'!setNextDirectionFromEvent: event	nextPageDirection _ bounds isWide ifTrue: [		event cursorPoint x >= slider referencePosition x	]	ifFalse: [		event cursorPoint y >= slider referencePosition y	]! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 4/14/2011 14:59'!updateDownButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #bottom size: bounds extent.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 4/14/2011 14:59'!updateLeftButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #left size: bounds extent.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 4/14/2011 14:59'!updateRightButtonImage	"update the receiver's as a downButton.  put a new image inside"	image _ self class arrowOfDirection: #right size: bounds extent.	self redrawNeeded! !!ScrollbarButton methodsFor: 'initialization' stamp: 'jmv 4/14/2011 14:59'!updateUpButtonImage	"update the receiver's as a upButton. put a new image inside"	image _ self class arrowOfDirection: #top size: bounds extent.	self redrawNeeded! !!ScrollbarButton methodsFor: 'drawing' stamp: 'jmv 4/14/2011 14:52'!drawOn: aCanvas	super drawOn: aCanvas.	aCanvas image: image at: bounds topLeft! !!ScrollbarButton methodsFor: 'geometry' stamp: 'jmv 4/14/2011 10:34'!bottom	^ bounds bottom! !!ScrollbarButton methodsFor: 'geometry' stamp: 'jmv 4/14/2011 10:34'!right	^ bounds right! !!ScrollbarButton class methodsFor: 'images' stamp: 'jmv 4/14/2011 13:40'!arrowOfDirection: aSymbol size: finalSizeInteger	"answer a form with an arrow based on the parameters"	CurrentSize = finalSizeInteger ifFalse: [		self initializeArrows: finalSizeInteger ].	^Arrows at: aSymbol! !!ScrollbarButton class methodsFor: 'images' stamp: 'jmv 4/14/2011 13:43'!createArrowOfDirection: aSymbolDirection size: finalSizeInteger	"PRIVATE - create an arrow with aSymbolDirectionDirection,  	finalSizeInteger and aColor  	 	aSymbolDirectionDirection = #top, #bottom. #left or #right  	 (self createArrowOfDirection: #up size: 120) display	"	| resizeFactor outerBox arrowMorph resizedForm f |	resizeFactor := 4.	outerBox := RectangleMorph new.	outerBox		extent: finalSizeInteger asPoint * resizeFactor;		borderWidth: 0;		color: Color transparent.		arrowMorph := self createArrowIn: outerBox bounds.	arrowMorph position: outerBox bounds center - (arrowMorph extent // 2).	outerBox addMorphFront: arrowMorph.		f _ outerBox imageForm: 32.	resizedForm := f				magnify: f boundingBox				by: 1 / resizeFactor				smoothing: 4.	aSymbolDirection == #right		ifTrue: [resizedForm _ resizedForm rotateBy: 90].	aSymbolDirection == #bottom		ifTrue: [resizedForm _ resizedForm rotateBy:  180].	aSymbolDirection == #left		ifTrue: [resizedForm _ resizedForm rotateBy:  270].			aSymbolDirection == #up		ifFalse: [ resizedForm _ resizedForm			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].			^resizedForm! !!ScrollbarButton class methodsFor: 'images' stamp: 'jmv 4/14/2011 13:40'!initializeArrows: finalSizeInteger	Arrows _ Dictionary new.	#(#top #bottom #left #right ) do: [ :dir |		Arrows at: dir put: (self createArrowOfDirection: dir size: finalSizeInteger) ].	CurrentSize _ finalSizeInteger! !!SketchMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 14:59'!extent: newExtent	"Change my scale to fit myself into the given extent."	bounds extent = newExtent ifTrue:[^self].	self layoutChanged.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jmv 4/14/2011 14:34'!originalColor: colorOrSymbol 	"Set the receiver's original color.  It is at this point that a command is launched to represent the action of the picker, in support of Undo."	originalColor := (colorOrSymbol is: #Color) 				ifTrue: [colorOrSymbol]				ifFalse: [Color lightGreen].	originalForm fill: RevertBox fillColor: originalColor.	selectedColor := originalColor.	self locationIndicator 		referencePosition: bounds topLeft + (self positionOfColor: originalColor)! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'jmv 4/14/2011 11:08'!initializeModal: beModal 	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	| tl |	isModal := beModal.	self removeAllMorphs.	tl _ bounds topLeft.	self addMorph: ((Morph newBounds: (DragBox translateBy: tl))				color: Color transparent;				setBalloonText: 'put me somewhere').	self 		addMorph: ((Morph newBounds: (RevertBox translateBy: tl))				color: Color transparent;				setBalloonText: 'restore original color').	self 		addMorph: ((Morph newBounds: (FeedbackBox translateBy: tl))				color: Color transparent;				setBalloonText: 'shows selected color').	self 		addMorph: ((Morph newBounds: (TransparentBox translateBy: tl))				color: Color transparent;				setBalloonText: 'adjust translucency').	self buildChartForm.	selectedColor ifNil: [selectedColor := Color white].	sourceHand := nil.	deleteOnMouseUp := false.	updateContinuously := true! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 4/14/2011 11:10'!pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt oldCursor |	aHand _ aMorph ifNil: [self activeHand] ifNotNil: [aMorph activeHand].	aHand ifNil: [aHand _ self currentHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullDisplayBounds.	self owner ifNil: [^ self].	oldCursor _ Sensor currentCursor.	ColorPickerMorph eyeDropperCursor show.	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	localPt _ Sensor cursorPoint - bounds topLeft.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt) ifTrue:			["Click or drag the drag-dot means to anchor as a modeless picker"			^ self anchorAndRunModeless: aHand].	].	(clickedTranslucency _ TransparentBox containsPoint: localPt)		ifTrue: [selectedColor _ originalColor].	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	aHand newMouseFocus: nil;		flushEvents.	oldCursor show.	self delete.		  ! !!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 11:02'!pickColorAt: aGlobalPoint	| alpha selfRelativePoint pickedColor |	clickedTranslucency ifNil: [clickedTranslucency _ false].	selfRelativePoint _ (self internalizePositionToOwner: aGlobalPoint from: nil) - bounds topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue:		[clickedTranslucency ifFalse: [^ self].  "Can't wander into translucency control"		alpha _ (selfRelativePoint x - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"		self 			updateColor: (selectedColor alpha: alpha)			feedbackColor: (selectedColor alpha: alpha).		^ self].	"pick up color, either inside or outside this world"	clickedTranslucency ifTrue: [^ self].  "Can't wander out of translucency control"	self locationIndicator visible: false. self refreshWorld.	pickedColor _ Display colorAt: aGlobalPoint.	self locationIndicator visible: true. self refreshWorld.	self 		updateColor: (			((selectedColor is: #Color) and: [ selectedColor isOpaque not ])						ifTrue: [ pickedColor alpha: selectedColor alpha ]						ifFalse: [ pickedColor ]		)		feedbackColor: pickedColor! !!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 11:04'!trackColorAt: aGlobalPoint 	"Before the mouse comes down in a modal color picker, track the color under the cursor, and show it in the feedback box, but do not make transparency changes"	| selfRelativePoint pickedColor |	selfRelativePoint _ (self internalizePositionToOwner: aGlobalPoint from: nil) - bounds topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue: [^ self].	"pick up color, either inside or outside this world"	pickedColor _ Display colorAt: aGlobalPoint.	self updateColor: (pickedColor alpha: originalColor alpha)		feedbackColor: pickedColor! !!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 4/14/2011 14:33'!updateColor: aColor feedbackColor: feedbackColor	"Set my selected color to the given color if it is different. Give user feedback. Inform the target of the change if the target and selector are not nil." 	selectedColor = aColor ifTrue: [^ self].  "do nothing if color doesn't change"	self updateAlpha: aColor alpha.	originalForm fill: FeedbackBox fillColor: feedbackColor.	self form: originalForm.	selectedColor _ aColor.	updateContinuously ifTrue: [self updateTargetColor].	self locationIndicator referencePosition: bounds topLeft + (self positionOfColor: feedbackColor).! !!StarMorph methodsFor: 'editing' stamp: 'jmv 4/14/2011 15:03'!dragVertex: label event: evt fromHandle: handle	| ext oldR pt center |	label == #center ifTrue:		[self position: self position + (evt cursorPoint - handle referencePosition)].	label == #outside ifTrue:		[center _ handles first referencePosition.		pt _ center - evt cursorPoint.		ext _ pt r.		oldR _ ext.		vertices _ (0 to: 359 by: (360//vertices size)) collect:			[:angle |			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])					degrees: angle + pt degrees)				+ center].		handle align: handle referencePosition with: evt cursorPoint].	self computeBounds.! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 4/14/2011 15:00'!makeMeVisible 	self world extent > (0@0) ifFalse: [^ self].	(self position >= (0@0) and: [ self position < (self world extent-self labelHeight)]) ifTrue: [		^ self "OK -- at least my top left is visible"].	"window not on screen (probably due to reframe) -- move it now"	self isCollapsed		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:11'!bottom: aNumber	self bounds: (bounds bottom: aNumber)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:12'!bottomLeft: aPoint	self bounds: (aPoint x @ bounds top corner: bounds right @ aPoint y)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:12'!bottomRight: aPoint	self bounds: (bounds origin corner: aPoint)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 15:00'!extent: aPoint 	"Set the receiver's extent to value provided. Respect my minimumExtent."	| newExtent |	newExtent _ self isCollapsed		ifTrue: [aPoint]		ifFalse: [aPoint max: self minimumExtent].	newExtent = bounds extent ifTrue: [^ self].	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	isCollapsed		ifTrue: [collapsedFrame _ bounds]		ifFalse: [fullFrame _ bounds]! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:11'!left: aNumber	self bounds: (bounds left: aNumber)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:14'!right: aNumber	self bounds: (bounds right: aNumber)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:13'!top: aNumber	self bounds: (bounds top: aNumber)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:14'!topLeft: aPoint	self bounds: (aPoint corner: bounds corner)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/14/2011 11:14'!topRight: aPoint	self bounds: (bounds left @ aPoint y corner: aPoint x @ bounds bottom)! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 10:45'!bottom	^bounds bottom! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 4/14/2011 10:45'!top	^bounds top! !ScrollbarButton class removeSelector: #boxOfSize:!ScrollbarButton class removeSelector: #createBoxIn:!ScrollbarButton class removeSelector: #createBoxOfSize:!ScrollbarButton class removeSelector: #initializeArrowsAndBox:!!classDefinition: #ScrollbarButton category: #'Morphic-Support'!BorderedMorph subclass: #ScrollbarButton	instanceVariableNames: 'image'	classVariableNames: 'Arrows CurrentSize'	poolDictionaries: ''	category: 'Morphic-Support'!HaloMorph removeSelector: #addHandleAt:color:icon:on:send:to:!Morph removeSelector: #addMorphCentered:!Morph removeSelector: #bottom!Morph removeSelector: #bottom:!Morph removeSelector: #bottomCenter!Morph removeSelector: #bottomLeft!Morph removeSelector: #bottomLeft:!Morph removeSelector: #bottomRight!Morph removeSelector: #bottomRight:!Morph removeSelector: #center!Morph removeSelector: #center:!Morph removeSelector: #left!Morph removeSelector: #left:!Morph removeSelector: #leftCenter!Morph removeSelector: #moveRight:!Morph removeSelector: #openCenteredInWorld!Morph removeSelector: #right!Morph removeSelector: #right:!Morph removeSelector: #rightCenter!Morph removeSelector: #setConstrainedPosition:hangOut:!Morph removeSelector: #setExtentFromHalo:!Morph removeSelector: #top!Morph removeSelector: #top:!Morph removeSelector: #topCenter!Morph removeSelector: #topLeft!Morph removeSelector: #topLeft:!Morph removeSelector: #topRight!Morph removeSelector: #topRight:!LightWidget removeSelector: #setExtentFromHalo:!