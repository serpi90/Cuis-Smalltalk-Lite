'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 19 December 2011 at 3:02:47 pm'!!AutoCompleter methodsFor: 'entries' stamp: 'jmv 12/19/2011 12:18'!                             insertSelected	| entry editor selEnd str |	entry _ self selectedEntry.	editor _ textMorph editor.	str _ model actualContents string.	selEnd _ position.	[selEnd < str size and: [ (str at: selEnd+1) tokenish ]] whileTrue: [ selEnd _ selEnd + 1 ].	(selEnd < str size and: [ (str at: selEnd+1) = $ ]) ifTrue: [ selEnd _ selEnd + 1].	editor selectFrom: position-prefix size+1 to: selEnd.	editor		replaceSelectionWith: entry;		deselectAndPlaceCursorAt: position - prefix size + 1 + (self newCursorPosition: entry).	textMorph redrawNeeded.	menuMorph delete.	menuMorph _ nil.	^ true! !!Editor methodsFor: 'menu messages' stamp: 'jmv 12/19/2011 12:24'!          paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary."	self replaceSelectionWith: self clipboardStringOrText! !!Editor methodsFor: 'menu messages' stamp: 'jmv 12/19/2011 12:24'!                         pasteString	"Paste the text's string from the shared buffer over the current selection and 	redisplay if necessary.	Pasting a string means using destination current attributes if appropriate."	self replaceSelectionWith: self clipboardStringOrText asString! !!Editor methodsFor: 'new selection' stamp: 'jmv 12/19/2011 12:17'!                    deselectAndPlaceCursorAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	self selectFrom: characterIndex to: characterIndex - 1! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/19/2011 12:18'!           clearSelection	self deselectAndPlaceCursorAt: 1! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/19/2011 12:18'!                               cursorTopHome: aKeyboardEvent	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."	self deselectAndPlaceCursorAt: 1.	^ true! !!Editor methodsFor: 'private' stamp: 'jmv 12/19/2011 12:18'!      moveCursor: directionBlock forward: forward event: aKeyboardEvent	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one."	| shift indices newPosition |	shift _ aKeyboardEvent shiftPressed.	indices _ self		setIndices: shift		forward: forward.	newPosition _ directionBlock value: (indices at: #moving).	shift		ifTrue: [			self				selectMark: (indices at: #fixed)				point: newPosition - 1 ]		ifFalse: [ self deselectAndPlaceCursorAt: newPosition ]! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 12/19/2011 14:48'!                 hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		owner redrawNeeded].	aBoolean ifFalse: [ hasEditingConflicts _ false].	"shout:  re-style the text iff aBoolean is true	Do not apply any formatting (i.e. changes to the characters in the text),	just styling (i.e. TextAttributes)"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess ]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/19/2011 14:49'!                   keyboardFocusChange: aBoolean		"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	aBoolean		ifTrue: [			"A hand is wanting to send us characters..."			editor ifNil: [ self editor storeSelectionInParagraph ].	"Forces install"			self startBlinking ]		ifFalse: [ self stopBlinking ].	"Selection might be shown differently when focused"	owner		ifNotNil: [ owner redrawNeeded ]		ifNil: [ self redrawNeeded ]		"Or at least redraw us"! !!SimpleEditor methodsFor: 'accessing' stamp: 'jmv 12/19/2011 12:23'!                  replaceSelectionWith: aString	"Deselect, and replace the selection text by aText."	| start stop |	start _ self startIndex.	stop _ self stopIndex.	(start = stop and: [aString size = 0]) ifFalse: [		string _ string copyReplaceFrom: start to: stop-1 with: aString.			self deselectAndPlaceCursorAt:  start + aString size.		self userHasEdited  " -- note text now dirty" ]! !!SimpleEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:22'!                            makeLowercase: aKeyboardEvent	"Force the current selection to lowercase.  Triggered by Cmd-X."	self replaceSelectionWith: self selection asLowercase.	^ true! !!SimpleEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:22'!                   makeUppercase: aKeyboardEvent	"Force the current selection to uppercase.  Triggered by Cmd-Y."	self replaceSelectionWith: self selection asUppercase.	^ true! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 12/19/2011 12:24'!                 addString: aString	"Think of a better name"	self replaceSelectionWith: aString! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 12/19/2011 12:24'!backTo: startIndex	"During typing, backspace to startIndex."	self markIndex: startIndex.	self replaceSelectionWith: ''.	self markIndex: self pointIndex! !!SimpleEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/19/2011 12:24'!              forwardDelete: aKeyboardEvent	"Delete forward over the next character."	| startIndex stopIndex |	startIndex _ self markIndex.	startIndex > string size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self replaceSelectionWith: ''.		^ false].	"Null selection - do the delete forward"	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [ stopIndex := (self nextWordStart: stopIndex) - 1 ].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: ''.	self deselectAndPlaceCursorAt: startIndex.	^false! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 12/19/2011 12:24'!                        replaceSelectionWith: aTextOrString	"Deselect, and replace the selection text by aText."	"This is a user command, and generates undo"	| start stop replacement |	start _ self startIndex.	stop _ self stopIndex.	(aTextOrString isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (model actualContents attributesAt: start) select: [:att |			att mayBeExtended]].	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [		replacement _ self addAttributesForPasting: aTextOrString.		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.		paragraph			recomposeFrom: start			to:  start + replacement size - 1			delta: replacement size - (stop-start).		self deselectAndPlaceCursorAt: start + replacement size.		selectionStartBlocks _ #().		selectionStopBlocks _ #().		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:20'!        inOutdent: aKeyboardEvent delta: delta	"Add/remove a tab at the front of every line occupied by the selection. 	Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	"This is a user command, and generates undo"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |	cr _ Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart _ self startIndex.	realStop _ self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and: [				realStart < 2 or: [(self privateCurrentString at: realStart - 1) == cr]])		ifTrue: [			delta < 0				ifTrue: [					morph flash]				ifFalse: [					self replaceSelectionWith: Character tab asSymbol.					self deselectAndPlaceCursorAt: realStart + 1].			^true].	lines _ paragraph lines.	startLine _ paragraph lineIndexFor: realStart.	stopLine _ paragraph lineIndexFor: (realStart max: realStop).	start _ (lines at: startLine) first.	stop _ (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart _ realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation _ (startLine to: stopLine) inject: 1000 into: [ :previousValue :each |		previousValue min: (paragraph indentationOfLineIndex: each ifBlank: [ :tabs | 1000 ])].				size _  stop + 1 - start.	numLines _ stopLine + 1 - startLine.	inStream _ ReadStream on: self privateCurrentString from: start to: stop.	newString _ String new: size + ((numLines * delta) max: 0).	outStream _ ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].	realStop _ realStop + outStream position - size.	"Prepare for another iteration"	indentation _ indentation + delta.	size _ outStream position.	inStream _ outStream setFrom: 1 to: size.	outStream		ifNil: [ 	"tried to outdent but some line(s) were already left flush"			morph flash]		ifNotNil: [			self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString _ outStream contents].			self replaceSelectionWith: newString].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:22'!        makeLowercase: aKeyboardEvent	"Force the current selection to lowercase.  Triggered by Cmd-X."	"This is a user command, and generates undo"	self replaceSelectionWith: self selection string asLowercase.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:22'!makeUppercase: aKeyboardEvent	"Force the current selection to uppercase.  Triggered by Cmd-Y."	"This is a user command, and generates undo"	self replaceSelectionWith: self selection string asUppercase.	^ true! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 12/19/2011 12:21'!                               deselectAndPlaceCursorAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	selectionStartBlocks _ #().	selectionStopBlocks _ #().	super deselectAndPlaceCursorAt: characterIndex! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 12/19/2011 12:24'!                              insertAndSelect: aString at: anInteger	"This is a user command, and generates undo"	self deselectAndPlaceCursorAt: anInteger.	self replaceSelectionWith: (Text string: (' ' , aString) attributes: emphasisHere).	self selectFrom: anInteger to: anInteger + aString size! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 12/19/2011 12:03'!      selectFrom: start to: stop	"Select the specified characters inclusive.	I.e. if contents is 'hello' and we want to select the $e, do 'self selectFrom: 2 to: 2'	If we want to put cursor after e, but with no selection, do 'self selectFrom: 3 to: 2', or better yet, call #selectAt:"	self selectInvisiblyFrom: start to: stop.	self storeSelectionInParagraph.	"Preserve current emphasis if selection is empty"	start > stop ifTrue: [		self setEmphasisHereFromText ]! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 12/19/2011 12:24'!  addString: aString	"Think of a better name"	"This is a user command, and generates undo"	self replaceSelectionWith: aString! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 12/19/2011 12:24'!                    backTo: startIndex	"During typing, backspace to startIndex."	"This is a user command, and generates undo"	self markIndex: startIndex.	self replaceSelectionWith: self nullText.	markBlock _ pointBlock! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/19/2011 12:24'!forwardDelete: aKeyboardEvent	"Delete forward over the next character."	"This is a user command, and generates undo"	| startIndex stopIndex |	startIndex _ self markIndex.	startIndex > model textSize ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self replaceSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	stopIndex _ startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self deselectAndPlaceCursorAt: startIndex.	^false! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/19/2011 12:24'!                       findAndReplaceOnce: indexStream	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	"This is a user command, and generates undo"	| where |	where _ model actualContents		findString: FindText		startingAt: self stopIndex		caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	selectionStartBlocks add: (paragraph characterBlockForIndex: where).	selectionStopBlocks add: (paragraph characterBlockForIndex: where + FindText size).	self selectInvisiblyFrom: where to: where + FindText size - 1.	"Repeat it here. Senders beware: only one of these should last"	ChangeText ~~ FindText ifTrue: [ self replaceSelectionWith: ChangeText ].	indexStream nextPut: where.	^ true! !!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 12/19/2011 14:15'!             flushUndoRedoCommands	model flushUndoRedoCommands! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:24'!                             pasteInitials: aKeyboardEvent 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor."	"This is a user command, and generates undo"	| i |	i _ self stopIndex.	self replaceSelectionWith: (Text fromString: Utilities changeStamp).	self deselectAndPlaceCursorAt: i.	^ true! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/19/2011 12:19'!           argAdvance: aKeyboardEvent	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.."	| start t |	t _ model actualContents.	start _ t findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [ start _ t size + 1].	self deselectAndPlaceCursorAt: start + 2.	^true! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 12/19/2011 14:15'!                         flushUndoRedoCommands	undoRedoCommands _ ReadWriteStream on: Array new.	Smalltalk garbageCollect 	"To actually collect unused imported styles"! !!methodRemoval: TextEditor #clearSelection!TextEditor removeSelector: #clearSelection!!methodRemoval: TextEditor #replace:with:and:!TextEditor removeSelector: #replace:with:and:!!methodRemoval: TextEditor #selectAt:!TextEditor removeSelector: #selectAt:!!methodRemoval: TextEditor #zapSelectionWith:!TextEditor removeSelector: #zapSelectionWith:!!methodRemoval: SimpleEditor #replace:with:and:!SimpleEditor removeSelector: #replace:with:and:!!methodRemoval: SimpleEditor #zapSelectionWith:!SimpleEditor removeSelector: #zapSelectionWith:!!methodRemoval: Editor #selectAt:!Editor removeSelector: #selectAt:!