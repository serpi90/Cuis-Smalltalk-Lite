'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 28 November 2010 at 11:39:21 am'!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector getLabelSelector getMenuSelector askBeforeChanging triggerOnMouseDown offColor onColor feedbackColor showSelectionFeedback arguments argumentsProvider argumentsSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!CodeHolder methodsFor: 'controls' stamp: 'jmv 11/28/2010 11:06'!optionalButtonRow	"Answer a row of control buttons"	| row buttons widths |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	self optionalButtonTuples do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button label: tuple second asString.		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].		buttons add: button ].	row _ AlignmentMorph proportional.	row addInRow: buttons widthProportionalTo: widths.	^row! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/28/2010 11:11'!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row aColor |	instanceSwitch := PluggableButtonMorph 				model: self				stateGetter: #instanceMessagesIndicated				action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		borderWidth: 0.	commentSwitch := PluggableButtonMorph 				model: self				stateGetter: #classCommentIndicated				action: #plusButtonHit.	commentSwitch		label: '?' asText allBold;		setBalloonText: 'class comment';		borderWidth: 0.	classSwitch := PluggableButtonMorph 				model: self				stateGetter: #classMessagesIndicated				action: #indicateClassMessages.	classSwitch		label: 'class';		borderWidth: 0.	row _ AlignmentMorph proportional.	row		addMorph: instanceSwitch fullFrame: (LayoutFrame fractions: (0@0 corner: 0.5@1));		addMorph: commentSwitch fullFrame: (LayoutFrame fractions: (0.51@0 corner: 0.65@1));		addMorph: classSwitch fullFrame: (LayoutFrame fractions: (0.66@0 corner: 1@1)).	aColor := Color colorFrom: self class windowColor.	row color: aColor.	aColor := aColor muchLighter.	{ 		instanceSwitch.		commentSwitch.		classSwitch} do: [:m | 				m					color: aColor;					onColor: ColorTheme current switchOn					offColor: ColorTheme current switchOff].	^row! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/28/2010 11:10'!optionalButtonRow	"Answer a row of buttons to occur in a tool pane"	| row buttons widths |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	self buttonSpecs do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button label: tuple second asString.		buttons add: button.		button setBalloonText: tuple fourth].	buttons add: self lineDiffButton.	widths add: 14.	buttons add: self wordDiffButton.	widths add: 16.	self wantsPrettyDiffOption ifTrue: [		buttons add:  self prettyLineDiffButton.		widths add: 21.		buttons add:  self prettyWordDiffButton.		widths add: 23 ].	row _ AlignmentMorph proportional.	row addInRow: buttons widthProportionalTo: widths.	^row! !!Debugger methodsFor: 'initialize' stamp: 'jmv 11/28/2010 11:10'!customButtonRow	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"	| aButton buttons row |	buttons _ OrderedCollection new.	self customButtonSpecs do: [ :tuple | 		aButton := PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple second.		aButton label: tuple first asString.		tuple size > 2 ifTrue: [aButton setBalloonText: tuple third].		buttons add: aButton].			row _ AlignmentMorph proportional.	row addInProportionalRow: buttons.	^row! !!LightWidget methodsFor: 'defaults' stamp: 'jmv 11/28/2010 09:48'!pressedBorderStyleWith: aColor"	^BorderStyle simple width: 1; color: aColor muchDarker"^ self borderStyleWith: aColor! !!Morph methodsFor: 'menus' stamp: 'jmv 11/28/2010 09:32'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	aMenu add: 'send to back' translated action: #goBehind.	aMenu add: 'bring to front' translated action: #comeToFront.	self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	(owner is: #TextMorph) ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addDebuggingItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu			add: ('unlock "{1}"' translated format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!BorderedMorph methodsFor: 'accessing' stamp: 'jmv 11/28/2010 10:38'!borderStyle	"Work around the borderWidth/borderColor pair"	| style |	borderColor ifNil: [^BorderStyle default].	borderWidth isZero ifTrue: [^BorderStyle default].	style := borderStyle ifNil: [BorderStyle default].		(borderWidth = style width and: [			"Hah!! Try understanding this..."			borderColor == style style or: [					"#raised/#inset etc"					#simple == style style and: [borderColor = style color]]]) 		ifFalse: [			style := (borderColor is: #Color)				ifTrue: [BorderStyle width: borderWidth color: borderColor]				ifFalse: [(BorderStyle perform: borderColor) width: borderWidth	"argh."].			borderStyle _ style].	^style trackColorFrom: self! !!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 11/28/2010 11:37'!extent: aPoint	bounds extent = aPoint ifFalse: [		self changed.		bounds _ bounds topLeft extent: aPoint.		self buildMagnifiedBackgroundImage.		self layoutChanged.		self changed ].	worldState ifNotNil: [		worldState viewBox ifNotNil: [			worldState viewBox = bounds ifFalse: [				worldState canvas: nil.				worldState viewBox: bounds ]]].! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 11/28/2010 11:11'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed. If the button's actionSelector takes any arguments, they are obtained dynamically by sending the argumentSelector to the argumentsProvider"	actionSelector ifNotNil: [		actionSelector numArgs = 0			ifTrue: [ model perform: actionSelector ]			ifFalse: [				argumentsProvider ifNotNil: [					arguments _ argumentsProvider perform: argumentsSelector].					model perform: actionSelector withArguments: arguments]]! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'jmv 11/28/2010 11:09'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model _ model.		Weakly copied""getStateSelector _ getStateSelector.		a Symbol""actionSelector _ actionSelector.		a Symbol""getLabelSelector _ getLabelSelector.		a Symbol""getMenuSelector _ getMenuSelector.		a Symbol"offColor _ offColor veryDeepCopyWith: deepCopier.onColor _ onColor veryDeepCopyWith: deepCopier.arguments _ arguments veryDeepCopyWith: deepCopier.argumentsProvider _ argumentsProvider veryDeepCopyWith: deepCopier.argumentsSelector _ argumentsSelector.  " a Symbol" ! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 11/28/2010 09:22'!drawOn: aCanvas 	| w f center x y |	super drawOn: aCanvas.	f _ self fontToUse.	center _ bounds center.	label ifNotNil: [		w _ f widthOfString: label.		x _ bounds width > w			ifTrue: [ center x - (w // 2) ]			ifFalse: [ bounds left +4].		y _ center y - (f height // 2).		aCanvas drawString: label at: x@y font: f color: ColorTheme current buttonLabel ]! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/28/2010 11:08'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	evt yellowButtonPressed ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	(self containsPoint: evt cursorPoint) ifTrue: [		(borderColor is: #Color)			ifFalse:[borderColor _ #inset].		self changed].	evt hand		waitForSimulatedYellow: self		event: evt		dblClkSel: #doubleClick:! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 11/28/2010 09:23'!mouseUp: evt	(borderColor is: #Color) ifFalse: [ borderColor _ #raised ].	self changed.	(self containsPoint: evt cursorPoint) ifTrue: [self performAction]! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 11/28/2010 11:09'!initialize	"initialize the state of the receiver"	super initialize.	model _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	onColor _ ColorTheme current buttonOn.	offColor _ ColorTheme current buttonOff.	argumentsProvider _ nil.	argumentsSelector _ nil.	self extent: 20 @ 15! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jmv 11/28/2010 11:10'!buttonToTriggerIn: aFileList 	"Answer a button that will trigger the receiver service in a file list"	| aButton |	aButton := PluggableButtonMorph 				model: self				stateGetter: nil				action: #performServiceFor:.	aButton arguments: { 				aFileList}.	aButton		color: Color transparent;		label: self buttonLabel.	aButton color: (ColorTheme current buttonColorFrom: aFileList class windowColor).	aButton setBalloonText: self description.	^aButton! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 11/28/2010 09:40'!createBox	"create a button with default to be used in the label area"	| box |	box := IconicButton new.	box		color: Color transparent;		borderWidth: 0;		target: self.			^box! !SimpleBorder removeSelector: #baseColor!SimpleBorder removeSelector: #baseColor:!PluggableButtonMorph removeSelector: #askBeforeChanging:!PluggableButtonMorph removeSelector: #triggerOnMouseDown:!PluggableButtonMorph removeSelector: #updateFeedbackForEvt:!!classDefinition: #PluggableButtonMorph category: #'Morphic-Windows'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font getStateSelector actionSelector getLabelSelector getMenuSelector offColor onColor arguments argumentsProvider argumentsSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!IconicButton removeSelector: #borderInset!IconicButton removeSelector: #borderNormal!IconicButton removeSelector: #borderRaised!IconicButton removeSelector: #borderThick!IconicButton removeSelector: #buttonSetup!EllipseMorph removeSelector: #canDrawBorder:!BorderedMorph removeSelector: #addBorderStyleMenuItems:hand:!BorderedMorph removeSelector: #borderStyle:!BorderedMorph removeSelector: #borderStyleForSymbol:!BorderedMorph removeSelector: #changeBorderColor:!BorderedMorph removeSelector: #changeBorderWidth:!BorderedMorph removeSelector: #setBorderStyle:!Morph removeSelector: #addBorderStyleMenuItems:hand:!Morph removeSelector: #canDrawBorder:!BorderStyle class removeSelector: #borderStyleChoices!BorderStyle class removeSelector: #borderStyleForSymbol:!BorderStyle removeSelector: #baseColor!BorderStyle removeSelector: #baseColor:!