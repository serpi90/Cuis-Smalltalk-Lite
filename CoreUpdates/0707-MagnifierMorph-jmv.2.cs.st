'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 10 December 2010 at 10:49:37 am'!!classDefinition: #MagnifierMorph category: #'Morphic-Demo'!BorderedMorph subclass: #MagnifierMorph	instanceVariableNames: 'magnification trackPointer lastPos srcExtent auxCanvas magnifiedForm'	classVariableNames: 'RecursionLock'	poolDictionaries: ''	category: 'Morphic-Demo'!!MagnifierMorph commentStamp: '<historical>' prior: 0!Provides a magnifying glass. Magnifies the morphs below (if grabbed) or the area around the mouse pointer.!!FormCanvas class methodsFor: 'instance creation' stamp: 'jmv 12/10/2010 10:10'!depth: depth over: aRectangle	"Color black represents one for 1bpp"	^ self new		setForm: (Form extent: aRectangle extent depth: depth);		setOrigin: aRectangle topLeft negated clipRect: (0@0 extent: aRectangle extent)! !!FormCanvas class methodsFor: 'instance creation' stamp: 'jmv 12/10/2010 10:23'!on: aForm over: aRectangle	"Warning: aForm extent must equal aRectangle extent"	^ self new		setForm: aForm;		setOrigin: aRectangle topLeft negated clipRect: (0@0 extent: aRectangle extent)! !!MagnifierMorph methodsFor: 'initialization' stamp: 'bf 9/20/1999 15:54'!initialize	super initialize.	trackPointer _ true.	magnification _ 2.	color _ Color black.	borderWidth _ 1.	lastPos _ self sourcePoint.	self extent: 128@128.! !!MagnifierMorph methodsFor: 'geometry' stamp: 'bf 9/21/1999 09:31'!borderWidth: anInteger	"Grow outwards preserving innerBounds"	| c |  	c _ self center.	super borderWidth: anInteger.	super extent: self defaultExtent.	self center: c.! !!MagnifierMorph methodsFor: 'geometry' stamp: 'bf 9/21/1999 09:22'!defaultExtent	^(srcExtent * magnification) truncated + (2 * borderWidth)! !!MagnifierMorph methodsFor: 'geometry' stamp: 'bf 9/21/1999 09:23'!extent: aPoint	"Round to multiples of magnification"	srcExtent _ (aPoint - (2 * borderWidth)) // magnification.	^super extent: self defaultExtent! !!MagnifierMorph methodsFor: 'drawing' stamp: 'jmv 12/10/2010 10:13'!drawOn: aCanvas	RecursionLock == self ifFalse: [		super drawOn: aCanvas.		"border and fill"		aCanvas isShadowDrawing ifFalse: [			"Optimize because #magnifiedForm is expensive"			aCanvas paintImage: self magnifiedForm at: self innerBounds origin]]! !!MagnifierMorph methodsFor: 'drawing' stamp: 'bf 9/21/1999 08:51'!hasTranslucentColor	"I may show what's behind me, so tell the hand to don't cache"	^self sourceRect intersects: self bounds! !!MagnifierMorph methodsFor: 'stepping' stamp: 'di 9/28/1999 07:57'!step	self changed! !!MagnifierMorph methodsFor: 'stepping' stamp: 'di 9/28/1999 07:57'!stepTime	^ 0! !!MagnifierMorph methodsFor: 'events' stamp: 'bf 9/18/1999 20:42'!handlesMouseDown: evt	^evt yellowButtonPressed		or: [super handlesMouseDown: evt]! !!MagnifierMorph methodsFor: 'events' stamp: 'bf 9/21/1999 10:45'!mouseDown: evt	evt yellowButtonPressed		ifTrue: [self chooseMagnification: evt]		ifFalse: [super mouseDown: evt]! !!MagnifierMorph methodsFor: 'menu' stamp: 'di 9/28/1999 23:06'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu		addLine;		add: 'magnification...' action: #chooseMagnification;		addUpdating: #trackingPointerString action: #toggleTrackingPointer;		addUpdating: #toggleRoundString action: #toggleRoundness.! !!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/28/1999 16:22'!chooseMagnification	| result |	result _ (SelectionMenu selections: #(1.5 2 4 8))		startUpWithCaption: 'Choose magnification(currently ', magnification printString, ')'.	(result == nil or: [result = magnification]) ifTrue: [^ self].	magnification _ result.	self extent: self extent. "round to new magnification"	self changed. "redraw even if extent wasn't changed".! !!MagnifierMorph methodsFor: 'menu' stamp: 'di 8/24/2000 14:02'!chooseMagnification: evt	| handle origin aHand currentMag |	currentMag _ magnification.	aHand _ evt ifNil: [self currentHand] ifNotNil: [evt hand].	origin _ aHand position y.	handle _ HandleMorph new forEachPointDo:		[:newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag].	aHand attachMorph: handle.	handle startStepping.	self changed. "Magnify handle"! !!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/20/1999 15:48'!toggleTrackingPointer	trackPointer _ trackPointer not! !!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/20/1999 15:49'!trackingPointerString	^trackPointer		ifTrue: ['stop tracking pointer']		ifFalse: ['start tracking pointer']! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 9/21/1999 12:27'!magnification: aNumber	| c |  	magnification _ aNumber min: 8 max: 0.5.	magnification _ magnification roundTo:		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).	srcExtent _ srcExtent min: (512@512) // magnification. "to prevent accidents"	c _ self center.	super extent: self defaultExtent.	self center: c.! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/10/2010 10:47'!magnifiedForm	| srcRect form neededExtent |	lastPos _ self sourcePoint.	srcRect _ self sourceRectFrom: lastPos.	((srcRect intersects: self bounds) and: [ RecursionLock == nil ])		ifTrue: [			RecursionLock _ self.			"try to reuse form if appropriate"			auxCanvas _ (auxCanvas notNil and: [ auxCanvas extent = srcExtent ])				ifTrue: [					"Just in case we go out of the Display"					srcRect origin > (0@0) ifFalse: [						auxCanvas form fillBlack ].					FormCanvas on: auxCanvas form over: srcRect ]				ifFalse: [ FormCanvas depth: 32 over: srcRect ].			World drawOn: auxCanvas.			World drawSubmorphsOn: auxCanvas.			form _ auxCanvas form.			RecursionLock _ nil]		ifFalse: [			"cheaper method if the source is not occluded"			form _ Display copy: srcRect].	"smooth if non-integer scale"	neededExtent _ (srcExtent * magnification ) truncated.	(magnifiedForm isNil or: [ magnifiedForm extent ~=  neededExtent ])		ifTrue: [ magnifiedForm _ Form extent: neededExtent depth: 32 ].	(WarpBlt current toForm: magnifiedForm)		sourceForm: form;		colorMap: (form colormapIfNeededFor: magnifiedForm);		cellSize: (magnification isInteger ifTrue: [1] ifFalse: [2]);  "installs a new colormap if cellSize > 1"		combinationRule: 3;		copyQuad: form boundingBox innerCorners toRect: magnifiedForm boundingBox.	^magnifiedForm.! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/10/2010 09:26'!sourcePoint	"If we are being dragged use our center, otherwise use pointer position"	^(trackPointer not or: [owner notNil and: [owner is: #HandMorph]])		ifTrue: [self center]		ifFalse: [self currentHand position]! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 9/21/1999 08:47'!sourceRect	^self sourceRectFrom: self sourcePoint! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'di 12/17/1999 13:42'!sourceRectFrom: aPoint	^ (aPoint extent: srcExtent) translateBy: (srcExtent // -2) + 1.! !!MagnifierMorph methodsFor: 'round view' stamp: 'jmv 12/10/2010 09:25'!isRound	^ "owner isMemberOf: ScreeningMorph" false! !!MagnifierMorph methodsFor: 'round view' stamp: 'di 9/28/1999 23:17'!toggleRoundString	^ self isRound		ifTrue: ['be square']		ifFalse: ['be round']! !!MagnifierMorph methodsFor: 'round view' stamp: 'jmv 12/10/2010 09:25'!toggleRoundness	| |"	w _ self world.	self isRound		ifTrue: [owner delete.				w addMorph: self]		ifFalse: [sm _ ScreeningMorph new position: self position.				sm addMorph: self.				sm addMorph: (EllipseMorph newBounds: self bounds).				w addMorph: sm]			"! !