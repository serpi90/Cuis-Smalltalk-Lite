'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 6 December 2010 at 11:33:08 am'!!ChangeSet methodsFor: 'accessing' stamp: 'jmv 12/6/2010 11:07'!editPostscript	"edit the receiver's postscript, in a separate window."	self assurePostscriptExists.	postscript openLabel: 'Postscript for ChangeSet named ' , name! !!ChangeSet methodsFor: 'accessing' stamp: 'jmv 12/6/2010 11:02'!postscriptHasDependents	^ postscript dependents size > 0 and: [		Smalltalk garbageCollect.		postscript dependents size > 0 ].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/6/2010 11:00'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble actualContents isEmptyOrNil])		ifTrue: [preamble _ TextModel new actualContents: self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/6/2010 10:58'!postscriptString	"Answer the string representing the postscript.  "	^ postscript		ifNil: [postscript]		ifNotNil: [postscript actualContents asString]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 12/6/2010 10:57'!preambleString	"Answer the string representing the preamble"	^ preamble		ifNil: [preamble]		ifNotNil: [preamble actualContents asString]! !!Debugger methodsFor: 'initialize' stamp: 'jmv 12/6/2010 11:16'!buttonRowForPreDebugWindow	| row aButton quads buttons |	buttons _ OrderedCollection new.	quads _ OrderedCollection withAll: self preDebugButtonQuads.	(self interruptedContext selector == #doesNotUnderstand:) ifTrue: [		quads add: { 'Create'. #createMethod. #magenta. 'create the missing method' }	].	quads do: [ :quad |		aButton _ PluggableButtonMorph new model: self.		aButton color: Color transparent.		aButton action: quad second.		aButton label: quad first.		aButton color: (Color colorFrom: quad third) muchLighter.		aButton setBalloonText: quad fourth.		buttons add: aButton].		row _ AlignmentMorph proportional.	row addInRow: buttons.	^row! !!Debugger methodsFor: 'accessing' stamp: 'jmv 12/6/2010 10:48'!acceptedStringOrText 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	^ self selectedMessage! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/6/2010 11:23'!createAcceptButton	"create the [accept] button"	| result frame buttonColor |	buttonColor _ Theme current buttonColorFrom: (Color r: 0.5 g: 0.8 b: 0.5).	result _ PluggableButtonMorph new		 model: self;		 color: buttonColor;		 label: 'Accept(s)' translated;		 action: #accept.	frame _ LayoutFrame fractions: (0.1 @ 0.75 corner: 0.45 @ 0.98).	result layoutFrame: frame.	self addMorph: result.	^ result! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/6/2010 11:23'!createCancelButton	"create the [cancel] button"	| result frame buttonColor |	buttonColor _ Theme current buttonColorFrom: (Color r: 0.8 g: 0.5 b: 0.5).	result _ PluggableButtonMorph new		 model: self;		 color: buttonColor;		 label: 'Cancel(l)' translated;		 action: #cancel.	frame _ LayoutFrame fractions: (0.55 @ 0.75 corner: 0.9 @ 0.98).	result layoutFrame: frame.	self addMorph: result.	^ result! !!MessageSet methodsFor: 'contents' stamp: 'jmv 12/6/2010 10:48'!acceptedStringOrText	"Answer the contents of the receiver"	^ messageListIndex = 0		ifTrue: [			currentCompiledMethod _ nil.			'' ]		ifFalse: [			self showingByteCodes				ifTrue: [ self selectedBytecodes ]				ifFalse: [ self selectedMessage ]].! !!MessageNames methodsFor: 'search' stamp: 'jmv 12/6/2010 10:53'!computeSelectorListFromSearchString	"Compute selector list from search string"	selectorList _ Cursor wait showWhile: [ | sorted |		sorted _ SortedCollection sortBlock: [ :x :y |			x asLowercase <= y asLowercase ].		(searchString findBetweenSubStrs: ';') do: [ :selPat | | raw n m |			selPat size > 0 ifTrue: [				(selPat first = $" and: [					selPat last = $" and: [ selPat size > 2 ]])					ifTrue: [						Symbol							hasInterned:								(selPat									copyFrom: 2									to: selPat size - 1)							ifTrue: [ :sym |								sorted add: sym ]]					ifFalse: [						raw _ ((n _ selPat occurrencesOf: $*) > 0 | ((m _ selPat occurrencesOf: $#) > 0) and: [ selPat size > (n + m) ])							ifTrue: [ Symbol selectorsMatching: selPat ]							ifFalse: [ Symbol selectorsContaining: selPat ].						sorted addAll: raw ]]].		sorted asArray ].	selectorList _ selectorList select: [ :sym |		(Smalltalk isThereAnImplementorOf: sym) or: [ Smalltalk isThereAReferenceTo: sym ]].	^ selectorList.! !!MessageNames methodsFor: 'search' stamp: 'jmv 12/6/2010 10:52'!searchString: aString	"Take what the user typed and find all selectors containing it"	searchString _ aString asString.	self containingWindow setLabel: 'Message names containing "', searchString asLowercase, '"'.	selectorList _ nil.	self changed: #selectorList.	self changed: #messageList.	^ true! !!MessageNames methodsFor: 'initialization' stamp: 'jmv 12/6/2010 11:30'!inMorphicWindowWithInitialSearchString: initialString	"Answer a morphic window with the given initial search string, nil if none""MessageNames openMessageNames"	| window selectorListView firstDivider secondDivider horizDivider typeInPane searchButton plugTextMor |	window _ (SystemWindow labelled: 'Message Names') model: self.	firstDivider _ 0.07.	secondDivider _ 0.5.	horizDivider _ 0.5.	typeInPane _ AlignmentMorph proportional height: 14.	plugTextMor _ TextModelMorph 		textProvider: self		textGetter: #searchString 		textSetter: #searchString:.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor textMorph		on: #mouseEnter send: #selectAll to: plugTextMor textMorph.	searchButton _ PluggableButtonMorph new 		model: self;		label: 'Search';		action: #doSearchFrom:;		arguments: {plugTextMor}.	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.	typeInPane addInRow: { searchButton. plugTextMor. } widthProportionalTo: #(1 3).	initialString isEmptyOrNil ifFalse:		[plugTextMor changeText: initialString].	window addMorph: typeInPane frame: (0@0 corner: horizDivider @ firstDivider).	selectorListView _ PluggableListMorph 		model: self		listGetter: #selectorList		indexGetter: #selectorListIndex		indexSetter: #selectorListIndex:		menuGetter: #selectorListMenu:		keystrokeAction: #selectorListKey:from:.	window addMorph: selectorListView frame: (0 @ firstDivider corner: horizDivider @ secondDivider).	window addMorph: self buildMorphicMessageList frame: (horizDivider @ 0 corner: 1@ secondDivider).	self 		addLowerPanesTo: window 		at: (0 @ secondDivider corner: 1@1) 		with: nil.	initialString isEmptyOrNil ifFalse: [		self searchString: initialString ].	^ window! !