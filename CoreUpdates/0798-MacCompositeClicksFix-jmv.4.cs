'From Cuis 3.0 of 31 January 2011 [latest update: #790] on 16 February 2011 at 6:26:17 pm'!!classDefinition: #EventSensor category: #'Kernel-Processes'!InputSensor subclass: #EventSensor	instanceVariableNames: 'mouseButtons mousePosition keyboardBuffer interruptKey interruptSemaphore eventQueue inputSemaphore lastEventPoll hasInputSemaphore '	classVariableNames: 'EventPollPeriod EventTicklerProcess '	poolDictionaries: ''	category: 'Kernel-Processes'!!HandMorph methodsFor: 'event handling' stamp: 'jmv 2/16/2011 17:38'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type hadAny |	ActiveEvent ifNotNil: [		"Meaning that we were invoked from within an event response.		Make sure z-order is up to date"		self mouseOverHandler processMouseOver: lastMouseEvent].	hadAny := false.	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [		evt := nil.	"for unknown event types"		type := evtBuf first.		type = EventSensor eventTypeMouse			ifTrue: [ evt := self generateMouseEvent: evtBuf ].		type = EventSensor eventTypeKeyboard 			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].		type = EventSensor eventTypeWindow			ifTrue: [ evt _ self generateWindowEvent: evtBuf ].		"All other events are ignored"		evt			ifNil: [				^hadAny]			ifNotNil: [				"Finally, handle it"				self handleEvent: evt.				hadAny := true.				"For better user feedback, return immediately after a mouse event has been processed."				evt isMouse ifTrue: [ ^hadAny ]]].	"note: if we come here we didn't have any mouse events"	mouseClickState 		ifNotNil: [ 			"No mouse events during this cycle. Make sure click states time out accordingly"			mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	^hadAny! !!HandMorph methodsFor: 'private events' stamp: 'jmv 2/16/2011 17:40'!generateKeyboardEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type keyValue pressType stamp |	stamp _ evtBuf second.	stamp = 0 ifTrue: [stamp _ Time millisecondClockValue].	(evtBuf sixth <= 0 or: [		(keyValue _ (Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth)) isNil ])			ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].	modifiers _ evtBuf fifth.	pressType _ evtBuf fourth.	pressType = EventSensor eventKeyDown ifTrue: [		type _ #keyDown.		lastKeyDownValue _ keyValue].	pressType = EventSensor eventKeyUp ifTrue: [type _ #keyUp].	pressType = EventSensor eventKeyChar ifTrue: [		type _ #keystroke.		"If Control key pressed, and the VM answers a code below 27,		 it means it did the translation, convert it back to regular character:		We want to handle the meaning of ctrl ourselves."		(modifiers anyMask: 2) ifTrue: [		"Control key pressed"			keyValue < 27 ifTrue: [								"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"				lastKeyDownValue = keyValue ifFalse: [		"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"					(keyValue + 64 = lastKeyDownValue or: [ 	"If Equal, Ctrl-alphabetic in Windows => do translate"							lastKeyDownValue < 64 ]) ifTrue: [		"Not on windows. If less (not sure about the bound), alphabetic on Mac => do translate"						keyValue _ (modifiers anyMask: 1)							ifFalse: [ keyValue + 96 ]	"shift not pressed: conver to lowercase letter"							ifTrue: [ keyValue + 64 ]].	"shift pressed: conver to uppercase letter"					]				].			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"			(self shouldControlEmulateAltFor: keyValue) ifTrue: [				modifiers _ modifiers bitOr: 8 ]			]].	buttons _ modifiers bitShift: 3.	^KeyboardEvent new 		setType: type		buttons: buttons		position: self position		keyValue: keyValue		hand: self		stamp: stamp! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 2/16/2011 17:49'!anyModifierKeyPressed	"ignore, however, the shift keys 'cause that's not REALLY a command key"	^ self primMouseButtons anyMask: InputSensor anyModifierKey! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 2/16/2011 17:49'!commandAltKeyPressed	"Answer whether the command (Mac) / alt(Windows) key on the keyboard is being held down."	^ self primMouseButtons anyMask: InputSensor commandAltKey! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 2/16/2011 17:47'!controlKeyPressed	"Answer whether the control/ctrl key on the keyboard is being held down."	^ self primMouseButtons anyMask: InputSensor controlKey! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 2/16/2011 18:17'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific."	self notifyWithLabel: 'Portability note:InputSensor>>macOptionKeyPressed is not portable.Please use InputSensor>>yellowButtonPressed instead!!'.	^ self rawMacOptionKeyPressed! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 2/16/2011 17:51'!rawMacOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific.  Clients are discouraged from calling this directly, since it circumvents bert's attempt to eradicate option-key checks"	^ self primMouseButtons anyMask: InputSensor macOptionKey! !!InputSensor methodsFor: 'modifier keys' stamp: 'jmv 2/16/2011 18:19'!shiftPressed	"Answer whether the shift key on the keyboard is being held down."	^ self primMouseButtons anyMask: InputSensor shiftKey! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/16/2011 17:25'!anyButtonPressed	"Answer whether at least one mouse button is currently being pressed."	^ self primMouseButtons anyMask: InputSensor anyButton! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/16/2011 17:26'!blueButtonPressed	"Answer whether only the blue mouse button is being pressed. 	This is the third mouse button or cmd+click on the Mac."	^ (self primMouseButtons bitAnd: 7) = InputSensor blueButton! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/16/2011 17:26'!redButtonPressed	"Answer true if only the red mouse button is being pressed.	This is the first mouse button, usually the left one."	^ (self primMouseButtons bitAnd: 7) = InputSensor redButton! !!InputSensor methodsFor: 'mouse' stamp: 'jmv 2/16/2011 17:27'!yellowButtonPressed	"Answer whether only the yellow mouse button is being pressed. 	This is the second mouse button or option+click on the Mac."	^ (self primMouseButtons bitAnd: 7) = InputSensor yellowButton! !!EventSensor methodsFor: 'accessing' stamp: 'jmv 2/16/2011 17:39'!flushAllButDandDEvents	| newQueue oldQueue  |		newQueue _ SharedQueue new.	self eventQueue ifNil: 		[eventQueue := newQueue.		^self].	oldQueue _ self eventQueue.	[oldQueue size > 0] whileTrue: [ | item type | 		item _ oldQueue next.		type _ item at: 1.		type = EventSensor eventTypeDragDropFiles ifTrue: [ newQueue nextPut: item]].	eventQueue _ newQueue.! !!EventSensor methodsFor: 'mouse' stamp: 'jmv 2/16/2011 17:37'!createMouseEvent	"create and return a new mouse event from the current mouse 	position; this is useful for restarting normal event queue 	processing after manual polling"	| buttons modifiers pos mapped eventBuffer |	eventBuffer _ Array new: 8.	buttons _ self primMouseButtons.	pos _ self primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	eventBuffer		at: 1 put: EventSensor eventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.	^ eventBuffer! !!EventSensor methodsFor: 'private' stamp: 'jmv 2/16/2011 17:39'!isKbdEvent: buf	^ (buf at: 1) = EventSensor eventTypeKeyboard and: [(buf at: 4) = EventSensor eventKeyChar]! !!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 2/16/2011 17:36'!fetchMoreEvents	"Fetch more events from the VM"	| eventBuffer type |	"Reset input semaphore so clients can wait for the next events after this one."	inputSemaphore isSignaled		ifTrue: [			hasInputSemaphore _ true.			inputSemaphore initSignals ].	"Remember the last time that I checked for events."	lastEventPoll _ Time millisecondClockValue.	eventBuffer _ Array new: 8.	[		self primGetNextEvent: eventBuffer.		type _ eventBuffer at: 1.		type = EventSensor eventTypeNone ]			whileFalse: [ self processEvent: eventBuffer ]! !!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 2/16/2011 17:54'!mapButtons: buttons modifiers: modifiers	"Map the buttons to yellow or blue based on the given modifiers.	If only the red button is pressed, then map		Ctrl-RedButton -> BlueButton.		Cmd-RedButton -> YellowButton.	"	(buttons = InputSensor redButton)		ifFalse: [ ^ buttons ].	(modifiers allMask: EventSensor macOptionKey) 		ifTrue: [ ^ InputSensor blueButton ].	(modifiers allMask: EventSensor commandAltKey) 		ifTrue: [ ^ InputSensor yellowButton ].	^buttons! !!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 2/16/2011 17:40'!primGetNextEvent: array	"Store the next OS event available into the provided array.	Essential. If the VM is not event driven the ST code will fall	back to the old-style mechanism and use the state based	primitives instead."	| kbd buttons modifiers pos mapped |	<primitive: 94>	"Simulate the events"	array at: 1 put: EventSensor eventTypeNone. "assume no more events"	"First check for keyboard"	kbd _ super primKbdNext.	kbd ifNotNil: [		"simulate keyboard event"		array at: 1 put: EventSensor eventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventSensor eventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^self].	"Then check for mouse"	buttons _ super primMouseButtons.	pos _ super primMousePt.	modifiers _ buttons bitShift: -3.	buttons _ buttons bitAnd: 7.	mapped _ self mapButtons: buttons modifiers: modifiers.	(pos = mousePosition and:[(mapped bitOr: (modifiers bitShift: 3)) = mouseButtons])		ifTrue:[^self].	array 		at: 1 put: EventSensor eventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.! !!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 2/16/2011 17:39'!processEvent: evt	"Process a single event. This method is run at high priority."	| type |	type _ evt at: 1.	"Check if the event is a user interrupt"	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [		((evt at: 3) bitOr: ((evt at: 5) bitShift: 8)) = interruptKey]])			 ifTrue: [				"interrupt key is meta - not reported as event"				^interruptSemaphore signal].	"Store the event in the queue if there's any"	type = EventSensor eventTypeMouse ifTrue: [		"Only swap secondary and tertiary buttons if there is no modifier keys.		This swap is done so a 3-button mouse  is			left -> red (select)			center -> blue (halo)			right -> yellow (menu).		This is only needed on the Mac, Window VM does this mapping by default.		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:			left -> left			macOption + left -> center			command + left -> right,		but Mac users are already used to 			macOption + left -> menu			command + left -> halo.		See #installMouseDecodeTable"		(evt at: 6) = 0 ifTrue: [			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].	self queueEvent: evt.	"Update state for InputSensor."	type = EventSensor eventTypeMouse ifTrue: [ self processMouseEvent: evt ].	type = EventSensor eventTypeKeyboard ifTrue: [ self processKeyboardEvent: evt ]! !!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 2/16/2011 17:40'!processKeyboardEvent: evt	"process a keyboard event, updating InputSensor state"	| charCode pressCode |	"Never update keyboardBuffer if we have an eventQueue active"	mouseButtons _ (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).	eventQueue ifNotNil:[^self]. 	charCode _ evt at: 3.	charCode ifNil: [^self]. "extra characters not handled in MVC"	pressCode _ evt at: 4.	pressCode = EventSensor eventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"	"mix in modifiers"	charCode _ charCode bitOr: ((evt at: 5) bitShift: 8).	keyboardBuffer nextPut: charCode.! !!EventSensor methodsFor: 'test' stamp: 'jmv 2/16/2011 17:40'!printEventBuffer: evtBuf	| type buttons macRomanCode modifiers position pressType stamp unicodeCodePoint |	type _ evtBuf first.	stamp _ evtBuf second.	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].	type = EventSensor eventTypeMouse		ifTrue: [			position _ evtBuf third @ evtBuf fourth.			buttons _ evtBuf fifth.			modifiers _ evtBuf sixth.			Transcript				cr;				show: 'Mouse';				show: ' position:', position printString;				show: ' buttons:', buttons printString;				show: ' modifiers:', modifiers printString.			].	type = EventSensor eventTypeKeyboard 		ifTrue: [			macRomanCode _ evtBuf third.			unicodeCodePoint _ evtBuf sixth.			pressType _ evtBuf fourth.			modifiers _ evtBuf fifth.			pressType = EventSensor eventKeyDown ifTrue: [				type _ #keyDown].			pressType = EventSensor eventKeyUp ifTrue: [				type _ #keyUp].			pressType = EventSensor eventKeyChar ifTrue: [				type _ #keystroke].			Transcript				cr;				show: type;				show: ' macRomanCode:', macRomanCode printString, '-', 					(Character value: (Character macRomanToLatin1: macRomanCode)) asString, '-';				show: ' unicodeCodePoint:', unicodeCodePoint printString.			(Character iso8859s15CodeForUnicodeCodePoint: unicodeCodePoint) ifNotNil: [ :latin15 |				Transcript show: '-', (Character value: latin15) asString, '-' ].			Transcript				show: ' modifiers:', modifiers printString.			(modifiers anyMask: 8) ifTrue: [ Transcript show: ' [commandWinAlt]' ].			(modifiers anyMask: 4) ifTrue: [ Transcript show: ' [macOption]' ].			(modifiers anyMask: 2) ifTrue: [ Transcript show: ' [control]' ].			(modifiers anyMask: 1) ifTrue: [ Transcript show: ' [shift]' ].			].! !!InputSensor class methodsFor: 'class initialization' stamp: 'jmv 2/16/2011 17:14'!installMouseDecodeTable	"Create a decode table that swaps the lowest-order 2 bits if not on Windows.	This is to make right mouse button be the yellow button, i.e. open menus, and middle (wheel) button open halos (blue).	See #processEvent:"	ButtonDecodeTable _ Smalltalk platformName = 'Win32'		ifTrue: [ ByteArray withAll: (0 to: 255) ]		ifFalse: [			ByteArray withAll:				((0 to: 255) collect: [ :ea |					((ea bitAnd: 1) << 1 bitOr: (ea bitAnd: 2) >> 1) bitOr: (ea bitAnd: 252) ]) ]! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:20'!anyButton	^ 7! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:49'!anyModifierKey	"ignore, however, the shift keys 'cause that's not REALLY a command key"	^ 16r70	"cmd | opt | ctrl"! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:20'!blueButton	^ 1! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:50'!commandAltKey	"command (Mac) / alt(Windows) key"	^16r40! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:50'!controlKey	"control / ctrl"	^ 16r10! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:51'!macOptionKey	"option (Mac only)  key"	^16r20! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:21'!redButton	^ 4! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:52'!shiftKey	"shift  key"	^16r08! !!InputSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:21'!yellowButton	^ 2! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:57'!commandAltKey	"Modifier keys.	command (Mac) / alt(Windows) key	Encoding specific to EventSensor primitives (not the same of InputSensor)"	^ 8! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:57'!controlKey	"Modifier keys.	control / ctrl	Encoding specific to EventSensor primitives (not the same of InputSensor)"	^ 2! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:35'!eventKeyChar	"Press codes for keyboard events"	^0! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:35'!eventKeyDown	"Press codes for keyboard events"	^1! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:35'!eventKeyUp	"Press codes for keyboard events"	^2! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:34'!eventTypeDragDropFiles	"Types of events"	^3! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:34'!eventTypeKeyboard	"Types of events"	^2! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:34'!eventTypeMenu	"Types of events"	^4! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:34'!eventTypeMouse	"Types of events"	^1! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:34'!eventTypeNone	"Types of events"	^0! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:35'!eventTypeWindow	"Types of events"	^5! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:57'!macOptionKey	"Modifier keys.	option (Mac only)  key	Encoding specific to EventSensor primitives (not the same of InputSensor)"	^ 4! !!EventSensor class methodsFor: 'constants' stamp: 'jmv 2/16/2011 17:57'!shiftKey	"Modifier keys.	shift  key	Encoding specific to EventSensor primitives (not the same of InputSensor)"	^ 1! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 2/16/2011 18:17'!anyModifierKeyPressed	"ignore, however, the shift keys 'cause that's not REALLY a command key "	^ self buttons anyMask: InputSensor anyModifierKey! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 2/16/2011 18:18'!commandAltKeyPressed	"Answer true if the command (Mac) / alt(Windows) key on the keyboard was being held down when this event occurred."	^ buttons anyMask: InputSensor commandAltKey! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 2/16/2011 18:18'!controlKeyPressed	"Answer true if the control/ctrl key on the keyboard was being held down when this event occurred."	^ buttons anyMask: InputSensor controlKey! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 2/16/2011 18:19'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific."	self notifyWithLabel: 'Portability note:MorphicEvent>>macOptionKeyPressed is not portable.Please use MorphicEvent>>yellowButtonPressed instead!!'.	^ self rawMacOptionKeyPressed! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 2/16/2011 18:19'!rawMacOptionKeyPressed	"Answer whether the option/alt key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific. Please do not confuse with the alt key on Windows and Linux, that is called 'command' on the mac. See #commandAltKeyPressed"	^ buttons anyMask: InputSensor macOptionKey! !!UserInputEvent methodsFor: 'modifier state' stamp: 'jmv 2/16/2011 18:19'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: InputSensor shiftKey! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/16/2011 17:25'!anyButtonPressed	"Answer true if any mouse button is being pressed."	^ buttons anyMask: InputSensor anyButton! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/16/2011 17:25'!blueButtonPressed	"Answer true if the blue mouse button is being pressed. This is the third mouse button or cmd+click on the Mac."	^ buttons anyMask: InputSensor blueButton! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/16/2011 17:26'!redButtonPressed	"Answer true if the red mouse button is being pressed. This is the first mouse button."	^ buttons anyMask: InputSensor redButton! !!MouseEvent methodsFor: 'button state' stamp: 'jmv 2/16/2011 17:27'!yellowButtonPressed	"Answer true if the yellow mouse button is being pressed. This is the second mouse button or option+click on the Mac."	^ buttons anyMask: InputSensor yellowButton! !MouseEvent class removeSelector: #anyButton!MouseEvent class removeSelector: #blueButton!MouseEvent class removeSelector: #redButton!MouseEvent class removeSelector: #yellowButton!Monitor class removeSelector: #controlKey!EventSensor class removeSelector: #commandKeyBit!EventSensor class removeSelector: #ctrlKeyBit!EventSensor class removeSelector: #optionKeyBit!EventSensor class removeSelector: #shiftKeyBit!!EventSensor class reorganize!('class initialization' eventPollPeriod eventPollPeriod: install)('constants' commandAltKey controlKey eventKeyChar eventKeyDown eventKeyUp eventTypeDragDropFiles eventTypeKeyboard eventTypeMenu eventTypeMouse eventTypeNone eventTypeWindow macOptionKey shiftKey)!!classDefinition: #EventSensor category: #'Kernel-Processes'!InputSensor subclass: #EventSensor	instanceVariableNames: 'mouseButtons mousePosition keyboardBuffer interruptKey interruptSemaphore eventQueue inputSemaphore lastEventPoll hasInputSemaphore'	classVariableNames: 'EventPollPeriod EventTicklerProcess'	poolDictionaries: ''	category: 'Kernel-Processes'!HandMorph removeSelector: #aagenerateKeyboardEvent:!Smalltalk removeClassNamed: #EventSensorConstants!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Editor initialize!