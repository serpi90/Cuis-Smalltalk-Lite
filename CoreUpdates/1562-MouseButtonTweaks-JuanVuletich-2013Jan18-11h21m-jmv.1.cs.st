'From Cuis 4.1 of 12 December 2012 [latest update: #1561] on 18 January 2013 at 11:24:32 am'!

!InputSensor methodsFor: 'buttons' stamp: 'jmv 1/17/2013 17:51'!
buttons
	"Answer the result of primMouseButtons, but swap the mouse  buttons if appropriate."
	^ ButtonDecodeTable at: self primMouseButtons + 1! !


!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 1/17/2013 18:00'!
processSensorEvent: evt
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: ((evt at: 5) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no command or option modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		((evt at: 6) anyMask: 12) ifFalse: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].

	self queueEvent: evt.

	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !


!Morph methodsFor: 'events' stamp: 'jmv 1/17/2013 17:20'!
mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event.
	This message will only be sent to Morphs that answer true to #handlesMouseDown:"! !

!Morph methodsFor: 'events' stamp: 'jmv 1/17/2013 17:20'!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse button 1 up event.
	This message will only be sent to Morphs that answer true to #handlesMouseDown:"! !

!Morph methodsFor: 'events' stamp: 'jmv 1/17/2013 17:20'!
mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse button 2 down event.
	This message will only be sent to Morphs that answer true to #handlesMouseDown:"
	self mouseButton2Activity! !

!Morph methodsFor: 'events' stamp: 'jmv 1/17/2013 17:20'!
mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse button 2 up event.
	This message will only be sent to Morphs that answer true to #handlesMouseDown:"! !

!Morph methodsFor: 'events' stamp: 'jmv 1/17/2013 17:19'!
mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Handle a mouse move event.
	This message will only be sent to Morphs that answer true to #handlesMouseDown:
	We can query aMouseMoveEvent to know about pressed mouse buttons."! !

!Morph methodsFor: 'event handling testing' stamp: 'jmv 1/17/2013 17:25'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown messages ?
	- #mouseButton1Down:localPosition:
	- #mouseButton1Up:localPosition:
	- #mouseButton2Down:localPosition:
	- #mouseButton2Up:localPosition:
	- #mouseButton3Down:localPosition:
	- #mouseButton3Up:localPosition:
	- #mouseMove:localPosition:
	- #mouseButton2Activity
	
	NOTE: The default response is false. Subclasses that implement these messages directly should override this one to return true.
	
	Implementors could query the argument, and only answer true for (for example) button 2 up only."

	^ false! !


!HaloHandleMorph methodsFor: 'event handling testing' stamp: 'jmv 1/17/2013 17:27'!
handlesMouseDown: aMouseButtonEvent
	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"
	
	^ mouseDownSelector notNil | mouseMoveSelector notNil | mouseUpSelector notNil! !


!MagnifierMorph methodsFor: 'event handling testing' stamp: 'jmv 1/17/2013 17:27'!
handlesMouseDown: aMouseButtonEvent

	^aMouseButtonEvent mouseButton2Pressed! !


!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 1/17/2013 18:33'!
dispatchWith: aMorph localPosition: positionInAMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| handledByInner eventPositionInChild |
	"See if we're fully outside aMorphs bounds"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [
		^#rejected ]. "outside"

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	"Check for being inside the receiver"	
	(handledByInner or: [ aMorph containsPoint: positionInAMorph event: self ])
		ifTrue: [ ^ self sentTo: aMorph localPosition: positionInAMorph ].

	^ #rejected! !


!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 1/17/2013 18:54'!
dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt handledByInner lastHandler eventPositionInChild |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph localPosition: positionInAMorph ].

	"Try to get out quickly"
	(aMorph morphFullBoundsInWorld containsPoint: self eventPosition) ifFalse: [
		^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ eventHandler.
	aMorphHandlesIt _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self)
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ].
			"Aca podriamos hacer que si aMorph isLocked not, entonces agarrarlo.
			Claro, si el no quiso manejar MouseDown. Y unicamente para button uno.
			Y con um metodo distinto. Asi que quizas no usar el dispatch... que termina en
			#mouseButton1Down:localPosition:
			O quizas si. Empezar haciendo #grabMorph en Morph, y en cualquier otro.
			Y listo.
			Claro, para que todo ande, todos los morphs deben arrancar lockeados, o va a ser un caos.
			Quizas agregar las 2 preguntas extras... Y si, hacerlas aca.
			
			Si lo hacemos con #mouseButton1Down:localPosition:, no hacen falta flags extra.
			Si se le envia ese mensaje, y no tiene nada mas interesante que hacer, bueno, que se cuelgue de la mano.
			
			Ahora, le vamos a enviar #mouseButton1Down:localPosition: incluso a los morhps que conteste falso a la pregunta.
			Asi que la pregunta esta al pedo. Directamente sacarla? Eso hara que el evento seimpre se mande al morph de mas adentro de todos? Podria hacer que no puedas apretar un boton, porque el evento lo agarra solo el label?
			
			Aparentemente solo falla el click en una lista. Y es que esta mal que lo maneje la lista de afuera... Debe manejarlo la de adentro!! Como hace InnerTextMorph!!
			
			O la manera facil de zafar (comentarlo) es con las 2 preguntas o el lock. Y entonces, mantenemos el #handlesMouseDown:. Y enviamos el mensaje al morph si #handlesMouseDown:, o si las 2 preguntas dan true (o alternativamente si no esta lockeado)
			
			Actualmente el concepto de #isLocked se usa para:
			- un punto que no esta en un morph, pero si en un submorph lockeado, se comporta como si lo fuera
			- En un morph lockeado, no se puede embeber otro.
			- Un morph lockeado no recibe NINGUN evento!!!!!!!!!! Esto es un stopper. No puedo andar lockeando todo!! Usar las 2 preguntas.
			"
			].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ aMorph containsPoint: positionInAMorph event: self ])
		ifTrue: [
			"aMorph is in the top-most unlocked, visible morph in the chain."
			aMorphHandlesIt ifTrue: [ self sentTo: aMorph localPosition: positionInAMorph ].
			eventHandler _ lastHandler.
			^self ].

	"Mouse was not on aMorph nor any of its children"
	eventHandler _ lastHandler.
	^ #rejected! !

!methodRemoval: Morph #grabMorph:!
Morph removeSelector: #grabMorph:!
