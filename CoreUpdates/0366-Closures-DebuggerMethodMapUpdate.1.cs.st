'From Cuis 1.0 of 28 November 2009 [latest update: #337] on 9 December 2009 at 10:34:33 pm'!!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'eem 7/6/2009 10:13'!sourceText	self method ifNotNil:		[:method|		method holdsTempNames ifTrue:			[^method				getSourceFor: (method selector ifNil: [method defaultSelector])				in: method methodClass]].	^methodNode sourceText! !!DebuggerMethodMap class methodsFor: 'debugger support' stamp: 'nice 10/21/2009 00:04'!cacheDebugMap: aDebuggerMethodMap forMethod: aCompiledMethod	MapCache finalizeValues.	[MapCache size >= MapCacheEntries] whileTrue:		[| mapsByAge |		 mapsByAge := MapCache keys asArray sort:							[:m1 :m2|							(MapCache at: m1) timestamp							< (MapCache at: m2) timestamp].		mapsByAge notEmpty ifTrue: "There be race conditions and reentrancy issues here"			[MapCache removeKey: mapsByAge last]].	^MapCache		at: aCompiledMethod		put: aDebuggerMethodMap! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 7/6/2009 10:14'!privateTempRefsForContext: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents	"Answer the sequence of temps in scope in aContext in the natural order,	 outermost arguments and temporaries first, innermost last.  Each temp is	 a pair of the temp's name followed by a reference.  The reference can be		integer - index of temp in aContext		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index in aContext		#( outer. temp reference ) - a temp reference in an outer context."	blockExtentsToTempRefs ifNil:		[blockExtentsToTempRefs := (aContext method holdsTempNames										ifTrue: [aContext method]										ifFalse: [methodNode]) blockExtentsToTempsMap.		 startpcsToTempRefs := Dictionary new].	^startpcsToTempRefs		at: aContext startpc		ifAbsentPut:			[| localRefs |			 localRefs := blockExtentsToTempRefs at: (theContextsStartpcsToBlockExtents at: aContext startpc).			 aContext outerContext				ifNil: [localRefs]				ifNotNil:					[:outer| | outerTemps |					"Present temps in the order outermost to innermost left-to-right, but replace					 copied outermost temps with their innermost copies"					 outerTemps := (self										privateTempRefsForContext: outer										startpcsToBlockExtents: theContextsStartpcsToBlockExtents) collect:						[:outerPair|						localRefs							detect: [:localPair| outerPair first = localPair first]							ifNone: [{ outerPair first. { #outer. outerPair last } }]].					outerTemps,					 (localRefs reject: [:localPair| outerTemps anySatisfy: [:outerPair| localPair first = outerPair first]])]]! !"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."DebuggerMethodMap initialize!