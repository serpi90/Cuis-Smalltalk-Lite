'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 30 May 2011 at 2:46:10 pm'!!classDefinition: #Editor category: #'System-Text'!Object subclass: #Editor	instanceVariableNames: 'morph selectionShowing '	classVariableNames: 'KeystrokeActions '	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph pointBlock markBlock beginTypeInIndex emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks '	classVariableNames: 'ChangeText FindText UndoInterval UndoMessage UndoParagraph UndoSelection Undone '	poolDictionaries: ''	category: 'System-Text'!!Editor methodsFor: 'new selection' stamp: 'jmv 5/30/2011 10:01'!selectMark: mark point: point	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse: [		self selectInvisiblyMark: mark point: point ]! !!Parser methodsFor: 'error correction' stamp: 'jmv 5/30/2011 10:01'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| correctSelector userSelection |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [^proposedKeyword asSymbol].		"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"	"	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])		ifFalse: [ ^ proposedKeyword asSymbol ].	"	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	correctSelector _ UnknownSelector name: proposedKeyword.	correctSelector ifNil: [^abortAction value].	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	self substituteSelector: correctSelector keywords wordIntervals: spots.	^(proposedKeyword last ~~ $:	   and: [correctSelector last == $:])		ifTrue: [abortAction value]		ifFalse: [correctSelector]! !!Parser methodsFor: 'error correction' stamp: 'jmv 5/30/2011 10:01'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding _ requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].		"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"	"	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])		ifFalse: [ ^encoder undeclared: proposedVariable ].	"	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	"Build the menu with alternatives"	action _ UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!SimpleEditor methodsFor: 'initialize-release' stamp: 'jmv 5/30/2011 10:10'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	pointIndex _ 1.	"Like pointBlock in EnhancedTextEditor"	markIndex _ 1.	"Like markBlock in EnhancedTextEditor"	beginTypeInIndex _ nil.! !!SimpleEditor methodsFor: 'initialize-release' stamp: 'jmv 5/30/2011 10:10'!stateArray		^ {	self selectionInterval.		beginTypeInIndex}! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 5/30/2011 10:02'!processKeyStroke: aKeyboardEvent	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	(self dispatchOn: aKeyboardEvent) ifTrue: [		self doneTyping.		^self].	self openTypeIn.	self markIndex: self pointIndex! !!SimpleEditor methodsFor: 'private' stamp: 'jmv 5/30/2011 10:02'!zapSelectionWith: aString	| start stop |	start _ self startIndex.	stop _ self stopIndex.	(start = stop and: [aString size = 0]) ifFalse: [		string _ string copyReplaceFrom: start to: stop-1 with: aString.		self markIndex: start pointIndex: start + aString size.		self userHasEdited  " -- note text now dirty" ]! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/30/2011 14:43'!markIndex: anIndex pointIndex: anotherIndex	"Called, for example, when selecting text with shift+arrow keys"	markBlock _ (paragraph characterBlockForIndex: anIndex).	pointBlock _ (paragraph characterBlockForIndex: anotherIndex)! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/30/2011 08:39'!selection	"Answer the text that is currently selected."	| t |	t _ self text.	^Text streamContents: [ :strm |		"Multiple selection"		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |			strm nextPutAll: (t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1).			strm cr ].		"Regular selection"		strm nextPutAll: ( t copyFrom: self startIndex to: self stopIndex - 1 ) ]! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 5/30/2011 10:03'!recomputeSelection	"The same characters are selected but their coordinates may have changed."	self markIndex: self markIndex pointIndex: self pointIndex! !!TextEditor methodsFor: 'events' stamp: 'jmv 5/30/2011 08:37'!mouseDown: evt 	| clickPoint b |	"Multiple selection of text.	Windows uses Control, Mac uses Command (i.e. commandAlt)	On the Mac, command-button1 is translated to command-button3 by the VM. do:		Preferences disable: #commandClickOpensHalo	to disable this behavior and make command-button1 work for multiple selection. "	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [		self selectionInterval size > 0 ifTrue: [			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]	ifFalse: [		selectionStartBlocks _ {}.		selectionStopBlocks _ {} ]	.	clickPoint _ evt position.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint for: model) ifTrue: [		markBlock _ b.		pointBlock _ b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			self closeTypeIn.			markBlock _ b.			pointBlock _ b ]! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 5/30/2011 10:10'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	markBlock _ paragraph defaultCharacterBlock.	pointBlock _ markBlock.	beginTypeInIndex _ nil.	UndoInterval _ 1 to: 0.	self setEmphasisHereFromText.	selectionStartBlocks _ {}.	selectionStopBlocks _ {}! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 5/30/2011 10:10'!stateArray	"nothing if not built yet"	markBlock ifNil: [ ^nil ].	^ {		self selectionInterval.		beginTypeInIndex.		emphasisHere.		selectionStartBlocks.		selectionStopBlocks}! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 5/27/2011 17:14'!stateArrayPut: stateArray	| sel |	sel _ stateArray at: 1.	self selectFrom: sel first to: sel last.	beginTypeInIndex _ stateArray at: 2.	emphasisHere _ stateArray at: 3.	selectionStartBlocks _ stateArray at: 4.	selectionStopBlocks _ stateArray at: 5.	morph possiblyChanged! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/30/2011 10:03'!align	"Align text according to the next greater alignment value,	cycling among leftFlush, rightFlush, center, and justified."	self changeAlignment.	self recomputeSelection! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/30/2011 10:49'!copySelection	"Copy the current selection and store it in the Clipboard, unless a caret.  Undoer & Redoer: undoCutCopy"	| multiSelection |	self lineSelectAndEmptyCheck: [^ self].	multiSelection _ self selection.	UndoSelection _ multiSelection.		"ok?"	self undoer: #undoCutCopy: with: self clipboardStringOrText.	UndoInterval _ self selectionInterval.	"ok?"	self clipboardTextPut: multiSelection! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/30/2011 13:59'!cut	"Cut out the current selection and redisplay the paragraph if necessary.  Undoer & Redoer: undoCutCopy:"	| multiSelection |	selectionStartBlocks ifEmpty: [		self lineSelectAndEmptyCheck: [^ self]].	multiSelection _ self selection.	self zapMultiSelection.	self replaceSelectionWith: self nullText.	"Ojo undoer: y UndoSelection..."	self undoer: #undoCutCopy: with: self clipboardStringOrText.	self clipboardTextPut: multiSelection.! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/30/2011 10:04'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	self closeTypeIn.	UndoParagraph == paragraph ifFalse: [ "Can't undo another paragraph's edit"		UndoMessage _ Message selector: #undoReplace.		UndoInterval _ 1 to: 0.		Undone _ true].	UndoInterval ~= self selectionInterval ifTrue: [ "blink the actual target"		self selectInterval: UndoInterval].	"Leave a signal of which phase is in progress"	UndoParagraph _ Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph _ paragraph! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 5/30/2011 10:01'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| userSelection delta loc |	aString = '#insert period' ifTrue: [		loc _ start.		[(loc _ loc-1)>0 and: [(paragraph string at: loc) isSeparator]]			whileTrue: [loc _ loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	userSelection _ self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString.	delta _ aString size - (stop - start + 1).	self		selectInvisiblyFrom: userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ])! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 5/30/2011 09:35'!selectAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	selectionStartBlocks _ {}.	selectionStopBlocks _ {}.	super selectAt: characterIndex! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 5/30/2011 09:35'!selectInterval: anInterval	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	selectionStartBlocks _ {}.	selectionStopBlocks _ {}.	super selectInterval: anInterval! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 5/30/2011 10:02'!processKeyStroke: aKeyboardEvent	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	(self dispatchOn: aKeyboardEvent) ifTrue: [		self doneTyping.		self storeSelectionInParagraph.		^self].	self openTypeIn.				self hasSelection ifTrue: [ "save highlighted characters"		UndoSelection _ self selection].	markBlock _ pointBlock.	self storeSelectionInParagraph! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 5/30/2011 09:33'!clearSelection	selectionStartBlocks _ {}.	selectionStopBlocks _ {}.	super clearSelection! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 5/30/2011 09:33'!selectAll	selectionStartBlocks _ {}.	selectionStopBlocks _ {}.	super selectAll! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 5/30/2011 09:34'!selectAll: aKeyboardEvent 	"select everything, invoked by cmd-a.  1/17/96 sw"	selectionStartBlocks _ {}.	selectionStopBlocks _ {}.	super selectAll: aKeyboardEvent! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/30/2011 14:22'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ self text				findString: FindText				startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	"self selectInvisiblyFrom: where to: where + FindText size - 1."	self selectInvisiblyFrom: where + FindText size to: where + FindText size - 1.	selectionStartBlocks add: (paragraph characterBlockForIndex: where).	selectionStopBlocks add: (paragraph characterBlockForIndex: where + FindText size).	ChangeText ~~ FindText ifTrue: [ self zapSelectionWith: ChangeText ].	indices nextPut: where.	^ true! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/30/2011 14:12'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: [ "Choose as FindText..."		FindText _ UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: [ "... else set it now as follows."			UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText _ ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: [ "just inserted at a caret"			home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: [ "Show where the search will start"			home last = self selectionInterval last ifFalse: [				self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	selectionStartBlocks _ OrderedCollection new.	selectionStopBlocks _ OrderedCollection new.	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue: [  "none found"		self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: [ "after undo, select this replacement"		home _ self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/30/2011 09:51'!storeSelectionInParagraph	"for proper display of selected text"	paragraph		selectionStartBlocks: (selectionStartBlocks copyWith: self startBlock)		selectionStopBlocks: (selectionStopBlocks copyWith: self stopBlock)! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/30/2011 14:00'!zapMultiSelection	| delta intervals mi pi t start stop miAndPiUpdated |	miAndPiUpdated _ false.	mi _ self markIndex.	pi _ self pointIndex.	delta _ 0.	intervals _ (selectionStartBlocks with: selectionStopBlocks		collect: [ :strt :stp | strt stringIndex to: stp stringIndex ])			sorted: [ :a :b | a first < b first ].	t _ self text.	intervals do: [ :interval |		miAndPiUpdated not ifTrue: [			interval first > mi				ifTrue: [					miAndPiUpdated _ true.					mi _ mi + delta.					pi _ pi + delta ]				ifFalse: [					interval last > mi ifTrue: [						miAndPiUpdated _ true.						mi _ interval first + delta.						pi _ mi ]]].		start _  interval first+delta.		stop _ interval last - 1 + delta.		t replaceFrom: start to: stop with: ''.		delta _ delta - (interval size-1).		paragraph			recomposeFrom: start			to:  start - 1			delta: delta ].	miAndPiUpdated not ifTrue: [		mi _ mi + delta.		pi _ pi + delta ].	selectionStartBlocks _ {}.	selectionStopBlocks _ {}.	self markIndex: mi pointIndex: pi! !!TextEditor methodsFor: 'private' stamp: 'jmv 5/30/2011 14:41'!zapSelectionWith: replacement	| start stop rep |	start _ self startIndex.	stop _ self stopIndex.	(replacement isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (self text attributesAt: start) select: [:att | att mayBeExtended]].	(start = stop and: [ replacement isEmpty ]) ifFalse: [		(replacement is: #Text)			ifTrue: [				"If we are pasting a text that doesn't bring a ParagraphStyleReference in the past paragraph, and we need it,				but it won't be provided by our text, as we are at the end, then add any paragraph attribute from emphasisHere"				(replacement notEmpty and: [ (replacement last = Character cr) not and: [ stop > self text size ]])					ifTrue: [						rep _ (replacement, (Text string: String cr attributes: emphasisHere)) copyFrom: 1 to: replacement size ]					ifFalse: [ rep _ replacement ]]			ifFalse: [ rep _ Text string: replacement attributes: emphasisHere ].		self text replaceFrom: start to: stop - 1 with: rep.		paragraph			recomposeFrom: start			to:  start + rep size - 1			delta: rep size - (stop-start).		self markIndex: start pointIndex: start + rep size.		UndoInterval _ self selectionInterval.		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged! !!SmalltalkEditor methodsFor: 'private' stamp: 'jmv 5/30/2011 10:05'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime _ self isRedoing		ifTrue: [prior _ sym _ selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret _ self startIndex.			self selectPrecedingIdentifier.			input _ self selection]		ifFalse: "Repeated Ctrl-q"			[caret _ UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input _ hintText.			prior _ selectorOrNil].	(input size ~= 0 and: [sym notNil or:			[(sym _ Symbol thatStarts: input string skipping: prior) notNil]])		ifTrue: [ "found something to offer"			newStart _ self startIndex.			outStream _ WriteStream on: (String new: 2 * sym size).			1 to: (kwds _ sym keywords) size do: [:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret _ newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection _ input.			self zapSelectionWith: outStream contents.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: ["no more matches"			firstTime ifFalse: [ "restore original text & set up for a redo"				UndoSelection _ self selection.				self zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone _ true].			morph flash].	self selectAt: caret! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 5/30/2011 14:17'!update: aSymbol	super update: aSymbol.	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents 		ifTrue: [			"Some day, it would be nice to keep objects and update them			instead of throwing them away all the time for no good reason..."			textMorph releaseParagraph.			self formatAndStyleIfNeeded.			^self].	aSymbol == #acceptedContents ifTrue: [		model refetch.		^self].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self].	aSymbol == #initialSelection 		ifTrue: [^self setSelection: model getSelection].	aSymbol == #autoSelect 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: model autoSelectString;						againOrSame: true many: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self redrawNeeded ].	aSymbol == #shoutStyle		ifTrue: [			self stylerStyled.			^self redrawNeeded ].! !!Theme methodsFor: 'colors' stamp: 'jmv 5/30/2011 14:31'!textHighlight	"A nice light blue."	"	^ Color r: 0.71 g: 0.835 b: 1.0	^ Color hue: 214 chroma: 0.29 luminance: 0.816	"	^Color hue: 204 chroma: 0.29 luminance: 0.77! !TextModelMorph removeSelector: #deselect!TextEditor removeSelector: #recomputeInterval!TextEditor removeSelector: #reverseSelection!!classDefinition: #TextEditor category: #'System-Text'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph markBlock pointBlock beginTypeInIndex emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks'	classVariableNames: 'ChangeText FindText UndoInterval UndoMessage UndoParagraph UndoSelection Undone'	poolDictionaries: ''	category: 'System-Text'!!TextEditor reorganize!('accessing' currentAttributes currentCharacterStyleOrNil currentParagraphStyle lastFont lastParagraphStyleOrNil replace:with:and: replaceSelectionWith: setSearch: string text)('accessing-selection' hasCaret markIndex markIndex: markIndex:pointIndex: pointIndex pointIndex: selection selectionAsStream startBlock startIndex stopBlock stopIndex)('as yet unclassified' totalTextHeight visibleHeight)('attributes' changeEmphasisOrAlignment changeTextFont offerColorMenu offerFontMenu)('current selection' recomputeSelection)('displaying' flash)('editing keys' align: cancel: changeEmphasis: changeLfToCr: chooseColor compareToClipboard: copyHiddenInfo enclose: hiddenInfo inOutdent:delta: indent: makeCapitalized: makeLowercase: makeUppercase: offerColorMenu: offerFontMenu: outdent: undo:)('events' doubleClick: mouseDown: mouseMove: mouseUp:)('initialize-release' changeParagraph: resetState stateArray stateArrayPut:)('menu commands' offerMenuFromEsc:)('menu messages' accept again align cancel changeAlignment chooseAlignment compareToClipboard copySelection cut find findAgain pasteRecent setSearchString undo)('model access' model:)('new selection' afterSelectionInsertAndSelect: correctFrom:to:with: insertAndSelect:at: selectAt: selectFrom:to: selectInterval: selectLine)('nonediting/nontyping keys' cursorEnd: cursorHome: openMenu selectCurrentTypeIn: setSearchString:)('parenblinking' blinkParen blinkParenAt: blinkPrevParen: clearParens)('scrolling' scrollBy:)('typing support' addString: backTo: closeTypeIn dispatchOn: doneTyping openTypeIn processKeyStroke: setEmphasisHereFromText setEmphasisHereFromTextForward:)('typing/selecting keys' backWord: clearSelection doAgainMany: find: findAgain: forwardDelete: search: selectAll selectAll:)('undo support' isDoing isRedoing isUndoing noUndoer undoMessage:forRedo: undoer: undoer:with: undoer:with:with: undoer:with:with:with:)('undoers' undoAgain:andReselect:typedKey: undoAndReselect:redoAndReselect: undoCutCopy: undoReplace)('private' againOnce: againOrSame: againOrSame:many: applyAttribute: beginningOfLine: endOfLine: indent:fromStream:toStream: isDisjointFrom: moveCursor:forward:event: nullText pageHeight sameColumn:newLine:forward: storeSelectionInParagraph unapplyAttribute: zapMultiSelection zapSelectionWith:)('binding' bindingOf:)!!SimpleEditor reorganize!('accessing' replace:with:and: replaceSelectionWith: string)('accessing-selection' hasCaret markIndex markIndex: markIndex:pointIndex: pointIndex pointIndex: selection startIndex stopIndex)('editing keys' makeCapitalized: makeLowercase: makeUppercase:)('events' mouseDown:index: mouseMove:index:)('initialize-release' changeString: initialize resetState stateArray stateArrayPut:)('menu messages' copySelection cut)('new selection' selectFrom:to: selectLine)('nonediting/nontyping keys' cursorEnd: cursorHome:)('typing support' addString: backTo: closeTypeIn dispatchOn: doneTyping openTypeIn processKeyStroke:)('typing/selecting keys' forwardDelete:)('testing' isAtEnd isAtStart)('private' sameColumn:newLine:forward: zapSelectionWith:)!Editor removeSelector: #deselect!!classDefinition: #Editor category: #'System-Text'!Object subclass: #Editor	instanceVariableNames: 'morph'	classVariableNames: 'KeystrokeActions'	poolDictionaries: ''	category: 'System-Text'!