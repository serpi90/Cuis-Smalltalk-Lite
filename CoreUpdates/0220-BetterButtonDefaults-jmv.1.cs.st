'From Cuis 1.0 of 2 July 2009 [latest update: #215] on 9 July 2009 at 10:09:49 am'!!AlignmentMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:27'!initialize	"initialize the state of the receiver"	super initialize.	self extent: 1@1! !!AlignmentMorph methodsFor: 'drawing' stamp: 'jmv 7/9/2009 09:27'!clipSubmorphs	^true! !!CodeHolder methodsFor: 'controls' stamp: 'jmv 7/9/2009 09:41'!addOptionalButtonsTo: window at: fractions plus: verticalOffset	"If the receiver wishes it, add a button pane to the window, and answer the verticalOffset plus the height added"	| delta buttons divider |	self wantsOptionalButtons ifFalse: [^verticalOffset].	delta _ self defaultButtonPaneHeight.	buttons _ self optionalButtonRow 		color: (Display depth <= 8 ifTrue: [Color transparent] ifFalse: [self class windowColor duller paler]).	divider _ BorderedSubpaneDividerMorph forBottomEdge.	Preferences alternativeWindowLook ifTrue: [		divider extent: 4@4; color: Color transparent; borderColor: #raised; borderWidth: 2.	].	window 		addMorph: buttons		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!CodeHolder methodsFor: 'controls' stamp: 'jmv 7/9/2009 09:32'!optionalButtonRow	"Answer a row of control buttons"	| row button aLabel buttons widths |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	Preferences menuButtonInToolPane ifTrue: [		buttons add: self menuButton.		widths add: 4 ].	self optionalButtonTuples do: [ :tuple | 		widths add: tuple first.		button _ PluggableButtonMorph 					on: self					getState: nil					action: tuple third.		aLabel := Preferences abbreviatedBrowserButtons 			ifTrue: [self abbreviatedWordingFor: tuple third]			ifFalse: [nil].		button label: (aLabel ifNil: [tuple second asString]).		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].		tuple size > 4 ifTrue: [button triggerOnMouseDown: tuple fifth].		buttons add: button ].	row _ AlignmentMorph proportional.	row addInRow: buttons widthProportionalTo: widths.	^row! !!CodeHolder methodsFor: 'misc' stamp: 'jmv 7/9/2009 09:24'!menuButton	"Answer a button that brings up a menu.  Useful when adding new features, but at present is between uses"	| aButton |	aButton _ IconicButton new target: self;		labelGraphic: (ScriptingSystem formAtKey: #TinyMenu);		color: Color transparent; 		actWhen: #buttonDown;		actionSelector: #offerMenu;		yourself.	aButton setBalloonText: 'click here to get a menu with further options'.	^ aButton! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 7/9/2009 09:31'!optionalButtonRow	"Answer a row of buttons to occur in a tool pane"	| row button buttons widths |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	self buttonSpecs do: [ :tuple | 		widths add: tuple first.		button _ PluggableButtonMorph 					on: self					getState: nil					action: tuple third.		button			label: tuple second asString;			askBeforeChanging: true.		buttons add: button.		button setBalloonText: tuple fourth].	buttons add: self regularDiffButton.	widths add: 9.	self wantsPrettyDiffOption ifTrue: [		buttons add:  self prettyDiffButton.		widths add: 16 ].	row _ AlignmentMorph proportional.	row addInRow: buttons widthProportionalTo: widths.	^row! !!Debugger methodsFor: 'initialize' stamp: 'jmv 7/9/2009 09:43'!buttonRowForPreDebugWindow: aDebugWindow	| row aButton quads buttons |	buttons _ OrderedCollection new.	quads _ OrderedCollection withAll: self preDebugButtonQuads.	(self interruptedContext selector == #doesNotUnderstand:) ifTrue: [		quads add: { 'Create'. #createMethod. #magenta. 'create the missing method' }	].	quads do: [ :quad |		aButton _ SimpleButtonMorph new target: aDebugWindow.		aButton color: Color transparent.		aButton actionSelector: quad second.		aButton label: quad first.		aButton color: (Color colorFrom: quad third) muchLighter.		aButton setBalloonText: quad fourth.		buttons add: aButton].		row _ AlignmentMorph proportional.	row addInRow: buttons.	^row! !!Debugger methodsFor: 'initialize' stamp: 'jmv 7/9/2009 09:45'!customButtonRow	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"	| aButton aLabel buttons row |	buttons _ OrderedCollection new.	self customButtonSpecs do: [ :tuple | 		aButton := PluggableButtonMorph 					on: self					getState: nil					action: tuple second.		(#(#proceed #restart #send #doStep #stepIntoBlock #fullStack #where) 			includes: tuple second) ifTrue: [aButton askBeforeChanging: true].		aLabel := Preferences abbreviatedBrowserButtons 					ifTrue: [self abbreviatedWordingFor: tuple second]					ifFalse: [nil].		aButton label: (aLabel ifNil: [tuple first asString]).		tuple size > 2 ifTrue: [aButton setBalloonText: tuple third].		buttons add: aButton].			row _ AlignmentMorph proportional.	row addInProportionalRow: buttons.	^row! !!Debugger methodsFor: 'controls' stamp: 'jmv 7/9/2009 09:42'!addOptionalButtonsTo: window at: fractions plus: verticalOffset	"Add button panes to the window.  A row of custom debugger-specific buttons (Proceed, Restart, etc.) is always added, and if optionalButtons is in force, then the standard code-tool buttons are also added.  Answer the verticalOffset plus the height added."	| delta buttons divider anOffset |	anOffset _ (Preferences optionalButtons and: [Preferences extraDebuggerButtons | true])		ifTrue:			[super addOptionalButtonsTo: window at: fractions plus: verticalOffset]		ifFalse:			[verticalOffset].	delta _ self defaultButtonPaneHeight.	buttons _ self customButtonRow.	buttons color: (Display depth <= 8 ifTrue: [Color transparent] ifFalse: [self class windowColor duller paler]).	divider _ BorderedSubpaneDividerMorph forBottomEdge.	Preferences alternativeWindowLook ifTrue:		[divider extent: 4@4; color: Color transparent; borderColor: #raised; borderWidth: 2].	window 		addMorph: buttons		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@anOffset corner: 0@(anOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(anOffset + delta - 1) corner: 0@(anOffset + delta))).	^ anOffset + delta! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 7/9/2009 09:46'!addButtonsAndFileListPanesTo: window at: upperFraction plus: offset forFileList: aFileList 	| fileListMorph column buttonHeight fileListTop divider dividerDelta buttons |	fileListMorph _ PluggableListMorph				on: aFileList				list: #fileList				selected: #fileListIndex				changeSelected: #fileListIndex:				menu: #fileListMenu:.	fileListMorph enableDrag: true; enableDrop: false.	aFileList wantsOptionalButtons		ifTrue: [			buttons _ aFileList optionalButtonRow.			divider _ BorderedSubpaneDividerMorph forBottomEdge.			dividerDelta _ 0.			Preferences alternativeWindowLook				ifTrue: [					buttons color: Color transparent.					divider extent: 4 @ 4;						 color: Color transparent;						 borderColor: #raised;						 borderWidth: 2.					fileListMorph borderColor: Color transparent.					dividerDelta _ 3].			column _ AlignmentMorph proportional.			buttonHeight _ self defaultButtonPaneHeight.			column				addMorph: buttons				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 0)						offsets: (0 @ 0 corner: 0 @ buttonHeight)).			column				addMorph: divider				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 0)						offsets: (0 @ buttonHeight corner: 0 @ buttonHeight + dividerDelta)).			column				addMorph: fileListMorph				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 1)						offsets: (0 @ buttonHeight + dividerDelta corner: 0 @ 0)).			window				addMorph: column				fullFrame: (LayoutFrame						fractions: upperFraction						offsets: (0 @ offset corner: 0 @ 0)).			Preferences alternativeWindowLook				ifTrue: [column borderWidth: 2]				ifFalse: [column borderWidth: 0]]		ifFalse: [			fileListTop _ 0.			window				addMorph: fileListMorph				frame: (0.3 @ fileListTop corner: 1 @ 0.3)].! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:47'!createAcceptButton	"create the [accept] button"	| result frame |	result := (SimpleButtonMorph new)				target: self;				color: Color lightGreen.	result		label: 'Accept(s)' translated;		actionSelector: #accept.	frame := LayoutFrame new.	frame		rightFraction: 0.4;		bottomFraction: 0.98.	result layoutFrame: frame.	self addMorph: result.	^result! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:47'!createCancelButton	"create the [cancel] button"	| result frame |	result := (SimpleButtonMorph new)				target: self;				color: Color lightRed.	result		label: 'Cancel(l)' translated;		actionSelector: #cancel.	frame := LayoutFrame new.	frame		leftFraction: 0.6;		bottomFraction: 0.98.	result layoutFrame: frame.	self addMorph: result.	^result! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:48'!setDefaultParameters	"change the receiver's appareance parameters"	| colorFromMenu worldColor menuColor menuBorderColor |	colorFromMenu := Preferences menuColorFromWorld				and: [Display depth > 4]				and: [(worldColor := self currentWorld color) isColor].	menuColor := colorFromMenu				ifTrue: [worldColor luminance > 0.7						ifTrue: [worldColor mixed: 0.85 with: Color black]						ifFalse: [worldColor mixed: 0.4 with: Color white]]				ifFalse: [Preferences menuColor].	menuBorderColor := #raised.	self		setColor: menuColor		borderWidth: Preferences menuBorderWidth		borderColor: menuBorderColor! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:50'!updateColor	"update the recevier's fillStyle"	textPane isNil		ifTrue: [^ self].	textPane borderColor: #inset! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 7/9/2009 09:22'!clipSubmorphs	^true! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:39'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ #raised! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 10:09'!defaultColor	"answer the default color/fill style for the receiver"	^ Color transparent! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:31'!initialize	"initialize the state of the receiver"	super initialize.	model _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	shortcutCharacter _ nil.	askBeforeChanging _ false.	triggerOnMouseDown _ false.	onColor _ Color transparent.	offColor _ Color transparent.	feedbackColor _ Color red.	showSelectionFeedback _ false.	allButtons _ nil.	argumentsProvider _ nil.	argumentsSelector _ nil.	self extent: 20 @ 15! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:43'!defaultBorderColor	^#raised! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'di 6/5/2000 09:08'!initialize	self initializeAllButLabel; setDefaultLabel! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:45'!initializeAllButLabel	super initialize.	self color: (Color r: 0.4 g: 0.8 b: 0.6).	self borderColor: self defaultBorderColor.	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp! !!SimpleButtonMorph methodsFor: 'drawing' stamp: 'jmv 7/9/2009 09:24'!clipSubmorphs	^true! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jmv 7/9/2009 09:51'!buttonToTriggerIn: aFileList 	"Answer a button that will trigger the receiver service in a file list"	| aButton |	aButton := PluggableButtonMorph 				on: self				getState: nil				action: #performServiceFor:.	aButton arguments: { 				aFileList}.	aButton		color: Color transparent;		label: self buttonLabel;		askBeforeChanging: true.	aButton color: aFileList class windowColor duller paler.	aButton setBalloonText: self description.	^aButton! !!SystemWindow methodsFor: 'initialization' stamp: 'jmv 7/9/2009 09:52'!createBox	"create a button with default to be used in the label area"	| box |	box := IconicButton new.	box		color: Color transparent;		target: self.			^box! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 7/9/2009 09:53'!buildTestsList	| column offset buttonRow |	column _ AlignmentMorph proportional.	testsList _ PluggableListMorphOfMany				on: self				list: #tests				primarySelection: #selectedSuite				changePrimarySelection: #selectedSuite:				listSelection: #listSelectionAt:				changeListSelection: #listSelectionAt:put:				menu: #listMenu:shifted:.	testsList autoDeselect: false.	offset _ 0.	self wantsOptionalButtons		ifTrue: [offset _ TextStyle default lineGrid + 16 ].	column		addMorph: testsList		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ offset negated)).	self wantsOptionalButtons		ifTrue: [			buttonRow _ self optionalButtonRow.			buttonRow				color: (Display depth <= 8						ifTrue: [Color transparent]						ifFalse: [Color gray alpha: 0.2]).			Preferences alternativeWindowLook				ifTrue: [					buttonRow color: Color transparent].			column				addMorph: buttonRow				fullFrame: (LayoutFrame						fractions: (0 @ 1 corner: 1 @ 1)						offsets: (0 @ (offset - 1) negated corner: 0 @ 0))].	^ column! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 7/9/2009 09:53'!buildUpperControls	| refreshButton filterButton stopButton runOneButton runButton row bWidth listsMorph |	row _ AlignmentMorph proportional.	row		color: (Display depth <= 8				ifTrue: [Color transparent]				ifFalse: [Color gray alpha: 0.2]).	refreshButton _ self buildRefreshButton.	filterButton _ self buildFilterButton.	stopButton _ self buildStopButton.	runOneButton _ self buildRunOneButton.	runButton _ self buildRunButton.	listsMorph _ self buildTestsList.	bWidth _ 90.	row		addMorph: refreshButton		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 0 @ 0.33)				offsets: (4 @ 2 corner: bWidth - 4 @ -2)).	row		addMorph: filterButton		fullFrame: (LayoutFrame				fractions: (0 @ 0.33 corner: 0 @ 0.66)				offsets: (4 @ 2 corner: bWidth - 4 @ -2)).	row		addMorph: stopButton		fullFrame: (LayoutFrame				fractions: (0 @ 0.66 corner: 0 @ 1)				offsets: (4 @ 2 corner: bWidth - 4 @ -2)).	row		addMorph: listsMorph		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (bWidth  @ 0 corner: bWidth negated @ 0)).	row		addMorph: runOneButton		fullFrame: (LayoutFrame				fractions: (1 @ 0 corner: 1 @ 0.5)				offsets: (bWidth negated + 4 @ 2 corner: -4 @ -2)).	row		addMorph: runButton		fullFrame: (LayoutFrame				fractions: (1 @ 0.5 corner: 1 @ 1)				offsets: (bWidth negated + 4 @ 2 corner: -4 @ -2)).	Preferences alternativeWindowLook		ifTrue: [			row color: Color transparent].	^ row! !!TestRunner methodsFor: 'interface opening' stamp: 'jmv 7/9/2009 09:32'!optionalButtonRow	| row btn buttons widths |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	self optionalButtonTuples do: [ :tuple | 		widths add: tuple first.		btn _ PluggableButtonMorph 			on: self			getState: nil			action: tuple third.		btn			label: tuple second.		buttons add: btn].	row _ AlignmentMorph proportional.	row addInRow: buttons widthProportionalTo: widths.	^row! !!AlignmentMorph reorganize!('classification' isAlignmentMorph)('initialization' defaultBorderWidth defaultColor initialize)('construction' addInProportionalRow: addInRow: addInRow:atFractions: addInRow:widthProportionalTo:)('drawing' clipSubmorphs)!