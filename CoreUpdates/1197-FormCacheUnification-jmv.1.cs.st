'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 4 January 2012 at 6:35 pm'!!classDefinition: #PluggableButtonMorph category: #'Morphic-Views for Models'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font icon getStateSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle '	classVariableNames: 'Arrows CurrentArrowSize '	poolDictionaries: ''	category: 'Morphic-Views for Models'!!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 1/4/2012 17:38'!            resetMenu	| w f |	firstVisible _ 1.	self selected: 1.	w _ 120.	f _ self class listFont.	1		to: completer entryCount		do: [ :index |			w _ w max: (f widthOfString: (completer entries at: index) asString)].	completer entryCount > self class itemsPerPage  ifTrue: [		w _ w + Theme current scrollbarThickness ].	self extent: w + 4 @ (self visibleItemsCount * self itemHeight+2)! !!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 1/4/2012 17:40'!                   drawOn: aCanvas	| rectangle w x0 y0 h y1 y2 scrollbarThickness |	aCanvas frameAndFillRectangle: self bounds fillColor: self color borderWidth: borderWidth borderColor: borderColor.	x0 _ bounds left+1.	y0 _ bounds top+1.	w _ bounds width-2.	scrollbarThickness _ Theme current scrollbarThickness.	completer entryCount > self class itemsPerPage  ifTrue: [		w _ bounds width-scrollbarThickness -2.		aCanvas			frameRectangle: (bounds topRight - (scrollbarThickness@0)				extent: scrollbarThickness @ bounds height)			borderWidth: 1			color: borderColor.		aCanvas			image: (FormCanvas arrowOfDirection: #up size: scrollbarThickness)			at: bounds topRight - (scrollbarThickness@0).		aCanvas			image: (FormCanvas arrowOfDirection: #down size: scrollbarThickness)			at: bounds bottomRight - scrollbarThickness.		h _ bounds height - (2 * scrollbarThickness).		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.		aCanvas			fillRectangle: (bounds right - scrollbarThickness+2@y1 corner: bounds right-2 @ y2)			colorOrInfiniteForm: Color veryLightGray ].	self firstVisible		to: self lastVisible		do: [ :index |			rectangle _ x0@y0 extent: w@self class itemHeight.			index = self selected				ifTrue: [					aCanvas fillRectangle: rectangle colorOrInfiniteForm: (Theme current listHighlightFocused: true) ].			aCanvas				drawString: (completer entries at: index) asString				in: rectangle				font: self class listFont				color: Theme current text.			y0 _ y0 + self itemHeight ]! !!DisplayObject methodsFor: 'displaying-generic' stamp: 'jmv 1/4/2012 16:50'!      displayOn: aDisplayMedium at: aDisplayPoint 	"Display the receiver located at aDisplayPoint with default settings for 	rule and halftone."	| r |	r _ (aDisplayMedium depth < 32 or: [ self mightBeTranslucent not]) 		ifTrue: [			"Rule Form paint treats pixels with a value of zero as transparent"			Form paint]		ifFalse: [ Form blend ].	self displayOn: aDisplayMedium		at: aDisplayPoint		clippingBox: aDisplayMedium boundingBox		rule: r		fillColor: nil! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jmv 1/4/2012 16:48'!     image: aForm at: aPoint sourceRect: sourceRect	"Draw a translucent image using the best available way of representing translucency.	Note: This will be fixed in the future."	| r |	self isShadowDrawing ifTrue: [		^self stencil: aForm at: aPoint sourceRect: sourceRect color: shadowColor ].	r _ (self depth < 32 or: [ aForm mightBeTranslucent not]) 		ifTrue: [			"Rule Form paint treats pixels with a value of zero as transparent"			Form paint]		ifFalse: [ Form blend ].	self image: aForm		at: aPoint		sourceRect: sourceRect		rule: r! !!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 1/4/2012 17:52'!          roundRect: aRectangle color: aColor radius: r gradientTop: topFactor gradientBottom: bottomFactor gradientHeight: h	"	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientBottom: 0.5 gradientHeight: 35	"	| bottomColor |	"top stripe"	self		image: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor		at: aRectangle topLeft.	self		image: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor		at: aRectangle topRight - (r@0).	self		fillRectangle: ((aRectangle withHeight: h) insetBy: r@0)		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor.	bottomColor _ aColor * bottomFactor.	"center stripe"	self fillRectangle: (aRectangle insetBy: (0 @ h corner: 0 @ r)) colorOrInfiniteForm: bottomColor.		"bottom stripe"	self		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: bottomColor		at: aRectangle bottomLeft - (0@r).	self		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: bottomColor		at: aRectangle bottomRight - (r@r) .	self fillRectangle: ((aRectangle bottomLeft + (r@r negated)) extent: (aRectangle width - r - r@r)) colorOrInfiniteForm: bottomColor! !!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 16:38'!                      arrowOfDirection: aSymbol size: finalSizeInteger	^CachedForms		at: { aSymbol . finalSizeInteger }		ifAbsentPut: [			self buildArrowOfDirection: aSymbol size: finalSizeInteger ]! !!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 17:17'!                       arrowWithGradientOfDirection: aSymbol	"	(FormCanvas arrowWithGradientOfDirection: #up) display	(FormCanvas arrowWithGradientOfDirection: #down) display	(FormCanvas arrowWithGradientOfDirection: #left) display	(FormCanvas arrowWithGradientOfDirection: #right) display	"	^CachedForms		at: { aSymbol . #gradient }		ifAbsentPut: [			self buildArrowWithGradientOfDirection: aSymbol ]! !!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 17:04'!       buildArrowOfDirection: aSymbolDirection size: finalSizeInteger	"PRIVATE - create an arrow with aSymbolDirectionDirection,  	finalSizeInteger and aColor  	 	aSymbolDirectionDirection = #up, #down. #left or #right	 (self buildArrowOfDirection: #down size: 120) display	"	| resizeFactor outerBox arrowMorph resizedForm f |	resizeFactor _ 4.	outerBox _ RectangleMorph new.	outerBox		extent: finalSizeInteger asPoint * resizeFactor;		borderWidth: 0;		color: Color transparent.		arrowMorph _ self buildArrowIn: outerBox bounds.	arrowMorph position: outerBox bounds center - (arrowMorph extent // 2).	outerBox addMorphFront: arrowMorph.		f _ outerBox imageForm: 32.	resizedForm _ f		magnify: f boundingBox		by: 1 / resizeFactor		smoothing: 4.	aSymbolDirection == #right ifTrue: [		resizedForm _ resizedForm rotateBy: 90 ].	aSymbolDirection == #down ifTrue: [		resizedForm _ resizedForm rotateBy: 180 ].	aSymbolDirection == #left ifTrue: [		resizedForm _ resizedForm rotateBy:  270 ].			aSymbolDirection == #up ifFalse: [		resizedForm _ resizedForm			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].			^resizedForm! !!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 17:23'!     buildArrowWith: insideForm borderForm: borderForm	| extent translucentForm color insideSpec borderSpec border background alpha|	"	Display getCanvas		image: (FormCanvas buildArrowWith: FormCanvas downInsideForm borderForm: FormCanvas downBorderForm)		at: 20@20	Display getCanvas		image: (FormCanvas buildArrowWith:FormCanvas upInsideForm borderForm: FormCanvas upBorderForm)		at: 40@20	"	extent _ insideForm extent - (1@2).	translucentForm _ Form extent: insideForm extent depth: 32.	0 to: extent x-1 do: [ :x |		0 to: extent y-1 do: [ :y |			insideSpec _ insideForm colorAt: x@(y+1).			borderSpec _ borderForm colorAt: x@(y+1).			insideSpec = Color blue				ifTrue: [ color _ Color transparent ]				ifFalse: [					borderSpec = Color red						ifTrue: [ color _ insideSpec ]						ifFalse: [							border _ x < (extent x//2)								ifTrue: [Color white]								ifFalse: [Color black].							background _ borderForm colorAt: extent x@(y+1).							alpha _ borderSpec red asFloat - background red / (border red - background red).							color _ border alpha: alpha ]].			translucentForm colorAt: x@y put: color ]].	^translucentForm! !!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 17:30'!           buildArrowWithGradientOfDirection: aSymbol	"	(FormCanvas buildArrowWithGradientOfDirection: #up) display	(FormCanvas buildArrowWithGradientOfDirection: #down) display	(FormCanvas buildArrowWithGradientOfDirection: #left) display	(FormCanvas buildArrowWithGradientOfDirection: #right) display	"	| insideForm borderForm form rotated extent |	(aSymbol == #up or: [ aSymbol == #right ])		ifTrue: [			insideForm _ FormCanvas upInsideForm.			borderForm _ FormCanvas upBorderForm ].	(aSymbol == #left or: [ aSymbol == #down ])		ifTrue: [			insideForm _ FormCanvas downInsideForm.			borderForm _ FormCanvas downBorderForm ].	form _ FormCanvas buildArrowWith: insideForm borderForm: borderForm.	(aSymbol == #right or: [ aSymbol == #left]) ifFalse: [		^form ].	extent _ form extent.	rotated _ Form extent: extent transposed depth: 32.	0 to: extent x-1 do: [ :x |		0 to: extent y-1 do: [ :y |			rotated colorAt: y@x put: (form colorAt: x@(extent y - y - 1)) ]]. 	^rotated! !!FormCanvas class methodsFor: 'private' stamp: 'jmv 1/4/2012 17:05'!                             buildArrowIn: aRectangle 	"PRIVATE - create an arrow bounded in aRectangle"	"	(self buildArrowOfDirection: #up size: 20) display	"	| arrow vertices |	vertices _ self verticesForSimpleArrow: aRectangle.	arrow _ PolygonMorph 		vertices: vertices		color: Color darkGray		borderWidth: 0		borderColor: Color black.	arrow bounds: (arrow bounds insetBy: (aRectangle width / 6) rounded).	^arrow! !!FormCanvas class methodsFor: 'private' stamp: 'jmv 1/4/2012 17:05'!      downBorderForm	"	(Base64MimeConverter mimeEncode: ((FileStream readOnlyFileNamed: 'DownBorder.png') binary)) upToEnd	FormCanvas downBorderForm display	"	^Form fromBinaryStream:		'iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAAABGdBTUEAANjr9RwUqgAAACBj		SFJNAACHCwAAjBgAAQCgAACBPQAAb+0AAPWtAAA89gAAIqepNAfrAAACH2lDQ1BWQTIyMjZ3		LTMAADjLrdNPaNNwFAfwb1plY4oHqbtshxxkKrbapTDE0/pnlbpSY5ttulubZG21SUOStlM8		CN48CnoTFcbUm7eJp4EHd/Eggg53FgQ9OdhBGdn7Jf2lIMxd9sqPfvLj5b1fXxMg+qtqWa0I		AMN07fKVjHjj5qI4tIURxGidwfmq6lhpWS5i39j5AoF9f06wWg83fj4uPh1//eZZ3kpcvvgd		/48TNjUEhDg5Vg88zVwLrDD3XMslN5jVRlUj3yPHbaWcJb9ideqB3zLXAm8wd9U6u3eTnDS1		pglEhsmXNN1RyayXpjmqQV4h/zGMNtWPPiefVS2b7o2yOqfZXIIjP/gNZBzKXx7sFS3g5Qdg		9NFgb4JyTm0B78YGe9ub/qyE0WFnKSX5W8KxNeDoE8/bXgCGzgG7Xz3v75rn7a5S72/A+o7a		sbv9eQnCR+Cg6+A3B9fAJ5drPwdz8SMJrK4Dyn0gR7N5QWuCzhUbA2SyMo1IKsVXMEM/RubT		kiRN9RIpHG4YrQ7vcZLWcbNWutb3D8uVFW6nW5nhXmrmC9xaNTfLfbeRLYU5dr7Mfat6VebW		zblKWL/lP/f9XpkwX3dmKoOaygK33SnPcd9uz4b5mp4Lz2a2SmHNplsIz495pCH5nyn0kAAN		MngWWSzSDMTrTO/HV478OyNXX/b/y2zbumM36w1XTNObqMfFgqleiItScnISexhVrtvCXxoz		AAAA60lEQVQ4T6XTsQqDMBAA0PTf/AtxF0TwH/wEVwfdXAQ3R3ERdBcc1dXBQcVB5eoZKk3T		UGMDlyl53CV3D0IAyP8LYF1XlKQC78zzDOM4wn5zX5LA67zv+7Asy3+IpmmwbRsQ3O5mous6		TNMEpO/720iWZdB1HX4MwDAM0pBpmkcBdV1TpKoqaaQoigMpy5IiGE3TXIZs2z6fkWJv7XGl		LEVRmH9IkoRF8jz/mY3jOAwSxzGLYFZt2wohVVW5boiiiEfCMBQinudxSBAEPILZ4GN9njYM		42tPUlgwd2manpBlWcKmdl1XjMjM5BMcKTQUZhJ7QAAAAABJRU5ErkJggg=='				base64Decoded asByteArray readStream! !!FormCanvas class methodsFor: 'private' stamp: 'jmv 1/4/2012 17:05'!       downInsideForm	"	(Base64MimeConverter mimeEncode: ((FileStream readOnlyFileNamed: 'DownInside.png') binary)) upToEnd	FormCanvas downInsideForm display	"	^Form fromBinaryStream:		 'iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAAABGdBTUEAANjr9RwUqgAAACBj		SFJNAACHCwAAjBgAAQCgAACBPQAAb+0AAPWtAAA89gAAIqepNAfrAAACH2lDQ1BWQTIyMjZ3		LTMAADjLrdNPaNNwFAfwb1plY4oHqbtshxxkKrbapTDE0/pnlbpSY5ttulubZG21SUOStlM8		CN48CnoTFcbUm7eJp4EHd/Eggg53FgQ9OdhBGdn7Jf2lIMxd9sqPfvLj5b1fXxMg+qtqWa0I		AMN07fKVjHjj5qI4tIURxGidwfmq6lhpWS5i39j5AoF9f06wWg83fj4uPh1//eZZ3kpcvvgd		/48TNjUEhDg5Vg88zVwLrDD3XMslN5jVRlUj3yPHbaWcJb9ideqB3zLXAm8wd9U6u3eTnDS1		pglEhsmXNN1RyayXpjmqQV4h/zGMNtWPPiefVS2b7o2yOqfZXIIjP/gNZBzKXx7sFS3g5Qdg		9NFgb4JyTm0B78YGe9ub/qyE0WFnKSX5W8KxNeDoE8/bXgCGzgG7Xz3v75rn7a5S72/A+o7a		sbv9eQnCR+Cg6+A3B9fAJ5drPwdz8SMJrK4Dyn0gR7N5QWuCzhUbA2SyMo1IKsVXMEM/RubT		kiRN9RIpHG4YrQ7vcZLWcbNWutb3D8uVFW6nW5nhXmrmC9xaNTfLfbeRLYU5dr7Mfat6VebW		zblKWL/lP/f9XpkwX3dmKoOaygK33SnPcd9uz4b5mp4Lz2a2SmHNplsIz495pCH5nyn0kAAN		MngWWSzSDMTrTO/HV478OyNXX/b/y2zbumM36w1XTNObqMfFgqleiItScnISexhVrtvCXxoz		AAABeElEQVQ4T6XTPauCYBgG4M4vKvoBLYV/osRViKChqbW9pVbRlhYLWlocwoaKWloaiiJQ		CZqKKBD68K5HfU8i5SnOO/gxeHE/H/7EYkDs/we4Xq/49tA3tm0/AjxC0Mf0cjwesdvtsN1u		YVkW1us1FosFZrMZptMpJpMJBoMBdF2HpmkYjUZoNBpP5Fug2+2i0+mA53kPud1uOJ1OHydg		QLlchiiKHrLf7+E4DjabzZ8lMKDZbCKRSGA4HHoIXaicw+EQ2QMGqKoKQRBQKBR8wEfm8zmo		rNVq9bKJQaBeryOZTLqN9lL4CD0YhuEmCk8hCFAZHMehUqkEgADCyloul79jDAOlUgmZTCYE		hJDxeIzL5YJer4cwIEkS4vE4arVaNEJpTNN0p0R7QE2kEmipcrkcstnsCyCUhJB2u43z+exu		JQOq1ao7UkVRPkMIoubSL9BqtSDLMlKpFPL5/BvgRRI2tn6/D1rEdDqNYrEYAUQgzx1gu/D+		fgcIOs3IAFwsJwAAAABJRU5ErkJggg=='				base64Decoded asByteArray readStream! !!FormCanvas class methodsFor: 'private' stamp: 'jmv 1/4/2012 17:06'! upBorderForm	"	(Base64MimeConverter mimeEncode: ((FileStream readOnlyFileNamed: 'UpBorder.png') binary)) upToEnd	FormCanvas upBorderForm display	"	^Form fromBinaryStream:		'iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAABGdBTUEAANjr9RwUqgAAACBj		SFJNAACHCwAAjBgAAQCgAACBPQAAb+0AAPWtAAA89gAAIqepNAfrAAACH2lDQ1BWQTIyMjZ3		LTMAADjLrdNPaNNwFAfwb1plY4oHqbtshxxkKrbapTDE0/pnlbpSY5ttulubZG21SUOStlM8		CN48CnoTFcbUm7eJp4EHd/Eggg53FgQ9OdhBGdn7Jf2lIMxd9sqPfvLj5b1fXxMg+qtqWa0I		AMN07fKVjHjj5qI4tIURxGidwfmq6lhpWS5i39j5AoF9f06wWg83fj4uPh1//eZZ3kpcvvgd		/48TNjUEhDg5Vg88zVwLrDD3XMslN5jVRlUj3yPHbaWcJb9ideqB3zLXAm8wd9U6u3eTnDS1		pglEhsmXNN1RyayXpjmqQV4h/zGMNtWPPiefVS2b7o2yOqfZXIIjP/gNZBzKXx7sFS3g5Qdg		9NFgb4JyTm0B78YGe9ub/qyE0WFnKSX5W8KxNeDoE8/bXgCGzgG7Xz3v75rn7a5S72/A+o7a		sbv9eQnCR+Cg6+A3B9fAJ5drPwdz8SMJrK4Dyn0gR7N5QWuCzhUbA2SyMo1IKsVXMEM/RubT		kiRN9RIpHG4YrQ7vcZLWcbNWutb3D8uVFW6nW5nhXmrmC9xaNTfLfbeRLYU5dr7Mfat6VebW		zblKWL/lP/f9XpkwX3dmKoOaygK33SnPcd9uz4b5mp4Lz2a2SmHNplsIz495pCH5nyn0kAAN		MngWWSzSDMTrTO/HV478OyNXX/b/y2zbumM36w1XTNObqMfFgqleiItScnISexhVrtvCXxoz		AAAA7klEQVQ4T63TsQqEMAwA0N7fiaNf4Ef4E25+gIibji5FcNHFRXB0d3NwcVBQRHLEuyrS		Bk+9glCa9iWm9MUYAPvPQEj9jeO4BYIgIPf1fY/FqJFlWaSA53lKbJ5nGgIciixd10nLmFRZ		EWag/sOyLCk0DIMMYUayGd8KkyQ5bGnbVoamaTqFdF0/QHVdH6GmaU4RIdi2vWFVVe1QWZY/		I0LIsmydFkWxQ1eqEZBpmus0TdMPlOf55WoE5rouxHEMLIqi2whihmEAGiwMw0eQpmmABvN9		/xHkOA6gsfaIc34LwwvCs9gn8tFSj5lafwP0L1EDCtnT7AAAAABJRU5ErkJggg=='				base64Decoded asByteArray readStream! !!FormCanvas class methodsFor: 'private' stamp: 'jmv 1/4/2012 17:06'!         upInsideForm	"	(Base64MimeConverter mimeEncode: ((FileStream readOnlyFileNamed: 'UpInside.png') binary)) upToEnd	FormCanvas upInsideForm display	"	^Form fromBinaryStream:		'iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAABGdBTUEAANjr9RwUqgAAACBj		SFJNAACHCwAAjBgAAQCgAACBPQAAb+0AAPWtAAA89gAAIqepNAfrAAACH2lDQ1BWQTIyMjZ3		LTMAADjLrdNPaNNwFAfwb1plY4oHqbtshxxkKrbapTDE0/pnlbpSY5ttulubZG21SUOStlM8		CN48CnoTFcbUm7eJp4EHd/Eggg53FgQ9OdhBGdn7Jf2lIMxd9sqPfvLj5b1fXxMg+qtqWa0I		AMN07fKVjHjj5qI4tIURxGidwfmq6lhpWS5i39j5AoF9f06wWg83fj4uPh1//eZZ3kpcvvgd		/48TNjUEhDg5Vg88zVwLrDD3XMslN5jVRlUj3yPHbaWcJb9ideqB3zLXAm8wd9U6u3eTnDS1		pglEhsmXNN1RyayXpjmqQV4h/zGMNtWPPiefVS2b7o2yOqfZXIIjP/gNZBzKXx7sFS3g5Qdg		9NFgb4JyTm0B78YGe9ub/qyE0WFnKSX5W8KxNeDoE8/bXgCGzgG7Xz3v75rn7a5S72/A+o7a		sbv9eQnCR+Cg6+A3B9fAJ5drPwdz8SMJrK4Dyn0gR7N5QWuCzhUbA2SyMo1IKsVXMEM/RubT		kiRN9RIpHG4YrQ7vcZLWcbNWutb3D8uVFW6nW5nhXmrmC9xaNTfLfbeRLYU5dr7Mfat6VebW		zblKWL/lP/f9XpkwX3dmKoOaygK33SnPcd9uz4b5mp4Lz2a2SmHNplsIz495pCH5nyn0kAAN		MngWWSzSDMTrTO/HV478OyNXX/b/y2zbumM36w1XTNObqMfFgqleiItScnISexhVrtvCXxoz		AAABdUlEQVQ4T63UvcqCUBgH8N47kqQLcAtBhK6gpTuIuga3LkDMIShaarChhghCqKEhWlxc		gkiooYK+rPz3PseMXlEreA+cRc75nf9zPvxJpYDU/zSCovvpdMLxeIQgCKjX67HjHmGikdvt		Bur7/R7L5RKSJEHTtAQsJg1+2+FwwHa7xXq9xng8RiaTwWazicEioMvlAtd1nwglms/nKJfL		KBaLn0G0oud52O12LEmA2LaN6XQKnufR6/UisFCi8/nMSgojlmVhNpuhUqlAFMVkiFansuKQ		yWSC0WgEWZahKEoIeySiQdfrlW3mazlBkgAZDofsKqTTaQwGgxfsAdFkujPvkH6/j263i0Kh		gHw+/xcyTZNtsOM47HRoY6OSBIhhGGg2m+A4Dqqq+li73cZqtWIlfYq0Wi0GlUol5HI5H2o0		GnT3vkZqtRqq1Sqy2awP6boOOvLFYvG2nCBJgHQ6HXYdnm+NPtAmf9toDs1NfLRxf4S473dR		zQFbumjFEQAAAABJRU5ErkJggg=='				base64Decoded asByteArray readStream! !!FormCanvas class methodsFor: 'private' stamp: 'jmv 1/4/2012 17:05'!            verticesForSimpleArrow: aRectangle 	"PRIVATE - answer a collection of vertices to draw a simple arrow"	| vertices |	vertices _ OrderedCollection new.		vertices add: aRectangle bottomLeft.	vertices add: aRectangle center x @ (aRectangle top + (aRectangle width / 8)).	vertices add: aRectangle bottomRight.		^ vertices! !!LayoutMorph methodsFor: 'private' stamp: 'jmv 1/4/2012 17:39'!                     minPaneWidthForReframe	^Theme current scrollbarThickness * 3! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2012 18:24'!                  actWhen: condition	"Accepts symbols:  #buttonDown, #buttonStillDown or #buttonUp (default)"	actWhen _ condition! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/4/2012 15:36'! drawInconOn: aCanvas	| c theIcon |	c _ self isPressed		ifTrue: [ Theme current buttonPressedIconColor ]		ifFalse: [			self mouseIsOver				ifTrue: [ Color gray: 0.75 ]				ifFalse: [ Color white ]].	theIcon _ self magnifiedIcon.	aCanvas		image: theIcon		multipliedBy: c		at: bounds center - (theIcon extent //2)! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/4/2012 15:54'!                drawOn: aCanvas	self isRoundButton		ifTrue: [ icon ifNil: [ self drawRoundGradientLookOn: aCanvas ]]		ifFalse: [			Theme current steButtons				ifTrue: [ self drawSTELookOn: aCanvas ]				ifFalse: [ self draw3DLookOn: aCanvas ]].	icon ifNotNil: [		self drawInconOn: aCanvas ].! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/4/2012 12:19'!                      drawSTELookOn: aCanvas	aCanvas		roundRect: bounds		color: (Color gray: 0.4)		radius: 4.	aCanvas		roundRect: (bounds insetBy: 1)		color: (Color white)		radius: 4		gradientTop: 0.95		gradientBottom: 0.6		gradientHeight: (bounds height-8 max: bounds height//2)! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/4/2012 18:25'!                              handlesMouseStillDown: evt	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"	"Acting when down (instead of waiting until releasing the button)	also means that the button actin is repeated if the button is kept pressed"	^actWhen == #buttonStillDown! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/4/2012 18:24'!                   mouseDown: event	event mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].	isPressed _ true.	self redrawNeeded.	(actWhen == #buttonDown or: [ actWhen == #buttonStillDown ])		ifTrue: [			self performAction ]		ifFalse: [			"Don't make multi-click slower if we act on button down, just do multiple actions"			event hand				waitForClicksOrDragOrSimulatedMouseButton2: self				event: event				clkSel: nil				clkNHalf: nil				dblClkSel: #doubleClick:				dblClkNHalfSel: nil				tripleClkSel: nil ]! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/4/2012 18:25'!      updateDownButtonImage	"update the receiver's as a downButton.  put a new image inside"	icon _ Theme current steButtons		ifFalse: [ FormCanvas arrowOfDirection: #down size: Theme current scrollbarThickness ]		ifTrue: [ FormCanvas arrowWithGradientOfDirection: #down ].	actionSelector _ #scrollDown.	self		roundButtonStyle: false;		actWhen: #buttonStillDown;		"to enable multiple action if held down"		redrawNeeded! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/4/2012 18:25'!   updateLeftButtonImage	"update the receiver's as a downButton.  put a new image inside"	icon _ Theme current steButtons		ifFalse: [ FormCanvas arrowOfDirection: #left size: Theme current scrollbarThickness ]		ifTrue: [ FormCanvas arrowWithGradientOfDirection: #left ].	actionSelector _ #scrollUp.	self		roundButtonStyle: false;		actWhen: #buttonStillDown;		"to enable multiple action if held down"		redrawNeeded! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/4/2012 18:25'!     updateRightButtonImage	"update the receiver's as a downButton.  put a new image inside"	icon _ Theme current steButtons		ifFalse: [ FormCanvas arrowOfDirection: #right size: Theme current scrollbarThickness ]		ifTrue: [ FormCanvas arrowWithGradientOfDirection: #right ].	actionSelector _ #scrollDown.	self		roundButtonStyle: false;		actWhen: #buttonStillDown;		"to enable multiple action if held down"		redrawNeeded! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/4/2012 18:25'!updateUpButtonImage	"update the receiver's as a upButton. put a new image inside"	icon _ Theme current steButtons		ifFalse: [ FormCanvas arrowOfDirection: #up size: Theme current scrollbarThickness ]		ifTrue: [ FormCanvas arrowWithGradientOfDirection: #up ].	actionSelector _ #scrollUp.	self		roundButtonStyle: false;		actWhen: #buttonStillDown;		"to enable multiple action if held down"		redrawNeeded! !!DraggeableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/4/2012 12:33'!                     drawSTELookOn: aCanvas	aCanvas		roundRect: ((bounds insetBy: (owner bounds isWide ifTrue: [0@4] ifFalse: [4@0])) translateBy: (0@0))		color: (Color black)		radius: 4.	aCanvas		roundRect: ((bounds insetBy: (owner bounds isWide ifTrue: [0@4] ifFalse: [5@0 corner: 4@0])) translateBy: (-1@0))		color: (self isPressed ifTrue: [Color red] ifFalse: [Color gray: 0.86])		radius: 4.! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/4/2012 17:39'!                  extent: newExtent		| minH minW |	"Figure out the minimum width and height for this pane so that scrollbars will appear"	minH _ Theme current scrollbarThickness * 2.	minW _ minH.	super extent: (newExtent max: (minW@minH)).	"Now reset widget sizes"	scroller adjustExtent.	self updateScrollBarsBounds.	self setScrollDeltas! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/4/2012 17:39'!        focusIndicatorRectangle	| b topLeft bottomRight |	b _ self innerBounds.	topLeft _ b topLeft.	bottomRight _ b bottomRight.	self vIsScrollbarShowing ifTrue: [		bottomRight _ scrollBar bounds left -1@ bottomRight y].	self hIsScrollbarShowing ifTrue: [		bottomRight _ bottomRight x @ 			(bottomRight y - Theme current scrollbarThickness)].	^topLeft corner: bottomRight! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/4/2012 17:39'!                           hScrollBarWidth	"Return the width of the horizontal scrollbar"	| w |		w _ bounds width - (2 * borderWidth).	self vIsScrollbarShowing		ifTrue: [ w _ w - Theme current scrollbarThickness ].	^w! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/4/2012 17:39'!             updateScrollBarsBounds		| t topLeft |	hideScrollBars ifTrue: [^self].	t _ Theme current scrollbarThickness.	topLeft _ bounds topRight + (0-t-borderWidth @ borderWidth).	scrollBar bounds: (topLeft extent: t @ self vScrollBarHeight).	topLeft _ bounds bottomLeft + (borderWidth @ (t + borderWidth) negated).	hScrollBar bounds: (topLeft extent: self hScrollBarWidth@ t)! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 1/4/2012 16:52'!                         expandedForm	^FormCanvas arrowOfDirection: #down size: 13! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 1/4/2012 16:30'!                      notExpandedForm	^FormCanvas arrowOfDirection: #right size: 13! !!ScrollBar methodsFor: 'geometry' stamp: 'jmv 1/4/2012 17:39'!                            buttonExtent	^Theme current scrollbarThickness! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 1/4/2012 17:43'!            sliderGrabbed	sliderShadow		bounds: (Theme current steButtons			ifTrue: [ slider bounds insetBy: (bounds isWide ifTrue: [0@3] ifFalse: [3@0]) ]			ifFalse: [ slider bounds ]);		show! !!ScrollBar methodsFor: 'initialization' stamp: 'jmv 1/4/2012 17:39'!                             defaultBounds"answer the default bounds for the receiver"	^ 0 @ 0 extent: Theme current scrollbarThickness @ 100! !!ScrollBar methodsFor: 'drawing' stamp: 'jmv 1/4/2012 17:47'!           drawOn: aCanvas	Theme current steButtons		ifTrue: [			aCanvas				roundRect: bounds				color: (Color gray: 0.4)				radius: 4.			aCanvas				roundRect: (bounds insetBy: 1)				color: (Color gray: 0.95)				radius: 4				gradientTop: 0.99				gradientBottom: 0.96				gradientHeight: (bounds height-8 max: bounds height//2).]		ifFalse: [			aCanvas				fillRectangle: bounds				colorOrInfiniteForm: (color alphaMixed: 0.3 with: Color white)				borderWidth: borderWidth				borderStyleSymbol: #simple				baseColorForBorder: borderColor ]! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 1/4/2012 17:40'!                        minPaneWidthForReframe	^Theme current scrollbarThickness * 3! !!Theme methodsFor: 'colors' stamp: 'jmv 1/4/2012 15:36'!    buttonPressedIconColor	^Color gray: 0.75! !!Theme methodsFor: 'other options' stamp: 'jmv 1/4/2012 17:36'!                 scrollbarThickness	^Preferences scrollbarThickness! !!Theme methodsFor: 'other options' stamp: 'jmv 1/2/2012 18:25'!        steButtons	^false! !!methodRemoval: PluggableButtonMorph class #arrowOfDirection:!PluggableButtonMorph class removeSelector: #arrowOfDirection:!!methodRemoval: PluggableButtonMorph class #arrowOfDirection:size:!PluggableButtonMorph class removeSelector: #arrowOfDirection:size:!!methodRemoval: PluggableButtonMorph class #createArrowIn:!PluggableButtonMorph class removeSelector: #createArrowIn:!!methodRemoval: PluggableButtonMorph class #createArrowOfDirection:size:!PluggableButtonMorph class removeSelector: #createArrowOfDirection:size:!!methodRemoval: PluggableButtonMorph class #initializeArrows:!PluggableButtonMorph class removeSelector: #initializeArrows:!!methodRemoval: PluggableButtonMorph class #verticesForSimpleArrow:!PluggableButtonMorph class removeSelector: #verticesForSimpleArrow:!!PluggableButtonMorph class reorganize!('example' example)('instance creation' model:action: model:stateGetter:action: model:stateGetter:action:label:)!!classDefinition: #PluggableButtonMorph category: #'Morphic-Views for Models'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font icon getStateSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!