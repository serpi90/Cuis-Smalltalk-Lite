'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 20 May 2011 at 4:30:46 am'!!ContentPack commentStamp: 'cbr 5/20/2011 04:29' prior: 0!ContentPack lets you read in and write out the (supported files in the) contents of a directory on your file system. It also allows you to trivially create "messenger" subclasses that capture the information containted in these directory trees, including any implicit communication that's there in the structure of the directory hierarchy itself, which are captured in your changes file. You can then file out a change set that contains a representation of the (supported file/object types and directory structurein) the stuff on your disk, or in your image. This subclass is a dummy which ContentPack compiles methods into containing base 64 encoded data. You can load this into another image, as long as that image has ContentPack loaded. The filed in class can then recreate the ContentPack on the other end with the media files and structure intact.The current implementation is based on #storeString, but the plan is to change that to SmartRefStream in the long run to support serializing things like morphs.ContentPack instances hang onto the actual tree of media objects. It has a nice simple EDSL that just interprets an array of strings from beginning to end as a "path" to a file (really a series of dictionary lookups to a Smalltalk object, wherin the dictionaries mirror the structure of what was on the disk, sans unsupported files.) This mechanism will likely change a little bit at some point, ContentPack came into the world a little faster than I expected, as I ended up using it to send some icons back in time to fix the Cuis update stream without having to sort my changes all over again. As such it had some unusual design pressures... it had to be able to carry information in and out of both the change set stream and the filesystem, as well as function in a slightly earlier (unreleased) version of Cuis than it was written in, and not break anything on it's way back up through the build to head.The code, in particular the way things are named, has not settled yet, and that's why this comment contains no code examples. Use with care and read the code first, for now.Currently, .bmp import and .png import are implemented, and both can be exported. Anything you can import, you can also shuffle into a change set. Plans are in the works to support audio, change sets, and text files. I'll support video if someone has a good importer, exporter, and player under the MIT license that'll work under Cuis. Currently, objects are serialized into single methods, which works for small icons, but likely doesn't work well (if at all) for larger files. My intent is to add some behavior that breaks up large objects into smaller chunks so that this becomes a non-issue. I'll likely get to that when I've removed most of the repetitive subtle variations of the same recursive tree walking visitor-trick from the code, and renamed everything. I think in essence this class is slightly smaller than it is as represented currently.Hopefully I will be able to explain all of this better once I've clarified the code a bit so that I can show off some examples.	- cbr!!Theme commentStamp: 'cbr 5/20/2011 04:10' prior: 0!To set a theme:"Note that some parts of the UI will not update. You may need to reopen your browsers, etc."ThemeName beCurrent."Actually now you can do this from the appearance menu too!!"Themes are collections of methods that affect the way the system presents itself. They can be used to change the color scheme, as well as to modify other look and feel properties (e.g., round versus square window corners, embossed versus solid window labels.) Each of these methods answers a value like true or false, or a Color. Various parts of the system relating primarily to tools and menus query Theme class>>current to determine their configuration.Theme serves as base theme. You can make new color schemes by subclassing it, and you can see what's possible by browsing its methods.Shout's colors are configured using #shout. The method should be fairly self explanatory. The data structure answered by this method is used in #generateShoutConfig to create a large nested array, which is in turn requested by Shout to configure it's color scheme. The default scheme on systems that the present author has encountered thus far use only a subsetof shout's full customizability, as does this facade for it's configuration. For more granular control of Shout, you can override #generateShoutConfig to answer the data structure directly. To get a sense of what it looks like,print:Theme new generateShoutConfig.*Be Warned:* If something goes wrong with this method, or the data isn't shaped correctly, weird and/or bad things can happen to Morphic. Be careful. I've supplied a test for it if you do decide to tinker with it. Send your theme #beCurrent in order to initialize Shout after modifying #shout.Icons can now be swapped in and out of the system using ContentPack. The actual system icons are kept in a ContentPack instance that Theme hangs onto in a class variable called Content. Access the data structure with:Theme content....and see the comment on ContentPack for more details. You can choose from three icon "moods;" in one almost every menu item has an icon, in another, the usual menu items have icons, and a few have been added, and in a third, icons are not shown, which is nice if you've done a theme using colors that don't work well with the built in icons and don't have a suitable set handy.MenuIcons has been removed from the system. It's duties have been absorbed by Theme and ContentPack.	- cbr!