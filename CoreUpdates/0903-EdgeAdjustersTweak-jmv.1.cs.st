'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 5 April 2011 at 9:56:33 pm'!!LayoutAdjustingMorph methodsFor: 'testing' stamp: 'jmv 4/5/2011 21:30'!isOpaqueMorph	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)	but is not an opaque rectangle covering bounds MUST answer false to this message"	((color is: #Color) and: [ color isOpaque not ]) ifTrue: [		^false ].	self borderWidth > 0 ifTrue: [		((self borderColor is: #Color) and: [ self borderColor  isOpaque not]) ifTrue: [			^false ]].	^true! !!SystemWindow methodsFor: 'testing' stamp: 'jmv 4/5/2011 21:31'!isOpaqueMorph	"Not really used, as we also reimplement #addPossiblyUncoveredAreasIn:to:"	^(Theme current roundWindowCorners or: [ color mightBeTranslucent ]) not! !!SystemWindow methodsFor: 'layout' stamp: 'jmv 4/5/2011 21:35'!layoutAndComputeFullBounds	"Compute a new layout of submorphs based on the given layout bounds."	| bl br h thickness tl tr w cornerExtent |	submorphs isEmpty ifTrue: [		^fullBounds _ bounds].	thickness _ 4.	cornerExtent _ 20.	tl _ bounds topLeft.	tr _ bounds topRight.	bl _ bounds bottomLeft.	br _ bounds bottomRight.	w _ bounds width - cornerExtent - cornerExtent.	h _ bounds height - cornerExtent - cornerExtent.	topAdjuster bounds: (tl + (cornerExtent@0) extent: w@thickness).	bottomAdjuster bounds: (bl+ (cornerExtent @ thickness negated) extent: w@thickness).	leftAdjuster bounds: (tl+ (0@cornerExtent) extent: thickness@h).	rightAdjuster bounds: (tr + (thickness negated@ cornerExtent) extent: thickness@h).	topLeftAdjuster bounds: (tl extent: cornerExtent@cornerExtent).	bottomLeftAdjuster bounds: (bl-(0@cornerExtent) extent: cornerExtent@cornerExtent).	topRightAdjuster bounds: (tr+(cornerExtent negated@0) extent: cornerExtent@cornerExtent).	bottomRightAdjuster bounds: (br-cornerExtent extent: cornerExtent@cornerExtent).	layoutMorph ifNotNil: [		layoutMorph bounds: self layoutBounds ].	fullBounds _ self computeFullBounds! !!WindowEdgeAdjustingMorph methodsFor: 'testing' stamp: 'jmv 4/5/2011 21:33'!isOpaqueMorph	"Not really needed, as we also answer false to #isOrthoRectangularMorph"	^false! !!WindowEdgeAdjustingMorph methodsFor: 'testing' stamp: 'jmv 4/5/2011 21:31'!isOrthoRectangularMorph	^false! !!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 4/5/2011 21:52'!containsPoint: aPoint	| sensitiveBorder |	(bounds containsPoint: aPoint) ifFalse: [ ^false ].	sensitiveBorder _ 4.	selector caseOf: {		[ #topLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].		[ #topRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].		[ #bottomLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].		[ #bottomRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].	}	otherwise: [		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."		^true ]! !!WindowEdgeAdjustingMorph reorganize!('initialization' initializeBottom initializeBottomLeft initializeBottomRight initializeLeft initializeRight initializeTop initializeTopLeft initializeTopRight)('adjusting' adjustIndicatorAt: adjustOwnerAt:)('accessing' cursor handPoint initialIndicatorBounds)('drawing' drawOn:)('testing' isOpaqueMorph isOrthoRectangularMorph)('geometry testing' containsPoint:)!