'From Cuis 1.0 of 4 September 2009 [latest update: #290] on 7 September 2009 at 9:22:34 am'!!BitBlt methodsFor: 'private' stamp: 'jmv 9/7/2009 09:03'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor	| lastSourceDepth targetColor sourceDepth destDepth |	sourceForm notNil ifTrue: [ lastSourceDepth _ sourceForm depth ].	sourceForm _ aStrikeFont glyphs.	sourceDepth _ sourceForm depth.	destDepth _ destForm depth.	"Ignore any halftone pattern since we use a color map approach here"	halftoneForm _ nil.	sourceY _ 0.	height _ aStrikeFont height.	sourceDepth = 1 ifTrue: [		self combinationRule: Form paint.		(colorMap isNil or: [ lastSourceDepth ~= sourceDepth ]) ifTrue: [			"Set up color map for a different source depth (color font)"			"Uses caching for reasonable efficiency			Warning: We are not considering that destDepth could change too, requiring a new colormap			This seems not to cause any problems..."			colorMap _ self cachedFontColormapFrom1BitTo: destDepth.			colorMap at: 1 put: (destForm pixelValueFor: Color transparent)].		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]		ifFalse: [		(Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ Preferences subPixelRenderColorFonts ]]) ifTrue: [			destDepth > 8 ifTrue: [				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"				self combinationRule: 37.		"rgbMul"				colorMap _ (destDepth = 32 or: [ (foregroundColor = Color black) not ]) ifTrue: [					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)					See #displayString:from:to:at:strikeFont:kern:"					"Note: In 32bpp we always need the second pass, as the source could have transparent pixels, and we need to add to the alpha channel"					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]			ifFalse: [				self combinationRule: 25.		"Paint"				targetColor _ foregroundColor = Color black ifFalse: [ foregroundColor ].				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]		ifFalse: [			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]].! !!Color class methodsFor: 'colormaps' stamp: 'jmv 9/7/2009 09:21'!computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.	keepSubPix		ifTrue: [ Answer colors that also include subpixelAA ]		ifFalse: [ 			Take fullpixel luminance level. Apply it to targetColor.			I.e. answer colors with NO subpixelAA ]"	| mask map c bitsPerColor r g b f v |	destDepth > 8		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"		ifFalse: [bitsPerColor _ 4].	"Usually a bit less is enough, but make it configurable"	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.	mask _ (1 bitShift: bitsPerColor) - 1.	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).	0 to: map size - 1 do: [:i |		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.		b _ (i bitShift: 0) bitAnd: mask.		f _ 1.0 - (r + g + b / 3.0 / mask).		c _ targetColor			ifNotNil: [				(keepSubPix and: [destDepth > 8]) ifTrue: [						Color							r: 1.0 - (r/mask) * targetColor red							g: 1.0 - (g/mask) * targetColor green							b: 1.0 - (b/mask) * targetColor blue							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]				ifFalse: [					destDepth = 32						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"		v _ destDepth = 32			ifTrue: [ c pixelValueForDepth: destDepth]			ifFalse: [				f < 0.1					ifTrue: [ 0 ]					ifFalse: [ c pixelValueForDepth: destDepth ]].		map at: i + 1 put: v ].	^ map! !Preferences class removeSelector: #properAlphaForBlackText!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."BitBlt recreateColorMaps!