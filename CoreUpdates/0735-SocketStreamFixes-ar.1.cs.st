'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 28 December 2010 at 11:19:27 am'!!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:50'!next: anInteger into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]] 		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount < anInteger 		ifTrue:[aCollection copyFrom: 1 to:  startIndex + amount-1]		ifFalse:[aCollection]! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:52'!readInto: aCollection startingAt: startIndex count: anInteger	"Read n objects into the given collection starting at startIndex. 	Return number of elements that have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]]		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:49'!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself."	[[self atEnd] whileFalse: [self beSignalingWhile:[self receiveData]]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !!SocketStream methodsFor: 'testing' stamp: 'ar 11/23/2010 00:04'!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we read more data.	Note: It is important not to rely on 'socket dataAvailable' here since this will	not work for subclasses such as SecureSocketStream (which can contain	undecrypted contents that has been read from the socket)." 	self isInBufferEmpty ifFalse: [^true].	^self receiveAvailableData < inNextToWrite! !!SocketStream methodsFor: 'private' stamp: 'ar 11/22/2010 23:48'!beSignalingWhile: aBlock	"Temporarily turn a non-signaling SocketStream into a signaling one.	Required for some of operations that will catch ConnectionClosed in 	order to find out that an operation completed"	| signaling |	signaling := shouldSignal.	shouldSignal := true.	^aBlock ensure:[shouldSignal := signaling]! !!SocketStream methodsFor: 'control' stamp: 'gk 4/14/2005 09:49'!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self atEnd not and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !