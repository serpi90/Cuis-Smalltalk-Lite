'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 6 December 2011 at 8:52:49 am'!!classDefinition: #ReferenceStreamTest category: #'System-Object Storage-Tests'!TestCase subclass: #ReferenceStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage-Tests'!!classDefinition: #SmartRefStreamTest category: #'System-Object Storage-Tests'!TestCase subclass: #SmartRefStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage-Tests'!!DiskProxy methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2011 09:48'!storeDataOn: aReferenceStream	"Besides just storing, get me inserted into references, so structures will know about class DiskProxy."	super storeDataOn: aReferenceStream.	"just so instVarInfo: will find it and put it into structures""	aReferenceStream references at: self put: #none."	aReferenceStream addSpecialReference: self! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'jmv 12/6/2011 08:35'!                               ascii	"do nothing"! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'jmv 12/6/2011 08:37'!                           cr	"Append a return character to the receiver."	self nextPut: Character cr! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'jmv 12/6/2011 08:37'! padToEndWith: aChar	"We don't have pages, so we are at the end, and don't need to pad."! !!ReferenceStream methodsFor: 'writing' stamp: 'jmv 11/25/2011 09:48'!                            addSpecialReference: aDiskProxy	"See senders. Added to avoid breaking encapsulation (assuming that #references would answer the actual collection)"	references at: aDiskProxy put: #none! !!ReferenceStream methodsFor: 'writing' stamp: 'jmv 12/6/2011 08:47'!                            references	"Values can be:		- integer: regular reference. Value is position in the output stream.		- #none: special value for DiskProxy. Value is just a marker.		- A collection of (still) weak only references. They are turned into regular references when the first regular reference to the key is dumped.	See #tryToPutReference:typeID:"		"Warning: Methods that need to deal with the internals of dumping weak references, or methods that need to actually modify the references dictionary CAN NOT use this method!!"	"Do not include provisory references created in #nextPutWeak that never became normal references,	because the referenced object was never added from a call to #nextPut:"	^ references select: [ :value | value isNumber or: [ value == #none ]]! !!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 11/25/2011 10:54'!                     statisticsOfRefs	"Analyze the information in references, the objects being written out"	| parents n kids nm ownerBags tallies owners objParent normalReferences |	normalReferences _ self references.	"Exclude unrealized weaks"	parents _ IdentityDictionary new: normalReferences size * 2.	n _ 0.	'Finding Owners...'	displayProgressAt: Sensor mousePoint	from: 0 to: normalReferences size	during: [:bar |	normalReferences keysDo:		[:parent | bar value: (n _ n+1).		kids _ parent class isFixed			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]			ifFalse: [parent class isBits ifTrue: [Array new]					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].		(kids select: [:x | normalReferences includesKey: x])			do: [:child | parents at: child put: parent]]].	ownerBags _ Dictionary new.	tallies _ Bag new.	n _ 0.	'Tallying Owners...'	displayProgressAt: Sensor mousePoint	from: 0 to: normalReferences size	during: [:bar |	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"		[:obj | bar value: (n _ n+1).		nm _ obj class name.		tallies add: nm.		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [			owners add: objParent class name]]].	^ String streamContents: [ :strm | 		tallies sortedCounts do: [ :assn |			n _ assn key.  nm _ assn value.			owners _ ownerBags at: nm.			strm cr; nextPutAll: nm; space; print: n.			owners size > 0 ifTrue: [				strm cr; tab; print: owners sortedCounts]]]! !!ReferenceStreamTest methodsFor: 'testing' stamp: 'jmv 12/6/2011 08:32'!              testDiskProxy	"	ReferenceStreamTest new testDiskProxy	"	| newInstance oldInstance |	oldInstance _ { Smalltalk . ActiveHand . Display . Morph}.	newInstance _ ReferenceStream unStream: (ReferenceStream streamedRepresentationOf: oldInstance).	1 to: oldInstance size do: [ :i |		self assert: (newInstance at: i) == (oldInstance at: i) ]! !!ReferenceStreamTest methodsFor: 'testing' stamp: 'jmv 12/6/2011 08:19'!                              testSortedCollection	"	ReferenceStreamTest new testSortedCollection	"	| newInstance oldInstance |	oldInstance _ SortedCollection sortBlock: [ :a :b | a printString < b printString ].	oldInstance add: 'hi'; add: 'there'; add: 'you'; add: 'all'.	newInstance _ ReferenceStream unStream: (ReferenceStream streamedRepresentationOf: oldInstance).	self assert: newInstance asArray = oldInstance asArray! !!ReferenceStreamTest methodsFor: 'testing' stamp: 'jmv 11/25/2011 10:55'!                              testWeakDumps	"Test that if we serialize a model with weak references to views, only the model is serialized and not the views.		Note: The bug became apparent only when dumping a model to a SmartRefStream, that calls #references, and the serialized stream	was later materialized in an image where the view classes had been deleted. In such rare cases, materialization would fail when trying to reference these	absent classes. If serializing to a ReferenceStream, the bug didn't become apparent (views were never serialized). If serializing to a SmartRefStream, but	view classes still existed, the bug didn't really become apparent (because views were not actually deserialized), the only effect was a larger file.		ReferenceStreamTest new testWeakDumps	"	| oldInstance window refStream |	oldInstance _TextModel withText: 'This is a text'.	window _ SystemWindow editText: oldInstance label: 'old instance' wrap: true.	refStream _ ReferenceStream on: (DummyStream on: nil).	refStream nextPut: oldInstance.	self deny: (refStream references keys anySatisfy: [ :dumpedObject | dumpedObject isKindOf: Morph ]).	window delete! !!SmartRefStreamTest methodsFor: 'testing' stamp: 'jmv 12/6/2011 08:34'!    testDiskProxy	"	SmartRefStreamTest new testDiskProxy	"	| newInstance oldInstance |	oldInstance _ { Smalltalk . ActiveHand . Display . Morph}.	newInstance _ SmartRefStream unStream: (SmartRefStream streamedRepresentationOf: oldInstance).	1 to: oldInstance size do: [ :i |		self assert: (newInstance at: i) == (oldInstance at: i) ]! !!SmartRefStreamTest methodsFor: 'testing' stamp: 'jmv 12/6/2011 08:34'!  testSortedCollection	"	SmartRefStreamTest new testSortedCollection	"	| newInstance oldInstance |	oldInstance _ SortedCollection sortBlock: [ :a :b | a printString < b printString ].	oldInstance add: 'hi'; add: 'there'; add: 'you'; add: 'all'.	newInstance _ SmartRefStream unStream: (SmartRefStream streamedRepresentationOf: oldInstance).	self assert: newInstance asArray = oldInstance asArray! !!SmartRefStreamTest methodsFor: 'testing' stamp: 'jmv 12/6/2011 08:34'!   testWeakDumps	"Test that if we serialize a model with weak references to views, only the model is serialized and not the views.		Note: The bug became apparent only when dumping a model to a SmartRefStream, that calls #references, and the serialized stream	was later materialized in an image where the view classes had been deleted. In such rare cases, materialization would fail when trying to reference these	absent classes. If serializing to a ReferenceStream, the bug didn't become apparent (views were never serialized). If serializing to a SmartRefStream, but	view classes still existed, the bug didn't really become apparent (because views were not actually deserialized), the only effect was a larger file.		SmartRefStreamTest new testWeakDumps	"	| oldInstance window refStream |	oldInstance _TextModel withText: 'This is a text'.	window _ SystemWindow editText: oldInstance label: 'old instance' wrap: true.	refStream _ SmartRefStream on: (DummyStream on: nil).	refStream nextPut: oldInstance.	self deny: (refStream references keys anySatisfy: [ :dumpedObject | dumpedObject isKindOf: Morph ]).	window delete! !