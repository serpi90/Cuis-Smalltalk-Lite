'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 29 November 2011 at 3:17:31 pm'!!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 11/29/2011 14:57'!                    characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder."	| runLength lineStop done stopCondition |	line _ textLine.	rightMargin _ line rightMargin.	lastIndex _ line first.	self setStopConditions.		"also sets font"	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ CharacterBlock					stringIndex: line first					text: text					topLeft: line leftMargin@line top					extent: 0 @ line lineHeight					textLine: line].	destX _ leftMargin _ line leftMarginForAlignment: alignment.	destY _ line top.	runLength _ text runLengthFor: line first.	lineStop _ characterIndex	"scanning for index"		ifNil: [ line last ].			"scanning for point"	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	self placeEmbeddedObject.	done  _ false.	[ done ] whileFalse: [		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth ifNil: [ font widthOf: (text at: lastIndex) ]).		(self perform: stopCondition) ifTrue: [			^characterIndex				ifNil: [	"Result for characterBlockAtPoint: "					CharacterBlock						stringIndex: lastIndex						text: text						topLeft: characterPoint						extent: lastCharacterExtent						textLine: line ]				ifNotNil: [	"Result for characterBlockForIndex: "					CharacterBlock						stringIndex: characterIndex						text: text						topLeft: characterPoint - (kern @ 0)						extent: lastCharacterExtent						textLine: line ]]]! !!Paragraph methodsFor: 'display' stamp: 'jmv 11/29/2011 15:11'!                   displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas paragraphTopLeft: paragraphTopLeft	| caretColor x1 isBold isItalic x0 h w halfW r newCaretRect d |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				"Keep tweaking if needed!! For italics with descenders (i.e. p), cursor shows a bit to the left..."			d _ isBold ifTrue: [ h // 8 ] ifFalse: [ h // 9].			x0 _ x- (h*5//24) + d.			x1 _ x + d ]		ifFalse: [			x0 _ x.			x1 _ x].	x0-paragraphTopLeft x < halfW ifTrue: [		x1 _ x1 - x0 + halfW+paragraphTopLeft x.		x0 _ halfW+paragraphTopLeft x ].	r _ extentForComposing x-halfW-1.	r < (x1-paragraphTopLeft x) ifTrue: [		x0 _ x0 + r - x1+paragraphTopLeft x.		x1 _ r +paragraphTopLeft x].	lastCaretRectNeedsRedraw _ false.	newCaretRect _ x0-halfW@ top corner: x1+halfW+1 @ (bottom+1).	lastCaretRect ifNotNil: [		lastCaretRect = newCaretRect ifFalse: [			"If we are actually drawing the last position of the text cursor,			but not the current one, request redraw."			((aCanvas isVisible: lastCaretRect) and: [(aCanvas isFullyVisible: newCaretRect) not ])				ifTrue: [					lastCaretRectNeedsRedraw _ true ]]].	lastCaretRect _ newCaretRect.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !