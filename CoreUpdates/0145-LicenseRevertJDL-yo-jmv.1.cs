'From Cuis 1.0 of 6 March 2009 [latest update: #5989] on 13 March 2009 at 10:26:08 am'!!OldSonogram methodsFor: 'all' stamp: 'jmv 3/13/2009 10:22'!plotColumn: dataArray	| chm1 i normVal r |	columnForm unhibernate.	chm1 _ columnForm height - 1.	0 to: chm1 do:		[:y | 		i _ y*(dataArray size-1)//chm1 + 1.		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).		normVal < 0.0 ifTrue: [normVal _ 0.0].		normVal > 1.0 ifTrue: [normVal _ 1.0].		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].	(lastX _ lastX + 1) > (image width - 1) ifTrue:		[self scroll].	image copy: (r _ (lastX@0 extent: 1@image height))			from: (32//image depth-1)@0			in: columnForm rule: Form over.	"self changed."	self invalidRect: (r translateBy: self position)! !!OldTableLayout methodsFor: 'layout' stamp: 'jmv 3/13/2009 10:23'!computeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |	maxCell _ cellHolder key.	cells _ cellHolder value.	properties wrapDirection == #none 		ifTrue:[wrap _ SmallInteger maxVal]		ifFalse:[wrap _ aBool ifTrue:[newBounds width] ifFalse:[newBounds height].				wrap < maxCell x ifTrue:[wrap _ maxCell x]].	spacing _ properties cellSpacing.	(spacing == #globalRect or:[spacing = #globalSquare]) ifTrue:[		"Globally equal spacing is a very special case here, so get out fast and easy"		^self computeGlobalCellArrangement: cells 			in: newBounds horizontal: aBool 			wrap: wrap spacing: spacing].	output _ (WriteStream on: Array new).	inset _ properties cellInset asPoint.	aBool ifFalse:[inset _ inset transposed].	first _ last _ nil.	maxExtent _ 0@0.	sum _ 0.	index _ 1.	n _ 0.	hFill _ vFill _ false.	[index <= cells size] whileTrue:[		w _ sum.		cell _ cells at: index.		cellMax _ maxExtent max: cell cellSize. "e.g., minSize"		(spacing == #localRect or:[spacing == #localSquare]) ifTrue:[			"Recompute entire size of current row"			spacing == #localSquare 				ifTrue:[max _ cellMax x max: cellMax y]				ifFalse:[max _ cellMax x].			sum _ (n + 1) * max.		] ifFalse:[			sum _ sum + (cell cellSize x).		].		((sum + (n * inset x)) > wrap and:[first notNil]) ifTrue:[			"It doesn't fit and we're not starting a new line"			(spacing == #localSquare or:[spacing == #localRect]) ifTrue:[				spacing == #localSquare 					ifTrue:[maxExtent _ (maxExtent x max: maxExtent y) asPoint].				first do:[:c| c cellSize: maxExtent]].			w _ w + ((n - 1) * inset x).			"redistribute extra space"			first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].			last _ OldLayoutCell new.			last cellSize: w @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			last nextCell: first.			output position = 0 ifFalse:[last addExtraSpace: 0@inset y].			output nextPut: last.			first _ nil.			maxExtent _ 0@0.			sum _ 0.			n _ 0.			hFill _ vFill _ false.		] ifFalse:[			"It did fit; use next item from input"			first ifNil:[first _ last _ cell] ifNotNil:[last nextCell: cell. last _ cell].			index _ index+1.			n _ n + 1.			maxExtent _ cellMax.			hFill _ hFill or:[cell hSpaceFill].			vFill _ vFill or:[cell vSpaceFill].		].	].	first ifNotNil:[		last _ OldLayoutCell new.		sum _ sum + ((n - 1) * inset x).		first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].		last cellSize: sum @ maxExtent y.		last hSpaceFill: hFill.		last vSpaceFill: vFill.		last nextCell: first.		output position = 0 ifFalse:[last addExtraSpace: 0@inset y].		output nextPut: last].	output _ output contents.	properties listSpacing == #equal ifTrue:[		"Make all the heights equal"		max _ output inject: 0 into:[:size :c| size max: c cellSize y].		output do:[:c| c cellSize: c cellSize x @ max].	].	^output! !!OldTableLayout methodsFor: 'optimized' stamp: 'jmv 3/13/2009 10:24'!layoutLeftToRight: aMorph in: newBounds	"An optimized left-to-right list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell props |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint x.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|		props _ m layoutProperties ifNil:[m].		props disableTableLayout ifFalse:[			n _ n + 1.			cell _ OldLayoutCell new target: m.			(props hResizing == #spaceFill) ifTrue:[				cell hSpaceFill: true.				extra _ m spaceFillWeight.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell hSpaceFill: false].			(props vResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeX.			last ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].		].	].	properties reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	n > 1 ifTrue:[width _ width + (n-1 * inset)].	(properties hResizing == #shrinkWrap and:[properties rubberBandCells or:[sum isZero]])		ifTrue:[extent _ width @ (extent y max: height)].	(properties vResizing == #shrinkWrap and:[properties rubberBandCells or:[vFill not]])		ifTrue:[extent _ (extent x max: width) @ height].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			height _ extent y.		] ifFalse:[			centering _ properties wrapCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)]		].	].	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ properties listCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		width _ cell cellSize.		(extraPerCell > 0 and:[cell hSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			width _ width + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posX _ posX + width + inset.		cell _ cell nextCell.	].! !!OldTableLayout methodsFor: 'optimized' stamp: 'jmv 3/13/2009 10:25'!layoutTopToBottom: aMorph in: newBounds	"An optimized top-to-bottom list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell props |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint y.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|		props _ m layoutProperties ifNil:[m].		props disableTableLayout ifFalse:[			n _ n + 1.			cell _ OldLayoutCell new target: m.			(props vResizing == #spaceFill) ifTrue:[				cell vSpaceFill: true.				extra _ m spaceFillWeight.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell vSpaceFill: false].			(props hResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeY.			first ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].		].	].	properties reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	n > 1 ifTrue:[height _ height + (n-1 * inset)].	(properties vResizing == #shrinkWrap and:[properties rubberBandCells or:[sum isZero]])		ifTrue:[extent _ (extent x max: width) @ height].	(properties hResizing == #shrinkWrap and:[properties rubberBandCells or:[vFill not]])		ifTrue:[extent _ width @ (extent y max: height)].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			width _ extent x.		] ifFalse:[			centering _ properties wrapCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)]		].	].	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ properties listCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		height _ cell cellSize.		(extraPerCell > 0 and:[cell vSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			height _ height + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posY _ posY + height + inset.		cell _ cell nextCell.	].! !!OldTableLayout methodsFor: 'optimized' stamp: 'jmv 3/13/2009 10:25'!minExtentHorizontal: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].		].	].	n > 1 ifTrue:[width _ width + (n-1 * inset x)].	^minExtentCache _ width @ height! !!OldTableLayout methodsFor: 'optimized' stamp: 'jmv 3/13/2009 10:25'!minExtentVertical: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph submorphsDo:[:m|		m disableTableLayout ifFalse:[			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].		].	].	n > 1 ifTrue:[height _ height + (n-1 * inset y)].	^minExtentCache _ width @ height! !