'From Cuis 2.7 of 3 September 2010 [latest update: #600] on 2 November 2010 at 11:05:30 pm'!!ProtoObject methodsFor: 'tracing' stamp: 'mtf 8/15/2008 18:40'!pointsTo: anObject"Answers true if I hold a reference to anObject, or false otherwise. Or stated another way:Answers true if the garbage collector would fail to collect anObject because I hold a reference to it, or false otherwise"	^ (self instVarsInclude: anObject)		or: [self class == anObject]! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:38'!chasePointers	PointerFinder on: self! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 17:43'!explorePointers	PointerExplorer new openExplorerFor: self! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 16:28'!inboundPointers"Answers a collection of all objects in the system that point to myself"	^ self inboundPointersExcluding: #()! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:07'!inboundPointersExcluding: objectsToExclude"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"	| anObj pointers objectsToAlwaysExclude |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	pointers := OrderedCollection new: 1000.	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious	 method and block contexts out of the results"	anObj := self someObject.	[0 == anObj] whileFalse: [		anObj isInMemory			ifTrue: [((anObj instVarsInclude: self)				or: [anObj class == self])					ifTrue: [pointers add: anObj]].		anObj := anObj nextObject].	objectsToAlwaysExclude := {		pointers collector.		thisContext.		thisContext sender.		thisContext sender sender.		objectsToExclude.	}.	^ pointers removeAllSuchThat: [:ea |		(objectsToAlwaysExclude identityIncludes: ea)			or: [objectsToExclude identityIncludes: ea]]! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:33'!outboundPointers"Answers a list of all objects I am causing not to be garbage-collected"	| collection |	collection := OrderedCollection new.	self outboundPointersDo: [:ea | collection add: ea].	^ collection! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 15:34'!outboundPointersDo: aBlock"do aBlock for every object I point to, exactly how the garbage collector would. Adapted from PointerFinder >> #followObject:"	aBlock value: self class.	1 to: self class instSize do: [:i | aBlock value: (self instVarAt: i)].	1 to: self basicSize do: [:i | aBlock value: (self basicAt: i)].! !!CompiledMethod methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:36'!outboundPointersDo: aBlock	| numLiterals |	aBlock value: self class.	numLiterals := self numLiterals.	1 to: numLiterals do: [:i | aBlock value: (self literalAt: i)]! !!MethodDictionary methodsFor: 'accessing' stamp: 'mtf 8/15/2008 14:28'!includesKey: aSymbol	"This override assumes that pointsTo is a fast primitive"	aSymbol ifNil: [^ false].	^ super instVarsInclude: aSymbol! !