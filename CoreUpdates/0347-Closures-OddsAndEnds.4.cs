'From Cuis 1.0 of 28 November 2009 [latest update: #337] on 8 December 2009 at 9:49:22 am'!!classDefinition: #SyntaxErrorNotification category: #'System-Exceptions Extensions'!Error subclass: #SyntaxErrorNotification	instanceVariableNames: 'inClass code doitFlag debugger category errorMessage location '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Extensions'!!AdditionalMethodState methodsFor: 'testing' stamp: 'jmv 12/8/2009 09:48'!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [(aBlock value: propertyOrPragma key)					or: [(aBlock value: propertyOrPragma value)					or: [(propertyOrPragma value is: #Array)						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'jmv 12/8/2009 09:48'!hasLiteralThorough: literal	"Answer true if any literal in these properties is literal,	 even if embedded in array structure."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [propertyOrPragma key == literal					or: [propertyOrPragma value == literal					or: [(propertyOrPragma value is: #Array)						and: [propertyOrPragma value hasLiteral: literal]]]]			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:			[^true]].	^false! !!Array methodsFor: 'as yet unclassified' stamp: 'jmv 12/8/2009 09:47'!is: aSymbol	^aSymbol = #Array or: [ super is: aSymbol ]! !!Behavior methodsFor: 'compiling' stamp: 'eem 5/13/2008 09:50'!instVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	"Nothing to do here; ClassDescription introduces named instance variables"	^self! !!Behavior methodsFor: 'compiling' stamp: 'eem 6/19/2008 09:08'!variablesAndOffsetsDo: aBinaryBlock	"This is the interface between the compiler and a class's instance or field names.  The	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed	 by the instance variable name strings and their integer offsets (1-relative).  The order is	 important; names evaluated later will override the same names occurring earlier."	"Only need to do instance variables here.  CProtoObject introduces field definitions."	self instVarNamesAndOffsetsDo: aBinaryBlock! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'jmv 12/8/2009 09:48'!addRemoteTemp: aTempVariableNode rootNode: rootNode "<MethodNode>"	"Add aTempVariableNode to my actualScope's sequence of	 remote temps.  If I am an optimized block then the actual	 scope is my actualScopeIfOptimized, otherwise it is myself."	(temporaries is: #Array) ifTrue:		[temporaries := temporaries asOrderedCollection].	remoteTempNode == nil ifTrue:		[remoteTempNode := RemoteTempVectorNode new								name: self remoteTempNodeName								index: arguments size + temporaries size								type: LdTempType								scope: 0.		 actualScopeIfOptimized			ifNil:				[temporaries addLast: remoteTempNode.				 remoteTempNode definingScope: self]			ifNotNil: [actualScopeIfOptimized addHoistedTemps: { remoteTempNode }]].	remoteTempNode addRemoteTemp: aTempVariableNode encoder: rootNode encoder.	"use remove:ifAbsent: because the deferred analysis for optimized	 loops can result in the temp has already been hoised into the root."	temporaries remove: aTempVariableNode ifAbsent: [].	^remoteTempNode! !!Character methodsFor: 'testing' stamp: 'jmv 12/8/2009 09:46'!canBeGlobalVarInitial	^self isUppercase! !!ClassDescription methodsFor: 'compiling' stamp: 'eem 5/13/2008 09:48'!instVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	| superInstSize |	(superInstSize := superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:		[superclass instVarNamesAndOffsetsDo: aBinaryBlock].	1 to: self instSize - superInstSize do:		[:i| aBinaryBlock value: (instanceVariables at: i) value: i + superInstSize]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/30/2008 08:55'!properties	"Answer the method properties of the receiver."	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector]		ifFalse: [AdditionalMethodState forMethod: self selector: propertiesOrSelector]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/29/2008 17:23'!properties: aMethodProperties	"Set the method-properties of the receiver to aMethodProperties."	self literalAt: self numLiterals - 1		put: (aMethodProperties isEmpty				ifTrue: [aMethodProperties selector]				ifFalse: [aMethodProperties							setMethod: self;							yourself])! !!Decompiler methodsFor: 'initialize-release' stamp: 'jmv 12/8/2009 09:49'!mapFromBlockStartsIn: aMethod toTempVarsFrom: schematicTempNamesString constructor: aDecompilerConstructor	| map |	map := aMethod				mapFromBlockKeys: aMethod startpcsToBlockExtents keys asArray sort				toSchematicTemps: schematicTempNamesString.	map keysAndValuesDo:		[:startpc :tempNameTupleVector|		tempNameTupleVector isEmpty ifFalse:			[| subMap numTemps tempVector |			subMap := Dictionary new.			"Find how many temp slots there are (direct & indirect temp vectors)			 and for each indirect temp vector find how big it is."			tempNameTupleVector do:				[:tuple|				(tuple last is: #Array)					ifTrue:						[subMap at: tuple last first put: tuple last last.						 numTemps := tuple last first]					ifFalse:						[numTemps := tuple last]].			"create the temp vector for this scope level."			tempVector := Array new: numTemps.			"fill it in with any indirect temp vectors"			subMap keysAndValuesDo:				[:index :size|				tempVector at: index put: (Array new: size)].			"fill it in with temp nodes."			tempNameTupleVector do:				[:tuple| | itv |				(tuple last is: #Array)					ifTrue:						[itv := tempVector at: tuple last first.						 itv at: tuple last last							put: (aDecompilerConstructor									codeTemp: tuple last last - 1									named: tuple first)]					ifFalse:						[tempVector							at: tuple last							put: (aDecompilerConstructor									codeTemp: tuple last - 1									named: tuple first)]].			"replace any indirect temp vectors with proper RemoteTempVectorNodes"			subMap keysAndValuesDo:				[:index :size|				tempVector					at: index					put: (aDecompilerConstructor							codeRemoteTemp: index							remoteTemps: (tempVector at: index))].			"and update the entry in the map"			map at: startpc put: tempVector]].	^map! !!Encoder methodsFor: 'results' stamp: 'jmv 12/8/2009 09:48'!tempNodes 	| tempNodes |	tempNodes := SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].	scopeTable associationsDo:		[:assn |		(assn value is: #Array)			ifTrue: [assn value do: [:temp| tempNodes add: temp]]			ifFalse: [assn value isTemp ifTrue: [tempNodes add: assn value]]].	^tempNodes! !!Encoder methodsFor: 'encoding' stamp: 'jmv 12/8/2009 09:42'!environment	"Answer the environment of the current compilation context,	 be it in a class or global (e.g. a workspace)"	^class == nil		ifTrue: [Smalltalk]		ifFalse: ["class environment" Smalltalk]		"No environments in Cuis..."! !!InstructionStream class methodsFor: 'compiling' stamp: 'eem 7/17/2008 13:16'!instVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 We override here to arrange that the compiler will use MaybeContextInstanceVariableNodes	 for instances variables of ContextPart or any of its superclasses and subclasses.  The	 convention to make the compiler use the special nodes is to use negative indices"	| superInstSize |	(self withAllSubclasses noneSatisfy: [:class|class isContextClass]) ifTrue:		[^super instVarNamesAndOffsetsDo: aBinaryBlock].	(superInstSize := superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:		[superclass instVarNamesAndOffsetsDo: aBinaryBlock].	1 to: self instSize - superInstSize do:		[:i| aBinaryBlock value: (instanceVariables at: i) value: (i + superInstSize) negated]! !!InstructionStream class methodsFor: 'compiling' stamp: 'eem 6/19/2008 10:00'!isContextClass	^false! !!ContextPart class methodsFor: 'private' stamp: 'eem 6/19/2008 10:00'!isContextClass	^true! !!MethodProperties methodsFor: 'testing' stamp: 'jmv 12/8/2009 09:49'!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	properties ifNil:[^false].	properties keysAndValuesDo: [:key :value |		((aBlock value: key)		 or: [(aBlock value: value)		 or: [(value is: #Array)			and: [value hasLiteralSuchThat: aBlock]]]) ifTrue: [^true]].	^false! !!String methodsFor: 'converting' stamp: 'jmv 12/8/2009 09:36'!asOctetString	^ self! !!SyntaxErrorNotification methodsFor: 'accessing' stamp: 'eem 9/23/2008 14:20'!setClass: aClass category: aCategory code: codeString doitFlag: aBoolean errorMessage: errorString location: anInteger	inClass := aClass.	category := aCategory.	code := codeString.	doitFlag := aBoolean.	errorMessage := errorString.	location := anInteger! !!SyntaxErrorNotification class methodsFor: 'exceptionInstantiator' stamp: 'eem 9/23/2008 14:19'!inClass: aClass category: aCategory withCode: codeString doitFlag: doitFlag errorMessage: errorString location: location	^ (self new		setClass: aClass		category: aCategory 		code: codeString		doitFlag: doitFlag		errorMessage: errorString		location: location) signal! !!classDefinition: #SyntaxErrorNotification category: #'System-Exceptions Extensions'!Error subclass: #SyntaxErrorNotification	instanceVariableNames: 'inClass code category doitFlag errorMessage location debugger'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Extensions'!!Array reorganize!('comparing' literalEqual:)('converting' asArray elementsExchangeIdentityWith: elementsForwardIdentityTo: elementsForwardIdentityTo:copyHash: evalStrings)('printing' isLiteral printOn: storeOn:)('private' hasLiteral: hasLiteralSuchThat: replaceFrom:to:with:startingAt:)('copying' copyWithDependent:)('accessing' atWrap: atWrap:put:)('testing')('as yet unclassified' is:)!