'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 27 December 2010 at 10:23:33 pm'!!Collection methodsFor: 'enumerating' stamp: 'jmv 12/27/2010 22:19'!collect: aBlock andFold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each ] andFold: [:a :b | a, ' ', b]	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each  size] andFold: [:a :b | a + b]	"	| first eachValue nextValue |	first _ true.	self do: [ :each |		eachValue _  aBlock value: each.		first			ifTrue: [				first _ false.				nextValue _eachValue ]			ifFalse: [				nextValue _ binaryBlock					value: nextValue					value: eachValue ]].	first ifTrue: [ self errorEmptyCollection ].	^ nextValue! !!Collection methodsFor: 'enumerating' stamp: 'jmv 12/27/2010 22:20'!fold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]	"	^self collect: [ :each | each ] andFold: binaryBlock! !!Collection methodsFor: 'enumerating' stamp: 'jmv 12/27/2010 22:21'!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	^self collect: [ :each | each ] andFold: binaryBlock! !!Collection methodsFor: 'math functions' stamp: 'jmv 12/27/2010 22:23'!sum	"Compute the sum of all the elements in the receiver"	^self collect: [ :each | each ] andFold: [ :a :b | a + b]! !!Collection methodsFor: 'math functions' stamp: 'jmv 12/27/2010 22:22'!sum: aBlock	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	^self collect: aBlock andFold: [ :a :b | a + b ]! !!Bag methodsFor: 'math functions' stamp: 'ul 11/7/2010 01:46'!sum	"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag)."		| sum first |	first := true.	contents keysAndValuesDo: [ :value :count |		first 			ifTrue: [ sum := value * count. first := false ]			ifFalse: [ sum := sum + (value * count) ] ].	first ifTrue: [ self errorEmptyCollection ].	^sum! !