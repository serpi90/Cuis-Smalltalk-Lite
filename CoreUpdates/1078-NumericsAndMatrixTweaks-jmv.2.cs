'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 7 September 2011 at 9:36:16 am'!!classDefinition: #NormalRandom category: #'Kernel-Numbers'!Random subclass: #NormalRandom	instanceVariableNames: 'cachedValue'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!NormalRandom commentStamp: '<historical>' prior: 0!My instances are random variables with Normal distribution (mean 0 and variance 1), using the Box-Muller method!!FFT methodsFor: 'testing' stamp: 'jmv 7/27/2011 16:19'!plot: samples in: rect color: aColor min: min max: max	"Throw-away code just to check out a couple of examples"	| x dx pen y |	pen _ Pen new.	pen color: aColor.	pen up.	x _ rect left.	dx _ rect width asFloat / samples size.	samples do: [ :v |		y _ (max-v) / (max-min) * rect height asFloat.		y _ y min: 1000.		y _ y max: 0.		pen goto: x asInteger @ (rect top + y asInteger).		pen down.		x _ x + dx].	max printString displayOn: Display at: (x+2) @ (rect top-9).	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)! !!Matrix methodsFor: 'accessing' stamp: 'jmv 7/12/2011 17:49'!subMatrixTopLeft: aPoint size: sizePoint	^ self subMatrixTopLeft: aPoint bottomRight: aPoint + sizePoint - 1! !!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/26/2011 15:04'!* aMatrixOrNumber	"Standard matrix multiplication"	| result |	(aMatrixOrNumber is: #Matrix) ifTrue: [		self width = aMatrixOrNumber height ifFalse: [ ^self error: 'Matrix sizes do not match' ].		result _ self appropriateResultClass newHeight: self height width: aMatrixOrNumber width.		result fillWith: self multipliedBy: aMatrixOrNumber ]	ifFalse: [		result _ self copy.		result replaceValues: [ :value | value * aMatrixOrNumber ] ].	^result	! !!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/26/2011 15:01'!+ aMatrixOrNumber	"Add element by element"	| result |	(aMatrixOrNumber is: #Matrix) ifTrue: [		(self width = aMatrixOrNumber width) & (self height = aMatrixOrNumber height)			ifFalse: [ ^self error: 'Matrix sizes do not match' ].		result _ self appropriateResultClass newHeight: self height width: self width.		result fillWith: self plus: aMatrixOrNumber ]	ifFalse: [		result _ self copy.		result replaceValues: [ :value | value + aMatrixOrNumber ] ].	^result	! !!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/26/2011 15:03'!- aMatrixOrNumber	"Substract element by element"	| result |	(aMatrixOrNumber is: #Matrix) ifTrue: [		(self width = aMatrixOrNumber width) & (self height = aMatrixOrNumber height)			ifFalse: [ ^self error: 'Matrix sizes do not match' ].		result _ self appropriateResultClass newHeight: self height width: self width.		result fillWith: self minus: aMatrixOrNumber ]	ifFalse: [		result _ self copy.		result replaceValues: [ :value | value - aMatrixOrNumber ] ].	^result	! !!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/26/2011 14:59'!/ aNumber	"Divide by a scalar"	| result |	result _ self copy.	result replaceValues: [ :value | value / aNumber ].	^result	! !!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/26/2011 15:03'!fillWith: aMatrix minus: bMatrix	| elem |	1 to: self height do: [ :i |		1 to: self width do: [ :j |			elem _ ((aMatrix i: i j: j) - (bMatrix i: i j: j)).			self i: i j: j put: elem ] ]! !!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/26/2011 15:04'!fillWith: aMatrix multipliedBy: bMatrix	| elem |	1 to: self height do: [ :i |		1 to: self width do: [ :j |			elem _ 0.			1 to: aMatrix width do: [ :k |				elem _ elem + ((aMatrix i: i j: k) * (bMatrix i: k j: j)) ].			self i: i j: j put: elem ] ]! !!Matrix methodsFor: 'aritmethic' stamp: 'jmv 7/26/2011 15:01'!fillWith: aMatrix plus: bMatrix	| elem |	1 to: self height do: [ :i |		1 to: self width do: [ :j |			elem _ ((aMatrix i: i j: j) + (bMatrix i: i j: j)).			self i: i j: j put: elem ] ]! !!Matrix methodsFor: 'eigenvalues and eigenvectors' stamp: 'jmv 7/26/2011 15:04'!eigenvaluesByQR	"This implementation only works if all the eigenvalues are real."	"(FloatMatrix fromArrayOfArrays: #(		#(6 4 4 1) 		#(4 6 1 4) 		#(4 1 6 4)		#(1 4 4 6)	)) eigenvaluesByQR"	| h q r loopCount |	h _ self hessembergSuperior.	q _ self appropriateResultClass newHeight: self height width: self width.	r _ self appropriateResultClass newHeight: self height width: self width.	loopCount _ 0.	[ h isFirstSubdiagonalZero ] whileFalse: [		h storeQRDecompositionOfHessemberSuperiorOnQ: q r: r.		h fillWith: r multipliedBy: q.		loopCount _ loopCount + 1.		loopCount > 200 ifTrue: [^self error: 'Could not find real eigenvalues'] ].	^h diagonal! !!Matrix methodsFor: 'misc' stamp: 'jmv 8/16/2011 09:24'!moveOriginToCenter: aBoolean	"This method performs a circular shift of the both in horizontal and vertical direction. The magnitude of the shift is half our extent.	This is useful, for example, to make a better visualization of convolution kernels:		To be properly applied, the kernel is centered at 1@1 . For instance a simple low pass filter could be	| 0.6   0.1   0.0   0.1 |	| 0.1   0.0   0.0   0.0 |	| 0.0   0.0   0.0   0.0 |	| 0.1   0.0   0.0   0.0 |		But it is much easier to 'see' it if the center of the filter is moved to the center of the matrix like this:	| 0.0   0.0   0.0   0.0 |	| 0.0   0.0   0.1   0.0 |	| 0.0   0.1   0.6   0.1 |	| 0.0   0.0   0.1   0.0 |		This method takes the receiver and answers a new instance, transforming it from 1@1 to center if aBoolean is true, or backwards if false.	(if the extent is even, then aBoolean makes no difference).		((FloatMatrix fromArrayOfArrays: #(		(0.6   0.1   0.0   0.1)		(0.1   0.0   0.0   0.0)		(0.0   0.0   0.0   0.0)		(0.1   0.0   0.0   0.0)))			moveOriginToCenter: true)			print	((FloatMatrix fromArrayOfArrays: #(		(0.6   0.1   0.0   0.0   0.1)		(0.1   0.0   0.0   0.0   0.0)		(0.0   0.0   0.0   0.0   0.0)		(0.0   0.0   0.0   0.0   0.0)		(0.1   0.0   0.0   0.0   0.0)))			moveOriginToCenter: true)			print	"	| answer deltaI deltaJ e ex ey |	e _ self size.	ey _ e y.	ex _ e x.	deltaI _ ey //2.	deltaJ _ ex // 2.	aBoolean ifFalse: [		deltaI _ 0.0 - deltaI.		deltaJ _ 0.0 - deltaJ ].	answer _ self class newSize: e.	0 to: ey-1 do: [ :i |		0 to: ex-1 do: [ :j |			answer i: i+deltaI\\ey+1 j: j+deltaJ\\ex+1 put: (self i: i+1 j: j+1) ]].	^answer! !!Matrix methodsFor: 'printing' stamp: 'jmv 7/12/2011 15:06'!print	self printOn: Transcript.	Transcript cr! !!Matrix methodsFor: 'operations' stamp: 'jmv 9/6/2011 22:41'!inverse	"Answers the inverse matrix"	| bigMatrix result |	self isSquare ifFalse: [ ^self error: 'Only for Square Matrices' ].	result _ self appropriateResultClass newHeight: self height width: self width.	bigMatrix _ self appropriateResultClass newHeight: self height width: self width + 1.	1 to: self width do: [ :i |		bigMatrix fillWith: self.		1 to: self width do: [ :j | bigMatrix i: j j: self width+1 put: 0 ].		bigMatrix i: i j: self width + 1 put: 1.		result j: i put: bigMatrix solveLinearSystem ].	^result! !!Matrix methodsFor: 'conversion' stamp: 'jmv 9/2/2011 15:41'!asFormG: greenMatrix b: blueMatrix	| answer min max b g r |	answer _ Form extent: width@height depth: 32.	min _ (self min min: greenMatrix min) min: blueMatrix min.	max _ (self max max: greenMatrix max) max: blueMatrix max.	0 to: height-1 do: [ :i |		0 to: width-1 do: [ :j |			r _ (self i: i+1 j: j+1) - min / (max - min) min: 1.0 max: 0.0.			g _ (greenMatrix i: i+1 j: j+1) - min / (max - min) min: 1.0 max: 0.0.			b _ (blueMatrix i: i+1 j: j+1) - min / (max - min) min: 1.0 max: 0.0.			answer colorAt: j@i put: (Color  r: r g: g b: b)]].	^answer! !!Matrix methodsFor: 'conversion' stamp: 'jmv 9/2/2011 15:41'!asFormG: greenMatrix b: blueMatrix min: min max: max	| answer b g r |	answer _ Form extent: width@height depth: 32.	0 to: height-1 do: [ :i |		0 to: width-1 do: [ :j |			r _ (self i: i+1 j: j+1) - min / (max - min) min: 1.0 max: 0.0.			g _ (greenMatrix i: i+1 j: j+1) - min / (max - min) min: 1.0 max: 0.0.			b _ (blueMatrix i: i+1 j: j+1) - min / (max - min) min: 1.0 max: 0.0.			answer colorAt: j@i put: (Color  r: r g: g b: b)]].	^answer! !!Matrix methodsFor: 'conversion' stamp: 'jmv 7/26/2011 18:12'!asFormMin: min max: max	| answer |	answer _ Form extent: width@height depth: 32.	0 to: height-1 do: [ :i |		0 to: width-1 do: [ :j |			answer colorAt: j@i put: (Color gray: 				((self i: i+1 j: j+1) - min / (max - min) min: 1.0 max: 0.0)			)]].	^answer! !!Matrix methodsFor: 'norm and condition number' stamp: 'jmv 9/6/2011 23:00'!conditionNumber	^self norm * self inverse norm! !!Matrix methodsFor: 'norm and condition number' stamp: 'jmv 9/6/2011 23:00'!norm	"	(FloatMatrix identity: 5) norm	"	^(self transposed * self) eigenvaluesByQR elements max sqrt! !!FloatMatrix methodsFor: 'accessing' stamp: 'jmv 8/1/2011 10:04'!bilinearInterpolationAtX: x y: y	"x and y are Floats"	| x1 x2 y1 y2 result f |	x1 _ x floor.	x2 _ x1 + 1.	y1 _ y floor.	y2 _ y1 + 1.	result _ ((self x: x1 y: y1) * (x2 - x) * (y2 - y)).	f _ (x2 - x) * (y - y1).	f = 0.0 ifFalse: [		result _ (self x: x1 y: y2) * f + result ].	f _ (x - x1) * (y2 - y).	f = 0.0 ifFalse: [		result _ (self x: x2 y: y1) * f + result ].	f _ (x - x1) * (y - y1).	f = 0.0 ifFalse: [		result _ (self x: x2 y: y2) * f + result].	^result! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 9/7/2011 09:35'!convolutionLinearWith: aForm	"Linear convolution. Warning: Slow.	It is usually preferred to do a circular convolution via FFT and take care of border effects."	"	| f m |	f _ Form fromUser.	m _ FloatMatrix m: 3 n: 3.	m fillGaussian.	(m convolutionWith: f) display	"	| resultWidth resultHeight result xx yy blue c green red k |	resultWidth _ self width + aForm width - 1.	resultHeight _ self height + aForm height - 1.	k _ 1.0 / elements sum.	result _ Form extent: resultWidth@resultHeight depth: 32.	1 to: resultHeight do: [ :y |		1 to: resultWidth do: [ :x |			red _ 0.0.			green _ 0.0.			blue _ 0.0.			1 to: self height do: [ :j |				1 to: self width do: [ :i |					xx _ x-i+1.					yy _ y-j+1.					(xx > 0) & (xx <= aForm width) & (yy > 0) & (yy <= aForm height)						ifTrue: [							c _ aForm colorAt: xx@yy.							red _ c red * (self i: i j: j) + red.							green _ c green * (self i: i j: j) + green.							blue _ c blue * (self i: i j: j) + blue ]]].			red _ red * k min: 1.0 max: 0.0.			green _ green * k min: 1.0 max: 0.0.			blue _ blue * k min: 1.0 max: 0.0.			result colorAt: x@y put:				(Color r: red g: green b: blue).		].	].	^result! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 7/26/2011 17:49'!convolveWith: aMatrix	"Compute convolution with aMatrix, usig 2D FFT. Store the result on self.	Note: The convolution is computed in the complex DFT space. Input is assumed to be real, and answer is real too.	| f m fm r1 |	f _ Form fromDisplay: (Rectangle fromUser origin extent: 128@128).	fm _ FloatMatrix form: f color: #green.	f _ fm asForm.	m _ FloatMatrix m: 3 n: 3.	m fillGaussian.	[ r1 _ m convolutionWith: f.] timeToRun print.	r1 displayAt: 10@10.	[ fm convolveWith: m ] timeToRun print.	fm asForm displayAt: 138@10	"	| kernelReal kernelImaginary imaginary fft |	aMatrix size = self size		ifTrue: [ kernelReal _ aMatrix ]		ifFalse: [			kernelReal _ FloatMatrix newSize: self size.			kernelReal fillWith: aMatrix ].	kernelImaginary _ FloatMatrix newSize: self size.	imaginary _ FloatMatrix newSize: self size.	fft _ FFT2D new.	fft realData: kernelReal imagData: kernelImaginary.	fft transformForward: true.	fft realData: self imagData: imaginary.	fft transformForward: true.	self imaginary: imaginary elementMultiplyBy: kernelReal imaginary: kernelImaginary.	fft transformForward: false! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 7/26/2011 17:34'!fftImaginary: aMatrix forward: forward	"Compute complex 2d FFT, being me the real part and aMatrix the imaginary part of the data to transform."	| transform |	transform _ FFT2D new.	transform realData: self imagData: aMatrix.	transform transformForward: forward! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 8/17/2011 13:21'!normalizeMax	"An image can be said to be properly exposed when the maximum value is 1.0"	elements /= elements max! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 8/17/2011 13:15'!normalizeSum	"A filter is normalized when its elements add to 1.0"	elements /= elements sum! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 8/26/2011 10:03'!scatterPlotWith: aFloatMatrix size: n	"Answer a FloatMatrix that represents a scatter plot of the receiver with the argument.	Useful to study the correlation between the distributions of the values of the matrices."	"A scatter plot is done by taking the bands (or color) by pairs, and doing a sort of	bidimensional histogram. For each pair of pixel values (in each pair of colors) the total	number of pixels is recorded."	| plotSize scatterPlot max min scale v1 v2 |	plotSize _ n.	scatterPlot _ FloatMatrix m: plotSize n: plotSize.	max _ self max max: aFloatMatrix max.	min _ self min min: aFloatMatrix min.	scale _ max = min		ifFalse: [ plotSize / (max-min) asFloat ]		ifTrue: [ 1 ].	"This maping gives values between 0 and plotSize-1"	1 to: height do: [ :i |		1 to: width do: [ :j |			v1 _ ((scale * ((self i: i j: j)-min)) truncated min: plotSize-1) max: 0.			v2 _ ((scale * ((aFloatMatrix i: i j: j)-min)) truncated min: plotSize-1) max: 0.			scatterPlot i: plotSize-v1 j: v2+1 put: (scatterPlot  i: plotSize-v1 j: v2+1) + 1 ]].	^scatterPlot! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 7/26/2011 18:01'!subsampled: n	| answer |	answer _ FloatMatrix newHeight: height//n width: width//n.	1 to: answer height do: [ :i |		1 to: answer width do: [ :j |			answer i: i j: j put: (self i: i*n j: j*n) ]].	^ answer! !!FloatMatrix methodsFor: 'signal processing' stamp: 'jmv 8/23/2011 16:04'!subsampled: subSamplingFactor extent: desiredExtent	| answer |	answer _ FloatMatrix newSize: desiredExtent.	1 to: answer height do: [ :i |		1 to: answer width do: [ :j |			answer i: i j: j put: (self bilinearInterpolationAtX: j*subSamplingFactor y: i*subSamplingFactor) ]].	^ answer! !!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/26/2011 15:14'!imaginary: imaginaryPart elementDivideBy: operandRealPart imaginary: operandImaginaryPart	"The receiver and imaginaryPart conform a complex matrix.	operandRealPart and operandImaginaryPart conform another complex matrix.	fill the receiver (and imaginaryPart) with the result of complex division with operand, element by element.	I.e., at each position of the matrix, compute (e+if) = (a+ib) / (c+id)	| r1 i1 r2 i2 |	r1 _ FloatMatrix fromArrayOfArrays: #(		#( 1 2 3)		#( 4 5 6)		#( 1 2 3)).	i1 _ FloatMatrix fromArrayOfArrays: #(		#( 1 1 0)		#( 0 0 1)		#( 0 0 0)).	r2 _ FloatMatrix fromArrayOfArrays: #(		#( 2 4 6)		#( 4 5 6)		#( 1 2 3)).	i2 _ FloatMatrix fromArrayOfArrays: #(		#( 5 5 5)		#( 5 5 5)		#( 7 8 9)).	Transcript clear.	r1 print. i1 print.	r1 imaginary: i1 elementMultiplyBy: r2 imaginary: i2.	r1 print. i1 print.	r1 imaginary: i1 elementDivideBy: r2 imaginary: i2.	r1 print. i1 print	"	| a b c d e f operandSquaredNorm |	1 to: self height do: [ :i |		1 to: self width do: [ :j |			a _ self i: i j: j.			b _ imaginaryPart i: i j: j.			c _ operandRealPart i: i j: j.			d _ operandImaginaryPart i: i j: j.			operandSquaredNorm _ c * c + (d * d).			operandSquaredNorm = 0.0				ifFalse: [					e _ a * c + (b * d) / operandSquaredNorm.					f _ b * c - (a * d) / operandSquaredNorm ]				ifTrue: [ e _ f _ 0.0 ].			self i: i j: j put: e.			imaginaryPart i: i j: j put: f ]]! !!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/29/2011 15:02'!imaginary: imaginaryPart elementDivideBy: operandRealPart imaginary: operandImaginaryPart threshold: threshold	"The receiver and imaginaryPart conform a complex matrix.	operandRealPart and operandImaginaryPart conform another complex matrix.	fill the receiver (and imaginaryPart) with the result of complex division with operand, element by element.	I.e., at each position of the matrix, compute (e+if) = (a+ib) / (c+id)	| r1 i1 r2 i2 |	r1 _ FloatMatrix fromArrayOfArrays: #(		#( 1 2 3)		#( 4 5 6)		#( 1 2 3)).	i1 _ FloatMatrix fromArrayOfArrays: #(		#( 1 1 0)		#( 0 0 1)		#( 0 0 0)).	r2 _ FloatMatrix fromArrayOfArrays: #(		#( 2 4 6)		#( 4 5 6)		#( 1 2 3)).	i2 _ FloatMatrix fromArrayOfArrays: #(		#( 5 5 5)		#( 5 5 5)		#( 7 8 9)).	Transcript clear.	r1 print. i1 print.	r1 imaginary: i1 elementMultiplyBy: r2 imaginary: i2.	r1 print. i1 print.	r1 imaginary: i1 elementDivideBy: r2 imaginary: i2.	r1 print. i1 print	"	| a b c d e f operandSquaredNorm |	1 to: self height do: [ :i |		1 to: self width do: [ :j |			a _ self i: i j: j.			b _ imaginaryPart i: i j: j.			c _ operandRealPart i: i j: j.			d _ operandImaginaryPart i: i j: j.			operandSquaredNorm _ c * c + (d * d).			operandSquaredNorm >= threshold				ifTrue: [					e _ a * c + (b * d) / operandSquaredNorm.					f _ b * c - (a * d) / operandSquaredNorm ]				ifFalse: [ e _ f _ 0.0 ].			self i: i j: j put: e.			imaginaryPart i: i j: j put: f ]]! !!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/26/2011 15:12'!imaginary: imaginaryPart elementMultiplyBy: operandRealPart imaginary: operandImaginaryPart	"The receiver and imaginaryPart conform a complex matrix.	operandRealPart and operandImaginaryPart conform another complex matrix.	fill the receiver (and imaginaryPart) with the result of complex multiplication with operand, element by element.	I.e., at each position of the matrix, compute (e+if) = (a+ib) * (c+id)"	| a b c d e f |	1 to: self height do: [ :i |		1 to: self width do: [ :j |			a _ self i: i j: j.			b _ imaginaryPart i: i j: j.			c _ operandRealPart i: i j: j.			d _ operandImaginaryPart i: i j: j.			e _ a * c - (b * d).			f _ b * c + (a * d).			self i: i j: j put: e.			imaginaryPart i: i j: j put: f ]]! !!FloatMatrix methodsFor: 'aritmethic - complex' stamp: 'jmv 7/27/2011 13:00'!magnitudeWithImaginary: imaginaryPart	"answer a new matrix"	| result a b magnitude |	result _ FloatMatrix newSize: self size.	1 to: self height do: [ :i |		1 to: self width do: [ :j |			a _ self i: i j: j.			b _ imaginaryPart i: i j: j.			magnitude _ (a * a + (b * b)) sqrt.			result i: i j: j put: magnitude ]].	^result! !!FloatMatrix methodsFor: 'misc' stamp: 'jmv 8/16/2011 09:55'!addNormalNoise: standardDeviation seed: randomSeed	| random |	random _ NormalRandom new seed: randomSeed.	self replaceValues: [ :v | random next * standardDeviation + v ]! !!NormalRandom methodsFor: 'accessing' stamp: 'jmv 7/28/2011 10:02'!next	"Two random values are generated. So, answer one and cache the other."	| x1 x2 t1 t2 y1 y2 |	cachedValue notNil		ifTrue: [			y1 _ cachedValue.			cachedValue _ nil.			^ y1 ].	x1 _ super next.	x2 _ super next.	t1 _ (-2 * x1 ln) sqrt.	t2 _ 2 * Float pi * x2.	y1 _ t1 * t2 cos.	y2 _ t1 * t2 sin.	cachedValue _ y2.	^ y1! !!Float methodsFor: 'printing' stamp: 'jmv 8/25/2011 16:15'!printPaddedLeft: integerDigits decimalPlaces: fractionDigits	"	Can be enhanced, especially for infinities and nans...	Add an extra leading space for positive numbers	Float pi printPaddedLeft: 3 decimalPlaces: 3	Float pi *1000 printPaddedLeft: 3 decimalPlaces: 3	Float pi negated printPaddedLeft: 3 decimalPlaces: 3	"	| i f integerString fractionString n |	self isInfinite ifTrue: [ ^ self printString ].	n _ self abs.	i _ n truncated.	f _ n - i.		"So that	0.999 printPaddedLeft: 1 decimalPlaces: 2	doesn't print as 0.000"	(f roundTo: (0.1 raisedToInteger: fractionDigits)) >= 1.0		ifTrue: [ ^ self rounded asFloat printPaddedLeft: integerDigits decimalPlaces: fractionDigits ].		integerString _ i printPaddedWith: $0 to: integerDigits.	fractionString _ f printShowingDecimalPlaces: fractionDigits.	^self < 0		ifFalse: [ ' ', integerString, (fractionString copyFrom: 2 to: fractionString size) ]		ifTrue: [ '-', integerString, (fractionString copyFrom: 2 to: fractionString size) ]! !!Point methodsFor: 'truncation and round off' stamp: 'jmv 7/29/2011 18:00'!ceiling	"Answer a Point that is the receiver's x and y ceiling. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x ceiling @ y ceiling! !!Point methodsFor: 'truncation and round off' stamp: 'jmv 7/29/2011 18:00'!floor	"Answer a Point that is the receiver's x and y floor. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x floor @ y floor! !!String methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30'!* arg	self shouldNotImplement."	^ arg adaptToString: self andSend: #*"! !!String methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:29'!+ arg	self shouldNotImplement."	^ arg adaptToString: self andSend: #+"! !!String methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30'!- arg	self shouldNotImplement."	^ arg adaptToString: self andSend: #-"! !!String methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30'!/ arg	self shouldNotImplement."	^ arg adaptToString: self andSend: #/"! !!String methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30'!// arg	self shouldNotImplement."	^ arg adaptToString: self andSend: #//"! !!String methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30'!\\ arg	self shouldNotImplement."	^ arg adaptToString: self andSend: #\\"! !String removeSelector: #adaptToString:andSend:!Point removeSelector: #adaptToString:andSend:!Number removeSelector: #adaptToString:andSend:!FloatMatrix removeSelector: #convolutionWith:!FloatMatrix removeSelector: #linearConvolutionWith:!!FloatMatrix reorganize!('accessing' bilinearInterpolationAtX:y: elements elementsIndexForI:j: fillWithZeroes i:j: i:j:put: max min)('initialization' initializeElements)('copying' copy)('signal processing' clearHighFftFrequencies convolutionLinearWith: convolveWith: fftImaginary:forward: fftRealForward: fillGaussian fillLowPassGaussian: gaussianI:j:sigma: lowPassFilter lowPassGaussian:i:j: normalizeMax normalizeSum scatterPlotWith:size: subsampled subsampled: subsampled:extent:)('aritmethic - complex' imaginary:elementDivideBy:imaginary: imaginary:elementDivideBy:imaginary:threshold: imaginary:elementMultiplyBy:imaginary: magnitudeWithImaginary:)('misc' addNormalNoise:seed:)!Matrix removeSelector: #fillResultOfMultiply:by:!Matrix removeSelector: #fillResultOfSum:by:!Collection removeSelector: #adaptToString:andSend:!