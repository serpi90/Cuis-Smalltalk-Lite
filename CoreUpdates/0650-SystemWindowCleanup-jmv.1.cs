'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 18 November 2010 at 9:16:21 am'!!PolygonMorph methodsFor: 'drawing' stamp: 'jmv 11/15/2010 14:07'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue: [		self filledForm colors: (Array with: Color transparent with: color).		aCanvas paintImage: self filledForm at: bounds topLeft-1].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo: [ :p1 :p2 |		p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor is: #Color])			ifTrue: [brush ifNil: [						brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil: [		self arrowForms do: [ :f |			f colors: (Array with: Color transparent with: borderColor).			aCanvas paintImage: f at: f offset]]! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 11/18/2010 09:16'!drawOn: aCanvas	| titleColor paneColorToUse |	aCanvas fillRectangle: bounds fillStyle: self fillStyle borderStyle: self borderStyle.	"aCanvas		fillRectangle: self boundsExcludingTitleArea		fillStyle: self fillStyle		borderStyle: self borderStyle."	paneColorToUse _ self paneColorToUse.	titleColor _ self isTopWindow		ifTrue: [ paneColorToUse paler ]		ifFalse: [ paneColorToUse ].	aCanvas fillRectangle: self titleAreaInnerRect color: titleColor.	"aCanvas fillRectangle: self titleAreaRect color: titleColor."	aCanvas		drawString: labelString		in: self labelRectangle		font: Preferences windowTitleFont		color: ColorTheme current label."	aCanvas		drawStringEmbossed: labelString		in: self labelRectangleForEmbossed		font: Preferences windowTitleFont		color: (Color h: paneColorToUse hue s: 0.7 v: paneColorToUse brightness * 0.55)"! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 11/17/2010 10:05'!boundsExcludingTitleArea	"Answers the rectangle for the receiver, including borders, but excluding the titleArea.	Together with #titleAreaRect covers the whole window	Assumes that the title area is 'outside' the window."	^ bounds insetBy: (0@self labelHeight corner: 0@0)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 11/15/2010 18:09'!innerBounds	"Exclude the label area"	| bw |	bw _ self borderWidth.	^ bounds insetBy: (bw @ (self labelHeight+bw) corner: bw @ bw)! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 11/17/2010 10:34'!labelRectangleForEmbossed	"Actually the whole label area"	| tl br e x0 y0 x1 y1 |	tl _ bounds topLeft.	br _ bounds bottomRight.	e _ self boxExtent.	x0 _ tl x + ( e x * 4 + 14).	y0 _ tl y + 1.	x1 _ br x - 1.	y1 _ tl y + e y + 2.	^x0@y0 corner: x1@y1			! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 11/17/2010 10:01'!titleAreaInnerRect	"Assumes a border will be drawn at the left, top and right of the title area.	The look is that the title area is inside the window"	^ (bounds insetBy: self borderWidth) withHeight: self labelHeight! !!SystemWindow methodsFor: 'geometry' stamp: 'jmv 11/17/2010 10:04'!titleAreaRect	"Assumes that the title area is 'outside' the window.	Together with #boundsExcludingTitleArea covers the whole window."	^ bounds withHeight: self labelHeight! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 11/15/2010 11:52'!spawnPaneFrameHandle: event 	| resizer localPt side growingPane newBounds adjoiningPanes limit cursor |	(self world firstSubmorph isKindOf: NewHandleMorph) 		ifTrue: [^self	"Prevent multiple handles"].	(self innerBounds containsPoint: event cursorPoint) 			ifFalse: [ ^self	"in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s]				near: event cursorPoint.	growingPane ifNil: [^self].	"don't resize pane side coincident with window side - RAA 5 jul 2000"	(growingPane perform: side) = (self innerBounds perform: side) 		ifTrue: [^self].	(side == #top and: [growingPane top = self innerBounds top]) ifTrue: [^self].	adjoiningPanes _ paneMorphs 				select: [ :pane | pane bounds bordersOn: growingPane bounds along: side ].	limit _ adjoiningPanes isEmpty 				ifFalse: [					(adjoiningPanes collect: [:pane | pane bounds perform: side]) 						perform: ((#(#top #left) includes: side) ifTrue: [#max] ifFalse: [#min])]				ifTrue: [ bounds perform: side].	cursor _ Cursor resizeForEdge: side.	resizer _ NewHandleMorph new				followHand: event hand					forEachPointDo: [ :p | 						localPt _ self internalizePositionFromWorld: p.						newBounds _ growingPane bounds 							withSideOrCorner: side							setToPoint: localPt							minExtent: 40 @ self minPaneHeightForReframe							limit: limit.						self fastFramingOn 							ifTrue: [								"For fast display, only higlight the rectangle during loop"								Cursor currentCursor == cursor 									ifFalse: [										event hand											visible: false;											refreshWorld;											visible: true.										cursor show].								newBounds _ growingPane bounds newRectButtonPressedDo: [ :f | 									growingPane bounds 										withSideOrCorner: side										setToPoint: (self internalizePositionFromWorld: Sensor cursorPoint)										minExtent: 40 @ self minPaneHeightForReframe										limit: limit ]].								self 									reframePanesAdjoining: growingPane									along: side									to: newBounds]					lastPointDo: [:p | ]					withCursor: cursor.	event hand world addMorphInLayer: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 11/17/2010 10:20'!invalidateTitleArea		bounds ifNotNil: [		"not really pretty... also invalidating the top border, regardless of it being above or below the title area		(#titleAreaRect and #titleAreaInnerRect)"		self invalidRect: (bounds withHeight: self labelHeight + self borderWidth) ]! !SystemWindow removeSelector: #layoutBounds!SystemWindow removeSelector: #panelRect!Canvas removeSelector: #image:at:!