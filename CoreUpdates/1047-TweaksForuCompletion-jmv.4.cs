'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 5 July 2011 at 1:33:01 pm'!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompletter '	classVariableNames: 'AutoCompletter '	poolDictionaries: ''	category: 'Morphic-Text Support'!!AbstractEvent class methodsFor: 'accessing' stamp: 'jmv 6/30/2011 16:08'!allItemKinds	"AbstractEvent allItemKinds	 #(#category #class #expression #method #protocol)"	^(AbstractEvent class organization listAtCategoryNamed: #'item kinds') 		collect: [:sel | self perform: sel]! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 6/29/2011 11:19'!autoCompletter: anUCompletter	autoCompletter _ anUCompletter.	autoCompletter ifNotNil: [		autoCompletter textMorph: self ]! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 7/4/2011 16:52'!keyStroke: evt	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].			"Maybe disable? Precludes the use of up and down arrows with control,	that are standard keystrokes in Windows to control the cursor.	Problem: At least Mac and Win VM generate ctrl-up and ctrl-down for	mouse wheel events.	I guess most people would prefer the mouse wheel to work properly..."	(editView scrollByKeyboard: evt)		ifTrue: [ ^self ].	autoCompletter 		ifNil: [ self processKeyStroke: evt ]		ifNotNil: [			autoCompletter				autoCompletionAround: [ self processKeyStroke: evt ]				keyStroke: evt ]! !!BlockContext methodsFor: 'printing' stamp: 'jmv 6/30/2011 10:22'!printOnStream: aStream	home ifNil: [^aStream print: 'a BlockContext with home=nil'].	aStream print: '[] in '.	super printOnStream: aStream! !!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 6/30/2011 10:17'!author	"	(CompiledMethod compiledMethodAt: #timeStamp) author	(BitBlt>>#destRect) author	"		^self timeStampPartsDo: [ :authorInitials :dateAndTime | authorInitials ]! !!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 6/30/2011 10:27'!dateAndtime	"Answer a DateAndTime object indicating when a method was last saved.  If there is no date stamp, return nil"	"	(CompiledMethod compiledMethodAt: #dateAndtime) dateAndtime	"	^self timeStampPartsDo: [ :authorInitials :dateAndTime | dateAndTime ]! !!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 6/30/2011 10:27'!dateMethodLastSubmitted	"Answer a Date object indicating when a method was last saved.  If there is no date stamp, return nil"	"	(CompiledMethod compiledMethodAt: #dateMethodLastSubmitted) dateMethodLastSubmitted	"	^self timeStampPartsDo: [ :authorInitials :dateAndTime | dateAndTime ifNotNil: [ dateAndTime date ]]! !!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 6/30/2011 10:34'!dateSortingValue	"Answer an integer that is suitable for chronologically sorting methods.	It is the number of whole minutes since 'The dawn of Squeak history'	"	"	(CompiledMethod compiledMethodAt: #dateAndtime) dateSortingValue	"	^self timeStampPartsDo: [ :authorInitials :dateAndTime |		dateAndTime			ifNil: [ 0 ]			ifNotNil: [ (dateAndTime - (DateAndTime fromString: '01/01/1996 00:00')) totalMinutes max: 0 ]]! !!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 6/30/2011 09:47'!timeStamp	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"	| file preamble stamp tokens tokenCount |	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"	file _ SourceFiles at: self fileIndex.	file ifNil: [^ String new].  "sources file not available"	"file does not exist happens in secure mode"	file _ [file readOnlyCopy] on: FileDoesNotExistException do: [ :ex| nil ].	file ifNil: [^ String new].	preamble _ self getPreambleFrom: file at: (0 max: self filePosition).	stamp _ String new.	tokens _ (preamble findString: 'methodsFor:' startingAt: 1) > 0		ifTrue: [Scanner new scanTokens: preamble]		ifFalse: [Array new  "ie cant be back ref"].	(((tokenCount _ tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])		ifTrue:			[(tokens at: tokenCount - 3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokenCount - 2]].	((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])		ifTrue:			[(tokens at: tokenCount  - 1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"					stamp _ tokens at: tokenCount]].	file close.	^ stamp! !!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 6/30/2011 10:26'!timeStampPartsDo: aBlock	"	CompiledMethod>>#timeStampPartsDo: timeStampPartsDo: [ :authorInitials :dateAndTime |		('*',authorInitials,'*') print. dateAndTime print ]	"	| stamp dateIndex aux dateAndTimePart |	stamp _ self timeStamp.	"Account for some unfortunately hacked stamps such as this: 'cwp 10/17/2007 23:29/eem 9/5/2009 11:10 - => :=' "	aux _ stamp lastIndexOf: $/.	aux _ stamp indexOf: $: startingAt: aux ifAbsent: [ 0 ].	aux > 0 ifTrue: [		(aux > 0 and: [ aux + 2 ~= stamp size]) ifTrue: [			stamp _ stamp copyFrom: 1 to: aux + 2 ]].	"Find start of date, if not possible, consider the whole stamp the author, and no date"	aux _ stamp		lastIndexOf: $/		startingAt: stamp size		ifAbsent: [ ^ aBlock value: stamp value: nil ].	aux _ stamp		lastIndexOf: $/		startingAt: aux		ifAbsent: [ ^ aBlock value: stamp value: nil ].	dateIndex _ stamp		lastIndexOf: $ 		startingAt: aux		ifAbsent: [ ^ aBlock value: stamp value: nil ].	"If only date, no time, add midnight time"	dateAndTimePart _ stamp copyFrom: dateIndex + 1 to: stamp size.	(dateAndTimePart indexOf: $:) = 0 ifTrue:[		dateAndTimePart _ dateAndTimePart, ' 00:00' ].	"Done"	^aBlock		value: (stamp copyFrom: 1 to: dateIndex-1)		value: (DateAndTime fromString: dateAndTimePart)! !!DataStream methodsFor: 'write and read' stamp: 'jmv 6/30/2011 09:33'!objectAt: anInteger	"PRIVATE -- Read & return the object at a given stream position.  08:18 tk  anInteger is a relative file position. "	| savedPosn anObject refPosn |	savedPosn _ byteStream position.		"absolute"	refPosn _ self getCurrentReference.	"relative position"	byteStream position: anInteger + basePos.	"was relative"	anObject _ self next.	self setCurrentReference: refPosn.		"relative position"	byteStream position: savedPosn.		"absolute"	^ anObject! !!Duration methodsFor: 'public protocol' stamp: 'jmv 6/30/2011 09:01'!totalMinutes	"Answer an integer number of minutes"	^ seconds // 60! !!Editor methodsFor: 'new selection' stamp: 'jmv 6/29/2011 15:56'!selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level	string here hereChar start stop |	string _ self string.	string size < 2 ifTrue: [^self selectFrom: 1 to: 1].	here _ self pointIndex min: string size max: 2.	openDelimiter _ string at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: [			"delimiter is on left -- match to the right"			start _ here.			direction _ 1.			here _ here - 1.			closeDelimiter _ rightDelimiters at: match]		ifFalse: [			openDelimiter _ string at: here.			match _ rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: [					"delimiter is on right -- match to the left"					stop _ here - 1.					direction _ -1.					closeDelimiter _ leftDelimiters at: match]				ifFalse: [					"no delimiters -- select a token"					direction _ -1]].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: [			hereChar _ string at: (here _ here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: [									start _ 1.									"go right if hit string start"									direction _ 1]]						ifFalse: [							direction < 0								ifTrue: [									start _ here + 1.									"go right if hit non-token"									direction _ 1]								ifFalse: [level _ 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level _ level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level _ level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!FilePackage methodsFor: 'accessing' stamp: 'jmv 6/30/2011 09:34'!fullName: aString	fullName _ aString! !!FilePackage methodsFor: 'accessing' stamp: 'jmv 6/30/2011 09:34'!packageName	^FileDirectory localNameFor: self fullPackageName! !!FilePackage methodsFor: 'initialize' stamp: 'jmv 6/30/2011 09:33'!initialize	classes _ Dictionary new.	classOrder _ OrderedCollection new.	sourceSystem _ ''.	doIts _ OrderedCollection new! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'jmv 6/30/2011 09:34'!putForm: aForm onStream: aWriteStream	"Store the given form on a file of the given name."	| writer |	writer _ self on: aWriteStream.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close! !!Integer methodsFor: 'printing' stamp: 'jmv 6/30/2011 10:21'!destinationBuffer:digitLength	digitLength <= 1		ifTrue: [self]		ifFalse: [LargePositiveInteger new: digitLength]! !!Integer methodsFor: 'printing' stamp: 'jmv 6/30/2011 10:21'!digitBuffer: digitLength  ^Array new: digitLength*8! !!MessageSet methodsFor: 'message list' stamp: 'jmv 6/30/2011 10:36'!sortByDate	"Sort the message-list by date of time-stamp"	| assocs aCompiledMethod aDate inOrder |	assocs _ messageList collect: [ :aRef |		aDate _ aRef methodSymbol == #Comment			ifTrue: [				aRef actualClass organization dateCommentLastSubmitted]			ifFalse: [				aCompiledMethod _ aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: nil.				aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].		aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"	inOrder _ assocs asArray sort: [ :a :b | a value < b value].	messageList _ inOrder collect: [:assoc | assoc key].	self changed: #messageList! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jmv 6/30/2011 10:22'!copyPixelsIndexed: y	"Handle non-interlaced indexed color mode (colorType = 3)"	| hack hackBlt swizzleHack swizzleBlt scanline hackDepth |	scanline := ByteArray new: bytesPerScanline + 3 // 4 * 4.	scanline replaceFrom: 1 to: thisScanline size with: thisScanline startingAt: 1.	hackDepth := bigEndian ifTrue:[form depth] ifFalse:[form depth negated].	hack := Form extent: width@1 depth: hackDepth bits: scanline.	hackBlt := BitBlt toForm: form.	hackBlt sourceForm: hack.	hackBlt combinationRule: Form over.	hackBlt destOrigin: 0@y.	hackBlt width: width; height: 1.	(form depth < 8 and:[bigEndian not]) ifTrue:[		swizzleHack := Form new hackBits: scanline.		swizzleBlt := BitBlt toForm: swizzleHack.		swizzleBlt sourceForm: swizzleHack.		swizzleBlt combinationRule: Form over.		swizzleBlt colorMap: (StandardSwizzleMaps at: form depth).		swizzleBlt copyBits.	].	hackBlt copyBits! !!PNGReadWriter methodsFor: 'writing' stamp: 'jmv 6/30/2011 10:22'!writeType3DataOn: zStream	"Write color indexed data."	| scanline hack hackBlt swizzleBlt swizzleHack hackDepth |	scanline := ByteArray new: bytesPerScanline + 3 // 4 * 4.	hackDepth := bigEndian ifTrue:[form depth] ifFalse:[form depth negated].	hack := Form extent: width@1 depth: hackDepth bits: scanline.	hackBlt := BitBlt toForm: hack.	hackBlt sourceForm: form.	hackBlt combinationRule: Form over.	hackBlt destOrigin: 0@0.	hackBlt width: width; height: 1.	(form depth < 8 and:[bigEndian not]) ifTrue:[		swizzleHack := Form new hackBits: scanline.		swizzleBlt := BitBlt toForm: swizzleHack.		swizzleBlt sourceForm: swizzleHack.		swizzleBlt combinationRule: Form over.		swizzleBlt colorMap: (StandardSwizzleMaps at: form depth).	].	0 to: height-1 do:[:i|		hackBlt sourceOrigin: 0@i; copyBits.		swizzleBlt ifNotNil:[swizzleBlt copyBits].		zStream nextPut: 0. "filterType"		zStream next: bytesPerScanline putAll: scanline startingAt: 1.	].	zStream close! !!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2011 09:34'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model _ anObject! !!BrowserWindow methodsFor: 'commands' stamp: 'jmv 6/30/2011 09:40'!findClass	"Search for a class by name."	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |	self okToChange ifFalse: [ ^self flash ].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self flash].	toMatch _ (pattern copyWithout: $.) asLowercase withBlanksTrimmed.	potentialClassNames _ model potentialClassNames asOrderedCollection.	classNames _ (pattern last = $. or: [pattern last = $ ])		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self flash].	exactMatch _ classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].	index = 0 ifTrue: [^ self flash].	foundClass _ Smalltalk at: (classNames at: index) asSymbol. 	model selectCategoryForClass: foundClass.	model selectClass: foundClass! !!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 6/29/2011 11:03'!updateProcessList	| oldSelectedProcess |	oldSelectedProcess _ selectedProcess.	processList _ selectedProcess _ selectedSelector _ nil.	Smalltalk garbageCollectMost.	"lose defunct processes"	processList _ Process allSubInstances reject: [:each | each isTerminated ].	processList _ processList sort: [ :a :b | a priority >= b priority ].	processList _ WeakArray withAll: processList.	self changed: #processNameList.	self selectedProcess: ((processList includes: oldSelectedProcess)		ifTrue: [oldSelectedProcess])! !!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 6/29/2011 15:57'!lastRange	| r i s |	s _ ranges size.	s = 0 ifTrue: [ ^nil ].	r _ ranges last.	^r type = #excessCode		ifFalse: [ r ]		ifTrue: [			i _ s-1.			i > 0 ifTrue: [ ranges at: i ]]! !!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 6/29/2011 09:51'!penultimateRange	| r s i |	s _ ranges size.	r _ ranges last.	i _ r type = #excessCode		ifFalse: [ s - 1 ]		ifTrue: [ s - 2 ].	^i >0 ifTrue: [ ranges at: i ]! !!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 6/29/2011 14:26'!namesBeginningWith: aString do: aBlock	"Evaluate aBlock for all available names that start with aString"	self nonGlobalNamesDo: [ :name |		(aString isEmpty or: [name beginsWith: aString]) ifTrue: [ aBlock value: name ]].	Smalltalk namesBeginningWith: aString do: aBlock! !!SHParserST80 methodsFor: 'testing' stamp: 'jmv 6/28/2011 14:34'!isPartialOrFullIdentifier: aSymbol	(#(#incompleteIdentifier		#blockTempVar #blockArg #tempVar #methodArg		#instVar #classVar 		#workspaceVar #poolConstant #globalVar ) 			pointsTo:aSymbol) ifTrue: [ ^ true ].	(self isReservedName: aSymbol) ifTrue: [ ^ true ].	^ false! !!SmallInteger methodsFor: 'printing' stamp: 'jmv 6/30/2011 10:21'!destinationBuffer:digitLength	^ LargePositiveInteger new: digitLength! !!String methodsFor: '*Ocompletion' stamp: 'jmv 6/29/2011 08:28'!separateKeywords	^self, ' '! !!Symbol methodsFor: '*Ocompletion' stamp: 'jmv 6/28/2011 16:01'!separateKeywords	^self isKeyword		ifFalse: [ self, ' ' ]		ifTrue: [			String streamContents: [ :strm |				self keywords					do: [ :keyword | strm nextPutAll: keyword ]					separatedBy: [ strm space; space ].				strm space]]! !!SystemChangeNotifier methodsFor: 'public' stamp: 'jmv 6/30/2011 16:08'!notify: anObject ofSystemChangesOfItem: itemKind  using: oneArgumentSelector 	"Notifies an object of system changes of the specified itemKind (#class, #method, #protocol, ...). Evaluate 'AbstractEvent allItemKinds' to get the complete list."	self 		notify: anObject		ofEvents: (self systemEventsForItem: itemKind)		using: oneArgumentSelector! !!SystemDictionary methodsFor: 'testing' stamp: 'jmv 6/30/2011 08:33'!namesBeginningWith: aString do: aBlock in: aCollection	"aCollection is sorted"	| count |	"Find the first element  starting with aString"	count _ aCollection size.	aCollection		findBinaryIndex: [ :element |			element < aString				ifFalse: [ -1 ]				ifTrue: [ 1 ] ]		do: [ :found | "Will never find any" ]		ifNone: [ :a :b | | i n |			i _ b.			[ i <= count and: [ 				n _ aCollection at: i.				aString isEmpty or: [					n beginsWith: aString ]]] whileTrue: [				aBlock value: n.				i _ i + 1 ]]! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 6/29/2011 11:31'!stylerStyled	textMorph paragraph composeAll.	self editor recomputeSelection.		textMorph updateFromParagraph.	self editor setEmphasisHereFromText.	self editor blinkParen.	self scrollSelectionIntoView! !!Utilities class methodsFor: 'identification' stamp: 'jmv 6/30/2011 09:38'!changeStampPerSe	"Answer a string to be pasted into source code to mark who changed it and when."	^ (self authorInitialsPerSe ifNil: ['?']) , ' ' , Date today mmddyyyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!Utilities class methodsFor: 'identification' stamp: 'jmv 6/30/2011 09:40'!setAuthorInitials: aString	AuthorInitials _ aString withBlanksTrimmed.	"Case of being reset due to, eg, copy of image."	aString isEmpty ifTrue: [AuthorName _ '']! !String removeSelector: #trimBlanks!BareTextMorph class removeSelector: #autoCompletter:!BareTextMorph removeSelector: #model!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompletter'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!