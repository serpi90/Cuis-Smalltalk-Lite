'From Cuis 3.0 of 31 January 2011 [latest update: #790] on 23 February 2011 at 4:12:37 pm'!!classDefinition: #LayoutSpec category: #'Morphic-Layouts'!Object subclass: #LayoutSpec	instanceVariableNames: 'morph fixedWidth fixedHeight minorDirectionPadding proportionalWidth proportionalHeight'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 2/23/2011 14:46'!morph: aMorph	morph _ aMorph! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 2/23/2011 14:48'!fixedHeight	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."	proportionalHeight ifNotNil: [		^0 ].	^ fixedHeight ifNil: [ morph height ]! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 2/23/2011 14:49'!fixedWidth	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."	proportionalWidth ifNotNil: [		^0 ].	^ fixedWidth ifNil: [ morph width ]! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 2/23/2011 14:50'!heightFor: availableSpace	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined.	Otherwise, we do proportional layout, and the stored extent is a minimum extent.	If there is no minimum extent, it should be set to zero."	proportionalHeight ifNotNil: [		^fixedHeight max: proportionalHeight * availableSpace ].	^ self fixedHeight! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 2/23/2011 14:51'!widthFor: availableSpace	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined.	Otherwise, we do proportional layout, and the stored extent is a minimum extent.	If there is no minimum extent, it should be set to zero."	proportionalWidth ifNotNil: [		^fixedWidth max: proportionalWidth * availableSpace ].	^ self fixedWidth! !!Morph methodsFor: 'layout-properties' stamp: 'jmv 2/23/2011 14:47'!layoutSpec: aLayoutSpec	"Layout specific. Set the layout spec describing where the receiver should appear in a proportional layout"	self layoutSpec == aLayoutSpec ifTrue:[^self].	aLayoutSpec morph: self.	self assureExtension layoutSpec: aLayoutSpec.	self layoutChanged.! !!LayoutMorph methodsFor: 'layout' stamp: 'jmv 2/23/2011 14:58'!layoutSubmorphsHorizontallyIn: boundsForLayout	"Compute a new layout based on the given layout bounds."	| usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |	usableWidth _ boundsForLayout width - ((submorphs size + 1) * separation).	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].	availableForPropWidth _ usableWidth - sumOfFixed.	padding ifNil: [		availableForPropWidth = 0 ifFalse: [			self width: self width - availableForPropWidth.			^ self doLayoutIfNeeded ]].	normalizationFactor _ self proportionalWidthNormalizationFactor.	availableForPropWidth _ availableForPropWidth * normalizationFactor.	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + separation max: 0) +  boundsForLayout left.	usableHeight _ boundsForLayout height - (2*separation) max: 0.	boundsTop _ boundsForLayout top.		boundsRight _ boundsForLayout right.	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |			m _ submorphs at: index.			w _ widths at: index.			"major direction"			r _ l + w min: boundsRight.			"minor direction"			ls _ m layoutSpec.			h _ (ls heightFor: usableHeight) min: usableHeight.			t _ (usableHeight - h) * ls minorDirectionPadding + separation + boundsTop.			b _ t + h.			"Set bounds and adjust major direction for next step"			m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).			w > 0 ifTrue: [				l _ r + separation min: boundsRight ]]! !!LayoutMorph methodsFor: 'layout' stamp: 'jmv 2/23/2011 14:57'!layoutSubmorphsVerticallyIn: boundsForLayout	"Compute a new layout based on the given layout bounds."	| usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |	usableHeight _ boundsForLayout height - ((submorphs size + 1) * separation).	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].	availableForPropHeight _ usableHeight - sumOfFixed.	padding ifNil: [		availableForPropHeight = 0 ifFalse: [			self height: self height - availableForPropHeight.			^ self doLayoutIfNeeded ]].	normalizationFactor _ self proportionalHeightNormalizationFactor.	availableForPropHeight _ availableForPropHeight * normalizationFactor.	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + separation max: 0) +  boundsForLayout top.	usableWidth _ boundsForLayout width - (2*separation) max: 0.	boundsLeft _ boundsForLayout left.		boundsBottom _ boundsForLayout bottom.	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |			m _ submorphs at: index.			h _ heights at: index.			"major direction"			b _ t + h min: boundsBottom.			"minor direction"			ls _ m layoutSpec.			w _ (ls widthFor: usableWidth) min: usableWidth.			l _ (usableWidth - w) * ls minorDirectionPadding + separation + boundsLeft.			r _ l + w.			"Set bounds and adjust major direction for next step"			m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).			h > 0 ifTrue: [				t _ b + separation min: boundsBottom ]]! !!LayoutMorph methodsFor: 'private' stamp: 'jmv 2/23/2011 14:57'!proportionalHeightNormalizationFactor	| sumOfProportional |	sumOfProportional _ submorphs sum: [ :m | m layoutSpec proportionalHeight ].	^1.0 / (sumOfProportional max: 1.0).! !!LayoutMorph methodsFor: 'private' stamp: 'jmv 2/23/2011 14:57'!proportionalWidthNormalizationFactor	| sumOfProportional |	sumOfProportional _ submorphs sum: [ :m | m layoutSpec proportionalWidth ].	^1.0 / (sumOfProportional max: 1.0).! !LayoutSpec removeSelector: #fixedHeightFor:!LayoutSpec removeSelector: #fixedWidthFor:!LayoutSpec removeSelector: #heightOf:for:!LayoutSpec removeSelector: #widthOf:for:!