'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 3 December 2010 at 1:53:17 pm'!!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 12/3/2010 13:23'!wantsSteps	^ Preferences smartUpdating! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 12/3/2010 13:33'!updateIfNecessary	"Recompute all of my panes."	| newList |	self okToChange ifFalse: [^ self].	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"	(myChangeSet isMoribund or: [(changeSetCategory notNil and: [changeSetCategory includesChangeSet: myChangeSet]) not]) ifTrue:		[self changed: #changeSetList.		^ self showChangeSet: self changeSetCategory defaultChangeSetToShow].	newList _ self changeSetList.	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])		ifTrue:			[priorChangeSetList _ newList.			self changed: #changeSetList]."	self showChangeSet: myChangeSet"! !!ChangeSorter methodsFor: 'self-updating' stamp: 'jmv 12/3/2010 13:27'!stepIn: aSystemWindow	self updateIfNecessary! !!ChangeSetBrowser methodsFor: 'menu' stamp: 'jmv 12/3/2010 13:41'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	aMenu title: 'Change set (shifted)'.	aMenu addStayUpIcons.	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	aMenu addLine.	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu add: 'check for uncommented methods' action: #checkForUncommentedMethods.	aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'.	aMenu add: 'check for uncommented classes' action: #checkForUncommentedClasses.	aMenu balloonTextForLastItem:'Check for classes with code in this changeset which lack class comments'.	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' action: #checkForAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'.		aMenu add: 'check for any other authors' action: #checkForAnyAlienAuthorship.		aMenu balloonTextForLastItem:'Check this change set for methods any of whose previous authoring stamps do not start with "', Utilities authorInitials, '"'].	aMenu add: 'check for uncategorized methods' action: #checkForUnclassifiedMethods.	aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu add: 'uninstall this change set' action: #uninstallChangeSet.	aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'.	aMenu addLine.	aMenu add: 'more...' action: #offerUnshiftedChangeSetMenu.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!DualChangeSorter methodsFor: 'self-updating' stamp: 'jmv 12/3/2010 13:28'!stepIn: aSystemWindow	leftCngSorter updateIfNecessary.	rightCngSorter updateIfNecessary! !!DualChangeSorter methodsFor: 'self-updating' stamp: 'jmv 12/3/2010 13:23'!wantsSteps	^ Preferences smartUpdating! !!FileList methodsFor: 'private' stamp: 'jmv 12/3/2010 13:36'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read' translated].	(brevityFlag not or: [(fileSize := f size) <= 100000]) ifTrue: [		acceptedContentsCache _ f contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ acceptedContentsCache ].	"if brevityFlag is true, don't display long files when first selected"	first5000 := f next: 5000.	f close.	acceptedContentsCache _ ('File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. fileSize. first5000}).	brevityState := #briefFile.   "don't change till actually read"	^ acceptedContentsCache! !TranscriptStream removeSelector: #step!FileList removeSelector: #modelWakeUp!FileList removeSelector: #readServerBrief!FileDirectory removeSelector: #isRemoteDirectory!FileDirectory removeSelector: #wakeUp!DualChangeSorter removeSelector: #wantsStepsIn:!Debugger removeSelector: #step!CodeProvider removeSelector: #wantsStepsIn:!