'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 2 June 2011 at 9:00:27 am'!!classDefinition: #Inspector category: #'Tools-Inspector'!TextProvider subclass: #Inspector	instanceVariableNames: 'acceptedContentsCache object selectionIndex timeOfLastListUpdate selectionUpdateTime context '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!classDefinition: #WorkspaceWindow category: #'Morphic-Tools'!SystemWindow subclass: #WorkspaceWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Tools'!!ConnectionQueue methodsFor: 'private' stamp: 'jmv 6/1/2011 23:00'!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	| newConnection |	socket := Socket newTCP.	"We'll accept four simultanous connections at the same time"	socket listenOn: portNumber backlogSize: 4.	"If the listener is not valid then the we cannot use the	BSD style accept() mechanism."	socket isValid ifFalse: [^self oldStyleListenLoop].	[true] whileTrue: [		socket isValid ifFalse: [			"socket has stopped listening for some reason"			socket destroy.			(Delay forMilliseconds: 10) wait.			^self listenLoop ].		newConnection := socket 			waitForAcceptFor: 10			ifTimedOut: [ nil ].		(newConnection notNil and: [newConnection isConnected]) ifTrue: [			accessSema critical: [connections addLast: newConnection.].			newConnection := nil.			self changed: self].		self pruneStaleConnections]. ! !!FileList methodsFor: 'initialization' stamp: 'jmv 6/1/2011 22:53'!directory: dir	"Set the path of the volume to be displayed."	directory _ dir.	sortMode ifNil: [		sortMode _ #date.		sortAscending _ false ].	self changed: #relabel.	self pattern: pattern! !!Inspector methodsFor: 'selecting' stamp: 'jmv 6/2/2011 08:35'!selectionPrintString	| text |	text := [self selection printStringLimitedTo: 12000]						on: Error						do: [text := self printStringErrorText.							text								addAttribute: TextColor red								from: 1								to: text size.							text].	^ text! !!Inspector methodsFor: 'selecting' stamp: 'jmv 6/2/2011 08:35'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionIndex = anInteger		ifTrue: [			"same index, turn off selection"			selectionIndex _ 0.			acceptedContentsCache _ '']		ifFalse: [			"different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [ acceptedContentsCache _ self selection]				ifFalse: [ acceptedContentsCache _ self selectionPrintString]].	self changed: #selection.	self acceptedContentsChanged.	self changed: #selectionIndex! !!Morph methodsFor: 'e-toy support' stamp: 'jmv 6/2/2011 08:25'!unlockOneSubpart	| unlockables aMenu reply |	unlockables _ self submorphs select:		[ :m | m isLocked].	unlockables size <= 1 ifTrue: [^ self unlockContents].	aMenu _ SelectionMenu labelList: (unlockables collect: [:m | m printStringLimitedTo: 40]) selections: unlockables.	reply _ aMenu startUpWithCaption: 'Who should be be unlocked?'.	reply ifNil: [^ self].	reply unlock! !!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 6/2/2011 08:24'!editBalloonHelpContent: aString	| reply |	reply _ FillInTheBlank		multiLineRequest: 'Edit the balloon help text for ' , (self printStringLimitedTo: 40)		centerAt: self world activeHand position		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])		answerHeight: 200.	reply ifNil: [^ self].  "User cancelled out of the dialog"	(reply isEmpty or: [reply asString = self noHelpString])		ifTrue: [self setBalloonText: nil]		ifFalse: [self setBalloonText: reply]! !!Morph methodsFor: 'menus' stamp: 'jmv 6/2/2011 08:23'!addHaloActionsTo: aMenu 	"Add items to aMenu representing actions requestable via halo"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu addTitle: (self printStringLimitedTo: 40).	subMenu addStayUpIcons.	subMenu addLine.	subMenu add: 'delete' action: #dismissViaHalo.	subMenu balloonTextForLastItem: 'Delete this object -- warning -- can be destructive!!' .	self maybeAddCollapseItemTo: subMenu.	subMenu add: 'grab' action: #openInHand.	subMenu balloonTextForLastItem: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' .	subMenu addLine.	subMenu add: 'resize' action: #resizeFromMenu.	subMenu balloonTextForLastItem: 'Change the size of this object'.	subMenu add: 'duplicate' action: #maybeDuplicateMorph.	subMenu balloonTextForLastItem: 'Hand me a copy of this object'.	subMenu 		add: 'set color'		target: self		action: #changeColor.	subMenu balloonTextForLastItem: 'Change the color of this object'.	subMenu 		add: 'inspect'		target: self		action: #inspect.	subMenu balloonTextForLastItem: 'Open an Inspector on this object'.	aMenu add: 'halo actions...' subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'jmv 6/2/2011 08:23'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	aMenu add: 'send to back' action: #goBehind.	aMenu add: 'bring to front' action: #comeToFront.	self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	self addColorMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addDebuggingItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu			add: ('unlock "{1}"' format: (unlockables first printStringLimitedTo: 40))			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'jmv 6/2/2011 08:23'!addTitleForHaloMenu: aMenu	aMenu addTitle: (self printStringLimitedTo: 40)! !!Morph methodsFor: 'menus' stamp: 'jmv 6/2/2011 08:24'!exportAsBMP	| fName |	fName _ FillInTheBlank request:'Please enter the name' initialAnswer: (self printStringLimitedTo: 20),'.bmp'.	fName isEmpty ifTrue:[^self].	(self imageForm: 32) writeBMPfileNamed: fName.! !!Morph methodsFor: 'menus' stamp: 'jmv 6/2/2011 08:24'!exportAsJPEG	"Export the receiver's image as a JPEG"	| fName |	fName _ FillInTheBlank request: 'Please enter the name' initialAnswer: (self printStringLimitedTo: 20),'.jpeg'.	fName isEmpty ifTrue: [^ self].	(self imageForm: 32) writeJPEGfileNamed: fName! !!Morph methodsFor: 'menus' stamp: 'jmv 6/2/2011 08:24'!exportAsPNG	| fName |	fName _ FillInTheBlank request:'Please enter the name' initialAnswer: (self printStringLimitedTo: 20),'.png'.	fName isEmpty ifTrue:[^self].	PNGReadWriter putForm: (self imageForm: 32) onFileNamed: fName.! !!HaloMorph methodsFor: 'private' stamp: 'jmv 6/2/2011 08:23'!addHandlesForWorldHalos	"Add handles for world halos, like the man said"	| box w |	w _ self world ifNil:[target world].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ w bounds insetBy: 9.	target addWorldHandlesTo: self box: box.	self		addNameBeneath: (box insetBy: (0@0 corner: 0@10))		string: (innerTarget printStringLimitedTo: 40).	growingOrRotating _ false.	self layoutChanged.	self redrawNeeded! !!HaloMorph methodsFor: 'private' stamp: 'jmv 6/2/2011 08:23'!addName	"Add a name readout at the bottom of the halo."	self addNameBeneath: self basicBox string: (target printStringLimitedTo: 40)! !!HaloMorph methodsFor: 'private' stamp: 'jmv 6/2/2011 08:22'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	self world displayWorld.	evt shiftPressed ifTrue: [		self delete.		^ innerTarget inspect].	menu _ innerTarget buildDebugMenu: evt hand.	menu addTitle: (innerTarget printStringLimitedTo: 40).	menu popUpInWorld: self world! !!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/2/2011 08:46'!example6	"	Useful example contributed by Ken Dickey	All these should look the same, right? (mmmh this should be a test...)	self example6	"| pane rect1 rect2 |pane _ LayoutMorph newRow separation: 5. "1"pane color: Color lightGreen; bounds: (120 @ 50 extent: 180 @ 100).pane addMorph: (StringMorph contents: '1').rect1 := RectangleMorph new color: (Color lightOrange); 	width: 20; height: 30.pane addMorph: rect1.rect2 := RectangleMorph new color: (Color cyan); 	width: 20; height: 30.pane addMorph: rect2.pane openInWorld.pane _ LayoutMorph newRow separation: 5. "2"pane color: Color lightGreen; bounds: (320 @ 50 extent: 180 @ 100).pane addMorph: (StringMorph contents: '2').rect1 := RectangleMorph new color: (Color lightOrange);	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).pane addMorph: rect1.rect2 := RectangleMorph new color: (Color cyan).pane addMorph: rect2	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).pane openInWorld.pane _ LayoutMorph newRow separation: 5. "3"pane color: Color lightGreen; bounds: (520 @ 50 extent: 180 @ 100).pane addMorph: (StringMorph contents: '3').rect1 := RectangleMorph new color: (Color lightOrange).pane addMorph: rect1          layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).rect2 := RectangleMorph new color: (Color cyan);	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).pane addMorph: rect2.pane openInWorld.! !!ObjectExplorerWrapper methodsFor: 'nil' stamp: 'jmv 6/1/2011 22:51'!asString	| explorerString string |	explorerString _ 		[item printString]			on: Error 			do: ['<error in printString: evaluate "' , itemName , ' printString" to debug>'].	string _ itemName , ': ' , explorerString.	(string includes: Character cr)		ifTrue: [^ string withSeparatorsCompacted].	^ string! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jmv 6/2/2011 08:25'!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu, given that the receiver is a World"	| unlockables |	self addColorMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addDebuggingItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[ :m | m isLocked].	unlockables size = 1 ifTrue: [		aMenu add: ('unlock "{1}"' format:{unlockables first printStringLimitedTo: 40})action: #unlockContents].	unlockables size > 1 ifTrue: [		aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!String methodsFor: 'converting' stamp: 'jmv 6/2/2011 08:52'!asInteger 	"Answer the Integer created by interpreting the receiver as the string representation of an integer.  Answer nil if no digits, else find the first digit and then all consecutive digits after that"	| startPosition tail endPosition |	startPosition _ self findFirst: [:ch | ch isDigit].	startPosition = 0 ifTrue: [^ nil].	tail _ self copyFrom: startPosition to: self size.	endPosition _ tail findFirst: [:ch | ch isDigit not].	endPosition = 0 ifTrue: [endPosition _ tail size + 1].	^ Number readFrom: (tail copyFrom: 1 to: endPosition - 1) readStream"'1796exportFixes-tkMX' asInteger'1848recentLogFile-sw'  asInteger'donald' asInteger'abc234def567' asInteger"! !!String methodsFor: 'converting' stamp: 'jmv 6/2/2011 08:51'!asNumber 	"Answer the Number created by interpreting the receiver as the string 	representation of a number."	^Number readFrom: self readStream! !!String methodsFor: 'converting' stamp: 'jmv 6/2/2011 08:50'!asSignedInteger	"Answer the Integer created by interpreting the receiver as the string representation of an integer, possibly with a leading minus sign.  Answer nil if no digits, else find the first digit and then all consecutive digits after that"	| startPosition tail endPosition |	startPosition _ self findFirst: [:ch | ch isDigit or: [ch == $-]].	startPosition = 0 ifTrue: [^ nil].	tail _ self copyFrom: startPosition to: self size.	endPosition _ tail findFirst: [:ch | ch isDigit not and: [ch ~~ $-]].	endPosition = 0 ifTrue: [endPosition _ tail size + 1].	^ Number readFrom: (tail copyFrom: 1 to: endPosition - 1) readStream"'znak -58 to wit' asSignedInteger"! !!Switch methodsFor: 'state' stamp: 'jmv 6/1/2011 23:00'!clear	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent. The receiver's off action is 	NOT executed."	self isOn		ifTrue: 			[on _ false.			self changed: self]! !!Switch methodsFor: 'state' stamp: 'jmv 6/1/2011 23:00'!set	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent. The receiver's on action is 	NOT executed."	self isOff		ifTrue: 			[on _ true.			self changed: self]! !!Switch methodsFor: 'state' stamp: 'jmv 6/1/2011 23:00'!turnOff	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent and the receiver's off action is 	executed."	self isOn		ifTrue: 			[on _ false.			self changed: self.			self doAction: offAction]! !!Switch methodsFor: 'state' stamp: 'jmv 6/1/2011 23:00'!turnOn	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent and the receiver's on action is 	executed."	self isOff		ifTrue: 			[on _ true.			self changed: self.			self doAction: onAction]! !!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/1/2011 22:42'!offerWindowMenu	self buildWindowMenu popUpInWorld: self world! !!SystemWindow methodsFor: 'stepping' stamp: 'jmv 6/2/2011 08:34'!stepTime	^ 200 "milliseconds"! !!SystemWindow methodsFor: 'top window' stamp: 'jmv 6/1/2011 22:53'!passivate	"Make me unable to respond to mouse and keyboard"	| focus |	focus _ ActiveHand keyboardFocus.	focus ifNotNil: [		(focus ownerThatIsA: SystemWindow) == self			ifTrue: [ ActiveHand releaseKeyboardFocus ]].	self redrawNeeded! !!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 6/1/2011 22:58'!buildMorphicWindow	" Inspector openAsMorphOn: SystemOrganization "	| contentsText list upperRow evaluatorText |	list _ PluggableListMorph			model: model 			listGetter: #fieldList			indexGetter: #selectionIndex			indexSetter: #toggleIndex:			mainView: self			menuGetter: #fieldListMenu			keystrokeAction: #inspectorKey:from:.	contentsText _ TextModelMorph			textProvider: model			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection.	evaluatorText _ (TextModelMorph textProvider: model)			askBeforeDiscardingEdits: false.	upperRow _ LayoutMorph newRow.	upperRow		addMorph: list proportionalWidth: 0.3;		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.	self layoutMorph		addMorph: upperRow proportionalHeight: 0.7;		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.	self setLabel: (model object printStringLimitedTo: 64).	self setUpdatablePanesFrom: #(fieldList)! !!SystemWindow class methodsFor: 'instance creation' stamp: 'jmv 6/1/2011 22:46'!editText: aTextModel label: labelString wrap: aBoolean	| window |	window _ self new model: aTextModel.	window setLabel: labelString.	window layoutMorph		addMorph: ((TextModelMorph withModel: aTextModel)			wrapFlag: aBoolean)		proportionalHeight: 1.	^ window openInWorld! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 6/1/2011 22:44'!openWorkspace	Workspace new		contents: '';		openLabel: 'Workspace'! !!Workspace methodsFor: 'drag and drop' stamp: 'jmv 6/2/2011 08:25'!acceptDroppingMorph: dropee event: evt inMorph: targetMorph 	"Return the dropee to its old position, and add a reference to it at the cursor point."	| bindingName |	bindingName _  ((dropee printStringLimitedTo: 40) translateToLowercase, dropee identityHash printString) asIdentifier: false.	targetMorph correctSelectionWithString: bindingName, ' '.	(self bindingOf: bindingName) value: dropee.	dropee rejectDropMorphEvent: evt.	^ true "success"! !!Workspace methodsFor: 'gui' stamp: 'jmv 6/1/2011 22:46'!openLabel: aString 	"Create a standard system view of the model, me, and open it."	WorkspaceWindow editText: self label: aString wrap: true! !!WorkspaceWindow methodsFor: 'menu' stamp: 'jmv 6/1/2011 22:42'!offerWindowMenu	| aMenu |	aMenu _ self buildWindowMenu.	aMenu addLine.	aMenu		add: 'reset variables'		target: model		action: #initializeBindings.	aMenu		addUpdating: #mustDeclareVariableWording		target: model		action: #toggleVariableDeclarationMode.	aMenu		addUpdating: #toggleStylingLabel		target: model		action: #toggleStyling.	aMenu popUpInWorld: self world! !Workspace removeSelector: #addModelItemsToWindowMenu:!!Workspace reorganize!('initialize-release' initialize)('binding' bindingOf: hasBindingOf: hasBindingThatBeginsWith: initializeBindings)('accessing' setBindings:)('drag and drop' acceptDroppingMorph:event:inMorph:)('code pane menu' editorClass)('*Shout-Styling' shouldStyle shoutAboutToStyle: toggleStyling toggleStylingLabel)('variable declarations' mustDeclareVariableWording toggleVariableDeclarationMode)('testing' is:)('gui' openLabel:)!SystemWindow removeSelector: #externalName!Symbol removeSelector: #asExplorerString!String removeSelector: #asExplorerString!String removeSelector: #asMorph!Stream removeSelector: #sleep!Preferences class removeSelector: #addModelItemsToWindowMenu:!PasteUpMorph removeSelector: #sleep!Number removeSelector: #defaultLabelForInspector!Morph removeSelector: #asMorph!Morph removeSelector: #defaultLabelForInspector!Inspector removeSelector: #stepTimeIn:!!classDefinition: #Inspector category: #'Tools-Inspector'!TextProvider subclass: #Inspector	instanceVariableNames: 'acceptedContentsCache object selectionIndex timeOfLastListUpdate context'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!Form removeSelector: #asMorph!FileList removeSelector: #modelSleep!FileDirectory removeSelector: #sleep!!Editor reorganize!('accessing' currentAttributes morph morph: userHasEdited)('accessing-selection' hasSelection selectionInterval)('editing keys' copySelection: cut: noop: paste:)('menu messages' clipboardStringOrText clipboardTextPut: lineSelectAndEmptyCheck: paste wordSelectAndEmptyCheck:)('new selection' selectAt: selectInterval: selectInvisiblyFrom:to: selectInvisiblyMark:point: selectMark:point: selectWord selectWordLeftDelimiters:rightDelimiters:)('nonediting/nontyping keys' cursorDown: cursorLeft: cursorPageDown: cursorPageUp: cursorRight: cursorUp: selectWord:)('typing/selecting keys' backspace: clearSelection cr: crWithIndent: crlf: cursorTopHome: enter: lf: normalCharacter: selectAll selectAll:)('private' beginningOfLine: beginningOfNextParagraph: beginningOfParagraph: beginningOfText endOfLine: endOfParagraph: endOfText lines moveCursor:forward:event: nextWordEnd: nextWordStart: previousWordStart: sameColumn:newLine:forward: setIndices:forward:)!Class removeSelector: #externalName!Object removeSelector: #addModelItemsToWindowMenu:!Object removeSelector: #asExplorerString!Object removeSelector: #asMorph!Object removeSelector: #changed!Object removeSelector: #defaultLabelForInspector!Object removeSelector: #externalName!Object removeSelector: #indexIfCompact!Object removeSelector: #logEntry!Object removeSelector: #logExecution!Object removeSelector: #logExit!Object removeSelector: #modelSleep!Object removeSelector: #noteSelectionIndex:for:!Object removeSelector: #readFromString:!Object removeSelector: #stepTime!Object removeSelector: #stepTimeIn:!!Object reorganize!('*tools-browser' browseClassHierarchy)('Breakpoint' break)('accessing' addInstanceVarNamed:withValue: at: at:put: basicAt: basicAt:put: basicSize customizeExplorerContents size yourself)('as yet unclassified' revisar)('associating' ->)('binding' bindingOf:)('casing' caseOf: caseOf:otherwise:)('class membership' class isKindOf: isMemberOf: respondsTo:)('comparing' = closeTo: hash literalEqual: ~=)('converting' adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: as: asOrderedCollection asString asStringOrText complexContents mustBeBoolean mustBeBooleanIn: withoutListWrapper)('copying' clone copy copyForClipboard copyFrom: copySameFrom: copyTwoLevel postCopy shallowCopy)('dependents access' addDependent: breakDependents dependents dependents: removeDependent:)('drag and drop' acceptDroppingMorph:event:inMorph:)('error handling' assert: caseError confirm: confirm:orCancel: doesNotUnderstand: error: halt halt: handles: notify:at: notifyWithLabel: primitiveFail primitiveFailed shouldBeImplemented shouldNotImplement subclassResponsibility)('evaluating' value valueWithArguments:)('events-accessing' actionForEvent: actionMap actionSequenceForEvent: actionsDo: hasActionForEvent: setActionSequence:forEvent: updateableActionMap)('events-registering' when:evaluate: when:send:to: when:send:to:with: when:send:to:withArguments:)('events-removing' releaseActionMap removeAction:forEvent: removeActionsForEvent: removeActionsSatisfying: removeActionsSatisfying:forEvent: removeActionsWithReceiver: removeActionsWithReceiver:forEvent:)('events-triggering' triggerEvent: triggerEvent:with: triggerEvent:withArguments:)('finalization' actAsExecutor executor finalizationRegistry finalize retryWithGC:until: toFinalizeSend:to:with:)('inspecting' basicInspect inspect inspectWithLabel: inspectorClass)('macpal' currentWorld flash)('message handling' disableCode: perform: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: withArgs:executeMethod:)('object serialization' comeFullyUpOnReload: convertToCurrentVersion:refStream: objectForDataStream: readDataFrom:size: storeDataOn:)('printing' fullPrintString isLiteral longPrintOn: longPrintOn:limitedTo:indent: longPrintString longPrintStringLimitedTo: nominallyUnsent: print printOn: printString printStringLimitedTo: printWithClosureAnalysisOn: storeOn: storeString stringRepresentation)('system primitives' becomeForward: becomeForward:copyHash: className instVarAt: instVarAt:put: instVarNamed: instVarNamed:put: primitiveChangeClassTo: someObject)('testing' is: isArray isBehavior isBlock isClosure isCollection isFloat isFraction isHeap isInteger isInterval isMethodProperties isNumber isPoint isPseudoContext isString isSymbol isVariableBinding name renameTo: stepAt:in: stepIn: wantsSteps wantsStepsIn:)('translation support' inline: success: var:declareC:)('updating' changed: update:)('user interface' explore hasContentsInExplorer inform: notYetImplemented)('private' errorImproperStore errorNonIntegerIndex errorNotIndexable errorSubscriptBounds: primitiveError: species storeAt:inTempFrame:)('nil' notify:)('tracing' explorePointers inboundPointers inboundPointersExcluding: outboundPointers outboundPointersDo:)!