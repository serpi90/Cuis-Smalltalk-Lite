'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 25 September 2011 at 10:23:22 pm'!!classDefinition: #Paragraph category: #'System-Text'!Object subclass: #Paragraph	instanceVariableNames: 'model container lines positionWhenComposed maxRightX selectionStartBlocks selectionStopBlocks focused editor showCaret lastCaretRect lastCaretRectNeedsRedraw extentForComposing '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #TextComposer category: #'Morphic-Text Support'!Object subclass: #TextComposer	instanceVariableNames: 'lines maxRightX currentY scanner possibleSlide nowSliding prevIndex prevLines currCharIndex startCharIndex stopCharIndex deltaCharIndex theText theContainer isFirstLine actualHeight anythingComposed editor extentForComposing '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!BareTextMorph methodsFor: 'drawing' stamp: 'jmv 9/25/2011 22:02'!drawOn: aCanvas	"Draw the receiver on a canvas"	false ifTrue: [self debugDrawLineRectsOn: aCanvas].  "show line rects for debugging"	"Hack here:  The canvas expects bounds to carry the location of the text, but we also need to communicate clipping.	??removed var fauxBounds...?"	aCanvas paragraph: self paragraph bounds: bounds color: color.	"Drawing the paragraph might change the #lastCaretRect, and therefor might	require a second update."	paragraph lastCaretRectNeedsRedraw ifTrue: [		paragraph lastCaretRect ifNotNil: [ :r | self invalidRect: r ]]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 9/25/2011 15:51'!composeToBounds	"Compose my text to fit my bounds.	If any text lies outside my bounds, it will be clipped,."	self releaseParagraph! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 9/25/2011 15:10'!extentForComposing	^wrapFlag		ifTrue: [ bounds width @ 9999999 ]		ifFalse: [ 9999999@9999999 ]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 9/25/2011 15:51'!fit	"Adjust my bounds to fit the text.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para |	newExtent := (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).	newExtent ~= bounds extent 		ifTrue: [			para := paragraph.	"Save para (layoutChanged smashes it)"			self basicExtent: newExtent.			paragraph := para].	"These statements should be pushed back into senders"	self redrawNeeded.	"Too conservative: only paragraph composition							should cause invalidation."	editView innerHeight: newExtent y! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 9/25/2011 15:20'!installEditorToReplace: priorEditor 	"Install an editor for my paragraph. Install also the paragraph if not there.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [ stateArray _ priorEditor stateArray] .	editor _ model editorClass new morph: self.	editor model: model.	paragraph		ifNotNil: [			editor changeParagraph: paragraph.			editor resetState ]		ifNil: [			"...Code here to recreate the paragraph..."			paragraph _ Paragraph new.			paragraph focused: self hasKeyboardFocus.			paragraph setModel: model extentForComposing: self extentForComposing.			editor changeParagraph: paragraph.			editor setEmphasisHereFromText.			paragraph composeAll.			self fit.			editor resetState.		].	stateArray ifNotNil: [ editor stateArrayPut: stateArray ].	self selectionChanged.	^editor! !!FormCanvas methodsFor: 'drawing' stamp: 'jmv 9/25/2011 22:07'!paragraph: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner _ DisplayScanner new 			text: para paragraphText			foreground: (shadowColor ifNil: [ c ])			ignoreColorChanges: self isShadowDrawing.	scanner setPort: (port clippedBy: (bounds translateBy: origin)).	para		displayOn: (self copyClipRect: bounds)		using: scanner		at: bounds topLeft		canvasOrigin: origin! !!ImageMorph methodsFor: 'drawing' stamp: 'jmv 9/25/2011 14:55'!drawOn: aCanvas	aCanvas image: image at: bounds origin! !!Paragraph methodsFor: 'access' stamp: 'jmv 9/25/2011 15:22'!extent	^ extentForComposing x @ (lines last bottom - lines first top)! !!Paragraph methodsFor: 'composition' stamp: 'jmv 9/25/2011 15:20'!composeAll	^self		composeLinesFrom: 1		to: model textSize		delta: 0		into: OrderedCollection new		priorLines: Array new		atY: 0! !!Paragraph methodsFor: 'composition' stamp: 'jmv 9/25/2011 15:25'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY 	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult composer |	composer _ TextComposer new.	editor ifNotNil: [		composer editor: editor ].	newResult _ composer				composeLinesFrom: start				to: stop				delta: delta				into: lineColl				priorLines: priorLines				atY: startingY				text: model actualContents				extentForComposing: extentForComposing.	lines _ newResult first asArray.	maxRightX _ newResult second.	^maxRightX! !!Paragraph methodsFor: 'composition' stamp: 'jmv 9/25/2011 15:26'!setModel: aTextModel extentForComposing: aPoint	model _ aTextModel.	extentForComposing _ aPoint! !!Paragraph methodsFor: 'display' stamp: 'jmv 9/25/2011 15:22'!displayInsertionMarkAtX: x top: top bottom: bottom emphasis: emphasis on: aCanvas	| caretColor x1 isBold isItalic x0 h w halfW r newCaretRect |	isBold _ emphasis allMask: 1.	isItalic _ emphasis allMask: 2.	caretColor _ Theme current insertionPoint.	h _ bottom - top.	w _ isBold		ifTrue: [ h // 25 + 2 ]		ifFalse: [ h // 30 + 1 ].	halfW _ w // 2.	isItalic		ifTrue: [				x0 _ x - (h * 1 // 22) - 3.			x1 _ x + (h * 4 // 22 ) - 3.			isBold ifTrue: [				x0 _ x0 - 3.				x1 _ x1 - 3 ]]		ifFalse: [			x0 _ x.			x1 _ x].	x0 < halfW ifTrue: [		x1 _ x1 - x0 + halfW.		x0 _ halfW ].	r _ extentForComposing x-halfW-1.	r < x1 ifTrue: [		x0 _ x0 + r - x1.		x1 _ r.		].	lastCaretRectNeedsRedraw _ false.	newCaretRect _ x0-halfW@ top corner: x1+halfW+1 @ bottom.	lastCaretRect ifNotNil: [		lastCaretRect = newCaretRect ifFalse: [			"If we are actually drawing the last position of the text cursor,			but not the current one, request redraw."			((aCanvas isVisible: lastCaretRect) and: [(aCanvas isFullyVisible: newCaretRect) not ])				ifTrue: [					lastCaretRectNeedsRedraw _ true ]]].	lastCaretRect _ newCaretRect.	aCanvas		line: x0@(bottom-halfW) to: x1@(top+halfW)		width: w color: caretColor! !!Paragraph methodsFor: 'fonts-display' stamp: 'jmv 9/25/2011 22:10'!displayOn: aCanvas using: displayScanner at: pos canvasOrigin: canvasOrigin	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle _ aCanvas clipRect.	offset _ (pos + canvasOrigin) truncated.	leftInRun _ 0.	(self lineIndexForPoint: visibleRectangle topLeft - pos)		to: (self lineIndexForPoint: visibleRectangle bottomRight - pos)		do: [ :i |			line _ self lines at: i.			self displaySelectionInLine: line on: aCanvas.			leftInRun _ displayScanner displayLine: line offset: offset leftInRun: leftInRun ]! !!Paragraph methodsFor: 'initialization' stamp: 'jmv 9/25/2011 15:53'!initialize	focused _ false.	showCaret _ false.	selectionStartBlocks _ #().	selectionStopBlocks _ #().	lastCaretRectNeedsRedraw _ false! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2011 15:48'!addEmptyTrailingLine	"The line to add is always the first line of a new paragraph"	| ts f h bs r lm rm w a leftMarginForAlignment s |	s _ theText size+1.	f _ editor		ifNotNil: [ editor lastFont ]		ifNil: [ theText fontAt: s ].	ts _ editor		ifNotNil: [ editor lastParagraphStyleOrNil ]		ifNil: [ theText paragraphStyleOrNilAt: s].	h _ f height.	bs _ f ascent.	lm _ 0.	rm _ 0.	w _ extentForComposing x.	a _ 0.	ts ifNotNil: [		h _h + ts spaceBefore + ts spaceAfter.		bs _ bs + ts spaceBefore.		lm _ (ts isListStyle not			ifTrue: [ts firstIndent]			ifFalse: [ts restIndent]).		rm _ ts rightIndent.		a _ ts alignment ].		leftMarginForAlignment _ a = CharacterScanner rightFlushCode		ifTrue: [ w - rm]		ifFalse: [			a = CharacterScanner centeredCode				ifTrue: [ (w - rm - lm) //2 + lm]				ifFalse: [ lm ]].	r _ leftMarginForAlignment @ currentY extent: 0@h.	lines addLast: (		EmptyLine new			firstIndex: s lastIndex: s - 1;			rectangle: r;			lineHeight: h baseline: bs;			paragraphStyle: ts)! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2011 15:47'!composeAllLines	[currCharIndex <= theText size and: [			currentY < extentForComposing y ]] whileTrue: [		nowSliding ifTrue: [			self slideOneLineDown ifNil: [^nil].		] ifFalse: [			self composeOneLine ifNil: [^nil].		]	].! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2011 15:47'!composeAllRectangles: rectangles	| charIndexBeforeLine numberOfLinesBefore reasonForStopping |	actualHeight _ 1.	charIndexBeforeLine _ currCharIndex.	numberOfLinesBefore _ lines size.	reasonForStopping _ self composeEachRectangleIn: rectangles.	currentY _ currentY + actualHeight.	currentY > extentForComposing y ifTrue: [		"Oops -- the line is really too high to fit -- back out"		currCharIndex _ charIndexBeforeLine.		lines size - numberOfLinesBefore timesRepeat: [lines removeLast].		^self	].		"It's OK -- the line still fits."	maxRightX _ maxRightX max: scanner rightX.	1 to: rectangles size - 1 do: [ :i |		"Adjust heights across rectangles if necessary"		(lines at: lines size - rectangles size + i)			lineHeight: lines last lineHeight			baseline: lines last baseline	].	anythingComposed _ true.	isFirstLine _ currCharIndex = 1 or: [		 (theText at: currCharIndex-1) = Character cr].	reasonForStopping == #columnBreak ifTrue: [^nil].	currCharIndex > theText size ifTrue: [		^nil		"we are finished composing"	]! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2011 15:48'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY text: argText extentForComposing: argExtentForComposing	lines _ argLinesCollection.	theText _ argText.	extentForComposing _ argExtentForComposing.	deltaCharIndex _ argDelta.	currCharIndex _ startCharIndex _ argStart.	stopCharIndex _ argStop.	prevLines _ argPriorLines.	currentY _ argStartY.	maxRightX _ 0.	possibleSlide _ stopCharIndex < theText size.	nowSliding _ false.	prevIndex _ 1.	scanner _ CompositionScanner new text: theText.	isFirstLine _ currCharIndex = 1 or: [		 (theText at: currCharIndex-1) = Character cr].	anythingComposed _ false.	self composeAllLines.	(anythingComposed not or: [ theText last = Character cr ])		ifTrue: [			self addEmptyTrailingLine ].	^{lines asArray. maxRightX}! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2011 15:43'!composeOneLine	| rectangles |	rectangles := self rectanglesAt: currentY.	rectangles notEmpty 		ifTrue: [(self composeAllRectangles: rectangles) ifNil: [^nil]]		ifFalse: [currentY := currentY + 1].	self checkIfReadyToSlide! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2011 15:46'!rectanglesAt: y	(y+1) > extentForComposing y ifTrue: [^ Array new].	^ Array with: (0 @ y corner: extentForComposing x @ (y+1))! !!Transcripter methodsFor: 'initialization' stamp: 'jmv 9/25/2011 15:17'!initInFrame: rect	frame _ rect insetBy: 2.  "Leave room for border"	para _ Paragraph new.	para		setModel: (TextModel withText: self contents asText)		extentForComposing: frame width-8 @9999.	para composeAll! !!Transcripter methodsFor: 'accessing' stamp: 'jmv 9/25/2011 15:26'!endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue: [		"Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para		setModel: (TextModel withText: c asText)		extentForComposing: frame width-8 @9999.	para composeAll.	d _ para extent y - frame height.	d > 0 ifTrue: [		"Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint:			0@0 + (0@(d+StrikeFont default height)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	Display getCanvas		paragraph: para 		bounds: (4@4 extent: Display extent) 		color: Color black! !!TransformMorph methodsFor: 'accessing' stamp: 'jmv 9/25/2011 14:56'!offset	^ self txOffset + bounds topLeft! !!TransformMorph methodsFor: 'accessing' stamp: 'jmv 9/25/2011 14:56'!offset: newOffset	| o |	o _ newOffset - bounds topLeft.	txOffset = o ifFalse: [		txOffset _ o.		self redrawNeeded ]! !!TransformMorph methodsFor: 'drawing' stamp: 'jmv 9/25/2011 14:56'!drawSubmorphsOn: aCanvas	| clippedCanvas |	clippedCanvas _ aCanvas		copyOffset: self txOffset negated truncated		clipRect: bounds.	submorphs reverseDo: [ :m | m fullDrawOn: clippedCanvas ]! !!classDefinition: #TextComposer category: #'Morphic-Text Support'!Object subclass: #TextComposer	instanceVariableNames: 'lines maxRightX currentY scanner possibleSlide nowSliding prevIndex prevLines currCharIndex startCharIndex stopCharIndex deltaCharIndex theText theContainer isFirstLine actualHeight anythingComposed editor extentForComposing'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!classDefinition: #Paragraph category: #'System-Text'!Object subclass: #Paragraph	instanceVariableNames: 'model container lines positionWhenComposed maxRightX selectionStartBlocks selectionStopBlocks focused editor showCaret lastCaretRect lastCaretRectNeedsRedraw extentForComposing'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!