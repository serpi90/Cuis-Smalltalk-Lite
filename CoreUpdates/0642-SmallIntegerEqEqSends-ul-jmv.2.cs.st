'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 16 November 2010 at 9:11:15 am'!!Object methodsFor: 'tracing' stamp: 'jmv 11/16/2010 09:05'!inboundPointersExcluding: objectsToExclude"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"	| object lastObject pointers objectsToAlwaysExclude |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	pointers := OrderedCollection new: 1000.	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious	 method and block contexts out of the results"	object := self someObject.	lastObject _ Object new.	[lastObject == object] whileFalse: [		object isInMemory			ifTrue: [((object instVarsInclude: self)				or: [object class == self])					ifTrue: [pointers add: object]].		object := object nextObject].	objectsToAlwaysExclude := {		pointers collector.		thisContext.		thisContext sender.		thisContext sender sender.		objectsToExclude.	}.	^ pointers removeAllSuchThat: [:ea |		(objectsToAlwaysExclude identityIncludes: ea)			or: [objectsToExclude identityIncludes: ea]]! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNilIfNotNil0Arg	self assert: (5@4 ifNil: [#foo] ifNotNil: [#bar]) = #bar.	self assert: (nil ifNil: [#foo] ifNotNil: [#bar]) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNilIfNotNil0ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [#bar].	self assert: (5@4 ifNil: block1 ifNotNil: block2) = #bar.	self assert: (nil ifNil: block1 ifNotNil: block2) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNilIfNotNil1Arg	self assert: (5@4 ifNil: [#foo] ifNotNil: [:a | a printString]) = '5@4'.	self assert: (nil ifNil: [#foo] ifNotNil: [:a | a printString]) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNilIfNotNil1ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [:a | a printString].	self assert: (5@4 ifNil: block1 ifNotNil: block2) = '5@4'.	self assert: (nil ifNil: block1 ifNotNil: block2) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNotNil0Arg	self assert: (5@4 ifNotNil: [#foo]) = #foo.	self assert: (nil ifNotNil: [#foo]) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNotNil0ArgAsVar	| block |	block := [#foo].	self assert: (5@4 ifNotNil: block) = #foo.	self assert: (nil ifNotNil: block) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNotNil1Arg	self assert: (5@4 ifNotNil: [:a | a printString]) = '5@4'.	self assert: (nil ifNotNil: [:a | a printString]) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNotNil1ArgAsVar	| block |	block := [:a | a printString].	self assert: (5@4 ifNotNil: block) = '5@4'.	self assert: (nil ifNotNil: block) = nil! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNotNilIfNil0Arg	self assert: (5@4 ifNotNil: [#foo] ifNil: [#bar]) = #foo.	self assert: (nil ifNotNil: [#foo] ifNil: [#bar]) = #bar! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNotNilIfNil0ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [#bar].	self assert: (5@4 ifNotNil: block2 ifNil: block1) = #bar.	self assert: (nil ifNotNil: block2 ifNil: block1) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:46'!testIfNotNilIfNil1Arg	self assert: (5@4 ifNotNil: [:a | a printString] ifNil: [#foo]) = '5@4'.	self assert: (nil ifNotNil: [:a | a printString] ifNil: [#foo]) = #foo! !!IfNotNilTests methodsFor: 'tests' stamp: 'jmv 11/16/2010 08:47'!testIfNotNilIfNil1ArgAsVar	| block1 block2 |	block1 := [#foo].	block2 := [:a | a printString].	self assert: (5@4 ifNotNil: block2 ifNil: block1) = '5@4'.	self assert: (nil ifNotNil: block2 ifNil: block1) = #foo! !!InstructionStream methodsFor: 'testing' stamp: 'jmv 11/15/2010 08:36'!willReallySend	"Answer whether the next bytecode is a real message-send,	not blockCopy:."	| byte |	byte := self method at: pc.	^byte >= 131	  and: [byte ~= 200	  and: [byte >= 176   "special send or short send"		or: [byte <= 134 "long sends"				and: [| litIndex |				"long form support demands we check the selector"				litIndex := byte = 132							ifTrue: [(self method at: pc + 1) // 32 > 1 ifTrue: [^false].									self method at: pc + 2]							ifFalse: [byte = 134										ifTrue: [(self method at: pc + 1) bitAnd: 2r111111]										ifFalse: [(self method at: pc + 1) bitAnd: 2r11111]].				(self method literalAt: litIndex + 1) ~~ #blockCopy:]]]]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 11/16/2010 08:44'!browseEqEqSentToSmallIntegerConstants	"	Smalltalk browseEqEqSentToSmallIntegerConstants	"	| hasMatch visitor |	hasMatch _ false.	visitor _ ParseNodeEnumerator		ofBlock: [ :node |			(node isMessageNode and: [				(#(#== #~~ ) identityIncludes: node selector key) and: [					node receiver isConstantNumber or: [ node arguments first isConstantNumber ]]]) ifTrue: [						hasMatch _ true ]]		select: [ :node |			hasMatch not ].	Smalltalk browseAllSelect: [ :method |		hasMatch _ false.		method decompile accept: visitor.		hasMatch ].! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 12/29/2009 12:03'!allObjectsDo: aBlock 	"Evaluate the argument, aBlock, for each object in the system	 excluding SmallIntegers."	| object lastObject |	object _ self someObject.	lastObject _ Object new.	[lastObject == object] whileFalse: [		aBlock value: object.		object _ object nextObject.	].! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 11/16/2010 09:08'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results object lastObject |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	object _ self someObject.	lastObject _ Object new.	[lastObject == object] whileFalse: [		object isInMemory ifTrue: [			(object pointsTo: anObject) ifTrue: [				"exclude the results collector and contexts in call chain"				((object ~~ results collector) and:				 [(object ~~ objectsToExclude) and:				 [(object ~~ thisContext) and:				 [(object ~~ thisContext sender) and:				 [object ~~ thisContext sender sender]]]])					 ifTrue: [ results add: object ].			]].		object _ object nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray! !