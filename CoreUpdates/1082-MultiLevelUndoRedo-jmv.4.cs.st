'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 21 September 2011 at 3:40:07 pm'!!classDefinition: #TextCommand category: #'System-Text'!Object subclass: #TextCommand	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!TextCommand commentStamp: '<historical>' prior: 0!My instances are user commands that can be undone and redone.!!classDefinition: #AttributesReplaceCommand category: #'System-Text'!TextCommand subclass: #AttributesReplaceCommand	instanceVariableNames: 'old new start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #TextModel category: #'System-Text'!ActiveModel subclass: #TextModel	instanceVariableNames: 'actualContents undoRedoCommands '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #TextReplaceCommand category: #'System-Text'!TextCommand subclass: #TextReplaceCommand	instanceVariableNames: 'old new position'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!TextReplaceCommand commentStamp: '<historical>' prior: 0!My instances are text replace commands, such as typing, pasting, deleting, etc.!!Browser methodsFor: 'class comment pane' stamp: 'jmv 9/21/2011 10:32'!newClassComment: aText	"The user has just entered aText.	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."	| theClass cleanedText redRange |	theClass _ self selectedClassOrMetaClass.	theClass ifNotNil: [		cleanedText _ aText asText.		redRange _ cleanedText			rangeOf: TextColor red			startingAt: 1.		redRange size = cleanedText size ifTrue: [			cleanedText				removeAttributes: { TextColor red }				from: 1				to: redRange last ].		theClass classComment: aText ].	self changed: #classCommentText.	^ true! !!Editor methodsFor: 'accessing' stamp: 'jmv 9/21/2011 10:00'!userHasEdited	"Note that my text is not free of user edits."	morph hasUnacceptedEdits: true! !!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 9/20/2011 09:20'!truncateAtPosition	"Truncate the receiver at current position.	For example, this should evaluate to true:		| s |		s _ ReadWriteStream on: Array new.		s nextPutAll: 'abcdefg'.		s reset.		s next; next.		s nextPut: $z.		s truncateAtPosition.		s atEnd	"	readLimit _ position! !!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/21/2011 10:40'!setAttributesIn: aText fromRanges: ranges in: anInterval	"modified by jmv to keep existing attributes if they answer true to #isParagraphAttribute"	| attributes defaultAttributes paragraphAttributes attr newRuns newValues lastAttr lastCount beginning chunkRuns end | 			anInterval		ifNil: [			beginning _ 1.			end _ aText size ]		ifNotNil: [			beginning _ anInterval first.			end _ anInterval last ].	defaultAttributes := self attributesFor: #default.	paragraphAttributes := Array new: end-beginning+1.	1 to: paragraphAttributes size do: [ :i |		paragraphAttributes at: i put:			((aText attributesAt: i+beginning-1) select: [ :each | each isParagraphAttribute ])].	attributes := Array new: end-beginning+1.	1 to: attributes size do: [ :i | attributes at: i put: (paragraphAttributes at: i), defaultAttributes].	ranges do: [ :range |		(attr := self attributesFor: range type)			ifNotNil: [ range start to: range end do: [:i |				attributes at: i put: (paragraphAttributes at: i), attr]]].	newRuns := OrderedCollection new: attributes size // 10.	newValues := OrderedCollection new: attributes size // 10.	1 to: attributes size do: [:i |		attr := attributes at: i.		i = 1 			ifTrue: [				newRuns add: 1.				lastCount := 1.				lastAttr := newValues add: attr]			ifFalse:[				attr == lastAttr					ifTrue: [						lastCount := lastCount + 1.						newRuns at: newRuns size put: lastCount]					ifFalse: [						newRuns add: 1.						lastCount := 1.						lastAttr := newValues add: attr]]].	chunkRuns _ (RunArray runs: newRuns values: newValues) coalesce.	aText		basicReplaceAttributesFrom: beginning		to: end		with: chunkRuns! !!Text methodsFor: 'accessing' stamp: 'jmv 9/20/2011 18:52'!commandForReplaceFrom: start to: stop with: replacement	^TextReplaceCommand		old: (self copyFrom: start to: stop)		new: replacement		at: start! !!Text methodsFor: 'converting' stamp: 'jmv 9/21/2011 11:20'!replaceReferencesToStyle: oldParagraphOrCharacterStyle with: newParagraphOrCharacterStyle	"Both arguments must be of the same kind (either para or char style)"	runs runsAndValuesDo: [ :count :attributes |		attributes do: [ :att |			(att isStyle and: [ att style == oldParagraphOrCharacterStyle ])				ifTrue: [ att style: newParagraphOrCharacterStyle ]]]! !!Text methodsFor: 'emphasis' stamp: 'jmv 9/21/2011 10:24'!addAttribute: aTextAttribute from: requestedStart to: requestedStop	"Set the attribute for characters in the interval start to stop.	Turned into a command to enable reuse by undo / redo"	(self		commandForAddAttribute: aTextAttribute		from: requestedStart		to: requestedStop) doOn: self! !!Text methodsFor: 'emphasis' stamp: 'jmv 9/21/2011 09:34'!commandForAddAttribute: aTextAttribute from: requestedStart to: requestedStop	"Set the attribute for characters in the interval start to stop."	| intervalToFix start stop new old |	start _ requestedStart.	stop _ requestedStop.		"If aTextAttribute must be applied to whole paragraphs, do so."	aTextAttribute isParagraphAttribute ifTrue: [		intervalToFix _ self encompassParagraph: (start to: stop).		start _ intervalToFix first.		stop _ intervalToFix last ].	old _ runs copyFrom: start to: stop.	new _ old copy mapValues: [ :attributes | 			Text addAttribute: aTextAttribute toArray: attributes ].	^AttributesReplaceCommand		old: old		new: new		start: start		stop: stop! !!Text methodsFor: 'emphasis' stamp: 'jmv 9/21/2011 10:28'!commandForRemoveAttributes: attributesToRemove from: requestedStart to: requestedStop	"Remove the attribute over the interval start to stop."	| intervalToFix start stop new old |	start _ requestedStart.	stop _ requestedStop.		"If att must be applied to whole paragraphs, do so."	(attributesToRemove anySatisfy: [ :att | att isParagraphAttribute ]) ifTrue: [		intervalToFix _ self encompassParagraph: (start to: stop).		start _ intervalToFix first.		stop _ intervalToFix last ].	old _ runs copyFrom: start to: stop.	new _ old copy mapValues: [ :attributes | 			attributes copyWithoutAll: attributesToRemove].	^AttributesReplaceCommand		old: old		new: new		start: start		stop: stop! !!Text methodsFor: 'emphasis' stamp: 'jmv 9/21/2011 10:30'!removeAttributes: attributesToRemove from: requestedStart to: requestedStop	"Remove the attribute over the interval start to stop.	Turned into a command to enable reuse by undo / redo"		(self		commandForRemoveAttributes: attributesToRemove		from: requestedStart		to: requestedStop) doOn: self! !!Text methodsFor: 'private' stamp: 'jmv 9/21/2011 10:40'!basicReplaceAttributesFrom: start to: stop with: replacement	"Private. Does not enforce invariants.	replacement size = (stop-start-1) "		self privateSetRuns: (runs		copyReplaceFrom: start		to: stop		with: replacement).	runs coalesce! !!TextCommand methodsFor: 'actions' stamp: 'jmv 9/20/2011 10:34'!doOn: aTextModel	"Perform the command, used for initial execution or for redo after undoing"	^nil! !!TextCommand methodsFor: 'actions' stamp: 'jmv 9/20/2011 10:34'!undoOn: aTextModel	"Undo the command, bringing the text model to the state it had prior to doing it"	^nil! !!AttributesReplaceCommand methodsFor: 'initialize-release' stamp: 'jmv 9/20/2011 18:32'!old: oldAttributes new: newAttributes start: startIndex stop: stopIndex	old _ oldAttributes.	new _ newAttributes.	start _ startIndex.	stop _ stopIndex! !!AttributesReplaceCommand methodsFor: 'actions' stamp: 'jmv 9/21/2011 10:40'!doOn: aTextModel	"Perform the command, used for initial execution or for redo after undoing"	aTextModel basicReplaceAttributesFrom: start to: stop with: new.	^nil! !!AttributesReplaceCommand methodsFor: 'actions' stamp: 'jmv 9/21/2011 10:40'!undoOn: aTextModel	"Perform the command, used for initial execution or for redo after undoing"	aTextModel basicReplaceAttributesFrom: start to: stop with: old.	^nil! !!AttributesReplaceCommand class methodsFor: 'instance creation' stamp: 'jmv 9/20/2011 18:32'!old: oldAttributes new: newAttributes start: startIndex stop: stopIndex	^self basicNew old: oldAttributes new: newAttributes start: startIndex stop: stopIndex! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/20/2011 09:35'!applyAttribute: aTextAttribute	"The user selected aTextAttribute via shortcut, menu or other means.	If there is a selection, apply the attribute to the selection.	In any case use the attribute for the user input (emphasisHere)"	"This generates undo"	| interval |	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.	interval _ self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].	model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	self userHasEdited.	morph possiblyChanged! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/20/2011 09:35'!unapplyAttribute: aTextAttribute	"The user selected aTextAttribute to be removed.	If there is a selection, unapply the attribute to the selection.	In any case do not use the attribute for the user input (emphasisHere)"	"This generates undo"	| interval |	emphasisHere _ emphasisHere copyWithout: aTextAttribute.	interval _ self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].	model logUndoAndRemoveAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	morph possiblyChanged! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/20/2011 09:37'!zapMultiSelection	"This generates undo"	| delta intervals mi pi start stop miAndPiUpdated |	miAndPiUpdated _ false.	mi _ self markIndex.	pi _ self pointIndex.	delta _ 0.	intervals _ (selectionStartBlocks with: selectionStopBlocks		collect: [ :strt :stp | strt stringIndex to: stp stringIndex ])			sorted: [ :a :b | a first < b first ].	intervals do: [ :interval |		miAndPiUpdated not ifTrue: [			interval first > mi				ifTrue: [					miAndPiUpdated _ true.					mi _ mi + delta.					pi _ pi + delta ]				ifFalse: [					interval last > mi ifTrue: [						miAndPiUpdated _ true.						mi _ interval first + delta.						pi _ mi ]]].		start _  interval first+delta.		stop _ interval last - 1 + delta.		model logUndoAndReplaceFrom: start to: stop with: ''.		delta _ delta - (interval size-1).		paragraph			recomposeFrom: start			to:  start - 1			delta: delta ].	miAndPiUpdated not ifTrue: [		mi _ mi + delta.		pi _ pi + delta ].	selectionStartBlocks _ #().	selectionStopBlocks _ #().	self markIndex: mi pointIndex: pi! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/20/2011 09:37'!zapSelectionWith: aTextOrString	"This generates undo"	| start stop replacement |	start _ self startIndex.	stop _ self stopIndex.	(aTextOrString isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (model actualContents attributesAt: start) select: [:att |			att mayBeExtended]].	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [		replacement _ self addAttributesForPasting: aTextOrString.		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.		paragraph			recomposeFrom: start			to:  start + replacement size - 1			delta: replacement size - (stop-start).		self markIndex: start pointIndex: start + replacement size.		selectionStartBlocks _ #().		selectionStopBlocks _ #().		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged! !!TextEditor methodsFor: 'commands' stamp: 'jmv 9/21/2011 10:42'!insertMorph: aMorph at: relPt	"This is a user command, and generates undo"	| index newText |	"Warning: As undo will only be done for text in the model, undoing this will neither	kill the morph nor send it to another owner!! See implementors of #removeMorph: in TextMorphs.	A specific undo for inserting / removing morphs might be in order. But I doubt the	TextModel should be responsible for that."	self flag: #jmv.	index _ (paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ ' ', (Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aMorph)), ' '.	model logUndoAndReplaceFrom: index to: index-1 with: newText.	paragraph recomposeFrom: index to: index + newText size -1 delta: newText size.! !!TextEditor methodsFor: 'commands' stamp: 'jmv 9/21/2011 10:42'!removeMorph: aMorph	"This is a user command, and generates undo"	| range |	"Warning: As undo will only be done for text in the model, undoing this will neither	recreate the morph nor add it to the TextMorph!! (See senders of #insertMorph:at:	A specific undo for inserting / removing morphs might be in order. But I doubt the	TextModel should be responsible for that."	self flag: #jmv.	range _ model actualContents find: (TextAnchor new anchoredFormOrMorph: aMorph).	range ifNotNil: [		model logUndoAndReplaceFrom: range first to: range last with: Text new.		paragraph recomposeFrom: range first to: range first  -1 delta: range size negated ]! !!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 9/21/2011 10:12'!redo	model redoAndEvaluate: [ :modelUpdated :newCursorPos |		newCursorPos			ifNil: [ self recomputeSelection ]			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].		modelUpdated ifTrue: [			self userHasEdited.			paragraph composeAll.			"this could be made more specific..."			morph possiblyChanged ]]! !!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 9/20/2011 10:29'!redo: aKeyboardEvent 	"Redo the last edit."	self redo.	^true! !!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 9/21/2011 10:12'!undo	model undoAndEvaluate: [ :modelUpdated :newCursorPos |		newCursorPos			ifNil: [ self recomputeSelection ]			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].		modelUpdated ifTrue: [			self userHasEdited.			paragraph composeAll.				"this could be made more specific..."			morph possiblyChanged ]]! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 9/20/2011 13:47'!evaluateSelectionAndDo: aBlock ifFail: failBlock	"Treat the current selection as an expression; evaluate it and return the result"	| provider result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	provider _ self codeProvider.	(provider respondsTo: #doItReceiver) 		ifTrue: [				rcvr _ provider doItReceiver.				ctxt _ provider doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new			sourceStreamGetter: #selectionAsStream;		"Cuis specific. Do not remove!!"			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [^ failBlock value]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	self userHasEdited.		"Needed to re-shout workspaces, that might have new variables binded."	^ aBlock value: result! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/20/2011 10:19'!initializeBasicCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor test"	"Editor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		"arranged in QWERTY keyboard order"	cmds _ #(		$w #backWord:		$a #selectAll:		$f #find:		$g #findAgain:		$h #setSearchString:		$z #undo:		$x #cut:		$c #copySelection:		$v #paste:		$R	#indent:		$Y	#makeUppercase:		$U	#changeLfToCr:		$S	#search:		$H	#cursorTopHome:		$J	#doAgainMany:		$L	#outdent:"		$Z	#makeCapitalized:"		$Z	#redo:		$X	#makeLowercase:		$C	#compareToClipboard:	).	1 to: cmds size		by: 2		do: [ :i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions _ cmdMap! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/20/2011 17:57'!initializeMenu	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."	"TextEditor initialize"	menu _ SelectionMenu fromArray: {		{'Find...(f)'.					#find}.		{'Find Again (g)'.			#findAgain}.		{'Set Search String (h)'.		#setSearchString}.		#-.		{'Do Again (j)'.				#again}.		{'Undo - multiple (z)'.		#undo}.		{'Redo - multiple (Z)'.		#redo}.		#-.		{'Copy (c)'.					#copySelection}.		{'Cut (x)'.					#cut}.		{'Paste (v)'.					#paste}.		{'Paste...'.					#pasteRecent}.		#-.		{'Set Font... (k)'.				#offerFontMenu}.		{'Set Alignment...'.			#chooseAlignment}.	}! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/20/2011 17:57'!initializeMenu	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."	"SmalltalkEditor initialize"	menu _ SelectionMenu fromArray: {		{'Find...(f)'.					#find}.		{'Find Again (g)'.			#findAgain}.		{'Set Search String (h)'.		#setSearchString}.		#-.		{'Do Again (j)'.				#again}.		{'Undo - multiple (z)'.		#undo}.		{'Redo - multiple (Z)'.		#redo}.		#-.		{'Copy (c)'.					#copySelection}.		{'Cut (x)'.					#cut}.		{'Paste (v)'.					#paste}.		{'Paste...'.					#pasteRecent}.		#-.		{'Do it (d)'.					#doIt}.		{'Print it (p)'.				#printIt}.		{'Inspect it (i)'.				#inspectIt}.		{'Explore it (I)'.				#exploreIt}.		{'Debug it'.					#debugIt}.		#-.		{'Explain'.					#explain}.		{'Browse it (b)'.				#browseIt}.		{'Senders of it (n)'.			#sendersOfIt}.		{'Implementors of it (m)'.	#implementorsOfIt}.		{'References to it (N)'.		#referencesToIt}.		#-.		{'Accept (s)'.				#accept}.		{'Cancel (l)'.				#cancel}.		#-.		{'Method Strings with it (E)'.	#methodStringsContainingit}.		{'Method Source with it'.		#methodSourceContainingIt}.		{'Class Comments with it'.		#classCommentsContainingIt}.	}! !!TextModel methodsFor: 'initialize-release' stamp: 'jmv 9/20/2011 09:50'!initialize	"Initialize the state of the receiver with its default contents."	actualContents _ '' asText.	undoRedoCommands _ ReadWriteStream on: Array new! !!TextModel methodsFor: 'accessing' stamp: 'jmv 9/20/2011 18:54'!actualContents: aTextOrString	actualContents _ aTextOrString ifNotNil: [ aTextOrString asText ].	undoRedoCommands resetToStart.	self changed: #actualContents! !!TextModel methodsFor: 'accessing' stamp: 'jmv 9/20/2011 18:54'!basicActualContents: aTextOrString	"Do not throw events... Not nice... Use with care... Clean some day..."	actualContents _ aTextOrString ifNotNil: [ aTextOrString asText ].	undoRedoCommands resetToStart.! !!TextModel methodsFor: 'shout support' stamp: 'jmv 9/21/2011 10:32'!privateRemoveBoldAt: idx	"Just for shout. No undo."	actualContents 		removeAttributes: { TextEmphasis bold }		from: idx		to: idx! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/21/2011 10:41'!basicReplaceAttributesFrom: start to: stop with: replacement	"As requested. Basic service used by Undo / Redo. Does not genertate undo."	actualContents basicReplaceAttributesFrom: start to: stop with: replacement! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/20/2011 09:56'!basicReplaceFrom: start to: stop with: replacement	"As requested. Basic service used by Undo / Redo. Does not genertate undo."	actualContents replaceFrom: start to: stop with: replacement! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/21/2011 11:36'!logUndoAndAddAttribute: aTextAttribute from: requestedStart to: requestedStop	"As requested."	| command |	command _ actualContents commandForAddAttribute: aTextAttribute from: requestedStart to: requestedStop.	undoRedoCommands		nextPut: command;		truncateAtPosition.	command doOn: self! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/21/2011 11:37'!logUndoAndRemoveAttribute: aTextAttribute from: requestedStart to: requestedStop	"As requested."	| command |	command _ actualContents commandForRemoveAttributes: { aTextAttribute } from: requestedStart to: requestedStop.	undoRedoCommands		nextPut: command;		truncateAtPosition.	command doOn: self! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/21/2011 11:37'!logUndoAndReplaceFrom: start to: stop with: replacement	"As requested."	| command |	command _ actualContents commandForReplaceFrom: start to: stop with: replacement.	undoRedoCommands		nextPut: command;		truncateAtPosition.	command doOn: self! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/21/2011 09:57'!redoAndEvaluate: aTwoArgBlock	| modelUpdated newCursorPos |	modelUpdated _ false.	undoRedoCommands atEnd ifFalse: [		newCursorPos _ undoRedoCommands next doOn: self.		modelUpdated _ true ].	aTwoArgBlock value: modelUpdated value: newCursorPos! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/21/2011 09:57'!undoAndEvaluate: aTwoArgBlock	| modelUpdated newCursorPos |	modelUpdated _ false.	undoRedoCommands position > 0 ifTrue: [		undoRedoCommands skip: -1.		newCursorPos _ undoRedoCommands peek undoOn: self.		modelUpdated _ true ].	aTwoArgBlock value: modelUpdated value: newCursorPos! !!PluggableTextModel methodsFor: 'initialize-release' stamp: 'jmv 9/20/2011 09:51'!initWith: aTextProvider	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."	textProvider _ aTextProvider.	undoRedoCommands _ ReadWriteStream on: Array new! !!PluggableTextModel class methodsFor: 'instance creation' stamp: 'jmv 9/20/2011 09:50'!on: aTextProvider	"aTextProvider can be a kind of TextProvider, or perhaps a more exotic object, like an ObjectExplorer or a TranscriptStream."	^self basicNew initWith: aTextProvider! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 9/20/2011 17:55'!redo	self handleEdit: [ self editor redo ]! !!TextModelMorph methodsFor: '*Styled Text' stamp: 'jmv 9/21/2011 11:32'!removeCharacterStyles	self handleEdit: [ textMorph editor removeCharacterStyles ]! !!TextReplaceCommand methodsFor: 'initialize-release' stamp: 'jmv 9/20/2011 09:26'!old: oldStringOrText new: newStringOrText at: anInteger	old _ oldStringOrText.	new _ newStringOrText.	position _ anInteger! !!TextReplaceCommand methodsFor: 'actions' stamp: 'jmv 9/21/2011 10:38'!doOn: aTextModel	"Perform the command, used for initial execution or for redo after undoing.	Answer a new position for the text cursor"	aTextModel basicReplaceFrom: position to: position + old size-1 with: new.	^position + new size! !!TextReplaceCommand methodsFor: 'actions' stamp: 'jmv 9/21/2011 10:38'!undoOn: aTextModel	"Undo the command, bringing the text model to the state it had prior to doing it.	Answer a new position for the text cursor"	aTextModel basicReplaceFrom: position to: position + new size-1 with: old.	^position + old size! !!TextReplaceCommand class methodsFor: 'instance creation' stamp: 'jmv 9/20/2011 09:26'!old: oldStringOrText new: newStringOrText at: anInteger	^self basicNew old: oldStringOrText new: newStringOrText at: anInteger! !PluggableTextModel removeSelector: #textProvider:!TextModel removeSelector: #addAttribute:from:to:!TextModel removeSelector: #removeAttribute:from:to:!TextModel removeSelector: #replaceFrom:to:with:!!classDefinition: #TextModel category: #'System-Text'!ActiveModel subclass: #TextModel	instanceVariableNames: 'actualContents undoRedoCommands'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!Text removeSelector: #removeAttribute:!Text removeSelector: #removeAttribute:from:to:!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Editor initialize!