'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 18 March 2011 at 12:31:34 am'!!Color class methodsFor: 'examples' stamp: 'jmv 3/18/2011 00:23'!experimentsTowarsANewColorPalette"self experimentsTowarsANewColorPalette"| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |width _ 300.height _ 120.selectedColor _ Color fromUser.selectedHue _ selectedColor hue.selectedSaturation _ selectedColor saturation.selectedChroma _ selectedColor chroma.selectedV _ selectedColor brightness.selectedLuminance _ selectedColor luminance.Display getCanvas fillRectangle: (0@0 extent: height@height) colorOrInfiniteForm: selectedColor.0 to: height do: [ :y |	v _ 1.0 - (y / height).	0 to: height do: [ :x |		s _ x / height.		color _ Color basicNew setHue: selectedHue saturation: s brightness: v.		Display colorAt: x@(y+height) put: color	].	Display forceToScreen].0 to: height do: [ :y | | c |	v _ 1.0 - (y / height).	s _ 1.0 - (y / height).	c _ s.	0 to: width do: [ :x |		h _ x / width * 360.				color _ Color basicNew setHue: h chroma: c luminance: selectedLuminance."		color _ Color basicNew setHue: h chroma: c brightness: selectedV."		color ifNil: [ color _ Color black ]."		color _ Color basicNew setHue: h saturation: s brightness: selectedV."		Display colorAt: x+height@y put: color.				color _ Color basicNew setHue: h chroma: selectedChroma luminance: v."		color _ Color basicNew setHue: h chroma: selectedChroma brightness: v."		color ifNil: [ color _ Color black ]."		color _ Color basicNew setHue: h saturation: selectedSaturation brightness: v."		Display colorAt: x+height@(y+height) put: color.			].	Display forceToScreen].! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'jmv 3/18/2011 00:20'!fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	"draw the border of the oval"	rect _ (r translateBy: origin) truncated.	(borderWidth = 0 or: [borderColor isTransparent]) ifFalse:[		self setFillColor: borderColor.		port frameOval: rect borderWidth: borderWidth].	"fill the inside"	fillColor isTransparent ifFalse: [		self setFillColor: fillColor.		port fillOval: (rect insetBy: borderWidth)].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/18/2011 00:23'!fillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm	"Fill the given rectangle."	| f colorOrInfiniteForm |	colorOrInfiniteForm _ aColorOrInfiniteForm.	self isShadowDrawing		ifTrue: [			colorOrInfiniteForm _ shadowColor ]		ifFalse: [			(aColorOrInfiniteForm isKindOf: InfiniteForm) ifTrue: [				f _ aColorOrInfiniteForm form.				^self fillRectangle: aRectangle tilingWith: f sourceRect: f boundingBox rule: Form paint ]].	^self 		frameAndFillRectangle: aRectangle		fillColor: colorOrInfiniteForm		borderWidth: 0		borderColor: Color transparent! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/18/2011 00:25'!fillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol	"	Display getCanvas		fillRectangle: (10@10 extent: 300@200)		fillStyle: (InfiniteForm verticalGradient: 24 topColor: Color black bottomColor:Color red)		borderWidth: 5		borderStyleSymbol: #raised	"	"Nicer. does frame with translucent black or white. Downside: requires proper color.	Some buttons are actually transparent (should be fixed!!), and there is a trick to grab some	opaque owner's color. And this is needed because (for instance) SystemWindow does NOT paint the inside with its color, but that color is needed to paint separators and button area. Something better is needed!!!!!!!!!!"	"	self fillRectangle: r color: .aColorOrInfiniteForm	self frameRectangle: r borderWidth: bw borderStyleSymbol: aSymbol	"	self fillRectangle: (aRectangle insetBy: bw) colorOrInfiniteForm: aColorOrInfiniteForm.	self frameRectangle: aRectangle color: aColorOrInfiniteForm asColor borderWidth: bw borderStyleSymbol: aSymbol! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/18/2011 00:25'!fillRectangle: aRectangle colorOrInfiniteForm: aColorOrInfiniteForm borderWidth: bw borderStyleSymbol: aSymbol baseColorForBorder: baseColorForBorder	"Pretty ugly.#fillRectangle:color::borderWidth:borderStyleSymbol:  is much better but has trouble with silly transparent morphs	"		self fillRectangle: (aRectangle insetBy: bw) colorOrInfiniteForm: aColorOrInfiniteForm.	self frameRectangle: aRectangle color: baseColorForBorder borderWidth: bw borderStyleSymbol: aSymbol! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/18/2011 00:20'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	rect _ r translateBy: origin.	"draw the border of the rectangle"	borderColor isTransparent ifFalse:[		self setFillColor: borderColor.		port frameRect: rect borderWidth: borderWidth ].	"fill the inside"	fillColor isTransparent ifFalse: [		self setFillColor: fillColor.		port fillRect: (rect insetBy: borderWidth) offset: origin ]! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/18/2011 00:16'!frameRectangle: r borderWidth: borderWidth color: borderColor	"	Display getCanvas		frameRectangle: (10@10 extent: 300@200)		width: 20		color: Color red	"	| rect |	rect _ r translateBy: origin.	self setFillColor: borderColor.	port		frameRect: rect		borderWidth: borderWidth.! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/18/2011 00:16'!frameRectangle: r color: aColor borderWidth: bw borderStyleSymbol: aSymbol	"	Display getCanvas		frameRectangle: (10@10 extent: 300@200)		color: Color green		borderWidth: 2		borderStyleSymbol: #raised	Display getCanvas fillRectangle: (10@10 extent: 300@200) color: Color white	"	aSymbol == #raised ifTrue: [		^ self			frameRectangle: r			borderWidth: bw			topLeftColor: aColor quiteWhiter			bottomRightColor: aColor quiteBlacker ].	aSymbol == #inset ifTrue: [		^ self			frameRectangle: r			borderWidth: bw			topLeftColor: aColor quiteBlacker			bottomRightColor: aColor quiteWhiter ].		"Unrecognized border style. Draw some border..."	self frameRectangle: r borderWidth: bw color: aColor! !!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 3/18/2011 00:25'!roundRect: aRectangle color: aColor radius: r	"	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10	"	"top stripe"	self		image: (FormCanvas topLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: aColor		at: aRectangle topLeft.	self		image: (FormCanvas topRightCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: aColor		at: aRectangle topRight - (r@0).	self fillRectangle: ((aRectangle withHeight: r) insetBy: r@0) colorOrInfiniteForm: aColor.	"center stripe"	self fillRectangle: (aRectangle insetBy: (0 @ r corner: 0 @ r)) colorOrInfiniteForm: aColor.		"bottom stripe"	self		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: aColor		at: aRectangle bottomLeft - (0@r).	self		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: aColor		at: aRectangle bottomRight - (r@r) .	self fillRectangle: ((aRectangle bottomLeft + (r@r negated)) extent: (aRectangle width - r - r@r)) colorOrInfiniteForm: aColor! !!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 3/18/2011 00:25'!roundRect: aRectangle color: aColor radius: r gradientTop: topFactor gradientBottom: bottomFactor gradientHeight: h	"	Display getCanvas roundRect: (10@10 extent: 200@100) color: Color red radius: 10 gradientTop: 1.0 gradientBottom: 0.5 gradientHeight: 35	"	"top stripe"	| bottomColor |	self		image: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor		at: aRectangle topLeft.	self		image: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor		at: aRectangle topRight - (r@0).	self		fillRectangle: ((aRectangle withHeight: h) insetBy: r@0)		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor.	bottomColor _ aColor * bottomFactor.	"center stripe"	self fillRectangle: (aRectangle insetBy: (0 @ h corner: 0 @ r)) colorOrInfiniteForm: bottomColor.		"bottom stripe"	self		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: bottomColor		at: aRectangle bottomLeft - (0@r).	self		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: bottomColor		at: aRectangle bottomRight - (r@r) .	self fillRectangle: ((aRectangle bottomLeft + (r@r negated)) extent: (aRectangle width - r - r@r)) colorOrInfiniteForm: bottomColor! !!FormCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 3/18/2011 00:26'!windowFrame: aRectangle color: aColor radius: r border: borderWidth labelHeight: h gradientTop: topFactor gradientBottom: bottomFactor insideColor: insideColor	"	Display getCanvas windowFrame: (10@10 extent: 200@100) color: Color red radius: 10  border: 5 labelHeight: 25 gradientTop: 1.0 gradientBottom: 0.5	"	"top stripe"	| bottomColor he tl tr |	self		image: (FormCanvas topLeftCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor		at: aRectangle topLeft.	self		image: (FormCanvas topRightCorner: r height: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor		at: aRectangle topRight - (r@0).	self		fillRectangle: ((aRectangle withHeight: h) insetBy: r@0)		infiniteForm: (FormCanvas verticalGrayGradient: h gradientTop: topFactor gradientBottom: bottomFactor)		multipliedBy: aColor.	bottomColor _ aColor * bottomFactor.	"left and right borders"	tl _ aRectangle topLeft + (0@h).	tr _ aRectangle topRight + (borderWidth negated@h).	he _ borderWidth@(aRectangle height - h - r).	self fillRectangle: (tl extent: he) colorOrInfiniteForm: bottomColor.	self fillRectangle: (tr extent: he) colorOrInfiniteForm: bottomColor.		"bottom stripe"	self		image: (FormCanvas bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: bottomColor		at: aRectangle bottomLeft - (0@r).	self		image: (FormCanvas bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1)		multipliedBy: bottomColor		at: aRectangle bottomRight - (r@r) .	self fillRectangle: ((aRectangle bottomLeft + (r@borderWidth negated)) extent: (aRectangle width - r - r@borderWidth)) colorOrInfiniteForm: bottomColor.	"inside"	self fillRectangle: (aRectangle insetBy: (borderWidth@h corner: borderWidth@borderWidth)) colorOrInfiniteForm: insideColor! !!FormCanvas methodsFor: 'private' stamp: 'jmv 3/18/2011 00:13'!fillRectangle: aRectangle tilingWith: aForm sourceRect: patternBox rule: aCombinationRule	"We assume that aForm is part of an InfiniteForm"	| additionalOffset rInPortTerms clippedPort targetTopLeft clipOffset ex 	targetBox savedMap top left |	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.	something better is needed, but not now"	ex _ patternBox extent.	additionalOffset _ 0@0.	rInPortTerms _ aRectangle translateBy: origin.	clippedPort _ port clippedBy: rInPortTerms.	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.	clipOffset _ rInPortTerms topLeft - targetTopLeft.	additionalOffset _ (clipOffset \\ ex) - ex.	"do it iteratively"	targetBox _ clippedPort clipRect.	savedMap _ clippedPort colorMap.	clippedPort sourceForm: aForm;		fillColor: nil;		combinationRule: aCombinationRule;		sourceRect: patternBox;		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.	left to: (targetBox right - 1) by: patternBox width do: [:x |		top to: (targetBox bottom - 1) by: patternBox height do: [:y |			clippedPort destOrigin: x@y; copyBits]].	clippedPort colorMap: savedMap! !!FormCanvas methodsFor: 'private' stamp: 'jmv 3/18/2011 00:18'!frameRectangle: r borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"	Display getCanvas		frameRectangle: (10@10 extent: 300@200)		borderWidth: 20		topLeftColor: Color green		bottomRightColor: Color red	Display getCanvas fillRectangle: (10@10 extent: 300@200) color: Color white	"	| rect w h |	self setFillColor: topLeftColor.	rect _ r translateBy: origin.	port frameRectTopLeft: rect borderWidth: borderWidth.	borderWidth isNumber		ifTrue: [w _ h _ borderWidth]		ifFalse: [w _ borderWidth x.   h _ borderWidth y].	self setFillColor: bottomRightColor.	port 		 frameRectRight: rect width: w;		 frameRectBottom: rect height: h! !!InfiniteForm methodsFor: 'testing' stamp: 'jmv 3/17/2011 23:43'!isTransparent	^false! !!LightWidget methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:25'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: Color red! !!ButtonLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:29'!drawOn: aCanvas	| w h c |	c _ self backColor.	aCanvas		fillRectangle: bounds		colorOrInfiniteForm: c		borderWidth: 3		borderStyleSymbol: (pressed ifTrue: [ #inset ] ifFalse: [ #raised ])		baseColorForBorder: c.	w _ (font widthOfString: label) // 2.	h _ font ascent // 2.	pressed ifTrue: [		w _ w - 1.		h _ h - 1].	aCanvas drawString: label at: bounds center - (w@h) font: font color: self foreColor! !!CheckBoxLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:23'!drawOn: aCanvas	| h c r pt1 pt2 pt3 |	c _ self backColor.	aCanvas fillRectangle: bounds colorOrInfiniteForm: c.	h _ font ascent // 2.	aCanvas		drawString: label 		at: bounds leftCenter + (5 @ h negated) 		font: font 		color: self foreColor.	h _ font ascent.	r _ bounds rightCenter - (h+5@(h//2 - 1)) extent: h@h.	aCanvas 		frameAndFillRectangle: r		fillColor: self foreColor		borderWidth: 2		borderColor: Color black.	selected ifTrue: [		pt2 _ r center + (-1@3).		pt1 _ pt2 - (4@4).		pt3 _ pt2 + (8@-8).		c _ Color green.		aCanvas			line: pt1 to: pt2 width: 3 color: c;			line: pt2 to: pt3 width: 4 color: c]		! !!EntryField2LW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:24'!drawCaretOn: aCanvas	|  w caretColor leftX top bottom |	top _ bounds top + 4.	bottom _ top + font height + 1.	leftX _ (font widthOfString: contents from: 1 to: editor startIndex-1) + bounds left + 4.	w := 3.	caretColor := Theme current insertionPoint.		1 to: w do: [:i |		"Draw caret triangles at top and bottom"		aCanvas			fillRectangle: ((leftX - w + i - 1) @ (top + i - 1) 				extent: ((w - i) * 2 + 4) @ 1)			colorOrInfiniteForm: caretColor.		aCanvas			fillRectangle: ((leftX - w + i - 1) @ (bottom - i) 				extent: ((w - i) * 2 + 4) @ 1)			colorOrInfiniteForm: caretColor].	aCanvas		fillRectangle: (leftX @ top corner: leftX+2 @ bottom)		colorOrInfiniteForm: caretColor! !!EntryField2LW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:24'!drawSelectionOn: aCanvas	| rightX leftX top bottom |	top _ bounds top + 5.	bottom _ top + font height.	leftX _ (font widthOfString: contents from: 1 to: editor startIndex-1) + bounds left + 5.	rightX _ (font widthOfString: contents from: 1 to: editor stopIndex-1) + bounds left + 5.	aCanvas		fillRectangle: (leftX @ top corner: rightX @ bottom)		colorOrInfiniteForm: self selectionColor! !!CellStyleEntryFieldLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:23'!drawCaretOn: aCanvas	| top bottom leftX rightX |	editor isInCellShiftMode not ifTrue: [		^super drawCaretOn: aCanvas ].		top _ bounds top + 4.	bottom _ top + font height + 1.	leftX _ (font widthOfString: contents from: 1 to: editor startIndex-2) + bounds left + 4.	rightX _ (font widthOfString: contents from: 1 to: editor stopIndex-1) + bounds left + 6.	aCanvas		fillRectangle: (leftX @ top corner: rightX @ bottom)		colorOrInfiniteForm: Theme current insertionPoint! !!HoleLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:25'!drawOn: aCanvas 	aCanvas drawsOnDisplay		ifTrue: [			(BitBlt current toForm: Display)				clipRect: aCanvas clipRect;				copy: bounds				from: 0@0 in: nil				fillColor: Color transparent rule: Form over]		ifFalse: [aCanvas fillRectangle: bounds colorOrInfiniteForm: Color blue]! !!ListItemLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:26'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: self backColor.	aCanvas drawString: label at: bounds topLeft + (5@2) font: font color: self foreColor! !!ListLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:26'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: backColor.	self drawScrollbarOn: aCanvas! !!ListLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:26'!drawScrollbarOn: aCanvas	| thumb |	thumb _ self scrollInterval.	(thumb first = bounds top and: [thumb last = bounds bottom ]) ifFalse: [		aCanvas			fillRectangle: (bounds right - 18 @ bounds top corner: bounds right @ bounds bottom)			colorOrInfiniteForm: scrollBarColor.		aCanvas			fillRectangle: (bounds right - 18 @ thumb first corner: bounds right @ thumb last)			colorOrInfiniteForm: scrollThumbColor ]! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:17'!drawDropHighlightOn: aCanvas	self highlightedForDrop ifTrue: [		aCanvas frameRectangle: self fullBounds borderWidth: 1 color: self dropHighlightColor ]! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:17'!drawMouseDownHighlightOn: aCanvas	self highlightedForMouseDown ifTrue: [		aCanvas frameRectangle: self fullBounds borderWidth: 1 color: self color darker darker ]! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:26'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: self color! !!Morph methodsFor: 'menus' stamp: 'jmv 3/17/2011 23:40'!addColorMenuItems: aMenu hand: aHand 	"Add the items for changing the current color of the Morph"	aMenu add: 'change color...' action: #changeColor! !!Morph methodsFor: 'menus' stamp: 'jmv 3/17/2011 23:41'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	aMenu add: 'send to back' action: #goBehind.	aMenu add: 'bring to front' action: #comeToFront.	self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	self addColorMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addDebuggingItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu			add: ('unlock "{1}"' format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!BareTextMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:16'!debugDrawLineRectsOn: aCanvas	"Shows where text line rectangles are"	self paragraph lines do: [ :line |		aCanvas frameRectangle: line rectangle borderWidth: 1 color: Color brown ]! !!BorderedMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:29'!drawOn: aCanvas	borderColor class == Symbol		ifTrue: [			"This would be better."			"aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: borderColor."			"But, for instance, pluggable lists and text in browsers are shown with an inset border, their color is white, and the baseColorForBorder must match the window..."			aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor			]		ifFalse: [			aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ]! !!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:24'!drawOn: aCanvas	| roundCorners |	roundCorners _ Theme current roundWindowCorners.	roundCorners		ifTrue: [			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]		ifFalse: [			super drawOn: aCanvas ].	aCanvas fillRectangle: textPane bounds colorOrInfiniteForm: (Color gray: 0.88)! !!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:28'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: 2 borderStyleSymbol: #raised! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:25'!drawBackgroundForMulti: row on: aCanvas	| selectionDrawBounds c |	"shade the background darker, if this row is selected"	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: bounds.	c _ (selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Theme current listHighlightFocused: listSource hasKeyboardFocus ]		ifFalse: [ Theme current listMultiHighlightFocused: listSource hasKeyboardFocus ].	aCanvas fillRectangle: selectionDrawBounds colorOrInfiniteForm: c! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:25'!drawSelectionOn: aCanvas	| selectionDrawBounds |	selectedRow ifNil: [ ^self ].	selectedRow = 0 ifTrue: [ ^self ].	selectionDrawBounds := self drawBoundsForRow: selectedRow.	selectionDrawBounds := selectionDrawBounds intersect: bounds.	aCanvas		fillRectangle: selectionDrawBounds		colorOrInfiniteForm: (Theme current listHighlightFocused: listSource hasKeyboardFocus)! !!LazyListMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:16'!highlightPotentialDropRow: row  on: aCanvas	| drawBounds  |	drawBounds := self drawBoundsForRow: row.	drawBounds := drawBounds intersect: bounds.	aCanvas frameRectangle: drawBounds borderWidth: 1 color: Color blue! !!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:26'!drawOn: aCanvas 	| stringColor stringBounds leftEdge |	stringColor := color.	isSelected & isEnabled		ifTrue: [			aCanvas fillRectangle: bounds colorOrInfiniteForm: Theme current menuHighlight].	leftEdge := 0.	self hasIcon		ifTrue: [| iconForm | 			iconForm := isEnabled ifTrue:[self icon] ifFalse:[self icon asGrayScale].			aCanvas image: iconForm at: self left @ (self top + (self height - iconForm height // 2)).			leftEdge := iconForm width + 2].	self hasMarker		ifTrue: [ leftEdge := leftEdge + self submorphBounds width + 8 ].	stringBounds := bounds left: bounds left + leftEdge.	aCanvas		drawString: contents		in: stringBounds		font: self fontToUse		color: stringColor.	subMenu		ifNotNil: [aCanvas image: SubMenuMarker at: self right - 8 @ (self top + self bottom - SubMenuMarker height // 2)]! !!MenuItemMorph methodsFor: 'private' stamp: 'jmv 3/18/2011 00:26'!onImage	"Return the form to be used for indicating an '<off>' marker"	| form |	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.	(form getCanvas)		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 			borderWidth: 1 borderColor: Color black;		fillRectangle: (form boundingBox insetBy: 2) colorOrInfiniteForm: Color black.	^form! !!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:26'!drawOn: aCanvas 	| baseColor |	baseColor := owner color.	aCanvas		fillRectangle: (bounds topLeft corner: bounds rightCenter)		colorOrInfiniteForm: baseColor twiceDarker.				aCanvas		fillRectangle: (bounds leftCenter corner: bounds bottomRight)		colorOrInfiniteForm: baseColor twiceLighter! !!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:27'!drawSelectionOn: aCanvas	| rightX leftX top bottom |	top _ bounds top.	bottom _ top + self baseFont height.	leftX _ (self fontToUse widthOfString: contents from: 1 to: editor startIndex-1) + bounds left.	rightX _ (self fontToUse widthOfString: contents from: 1 to: editor stopIndex-1) + bounds left.	aCanvas		fillRectangle: (leftX @ top corner: rightX @ bottom)		colorOrInfiniteForm: self selectionColor! !!Paragraph methodsFor: 'display' stamp: 'jmv 3/18/2011 00:27'!displaySelectionInLine: line on: aCanvas	| leftX rightX idx caretFont t b caretAttributes |	selectionStart ifNil: [^self].	"No selection"	selectionStart = selectionStop 		ifTrue: [			"Only show caret on line where clicked"			selectionStart textLine ~= line ifTrue: [ ^self ]]		ifFalse: [			"Test entire selection before or after here"			(selectionStop stringIndex < line first 				or: [selectionStart stringIndex > (line last + 1)])					ifTrue: [^self].	"No selection on this line"			(selectionStop stringIndex = line first 				and: [selectionStop textLine ~= line])					ifTrue: [^self].	"Selection ends on line above"			(selectionStart stringIndex = (line last + 1) 				and: [selectionStop textLine ~= line])					ifTrue: [^self]].	"Selection begins on line below"	selectionStart = selectionStop 		ifTrue: [			leftX _ selectionStart left.			idx _ selectionStart stringIndex.			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].			caretFont _ caretAttributes				ifNil: [ self text fontAt: idx ]				ifNotNil: [ self text fontIfApplying: caretAttributes ].			b _ line top + line baseline + caretFont descent.			t _ line top + line baseline - caretFont ascent.			self showCaret ifTrue: [				self					displayInsertionMarkAtX: leftX					top: t					bottom: b					emphasis: caretFont emphasis					on: aCanvas ]]		ifFalse: [			caretRect _ nil.			leftX _ (selectionStart stringIndex < line first 				ifTrue: [ line ]				ifFalse: [ selectionStart ]) left.			rightX _ (selectionStop stringIndex > (line last + 1) or: [					selectionStop stringIndex = (line last + 1) 						and: [selectionStop textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [selectionStop left].			aCanvas				fillRectangle: (leftX @ line top corner: rightX @ line bottom)				colorOrInfiniteForm: self selectionColor]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jmv 3/17/2011 23:41'!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu, given that the receiver is a World"	| unlockables |	self addColorMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addDebuggingItemsTo: aMenu hand: aHandMorph.	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[ :m | m isLocked].	unlockables size = 1 ifTrue: [		aMenu add: ('unlock "{1}"' format:{unlockables first externalName})action: #unlockContents].	unlockables size > 1 ifTrue: [		aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:28'!draw3DLookOn: aCanvas	| w f center x y borderStyleSymbol c availableW l labelMargin |	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].	c _ color.	self mouseIsOver ifTrue: [ c _ c  lighter ].	aCanvas		fillRectangle: bounds		colorOrInfiniteForm: c		borderWidth: 2		borderStyleSymbol: borderStyleSymbol.	f _ self fontToUse.	center _ bounds center.	label ifNotNil: [		labelMargin _ 4.		w _ f widthOfString: label.		availableW _ bounds width-labelMargin-labelMargin-1.		availableW >= w			ifTrue: [				x _ center x - (w // 2).				l _ label ]			ifFalse: [				x _ bounds left + labelMargin.				l _ label squeezedTo: (label size * availableW / w) rounded ].		y _ center y - (f height // 2).		self isPressed ifTrue: [			x _ x + 1.			y _ y + 1 ].		aCanvas			drawString: l			in: (x@y extent: bounds extent - (labelMargin*2-2@4))			font: f			color: Theme current buttonLabel ]! !!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:17'!drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle			borderWidth: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].! !!ProgressBarMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:27'!drawOn: aCanvas	| width inner |	super drawOn: aCanvas.	inner _ self innerBounds.	width _ (inner width * value) truncated min: inner width.	aCanvas fillRectangle: (inner origin extent: width @ inner height) colorOrInfiniteForm: progressColor.! !!ScrollingLabel2LW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:27'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: Color blue.	aCanvas		drawString: contents		from: scrollPos		to: (scrollPos + 70 min: contents size )		at: bounds topLeft		font: font 		color: self fontColor! !!ScrollingLabelLW methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:27'!drawOn: aCanvas	aCanvas fillRectangle: bounds colorOrInfiniteForm: (Color blue alpha: 0.4).	aCanvas		drawString: contents		at: bounds topLeft - (scrollPos @ 0)		font: font 		color: self fontColor! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:28'!drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle 			borderWidth: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].	selectedMorph  ifNotNil: [		aCanvas			fillRectangle: ((selectedMorph bounds: selectedMorph bounds in: self)				intersect: scroller bounds)			colorOrInfiniteForm: (Theme current listHighlightFocused: self hasKeyboardFocus)].	Preferences showLinesInHierarchyViews ifTrue:[		self drawLinesOn: aCanvas ]! !!SketchMorph methodsFor: 'menus' stamp: 'jmv 3/17/2011 23:41'!addColorMenuItems: aMenu hand: aHand	"Do nothing here - we do not allow changing the color of a SketchMorph yet."! !!ColorPickerMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:24'!drawOn: aCanvas	aCanvas depth = 1 ifTrue: [aCanvas fillRectangle: bounds colorOrInfiniteForm: Color white].	Display depth = originalForm depth ifFalse: [self buildChartForm].	super drawOn: aCanvas! !!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:28'!drawClassicFrameOn: aCanvas color: titleColor	"Window border encompasses title area. No round corners. No title gradient."	borderColor class == Symbol		ifTrue: [			" This would of course be much better...			""			aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: borderColor			"			aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: borderColor baseColorForBorder: self raisedColor			]		ifFalse: [			aCanvas fillRectangle: bounds colorOrInfiniteForm: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: borderColor ].	aCanvas fillRectangle: self titleAreaInnerRect colorOrInfiniteForm: titleColor! !!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 3/18/2011 00:17'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self hasUnacceptedEdits							ifTrue: [								bc _ Color red]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Theme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !SketchMorph removeSelector: #addFillStyleMenuItems:hand:!Paragraph removeSelector: #displayClassicInsertionMarkAtX:top:bottom:emphasis:on:!Morph removeSelector: #addFillStyleMenuItems:hand:!FormCanvas removeSelector: #fillRectangle:color:!FormCanvas removeSelector: #fillRectangle:color:borderWidth:borderStyleSymbol:!FormCanvas removeSelector: #fillRectangle:color:borderWidth:borderStyleSymbol:baseColorForBorder:!FormCanvas removeSelector: #fillRectangle:fillStyle:!FormCanvas removeSelector: #fillRectangle:fillStyle:borderWidth:borderStyleSymbol:!FormCanvas removeSelector: #fillRectangle:fillStyle:borderWidth:borderStyleSymbol:baseColorForBorder:!FormCanvas removeSelector: #frameRectangle:color:!FormCanvas removeSelector: #frameRectangle:width:color:!