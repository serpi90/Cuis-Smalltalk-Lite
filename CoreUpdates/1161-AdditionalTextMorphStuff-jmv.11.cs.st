'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 5 December 2011 at 11:25:15 am'!!classDefinition: #Paragraph category: #'System-Text'!Object subclass: #Paragraph	instanceVariableNames: 'model extentForComposing lines maxRightX selectionStartBlocks selectionStopBlocks focused editor showCaret lastCaretRect '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!EntryField2LW methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:25'!             editor	"Return my current editor, or install a new one."	editor ifNil: [ self installEditor ].	^editor! !!EntryField2LW methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:24'!             installEditor	"Install an editor for my contents.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	editor _ self editorClass new morph: self.	editor changeString: contents.	self redrawNeeded.	^editor! !!EntryField2LW methodsFor: 'drawing' stamp: 'jmv 12/4/2011 21:58'!                drawSelectionOn: aCanvas	| rightX leftX top bottom |	top _ bounds top + 5.	bottom _ top + font height.	leftX _ (font widthOfString: contents from: 1 to: editor startIndex-1) + bounds left + 5.	rightX _ (font widthOfString: contents from: 1 to: editor stopIndex-1) + bounds left + 5.	aCanvas		fillRectangle: (leftX @ top corner: rightX @ bottom)		colorOrInfiniteForm: (Theme current textHighlightFocused: self hasKeyboardFocus)! !!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 12/4/2011 22:08'! paragraph: aParagraph bounds: boundsInWorld color: c selectionColor: sc	| displayScanner leftInRun line |	self setPaintColor: c.	displayScanner _ DisplayScanner new 		text: aParagraph paragraphText		foreground: (shadowColor ifNil: [ c ])		ignoreColorChanges: self isShadowDrawing.	displayScanner setPort: port.	leftInRun _ 0.	(aParagraph lineIndexForPoint: 0@0)		to: (aParagraph lineIndexForPoint: boundsInWorld extent)		do: [ :i |			line _ aParagraph lines at: i.			aParagraph				displaySelectionInLine: line				on: self				paragraphTopLeft: boundsInWorld topLeft				selectionColor: sc.			"This is still not really nice... We need to take into account origin here, because the DisplayScanners deals with the port			(i.e. the BitBlt) and not with us. So it won't have access to the origin!!			(drawing the selection uses FromCanvas services, that DO account for origin)			This could indeed be nicer!!"			leftInRun _ displayScanner displayLine: line paragraphTopLeft: boundsInWorld topLeft + origin leftInRun: leftInRun  ]! !!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:19'!                              contents: aString	contents _ aString.	paragraph _ Paragraph new.	paragraph		setModel: (TextModel withText: contents asText);		extentForComposing: 9999999@9999999.	paragraph composeAll.	self extent: paragraph usedExtent + 8! !!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 12/4/2011 21:55'!                  drawOn: aCanvas	aCanvas roundRect: bounds color: self color radius: 2.	aCanvas		paragraph: paragraph		bounds: (self bounds insetBy: 4)		color: Color black		selectionColor: (Theme current textHighlightFocused: false)! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:27'!                      editor	"Return my current editor, or install a new one."	editor ifNil: [ self installEditorAndParagraph ].	^editor! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/4/2011 15:43'!model: aTextModel	model _ aTextModel.	styler ifNotNil: [ styler textModel: model ].	self releaseEditorAndParagraph.	"So the model is properly set on the editor and the paragraph"! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:32'!wrapFlag: aBoolean	"Change whether contents are wrapped to the container."	aBoolean == wrapFlag ifTrue: [^ self].	wrapFlag _ aBoolean.	"Compose my text to fit my bounds.	If any text lies outside my bounds, it will be clipped,."	self resetParagraph! !!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 12/4/2011 22:07'!                        drawOn: aCanvas	"Draw the receiver on a canvas"	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"	aCanvas		paragraph: self paragraph		bounds: self bounds		color: color		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/4/2011 21:59'!              keyboardFocusChange: aBoolean		"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	aBoolean		ifTrue: [			"A hand is wanting to send us characters..."			editor ifNil: [ self editor storeSelectionInParagraph ].	"Forces install"			self startBlinking ]		ifFalse: [ self stopBlinking ].	"Selection might be shown differently when focused"	owner ifNotNil: [ owner redrawNeeded ].	self redrawNeeded! !!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/4/2011 22:23'!                         extent: aPoint	| newExtent |	"Resist changing the extent if no wordwrap.. this should be checked."	wrapFlag ifFalse: [ ^ self ].	newExtent _ aPoint truncated max: self minimumExtent.		"No change of wrap width"	newExtent x = bounds extent x ifTrue: [ ^ self ].	super extent: newExtent.		self resetParagraph! !!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 12/3/2011 00:41'!                    initialize	super initialize.	wrapFlag _ true.	acceptOnCR _ false.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.	askBeforeDiscardingEdits _ true! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/4/2011 22:26'!                       installEditorAndParagraph	"Install an editor for my paragraph. Install also the paragraph."	editor _ model editorClass new morph: self.	editor model: model.	"...Code here to recreate the paragraph... We positively know it is nil."	paragraph _ Paragraph new.	paragraph		setModel: model;		extentForComposing: self extentForComposing.	editor paragraph: paragraph.	paragraph editor: editor.	editor setEmphasisHereFromText.	paragraph composeAll.	self fit.	editor resetState.	self selectionChanged.	^editor! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/4/2011 22:28'!                 paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNil: [ self installEditorAndParagraph ].	^paragraph! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/4/2011 22:35'!           releaseEditorAndParagraph	"Editor and Paragraph instantiation is lazy -- they will be created only when needed"	editor _ nil.	paragraph _ nil! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/5/2011 10:31'!      resetParagraph	paragraph ifNotNil: [		paragraph			initialize;			extentForComposing: self extentForComposing;			composeAll.		editor storeSelectionInParagraph ].	self fit.	self selectionChanged.! !!InnerTextMorph methodsFor: 'shout' stamp: 'jmv 12/4/2011 16:04'!                 stylerStyled	self paragraph composeAll.	self editor recomputeSelection.		self updateFromParagraph.	self editor blinkParen.	self scrollSelectionIntoView! !!MessageSet methodsFor: 'message list' stamp: 'jmv 12/5/2011 10:47'!                        messageListIndex: anInteger	"Set the index of the selected item to be anInteger."	selectedMessage _ anInteger = 0 ifFalse: [ self messageList at: anInteger ].	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self acceptedContentsChanged! !!MessageSet methodsFor: 'message functions' stamp: 'jmv 12/5/2011 10:48'!                       reformulateList	"The receiver's messageList has been changed; rebuild it"	super reformulateList.	self initializeMessageList: messageList.	self changed: #messageList.	self changed: #messageListIndex.	self acceptedContentsChanged! !!MessageSet methodsFor: 'contents' stamp: 'jmv 12/5/2011 10:47'!                 acceptedContentsChanged	super acceptedContentsChanged.	autoSelectString ifNotNil: [		self changed: #autoSelect]! !!MessageSet methodsFor: 'private' stamp: 'jmv 12/5/2011 11:05'!         initializeMessageList: anArray	| s |	messageList _ OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil: [					s _ class name , ' ' , sel , ' {' , ((class organization categoryOfElement: sel) ifNil: ['']) , '}'.					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s) ]]]! !!MessageSetWindow methodsFor: 'top window' stamp: 'jmv 12/5/2011 11:05'!      activateAndSendTopToBack: aBoolean	super activateAndSendTopToBack: aBoolean.	self isCollapsed 		ifFalse: [			model messageListIndex: 1 ]! !!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:25'!    editor	"Return my current editor, or install a new one."	editor ifNil: [ self installEditor ].	^editor! !!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 12/4/2011 21:58'!          drawSelectionOn: aCanvas	| rightX leftX top bottom |	top _ bounds top.	bottom _ top + self baseFont height.	leftX _ (self fontToUse widthOfString: contents from: 1 to: editor startIndex-1) + bounds left.	rightX _ (self fontToUse widthOfString: contents from: 1 to: editor stopIndex-1) + bounds left.	aCanvas		fillRectangle: (leftX @ top corner: rightX @ bottom)		colorOrInfiniteForm: (Theme current textHighlightFocused: self hasKeyboardFocus)! !!OneLineEditorMorph methodsFor: 'private' stamp: 'jmv 12/4/2011 22:25'!              installEditor	"Install an editor for my contents.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	editor _ SimpleEditor new morph: self.	editor changeString: contents.	self redrawNeeded.	^editor! !!Paragraph methodsFor: 'composition' stamp: 'jmv 12/4/2011 22:19'!                   extentForComposing: aPoint	extentForComposing _ aPoint! !!Paragraph methodsFor: 'composition' stamp: 'jmv 12/4/2011 22:19'! setModel: aTextModel	model _ aTextModel! !!Paragraph methodsFor: 'display' stamp: 'jmv 12/4/2011 21:57'!                    displaySelectionInLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft  selectionColor: sc	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |		self			displaySelectionStartBlock: startBlock			stopBlock: stopBlock			InLine: line			on: aCanvas			paragraphTopLeft: paragraphTopLeft			selectionColor: sc ]! !!Paragraph methodsFor: 'display' stamp: 'jmv 12/4/2011 21:57'!       displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas paragraphTopLeft: paragraphTopLeft  selectionColor: sc	| leftX rightX idx caretFont t b caretAttributes |	startBlock ifNil: [^self].	"No selection"	startBlock = stopBlock 		ifTrue: [			"Only show caret on line where clicked"			startBlock textLine first = line first ifFalse: [				^self ].			leftX _ paragraphTopLeft x + startBlock left.			idx _ startBlock stringIndex.			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].			caretFont _ caretAttributes				ifNil: [ model actualContents fontAt: idx ]				ifNotNil: [ model actualContents fontIfApplying: caretAttributes ].			b _ paragraphTopLeft y + line top + line baseline + caretFont descent-1.			t _ paragraphTopLeft y + line top + line baseline - caretFont ascent.			showCaret ifTrue: [				self					displayInsertionMarkAtX: leftX					top: t					bottom: b					emphasis: caretFont emphasis					on: aCanvas					paragraphTopLeft: paragraphTopLeft ]]		ifFalse: [			"Test entire selection before or after here"			(stopBlock stringIndex < line first 				or: [startBlock stringIndex > (line last + 1)])					ifTrue: [^self].	"No selection on this line"			(stopBlock stringIndex = line first 				and: [stopBlock textLine ~= line])					ifTrue: [^self].	"Selection ends on line above"			(startBlock stringIndex = (line last + 1) 				and: [stopBlock textLine ~= line])					ifTrue: [^self].			lastCaretRect _ nil.			leftX _  paragraphTopLeft x + (startBlock stringIndex < line first 				ifTrue: [ line ]				ifFalse: [ startBlock ]) left.			rightX _  paragraphTopLeft x + ((stopBlock stringIndex > (line last + 1) or: [					stopBlock stringIndex = (line last + 1) 						and: [stopBlock textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [stopBlock left]).			aCanvas				fillRectangle: (leftX @ (line top +  paragraphTopLeft y) corner: rightX @ (line bottom +  paragraphTopLeft y))				colorOrInfiniteForm: sc ].	"Selection begins on line below"! !!Paragraph methodsFor: 'initialization' stamp: 'jmv 12/4/2011 21:59'!      initialize	showCaret _ false.	selectionStartBlocks _ #().	selectionStopBlocks _ #()! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 12/4/2011 22:17'!                         paragraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	paragraph _ aParagraph! !!TextEditorTest methodsFor: 'testing' stamp: 'jmv 12/4/2011 22:20'!        testUndoRedo	"	TextEditorTest new testUndoRedo	"	| editor model paragraph m text1 text0 text2 |	text0 _ ''.	model _ TextModel withText: text0 copy.	editor _ TextEditor new.	m _ InnerTextMorph new.	m privateOwner: TextModelMorph new.	editor morph: m.	editor instVarNamed: 'emphasisHere' put: Array new.	editor model: model.	paragraph _ Paragraph new.	paragraph		setModel: model;		extentForComposing: 300@300.	editor paragraph: paragraph.	paragraph editor: editor.	paragraph composeAll.	text1 _ 'some words' asText.	editor addString: text1.	self assert: model actualContents = text1.	editor undo.	self assert: model actualContents = text0.	editor redo.	self assert: model actualContents = text1.	text2 _ ' additional inserted stuff' asText.	editor addString: text2.	self assert: model actualContents = (text1, text2).	editor undo.	self assert: model actualContents = text1.	editor undo.	self assert: model actualContents = text0.	editor redo.	self assert: model actualContents = text1.	editor redo.	self assert: model actualContents = (text1, text2).! !!Transcripter methodsFor: 'initialization' stamp: 'jmv 12/4/2011 22:20'!                  initInFrame: rect	frame _ rect insetBy: 2.  "Leave room for border"	para _ Paragraph new.	para		setModel: (TextModel withText: self contents asText);		extentForComposing: frame width-8 @9999.	para composeAll! !!Transcripter methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:20'!  endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue: [		"Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para		setModel: (TextModel withText: c asText);		extentForComposing: frame width-8 @9999.	para composeAll.	d _ para extent y - frame height.	d > 0 ifTrue: [		"Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint:			0@0 + (0@(d+StrikeFont default height)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	Display getCanvas		paragraph: para		bounds: (4@4 extent: Display extent)		color: Color black		selectionColor: Color blue! !TextEditor removeSelector: #changeParagraph:!TextEditor removeSelector: #stateArray!TextEditor removeSelector: #stateArrayPut:!SimpleEditor removeSelector: #stateArray!SimpleEditor removeSelector: #stateArrayPut:!Paragraph removeSelector: #displaySelectionInLine:on:paragraphTopLeft:!Paragraph removeSelector: #displaySelectionStartBlock:stopBlock:InLine:on:paragraphTopLeft:!Paragraph removeSelector: #focused!Paragraph removeSelector: #focused:!Paragraph removeSelector: #selectionColor!Paragraph removeSelector: #setModel:extentForComposing:!!classDefinition: #Paragraph category: #'System-Text'!Object subclass: #Paragraph	instanceVariableNames: 'model extentForComposing lines maxRightX selectionStartBlocks selectionStopBlocks editor showCaret lastCaretRect'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!OneLineEditorMorph removeSelector: #installEditorToReplace:!OneLineEditorMorph removeSelector: #selectionColor!InnerTextMorph removeSelector: #installEditorToReplace:!FormCanvas removeSelector: #display:using:in:!FormCanvas removeSelector: #paragraph:bounds:color:!EntryField2LW removeSelector: #installEditorToReplace:!EntryField2LW removeSelector: #selectionColor!