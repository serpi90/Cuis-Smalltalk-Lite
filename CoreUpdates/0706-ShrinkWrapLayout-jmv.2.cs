'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 10 December 2010 at 8:43:01 am'!!LayoutMorph commentStamp: '<historical>' prior: 0!A row or column of widgets, does layout by placing them either horizontally or vertically.Submorphs might specify a LayoutSpec. If some doesn't, then, for a column, the column width is taken as the width, and any morph height is kept. Same for rows: submorph width would be maintained, and submorph height would be made equal to row height.!!classDefinition: #LayoutSpec category: #'Morphic-Layouts'!Object subclass: #LayoutSpec	instanceVariableNames: 'proportionalWidth proportionalHeight minorDirectionPadding fixedWidth fixedHeight '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!!LayoutSpec commentStamp: '<historical>' prior: 0!LayoutSpecs are the basis for a new layout mechanism, alternative to LayoutFrame. Any Morph can be given a LayoutSpec, but in order to honor it, its owner must be a LayoutMorph.A LayoutSpec specifies how a morph wants to be layed out. It can specify either a fixed width or a fraction of some available owner width. Same goes for height. If a fraction is specified, a minimum extent is also possible.Alternatives:	- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width	- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width	- proportionalWidth isNil, fixedWidth notNil		->		Use fixedWidth	- proportionalWidth notNil, fixedWidth isNil		->		NOT VALIDSame goes for proportionalHeight and fixedHeight!!ScrollPane commentStamp: '<historical>' prior: 0!The scroller (a transform) of a scrollPane is driven by the scrollBar. The scroll values vary from 0.0 to 1.0.!!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 12/7/2010 16:19'!padding: aSymbolOrNumber	"This sets how extra space is used when doing layout. For example, a column might have extra , unneded vertical space. #top means widgets are set close to the top, and extra space is at bottom. Conversely, #bottom means widgets are set close to the bottom, and extra space is at top. Valid values include #left and #right (for rows) and #center. Alternatively, any number between 0.0 and 1.0 might be used.	self new padding: #center	self new padding: 0.9	"	padding _ aSymbolOrNumber		caseOf: {			[ #top ] -> [ 0.0 ].			[ #left ] -> [ 0.0 ].			[ #center ] -> [ 0.5 ].			[ #right ] -> [ 1.0 ].			[ #bottom ] -> [ 1.0 ].			[ #shrink ] -> [ nil ]		}		otherwise: [ aSymbolOrNumber ]! !!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/9/2010 16:52'!layoutSubmorphsHorizontallyIn: boundsForLayout	"Compute a new layout based on the given layout bounds."	| usableWidth sumOfFixed sumOfProportional normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |	usableWidth _ boundsForLayout width - ((submorphs size + 1) * separation).	sumOfFixed _ submorphs sum: [ :m | m layoutSpec ifNil: [ m width ] ifNotNil: [ :ls | ls  fixedWidthFor: m ]].	availableForPropWidth _ usableWidth - sumOfFixed.	padding ifNil: [		availableForPropWidth = 0 ifFalse: [			self width: self width - availableForPropWidth.			^ self doLayoutIfNeeded ]].	sumOfProportional _ submorphs sum: [ :m | m layoutSpec ifNil: [ 0 ] ifNotNil: [ :ls | ls proportionalWidth ]].	normalizationFactor _ 1.0 / (sumOfProportional max: 1.0).	availableForPropWidth _ availableForPropWidth * normalizationFactor.	widths _ submorphs collect: [ :m | m layoutSpec ifNil: [ m width ] ifNotNil: [ :lm | lm widthOf: m for: availableForPropWidth ]].	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + separation max: 0) +  boundsForLayout left.	usableHeight _ boundsForLayout height - (2*separation) max: 0.	boundsTop _ boundsForLayout top.		boundsRight _ boundsForLayout right.	submorphs		with: widths		do: [ :m :w | | h |			"major direction"			r _ l + w min: boundsRight.			"minor direction"			m layoutSpec				ifNotNil: [ :ls |					h _ (ls heightOf: m for: usableHeight) min: usableHeight.					t _ (usableHeight - h) * ls minorDirectionPadding + separation + boundsTop ]				ifNil: [					h _ usableHeight.					t _ separation + boundsTop ].			b _ t + h.			"Set bounds and adjust major direction for next step"			m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).			w > 0 ifTrue: [				l _ r + separation min: boundsRight ]]! !!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/9/2010 16:54'!layoutSubmorphsVerticallyIn: boundsForLayout	"Compute a new layout based on the given layout bounds."	| usableHeight sumOfFixed sumOfProportional normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |	usableHeight _ boundsForLayout height - ((submorphs size + 1) * separation).	sumOfFixed _ submorphs sum: [ :m | m layoutSpec ifNil: [ m height ] ifNotNil: [ :ls | ls fixedHeightFor: m ]].	availableForPropHeight _ usableHeight - sumOfFixed.	padding ifNil: [		availableForPropHeight = 0 ifFalse: [			self height: self height - availableForPropHeight.			^ self doLayoutIfNeeded ]].	sumOfProportional _ submorphs sum: [ :m | m layoutSpec ifNil: [ 0 ] ifNotNil: [ :ls | ls proportionalHeight ]].	normalizationFactor _ 1.0 / (sumOfProportional max: 1.0).	availableForPropHeight _ availableForPropHeight * normalizationFactor.	heights _ submorphs collect: [ :m | m layoutSpec ifNil: [ m height ] ifNotNil: [ :lm | lm heightOf: m for: availableForPropHeight ]].	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + separation max: 0) +  boundsForLayout top.	usableWidth _ boundsForLayout width - (2*separation) max: 0.	boundsLeft _ boundsForLayout left.		boundsBottom _ boundsForLayout bottom.	submorphs		with: heights		do: [ :m :h | | w |			"major direction"			b _ t + h min: boundsBottom.			"minor direction"			m layoutSpec				ifNotNil: [ :ls |					w _ (ls widthOf: m for: usableWidth) min: usableWidth.					l _ (usableWidth - w) * ls minorDirectionPadding + separation + boundsLeft ]				ifNil: [					w _ usableWidth.					l _ separation + boundsLeft ].			r _ l + w.			"Set bounds and adjust major direction for next step"			m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).			h > 0 ifTrue: [				t _ b + separation min: boundsBottom ]]! !!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 12/9/2010 11:04'!example4	"	self example4"	| pane |	pane _ LayoutMorph newColumn.	pane padding: #shrink.	pane color: Color red.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.'))		layoutSpec: LayoutSpec new useMorphHeight.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.'))		layoutSpec: LayoutSpec new useMorphHeight.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.'))		layoutSpec: LayoutSpec new useMorphHeight.	pane openInWorld.! !!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 12/9/2010 14:40'!example5	"	self example5"	| pane |	pane _ LayoutMorph newColumn.	pane padding: #shrink.	pane color: Color red.	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.')).	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.')).	pane		addMorph:			(LimitedHeightTextMorph new				 maxHeight: 48;				 model: (TextModel new contents: 'This is some text to test the morph.')).	pane openInWorld.! !!LayoutSpec methodsFor: 'initialization' stamp: 'jmv 12/9/2010 10:50'!initialize	"Just some reasonable defaults, use all available space"	minorDirectionPadding _ 0.5.	fixedWidth _ 0.	fixedHeight _ 0.	proportionalWidth _ 1.0.	proportionalHeight _ 1.0! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:49'!fixedHeight: aNumber	"aNumber is taken as the fixed height to use.	No proportional part."	fixedHeight _ aNumber.	proportionalHeight _ nil! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:49'!fixedWidth: aNumber	"aNumber is taken as the fixed width to use.	No proportional part."	fixedWidth _ aNumber.	proportionalWidth _ nil! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:24'!minorDirectionPadding	^minorDirectionPadding! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:25'!minorDirectionPadding: aSymbolOrNumber	"This sets how padding is done in the secondary direction. For instance, if the owning morph is set in a row, the row will control horizontal layout. But if there is unused vertical space, it will be used according to this parameter. For instance, #top sets the owning morph at the top. Same for #bottom and #center. If the owner is contained in a column, #left, #center or #right should be used. Alternatively, any number between 0.0 and 1.0 can be used.	self new minorDirectionPadding: #center	self new minorDirectionPadding: 0.9	"	minorDirectionPadding _ aSymbolOrNumber		caseOf: {			[ #top ] -> [ 0.0 ].			[ #left ] -> [ 0.0 ].			[ #center ] -> [ 0.5 ].			[ #right ] -> [ 1.0 ].			[ #bottom ] -> [ 1.0 ]		}		otherwise: [ aSymbolOrNumber ]! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:50'!proportionalHeight: aNumberOrNil minimum: otherNumberOrNil	"Alternatives: same as in #proportionalWidth:minimum:, see comment there"	proportionalHeight _ aNumberOrNil.	fixedHeight _ otherNumberOrNil! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:50'!proportionalWidth: aNumberOrNil minimum: otherNumberOrNil	"Alternatives:		- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width		- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width		- proportionalWidth isNil, fixedWidth notNil	->		Use fixedWidth		- proportionalWidth notNil, fixedWidth isNil	->		NOT VALID"	proportionalWidth _ aNumberOrNil.	fixedWidth _ otherNumberOrNil! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:51'!useMorphHeight	"Do not attempt to layout height. Use current morph height if at all possible."	fixedHeight _ nil.	proportionalHeight _ nil! !!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/9/2010 10:48'!useMorphWidth	"Do not attempt to layout width. Use current morph width if at all possible."	fixedWidth _ nil.	proportionalWidth _ nil! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/9/2010 10:52'!fixedHeightFor: aMorph	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."	proportionalHeight ifNotNil: [		^0 ].	^ fixedHeight ifNil: [ aMorph height ]! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/9/2010 10:48'!fixedWidthFor: aMorph	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."	proportionalWidth ifNotNil: [		^0 ].	^ fixedWidth ifNil: [ aMorph width ]! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/9/2010 10:51'!heightOf: aMorph for: availableSpace	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined.	Otherwise, we do proportional layout, and the stored extent is a minimum extent.	If there is no minimum extent, it should be set to zero."	proportionalHeight ifNotNil: [		^fixedHeight max: proportionalHeight * availableSpace ].	^ self fixedHeightFor: aMorph! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/9/2010 10:53'!proportionalHeight	^proportionalHeight ifNil: [ 0 ]! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/9/2010 10:48'!proportionalWidth	^proportionalWidth ifNil: [ 0 ]! !!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/9/2010 10:47'!widthOf: aMorph for: availableSpace	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined.	Otherwise, we do proportional layout, and the stored extent is a minimum extent.	If there is no minimum extent, it should be set to zero."	proportionalWidth ifNotNil: [		^fixedWidth max: proportionalWidth * availableSpace ].	^ self fixedWidthFor: aMorph! !!LayoutSpec methodsFor: 'testing' stamp: 'jmv 12/9/2010 09:56'!is: aSymbol	^ aSymbol == #LayoutSpec or: [ super is: aSymbol ]! !!LayoutSpec class methodsFor: 'instance creation' stamp: 'jmv 12/9/2010 10:33'!fixedWidth: aNumber fixedHeight: otherNumber	^ LayoutSpec new		fixedWidth: aNumber;		fixedHeight: otherNumber! !!LayoutSpec class methodsFor: 'instance creation' stamp: 'jmv 12/9/2010 10:33'!fixedWidth: aNumber fixedHeight: otherNumber minorDirectionPadding: aSymbolOrNumber	^ LayoutSpec new		fixedWidth: aNumber;		fixedHeight: otherNumber;		minorDirectionPadding: aSymbolOrNumber! !!TextModelMorph methodsFor: 'geometry' stamp: 'jmv 12/9/2010 09:49'!extent: newExtent 	super extent: newExtent.	textMorph ifNotNil: [		textMorph extent = self viewableBounds extent ifFalse: [			textMorph extent: self viewableBounds extent ]].	self setScrollDeltas! !!classDefinition: #LayoutSpec category: #'Morphic-Layouts'!Object subclass: #LayoutSpec	instanceVariableNames: 'fixedWidth fixedHeight minorDirectionPadding proportionalWidth proportionalHeight'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Layouts'!Smalltalk removeClassNamed: #FixedLayoutSpec!