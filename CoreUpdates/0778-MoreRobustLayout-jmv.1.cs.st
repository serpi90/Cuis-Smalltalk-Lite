'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 22 January 2011 at 1:36:26 pm'!!Morph methodsFor: 'layout' stamp: 'jmv 1/22/2011 13:29'!doLayoutIfNeeded	"Return self. Recompute the layout if necessary."	fullBounds ifNotNil: [ ^self ].	"Errors at this point can be critical so make sure we catch 'em all right"	[self layoutSubmorphsIn: self layoutBounds] on: Exception do: [ :ex |		"This should do it unless you don't screw up the bounds"		fullBounds _ bounds.		ex pass ]! !!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 1/22/2011 13:35'!noticeMouseOver: aMorph event: anEvent	"Remember that the mouse is currently over some morph"	leftMorphs ifNil: [ ^self ].		"Might happen if you halt during layout."	(leftMorphs includes: aMorph) 		ifTrue:[leftMorphs remove: aMorph]		ifFalse:[enteredMorphs nextPut: aMorph].	overMorphs nextPut: aMorph.! !!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 1/22/2011 13:34'!processMouseOver: anEvent 	"Re-establish the z-order for all morphs wrt the given event"	| hand localEvt focus evt |	hand := anEvent hand.	leftMorphs := mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs := WriteStream on: (Array new: leftMorphs size).	enteredMorphs := WriteStream on: #().	"Now go looking for eventual mouse overs"	hand handleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."		(leftMorphs isEmpty and: [enteredMorphs position = 0])])		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].	focus := hand mouseFocus.	"Send #mouseLeave as appropriate"	evt := anEvent asMouseLeave.	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"	leftMorphs size > 1 		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].	leftMorphs do: 			[:m | 			(m == focus or: [m hasOwner: focus]) 				ifTrue: [					localEvt := evt internalizedToOwnerOf: m from: hand.					m handleEvent: localEvt]				ifFalse: [overMorphs nextPut: m]].	"Send #mouseEnter as appropriate"	evt := anEvent asMouseEnter.	enteredMorphs ifNil: 			["inform: was called in handleEvent:"			^leftMorphs := enteredMorphs := overMorphs := nil].	enteredMorphs := enteredMorphs contents.	enteredMorphs reverseDo: 			[:m | 			(m == focus or: [m hasOwner: focus]) 				ifTrue: 					[localEvt := evt internalizedToOwnerOf: m  from: hand.					m handleEvent: localEvt]].	"And remember the over list"	overMorphs ifNil: 			["inform: was called in handleEvent:"			^leftMorphs := enteredMorphs := overMorphs := nil].	mouseOverMorphs := overMorphs contents.	leftMorphs := enteredMorphs := overMorphs := nil! !