'From Cuis 2.0 of 4 January 2010 [latest update: #393] on 11 January 2010 at 10:55:33 pm'!!AdditionalMethodState methodsFor: 'accessing' stamp: 'bs 12/18/2009 13:38'!at: aKey put: aValue	"Replace the property value or pragma associated with aKey."	| keyAlreadyExists |	keyAlreadyExists := false.		1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue: [			keyAlreadyExists := true.			propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value: aValue]				ifFalse: [self basicAt: i put: aValue]]].		keyAlreadyExists ifFalse: [		method propertyValueAt: aKey put: aValue ].		^ aValue! !!BlockClosure methodsFor: 'debugger access' stamp: 'nice 4/14/2009 19:09'!sender	"Answer the context that sent the message that created the receiver."	^outerContext sender! !!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 1/11/2010 22:45'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| flagByte source |	flagByte := self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) allSatisfy: [:i | (self at: self size - i) = 0])]])		ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNamesString)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"		source := [self getSourceFromFile]				on: Error		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."				do: [ :ex | ex return: nil].			^source		ifNil: [			"Something really wrong -- decompile blind (no temps)"			 (class decompilerClass new decompile: selector in: class method: self)				decompileString]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'ul 12/15/2009 19:04'!objectClass: anObject	<primitive: 111>	self primitiveFailed! !!MethodDictionary methodsFor: 'accessing' stamp: 'jmv 1/11/2010 22:24'!includesKey: aSymbol	"This override assumes that pointsTo is a fast primitive"	aSymbol ifNil: [^ false].	^ self pointsTo: aSymbol! !!ProcessorScheduler methodsFor: 'private' stamp: 'ar 12/10/2009 00:22'!anyProcessesAbove: highestPriority 	"Do any instances of Process exist with higher priorities?"	^(Process allSubInstances select: [:aProcess | 		aProcess priority > highestPriority]) isEmpty		"If anyone ever makes a subclass of Process, be sure to use allSubInstances."! !