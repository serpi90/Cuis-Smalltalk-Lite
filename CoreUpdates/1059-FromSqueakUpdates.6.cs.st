'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 7 August 2011 at 12:04:50 am'!!classDefinition: #Time category: #'Kernel-Chronology'!Magnitude subclass: #Time	instanceVariableNames: 'seconds nanos '	classVariableNames: 'MillisecondClockMask '	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!Compiler methodsFor: 'public access' stamp: 'jmv 8/6/2011 23:23'!evaluate: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.	Anser nil in case of failure"	^self		evaluate: aString		in: aContext		to: aReceiver		notifying: nil		ifFail: nil! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'jmv 8/6/2011 23:45'!startUp: resuming	resuming ifFalse: [ ^ self ].	Time initializeMillisecondClockMask.	OffsetsAreValid _ false.	[		self initializeOffsets.		OffsetsAreValid _ true	] forkAt: Processor userInterruptPriority.! !!Debugger methodsFor: 'accessing' stamp: 'jmv 8/5/2011 23:15'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		(result := self contents: aText notifying: aController) ifTrue: [			self acceptedContentsChanged].		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	World		addAlarm: #changed:		withArguments: #(contentsSelection)		for: self		at: (Time millisecondClockValue + 200).	^true! !!Debugger methodsFor: 'private' stamp: 'jmv 8/5/2011 23:13'!selectedContext'' print.thisContext printStack: 10.	contextStackIndex = 0		ifTrue: [^contextStackTop]		ifFalse: [^contextStack at: contextStackIndex]! !!Delay methodsFor: 'private' stamp: 'jmv 8/6/2011 23:36'!resumptionTime: anInteger	"Private!! Set the value of the system's millisecondClock at which the receiver's suspended Process will resumed.	Must only be called from the class-side #scheduleDelay:."		resumptionTime := anInteger! !!Delay methodsFor: 'private' stamp: 'jmv 8/6/2011 23:36'!schedule	"Schedule this delay."		beingWaitedOn ifTrue: [^self error: 'This Delay has already been scheduled.'].	AccessProtect critical: [		ScheduledDelay := self.		TimingSemaphore signal]! !!Delay class methodsFor: 'timer process' stamp: 'jmv 8/6/2011 23:36'!scheduleDelay: aDelay	"Private. Schedule this Delay."		aDelay resumptionTime: Time millisecondClockValue + aDelay delayDuration. 		"Gary Chambers:  do the above here, via the high priority timer process to avoid rollover bug due to process pre-emption		since the caller cannot use the AccessProtect semaphore."	aDelay beingWaitedOn: true.	ActiveDelay 		ifNil: [ActiveDelay := aDelay]		ifNotNil: [aDelay resumptionTime < ActiveDelay resumptionTime			ifTrue: [SuspendedDelays add: ActiveDelay.					ActiveDelay := aDelay]			ifFalse: [SuspendedDelays add: aDelay]]! !!Inspector methodsFor: 'selecting' stamp: 'jmv 8/6/2011 23:20'!accept: aString	| result |	result _ self doItReceiver class evaluatorClass new				evaluate: (ReadStream on: aString)				in: self doItContext				to: self doItReceiver				notifying: nil	"fix this"				ifFail:  [^ false].	acceptedContentsCache _ result printString.	self replaceSelectionValue: result.	"may put contents back"	self acceptedContentsChanged.	^ true! !!Integer methodsFor: 'bit manipulation' stamp: 'jmv 8/6/2011 23:40'!bitReverse: highBit 	"Reverse the bits of the receiver so that the lsb is the highBit'th bit of the answer.  Translated from C code at:  http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious."	| v r s |	highBit < self highBit ifTrue: [ self error: 'Not enough bits.' ].	v := self.	r := v bitAnd: 1.	s := highBit - 1.	[ v := v bitShift: -1.	v = 0 ] whileFalse:		[ r := r bitShift: 1.		r := r bitOr: (v bitAnd: 1).		s := s - 1 ].	^ r bitShift: s! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'jmv 8/6/2011 23:40'!bitReverse: highBit 	"This implementation is faster than super"		| digitSize reversed |	highBit < self highBit ifTrue: [ self error: 'Not enough bits.' ].	digitSize := highBit + 7 // 8.	reversed := self class new: digitSize.	1 to: self digitLength do: [:i |		reversed digitAt: digitSize + 1 - i put: (self digitAt: i) byteReversed].	^reversed bitShift: highBit - (digitSize * 8)! !!MessageNode methodsFor: 'testing' stamp: 'jmv 8/5/2011 23:28'!ensureCanCascade: encoder	special > 0 ifTrue: [		special := 0.		selector := encoder encodeSelector: originalSelector.		arguments := originalArguments.		receiver isBlockNode ifTrue: [receiver deoptimize].		arguments do:			[:each|			each isBlockNode ifTrue:				[each deoptimize]]]! !!Parser methodsFor: 'error correction' stamp: 'jmv 8/6/2011 23:57'!canDeclareInstanceVariable	^encoder classEncoding ~~ UndefinedObject! !!SequenceableCollection methodsFor: 'testing' stamp: 'jmv 8/5/2011 23:20'!beginsWith: sequence	"Answer true if the receiver starts with the argument collection."		| sequenceSize |	((sequenceSize := sequence size) = 0 or: [ self size < sequence size ]) ifTrue: [ ^false ].	1 to: sequenceSize do: [ :index |		(sequence at: index) = (self at: index) ifFalse: [ ^false ] ].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'jmv 8/5/2011 23:21'!endsWith: sequence	"Answer true if the receiver ends with the argument collection."		| sequenceSize offset |	((sequenceSize := sequence size) = 0 or: [ (offset := self size - sequence size) < 0 ]) ifTrue: [ ^false ].	1 to: sequenceSize do: [ :index |		(sequence at: index) = (self at: index + offset) ifFalse: [ ^false ] ].	^true! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'jmv 8/6/2011 23:40'!byteReversed	"Answer the receiver with bits reversed in a byte.	The receiver must be between 0 and 255.	The constant has been obtained by this snippet:	(0 to: 255) collect: [:e |		| r |		r := ((e bitAnd: 2r11110000) bitShift: -4) + ((e bitAnd: 2r00001111) bitShift: 4).		r := ((r bitAnd: 2r11001100) bitShift: -2) + ((r bitAnd: 2r00110011) bitShift: 2).		((r bitAnd: 2r10101010) bitShift: -1) + ((r bitAnd: 2r01010101) bitShift: 1).] as: ByteArray"		^#[0 128 64 192 32 160 96 224 16 144 80 208 48 176 112 240 8 136 72 200 40 168 104 232 24 152 88 216 56 184 120 248 4 132 68 196 36 164 100 228 20 148 84 212 52 180 116 244 12 140 76 204 44 172 108 236 28 156 92 220 60 188 124 252 2 130 66 194 34 162 98 226 18 146 82 210 50 178 114 242 10 138 74 202 42 170 106 234 26 154 90 218 58 186 122 250 6 134 70 198 38 166 102 230 22 150 86 214 54 182 118 246 14 142 78 206 46 174 110 238 30 158 94 222 62 190 126 254 1 129 65 193 33 161 97 225 17 145 81 209 49 177 113 241 9 137 73 201 41 169 105 233 25 153 89 217 57 185 121 249 5 133 69 197 37 165 101 229 21 149 85 213 53 181 117 245 13 141 77 205 45 173 109 237 29 157 93 221 61 189 125 253 3 131 67 195 35 163 99 227 19 147 83 211 51 179 115 243 11 139 75 203 43 171 107 235 27 155 91 219 59 187 123 251 7 135 71 199 39 167 103 231 23 151 87 215 55 183 119 247 15 143 79 207 47 175 111 239 31 159 95 223 63 191 127 255] at: 1 + self! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/5/2011 23:33'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelectionAndDo: [ :result | result ] ifFail: nil! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/5/2011 23:33'!evaluateSelectionAndDo: aBlock ifFail: failBlock	"Treat the current selection as an expression; evaluate it and return the result"	| provider result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	provider _ self codeProvider.	(provider respondsTo: #doItReceiver) 		ifTrue: [				rcvr _ provider doItReceiver.				ctxt _ provider doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new			sourceStreamGetter: #selectionAsStream;		"Cuis specific. Do not remove!!"			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [^ failBlock value]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	^ aBlock value: result! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/5/2011 23:35'!exploreIt	self		evaluateSelectionAndDo: [ :result | result explore ]		ifFail: [ morph flash ]! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/5/2011 23:36'!inspectIt	self		evaluateSelectionAndDo: [ :result | result inspect ]		ifFail: [ morph flash ]! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/5/2011 23:37'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	self		evaluateSelectionAndDo: [ :result |			self afterSelectionInsertAndSelect: result printString ]		ifFail: [ morph flash ]! !!String methodsFor: 'comparing' stamp: 'jmv 8/5/2011 23:25'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	| sequenceSize |	((sequenceSize _ prefix size) = 0 or: [ self size < sequenceSize ]) ifTrue: [ ^false ].	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."	(self basicAt: 1) = (prefix basicAt: 1) ifFalse: [ ^false ].	^(self findSubstring: prefix in: self startingAt: 1 matchTable: CaseSensitiveOrder) = 1! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 8/5/2011 23:41'!doIt	self handleEdit: [ self editor evaluateSelectionAndDo: nil ifFail: nil ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 8/5/2011 23:38'!exploreIt	self handleEdit: [ self editor exploreIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 8/5/2011 23:41'!inspectIt	self handleEdit: [ self editor inspectIt ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 8/5/2011 23:40'!printIt	| result oldEditor |	textMorph handleEdit: [		result _ (oldEditor _ textMorph editor)			evaluateSelectionAndDo: [ :r | r]			ifFail: [^self flash]].	textMorph installEditorToReplace: oldEditor.	textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	self scrollSelectionIntoView.! !!Time class methodsFor: 'general inquiries' stamp: 'jmv 8/6/2011 23:44'!millisecondClockMask	"Answer the mask used for millisecond clock rollover in the virtual machine.	Answer a default if the VM cannot supply the value."	^MillisecondClockMask ifNil: [16r1FFFFFFF]! !!Time class methodsFor: 'general inquiries' stamp: 'jmv 8/6/2011 23:32'!milliseconds: currentTime since: lastTime	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."	| delta |	delta := currentTime - lastTime.	^ delta < 0		ifTrue: [self millisecondClockMask + delta]		ifFalse: [delta]! !!Time class methodsFor: 'clock' stamp: 'jmv 8/6/2011 23:44'!initializeMillisecondClockMask	"Initialize cached value from the VM, or set to nil if VM cannot support the request"	MillisecondClockMask := self primMillisecondClockMask! !!Time class methodsFor: 'clock' stamp: 'jmv 8/6/2011 23:43'!primMillisecondClockMask	"Answer the mask value used for millisecond clock rollover in the	virtual machine, or nil if the VM cannot support the request."	<primitive: 'primitiveMillisecondClockMask'>	^nil! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'jmv 8/6/2011 23:59'!openMenuIn: aBlock	| alternatives labels actions lines caption choice |	alternatives _ parser possibleVariablesFor: name.	labels _ OrderedCollection new.	actions _ OrderedCollection new.	lines _ OrderedCollection new.	name first isLowercase		ifTrue: [			labels add: 'declare block-local temp'.			actions add: [				parser					declareTemp: name					at: #block ].			labels add: 'declare method temp'.			actions add: [				parser					declareTemp: name					at: #method ].			parser canDeclareInstanceVariable ifTrue: [				labels add: 'declare instance'.				actions add: [ parser declareInstVar: name ]]]		ifFalse: [			labels add: 'define new class'.			actions add: [ parser defineClass: name ].			labels add: 'declare global'.			actions add: [ parser declareGlobal: name ].			parser canDeclareClassVariable ifTrue: [				labels add: 'declare class variable'.				actions add: [ parser declareClassVar: name ]]].	lines add: labels size.	alternatives do: [ :each |		labels add: each.		actions add: [			parser				substituteVariable: each				atInterval: interval ]].	lines add: labels size.	labels add: 'cancel'.	caption _ 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice _ aBlock		value: labels		value: lines		value: caption.	self resume:		(actions			at: choice			ifAbsent: [ ]).! !!Utilities class methodsFor: 'closure support' stamp: 'jmv 8/6/2011 23:50'!postRecompileCleanup	"Utilities postRecompileCleanup"	"Cleanup after loading closure bootstrap"	"Before doing this, please start a new UI process (for example, by hitting alt-period and closing the debugger)."	| unboundMethods contexts |	World removeAllKnownFailing.	ProcessorScheduler startUp.	WeakArray restartFinalizationProcess.	MethodChangeRecord allInstancesDo:[:x| x noteNewMethod: nil].	Undeclared removeUnreferencedKeys.	Delay startTimerEventLoop.	EventSensor install.	WorldState allInstancesDo:[:ws| ws convertAlarms; convertStepList].	Workspace allInstancesDo:[:ws| ws initializeBindings].	Smalltalk garbageCollect.	Smalltalk		at: #DebuggerMethodMap		ifPresent: [ :dmm | dmm voidMapCache ].	Smalltalk forgetDoIts.	Smalltalk garbageCollect.	unboundMethods _ CompiledMethod unboundMethods.	unboundMethods notEmpty ifTrue: [		unboundMethods inspectWithLabel: 'Unbound Methods'].	Smalltalk at: #BlockContext ifPresent: [ :bc |		contexts _ bc allInstances.		contexts ifNotEmpty: [			contexts inspect. 			self inform: 'There are left-over BlockContexts'.			^self ]].	unboundMethods isEmpty ifTrue:[		self inform:'Congratulations - The bootstrap is now complete.'.	]! !!Workspace methodsFor: 'initialize-release' stamp: 'jmv 8/6/2011 23:52'!initialize		super initialize.	self initializeBindings.	mustDeclareVariables := false! !!Workspace methodsFor: 'binding' stamp: 'jmv 8/6/2011 23:53'!bindingNamesDo: aBlock	bindings keysDo: aBlock! !!Workspace methodsFor: 'binding' stamp: 'jmv 8/6/2011 23:53'!bindingOf: aString	mustDeclareVariables ifTrue: [^ nil].	(bindings includesKey: aString) ifFalse: [		aString first isUppercase			ifTrue: [^nil]			ifFalse: [bindings at: aString put: nil]].	^bindings associationAt: aString! !!Workspace methodsFor: 'binding' stamp: 'jmv 8/6/2011 23:53'!hasBindingOf: aString	^bindings includesKey: aString! !!Workspace methodsFor: 'binding' stamp: 'jmv 8/6/2011 23:54'!hasBindingThatBeginsWith: aString 	bindings keysDo: [ :each |		(each beginsWith: aString) ifTrue: [ ^true ] ].	^false! !!Workspace methodsFor: 'binding' stamp: 'jmv 8/6/2011 23:54'!initializeBindings		bindings _ Dictionary new! !Workspace removeSelector: #setBindings:!!classDefinition: #Time category: #'Kernel-Chronology'!Magnitude subclass: #Time	instanceVariableNames: 'seconds nanos'	classVariableNames: 'MillisecondClockMask'	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!SmalltalkEditor removeSelector: #evaluateSelection!SmalltalkEditor removeSelector: #evaluateSelectionAndDo:!Scanner removeSelector: #nextLiteral!Scanner removeSelector: #revertToCheckpoint:!MethodContext removeSelector: #cachedStackTop!