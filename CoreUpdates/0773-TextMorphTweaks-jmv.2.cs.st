'From Cuis 3.0 of 18 January 2011 [latest update: #768] on 19 January 2011 at 11:11:34 am'!!TextModel methodsFor: 'misc' stamp: 'jmv 1/19/2011 10:39'!refetch	"Nothing here. Answer true if actualContents was actually fetched."	^false! !!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 1/19/2011 10:39'!refetch	"Answer true if actualContents was actually fetched."	textGetter		ifNil: [			actualContents ifNil: [				actualContents _ Text new ].			^false ]		ifNotNil: [			actualContents _ Text				initialFont: Preferences standardCodeFont				stringOrText: (textProvider perform: textGetter).			^true ]! !!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 1/19/2011 11:11'!model: aTextModel	editorClass _ aTextModel editorClass.	super model: aTextModel.	textMorph		model: model wrappedTo: self viewableWidth.	styler ifNotNil: [ styler textModel: model ].	model refetch		ifTrue: [			"Do all this if stuff only if we actually fetch stuff			(for instance, in the Inspector, leave the bottom text pane alone!!)"			self formatAndStyleIfNeeded.			self setSelection: model getSelection ]! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 1/19/2011 10:42'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true 		ifTrue: [			model refetch				ifTrue: [					"Do all this if stuff only if we actually fetch stuff					(for instance, in the Inspector, leave the bottom text pane alone!!)"					self formatAndStyleIfNeeded.					self hasUnacceptedEdits: false ]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			model updatePaneIfNeeded.			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 1/19/2011 10:43'!cancel	model refetch		ifTrue: [			"Do all this if stuff only if we actually fetch stuff			(for instance, in the Inspector, leave the bottom text pane alone!!)"			self formatAndStyleIfNeeded.			self setSelection: model getSelection.			self hasUnacceptedEdits: false ]! !!TextModelMorph methodsFor: 'updating' stamp: 'jmv 1/19/2011 10:43'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #acceptedContents 		ifTrue: [			model refetch				ifTrue: [					"Do all this if stuff only if we actually fetch stuff					(for instance, in the Inspector, leave the bottom text pane alone!!)"					self formatAndStyleIfNeeded.					"Some day, it would be nice to keep objects and update them					instead of throwing them away all the time for no good reason..."					textMorph releaseParagraph.					self setSelection: model getSelection ].			^self].	aSymbol == #initialSelection 		ifTrue: [^self setSelection: model getSelection].	aSymbol == #autoSelect 		ifTrue: [			self handleEdit: [					TextEditor abandonChangeText.	"no replacement!!"					self editor						setSearch: model autoSelectString;						againOrSame: true ]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: [			self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	aSymbol == #appendEntry 		ifTrue: [			self handleEdit: [self appendEntry].			^self refreshWorld ].	aSymbol == #clearText 		ifTrue: [			self handleEdit: [self changeText: Text new].			textMorph releaseParagraph.			^self refreshWorld ].	aSymbol == #codeChangedElsewhere 		ifTrue: [			self hasEditingConflicts: true.			^self changed ].	aSymbol == #shoutStyle		ifTrue: [			self stylerStyled.			^self changed ].! !