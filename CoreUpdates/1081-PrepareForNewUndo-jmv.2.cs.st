'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 21 September 2011 at 3:30:50 pm'!!BareTextMorph methodsFor: 'anchors' stamp: 'jmv 9/19/2011 13:43'!anchorMorph: aMorph at: aPoint	| relPt |	aMorph owner == self ifTrue: [ self removeMorph: aMorph ].	self addMorphFront: aMorph.	relPt _ self internalizePosition: aPoint from: self world.	editor insertMorph: aMorph at: relPt.	self fit.! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 9/19/2011 13:47'!enterClickableRegion: evt	| index isLink |	evt hand hasSubmorphs ifTrue: [ ^self ].	paragraph ifNotNil:[		index _ (paragraph characterBlockAtPoint: evt position) stringIndex.		isLink _ (model actualContents attributesAt: index) 					anySatisfy: [ :attr | attr mayActOnClick ].		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 9/19/2011 13:47'!handleInteraction: interactionBlock	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple ParagraphEditor to Morphic keyboard events"	| oldEditor oldParagraph oldSize |	oldEditor _ editor.	oldParagraph _ paragraph.	oldSize _ model textSize.	self selectionChanged.  "Note old selection"	interactionBlock value.	(oldParagraph == paragraph) ifTrue:[		"this will not work if the paragraph changed"		editor _ oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	oldSize = model textSize		ifFalse: [ self updateFromParagraph ]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 9/19/2011 13:43'!removedMorph: aMorph	editor removeMorph: aMorph.	self fit.	super removedMorph: aMorph! !!Editor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 11:19'!selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level	string here hereChar start stop |	string _ self privateCurrentString.	string size < 2 ifTrue: [^self selectFrom: 1 to: 1].	here _ self pointIndex min: string size max: 2.	openDelimiter _ string at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: [			"delimiter is on left -- match to the right"			start _ here.			direction _ 1.			here _ here - 1.			closeDelimiter _ rightDelimiters at: match]		ifFalse: [			openDelimiter _ string at: here.			match _ rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: [					"delimiter is on right -- match to the left"					stop _ here - 1.					direction _ -1.					closeDelimiter _ leftDelimiters at: match]				ifFalse: [					"no delimiters -- select a token"					direction _ -1]].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: [			hereChar _ string at: (here _ here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: [									start _ 1.									"go right if hit string start"									direction _ 1]]						ifFalse: [							direction < 0								ifTrue: [									start _ here + 1.									"go right if hit non-token"									direction _ 1]								ifFalse: [level _ 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level _ level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level _ level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 16:54'!backspace: aKeyboardEvent	"Backspace over the last character."	"This is a user command, and generates undo"	| startIndex |	aKeyboardEvent shiftPressed ifTrue: [		"^ self backWord: aKeyboardEvent keyCharacter"		^self forwardDelete: aKeyboardEvent ].	startIndex _ self markIndex + (self hasCaret ifTrue: [0] ifFalse: [1]).	startIndex _ 1 max: startIndex - 1.	self backTo: startIndex.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 11:19'!selectAll	self selectFrom: 1 to: self privateCurrentString size! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 11:19'!selectAll: aKeyboardEvent 	"select everything, invoked by cmd-a.  1/17/96 sw"	self selectFrom: 1 to: self privateCurrentString size.	^ true! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:18'!beginningOfNextParagraph: position	| s |	s _ self privateCurrentString.	^ (s		indexOf: Character cr		startingAt: position		ifAbsent: [ s size ]) + 1! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:19'!beginningOfParagraph: position	^ (self privateCurrentString		lastIndexOf: Character cr		startingAt: position		ifAbsent: [ 0 ]) + 1.! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:19'!endOfParagraph: position	| s |	s _ self privateCurrentString.	^ s		indexOf: Character cr		startingAt: position		ifAbsent: [ s size + 1 ].! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:19'!endOfText	^self privateCurrentString size + 1! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:19'!lines	"Compute lines based on logical line breaks, not optical (which may change due to line wrapping of the editor).	Subclasses using kinds of Paragraphs can instead use the service provided by it.	"	| lines string index lineIndex stringSize |	string _ self privateCurrentString.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize _ string size.	lines _ OrderedCollection new: (string size // 15).	index _ 0.	lineIndex _ 0.	string linesDo:[:line |		lines addLast: (Array			with: (index _ index + 1)			with: (lineIndex _ lineIndex + 1)			with: (index _ index + line size min: stringSize))].	"Special workaround for last line empty."	string last == Character cr	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:19'!nextWordEnd: position	| string index |	string _ self privateCurrentString.	index _ position.	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers not ]]		whileTrue: [ index _ index + 1 ].	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers ]]		whileTrue: [ index _ index + 1 ].	^ index! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:19'!nextWordStart: position	| string index |	string _ self privateCurrentString.	index _ position.	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers ]]		whileTrue: [ index _ index + 1 ].	[ (index between: 1 and: string size) and: [(string at: index) isGenerallyValidInIdentifiers not ]]		whileTrue: [ index _ index + 1 ].	^ index! !!Editor methodsFor: 'private' stamp: 'jmv 9/19/2011 11:19'!previousWordStart: position	| string index |	string _ self privateCurrentString.	index _ position.	[ (index between: 1 and: string size) and: [ (string at: index) isGenerallyValidInIdentifiers not ]]		whileTrue: [ index _ index - 1 ].	[ (index between: 1 and: string size) and: [ (string at: index) isGenerallyValidInIdentifiers ]]		whileTrue: [ index _ index - 1 ].	^ index + 1! !!FormCanvas methodsFor: 'drawing' stamp: 'jmv 9/19/2011 11:34'!paragraph: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner _ DisplayScanner new 			text: para paragraphText			foreground: (shadowColor ifNil: [ c ])			ignoreColorChanges: self isShadowDrawing.	scanner setPort: (port clippedBy: (bounds translateBy: origin)).	para		displayOn: (self copyClipRect: bounds)		using: scanner		at: origin+ bounds topLeft! !!Paragraph methodsFor: 'access' stamp: 'jmv 9/19/2011 11:34'!paragraphText	"Not named #text just to avoid false polyphormism"	"The returned object should be treated as read-only, and never modified"	^ model actualContents! !!Paragraph methodsFor: 'composition' stamp: 'jmv 9/20/2011 08:44'!composeAll	self		composeLinesFrom: 1		to: model textSize		delta: 0		into: OrderedCollection new		priorLines: Array new		atY: container top! !!Paragraph methodsFor: 'composition' stamp: 'jmv 9/19/2011 11:33'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY 	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult composer |	composer _ TextComposer new.	editor ifNotNil: [		composer editor: editor ].	newResult _ composer				composeLinesFrom: start				to: stop				delta: delta				into: lineColl				priorLines: priorLines				atY: startingY				text: model actualContents				container: container.	lines _ newResult first asArray.	maxRightX _ newResult second.	^maxRightX! !!Paragraph methodsFor: 'composition' stamp: 'jmv 9/19/2011 11:33'!recomposeFrom: startArg to: stopArg delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed.	Expand the requested interval to include whole paragraphs because there could be paragraph attributes."	| intervalToFix start stop startLine newLines |	"Have to recompose line above in case a word-break was affected."	intervalToFix _ model actualContents encompassParagraph: (startArg to: stopArg).	start _ intervalToFix first.	stop _ intervalToFix last.	startLine _ (self lineIndexFor: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	newLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].	self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top! !!Paragraph methodsFor: 'display' stamp: 'jmv 9/19/2011 11:33'!displaySelectionStartBlock: startBlock stopBlock: stopBlock InLine: line on: aCanvas	| leftX rightX idx caretFont t b caretAttributes |	startBlock ifNil: [^self].	"No selection"	startBlock = stopBlock 		ifTrue: [			"Only show caret on line where clicked"			startBlock textLine first = line first ifFalse: [				^self ].			leftX _ startBlock left.			idx _ startBlock stringIndex.			caretAttributes _ editor ifNotNil: [ editor currentAttributes ].			caretFont _ caretAttributes				ifNil: [ model actualContents fontAt: idx ]				ifNotNil: [ model actualContents fontIfApplying: caretAttributes ].			b _ line top + line baseline + caretFont descent.			t _ line top + line baseline - caretFont ascent.			showCaret ifTrue: [				self					displayInsertionMarkAtX: leftX					top: t					bottom: b					emphasis: caretFont emphasis					on: aCanvas ]]		ifFalse: [			"Test entire selection before or after here"			(stopBlock stringIndex < line first 				or: [startBlock stringIndex > (line last + 1)])					ifTrue: [^self].	"No selection on this line"			(stopBlock stringIndex = line first 				and: [stopBlock textLine ~= line])					ifTrue: [^self].	"Selection ends on line above"			(startBlock stringIndex = (line last + 1) 				and: [stopBlock textLine ~= line])					ifTrue: [^self].			lastCaretRect _ nil.			lastCaretRectNeedsRedraw _ false.			leftX _ (startBlock stringIndex < line first 				ifTrue: [ line ]				ifFalse: [ startBlock ]) left.			rightX _ (stopBlock stringIndex > (line last + 1) or: [					stopBlock stringIndex = (line last + 1) 						and: [stopBlock textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [stopBlock left].			aCanvas				fillRectangle: (leftX @ line top corner: rightX @ line bottom)				colorOrInfiniteForm: self selectionColor].	"Selection begins on line below"! !!Paragraph methodsFor: 'editing' stamp: 'jmv 9/19/2011 11:32'!clickAt: clickPoint	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action target range boxes box t |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	t _ model actualContents.	(t attributesAt: startBlock stringIndex) do: [ :att | 		att mayActOnClick ifTrue:				[(target _ model) ifNil: [ target _ editor morph].				range _ t rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint] ifNone: nil.				box ifNotNil: [					box _ editor morph displayBounds.					editor morph allOwnersDo: [ :m | box _ box intersect: (m displayBounds) ].					Utilities						awaitMouseUpIn: box						repeating: nil						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action _ true]].					Cursor currentCursor == Cursor webLink ifTrue:[Cursor normal show].				]]].	^ action! !!Paragraph methodsFor: 'selection' stamp: 'jmv 9/19/2011 11:32'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: model actualContents)		characterBlockAtPoint: aPoint index: nil		in: line! !!Paragraph methodsFor: 'selection' stamp: 'jmv 9/19/2011 11:32'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line t |	line _ lines at: (self lineIndexFor: index).	t _ model actualContents.	^ (CharacterBlockScanner new text: t)		characterBlockAtPoint: nil index: ((index max: line first) min: t size+1)		in: line! !!Paragraph methodsFor: 'selection' stamp: 'jmv 9/19/2011 11:33'!defaultCharacterBlock	^ CharacterBlock		stringIndex: 1		text: model actualContents		topLeft: lines first topLeft		extent: 0 @ 0		textLine: lines first! !!Paragraph methodsFor: 'private' stamp: 'jmv 9/19/2011 11:12'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last cr str |	str _ model actualContents string.	cr _ Character cr.	arrayIndex _ lineIndex.	[		first _ (lines at: arrayIndex) first.		 first > 1 and: [(str at: first - 1) ~~ cr] ] whileTrue: [ "word wrap"			arrayIndex _ arrayIndex - 1].	last _ (lines at: arrayIndex) last.		^(str copyFrom: first to: last) indentationIfBlank: aBlock.! !!Parser methodsFor: 'error correction' stamp: 'jmv 9/19/2011 14:11'!pasteTempAtMethodLevel: name	| insertion delta theTextString  characterBeforeMark |	theTextString := requestor text string.	characterBeforeMark := theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion := name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion := ' ', insertion].		delta := 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion := '| ' , name , ' |',String cr.		delta := 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion := insertion , String tab.			delta := delta + 1.	"the tab"		].	].	tempsMark := tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta! !!SimpleEditor methodsFor: 'private' stamp: 'jmv 9/20/2011 08:46'!privateCurrentString	"Answer the string I'm editing. Private. Just for internal Editor use."	^string! !!Text methodsFor: 'emphasis' stamp: 'jmv 9/19/2011 17:26'!addAttribute: aTextAttribute from: requestedStart to: requestedStop	"Set the attribute for characters in the interval start to stop."	| intervalToFix start stop |	start _ requestedStart.	stop _ requestedStop.		"If aTextAttribute must be applied to whole paragraphs, do so."	aTextAttribute isParagraphAttribute ifTrue: [		intervalToFix _ self encompassParagraph: (start to: stop).		start _ intervalToFix first.		stop _ intervalToFix last ].	self privateSetRuns: (runs		copyReplaceFrom: start		to: stop		with: ((runs copyFrom: start to: stop) mapValues: [ :attributes | 			Text addAttribute: aTextAttribute toArray: attributes])).	runs coalesce! !!Text methodsFor: 'emphasis' stamp: 'jmv 9/19/2011 17:26'!removeAttribute: aTextAttribute 	^ self removeAttribute: aTextAttribute from: 1 to: self size! !!Text methodsFor: 'emphasis' stamp: 'jmv 9/19/2011 17:27'!removeAttribute: aTextAttribute from: requestedStart to: requestedStop	"Remove the attribute over the interval start to stop."	| intervalToFix start stop |	start _ requestedStart.	stop _ requestedStop.		"If att must be applied to whole paragraphs, do so."	aTextAttribute isParagraphAttribute ifTrue: [		intervalToFix _ self encompassParagraph: (start to: stop).		start _ intervalToFix first.		stop _ intervalToFix last ].	self privateSetRuns: (runs		copyReplaceFrom: start		to: stop		with: ((runs copyFrom: start to: stop) mapValues: [ :attributes | 			attributes copyWithout: aTextAttribute ])).	runs coalesce! !!Text class methodsFor: 'instance creation' stamp: 'jmv 9/19/2011 17:27'!initialFont: aStrikeFont string: aString attribute: aTextAttribute	"Answer an instance of me whose characters are aString.	Note: use #baseFont. If emphasis is desired, add it separatedly."	^self		string: aString		attributes: {TextFontFamilyAndSize			familyName: aStrikeFont familyName			pointSize: aStrikeFont pointSize.			aTextAttribute}! !!Text class methodsFor: 'instance creation' stamp: 'jmv 9/19/2011 17:28'!string: aString attribute: aTextAttribute	"Answer an instance of me whose characters are aString."	^self string: aString attributes: (Array with: aTextAttribute)! !!Text class methodsFor: 'private' stamp: 'jmv 9/19/2011 17:27'!addAttribute: aTextAttribute toArray: others	"Add a new text attribute to an existing set"	"NOTE: The use of reset and isSet in this code is a specific	hack for merging TextKerns.	(jmv: it also means that TextEmphasis normal is not added. Same for TextColor black)"	aTextAttribute reset.	^ Array streamContents: [ :strm |		others do: [ :other |			(aTextAttribute dominates: other) ifFalse: [strm nextPut: other ]].		aTextAttribute isSet ifTrue: [ strm nextPut: aTextAttribute ]]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 13:58'!currentAttributes	| i |	i _ self startIndex.	^i > model textSize		ifTrue: [			emphasisHere ]		ifFalse: [			"paragraph attributes at the current paragraph will later be applied.			include them in the answer"			(emphasisHere reject: [ :attr | attr isParagraphAttribute ]),				((model actualContents attributesAt: i) select: [ :attr | attr isParagraphAttribute ]) ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 13:57'!currentCharacterStyleOrNil	"Answer the CharacterStyle for the current selection or cursor location if any"	^self hasSelection		ifTrue: [ model actualContents characterStyleOrNilAt: self startIndex ]		ifFalse: [ model actualContents characterStyleOrNilIfApplying: emphasisHere ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 13:57'!currentParagraphStyle	"Answer the ParagraphStyle for the current selection or cursor location if any"		| i |	i _ self startIndex.	^i > model textSize		ifTrue: [ model actualContents paragraphStyleOrNilIfApplying: emphasisHere ]		ifFalse: [ model actualContents paragraphStyleOrNilAt: i ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 14:01'!lastFont	"Answer the Font for to be used if positioned at the end of the text"	^self startIndex > model textSize		ifTrue: [ model actualContents fontIfApplying: emphasisHere ]		ifFalse: [ model actualContents fontAt: model textSize +1 ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 14:01'!lastParagraphStyleOrNil	"Answer the ParagraphStyle for to be used if positioned at the end of the text"	^self startIndex > model textSize		ifTrue: [ model actualContents paragraphStyleOrNilIfApplying: emphasisHere ]		ifFalse: [ model actualContents paragraphStyleOrNilAt: model textSize +1 ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 16:55'!replace: anInterval with: newText and: selectingBlock 	"Replace the text in anInterval with newText and execute selectingBlock to establish the new selection."	"This is a user command, and generates undo"	| currentInterval |	currentInterval _ self selectionInterval.	currentInterval = anInterval ifFalse: [ self selectInterval: anInterval ].	self zapSelectionWith: newText.	selectingBlock value! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 16:56'!replaceSelectionWith: aTextOrString	"Deselect, and replace the selection text by aText."	"This is a user command, and generates undo"	self zapSelectionWith: aTextOrString.! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 14:11'!text	"The returned object should be treated as read-only, and never modified"	^ model actualContents! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 9/19/2011 14:02'!selection	"Answer the text that is currently selected."	| t |	t _ model actualContents.	^Text streamContents: [ :strm |		"Multiple selection"		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock | | toAppend |			toAppend _ t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1.			toAppend size > 0 ifTrue: [				strm nextPutAll: toAppend.				strm withAttributes: (toAppend attributesAt: toAppend size) do: [ strm cr ]]].		"Regular selection"		strm nextPutAll: ( t copyFrom: self startIndex to: self stopIndex - 1 ) ]! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 9/19/2011 11:20'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently  selected."	^ReadWriteStream		on: self privateCurrentString		from: self startIndex		to: self stopIndex - 1! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 9/19/2011 17:22'!changeEmphasisOrAlignment	"This is a user command, and generates undo"	| menuStrings aList reply code align menuList startIndex attribute |	startIndex _ self startIndex.	aList _ #(normal bold italic underlined struckThrough leftFlush centered rightFlush justified).	align _ model actualContents alignmentAt: startIndex.	code _ model actualContents emphasisAt: startIndex.	menuList _ WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal'.	menuList nextPutAll: (#(bold italic underlined struckThrough) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue: [ '<on>', emph asString ]			ifFalse: [ '<off>', emph asString ]]).	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collectWithIndex: [ :type :i |		align = (i-1)			ifTrue: [ '<on>', type asString ]			ifFalse: [ '<off>', type asString ]]).	menuStrings _ menuList contents.	aList _ #(normal bold italic underlined struckThrough leftFlush centered rightFlush justified).	reply _ (SelectionMenu labelList: menuStrings lines: #(1 5) selections: aList) startUpWithoutKeyboard.	reply ifNotNil: [		(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue: [				attribute _TextAlignment perform: reply]			ifFalse: [				attribute _ TextEmphasis perform: reply].		((menuStrings at: (aList indexOf: reply)) beginsWith: '<on>')			ifTrue: [ self unapplyAttribute: attribute ]			ifFalse: [ self applyAttribute:  attribute ]].	^ true! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 9/19/2011 17:23'!changeTextFont	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.	Note: use #baseFont. If emphasis is desired, add it separatedly."	"This is a user command, and generates undo"	| curFont newFont attr startIndex |	startIndex _ self startIndex.	curFont _ model actualContents fontAt: startIndex.	newFont _ StrikeFont fromUser: curFont.	newFont ifNil: [ ^self ].	attr _ TextFontFamilyAndSize			familyName: newFont familyName			pointSize: newFont pointSize.	self applyAttribute: attr! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 9/19/2011 17:23'!offerColorMenu	"Present a menu of available colors, and if one is chosen, apply it to the current selection."	"This is a user command, and generates undo"	| attribute colors index thisSel |	thisSel _ self selection.	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).	index _ (PopUpMenu		labelArray: colors , #('choose color...' )		lines: (Array with: colors size + 1)) startUp.	index = 0 ifTrue: [ ^ true ].	index <= colors size		ifTrue: [ attribute _ TextColor color: (Color perform: (colors at: index)) ]		ifFalse: [			index _ index - colors size - 1.			"Re-number!!!!!!"			index = 0 ifTrue: [ attribute _ self chooseColor ].			thisSel ifNil: [ ^ true ]].	attribute ifNotNil: [ self applyAttribute: attribute ].	^ true.! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 17:22'!changeEmphasis: aKeyboardEvent	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis."	"control 0..9 -> 0..9"	"This is a user command, and generates undo"	| keyCode attributeToAdd attributeToRemove oldAttributes |	keyCode _ ('0123456'		indexOf: aKeyboardEvent keyCharacter		ifAbsent: [ 1 ]) - 1.	oldAttributes _ emphasisHere.	keyCode = 0 ifTrue: [ attributeToAdd _ TextEmphasis normal ].	(keyCode between: 1 and: 4) ifTrue: [		attributeToAdd _ TextEmphasis perform: (#(#bold #italic #underlined #struckThrough ) at: keyCode).		oldAttributes do: [ :oldAtt |			oldAtt = attributeToAdd ifTrue: [				attributeToAdd _ nil.				attributeToRemove _ oldAtt ]]].	keyCode = 5 ifTrue: [ attributeToAdd _ TextKern kern: -1 ].	keyCode = 6 ifTrue: [ attributeToAdd _ TextKern kern: 1 ].	attributeToAdd ifNotNil: [ self applyAttribute: attributeToAdd ].	attributeToRemove ifNotNil: [ self unapplyAttribute: attributeToRemove ].	^ true.! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 16:57'!changeLfToCr: aKeyboardEvent	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites	jmv- Modified to als change crlf by cr"	"This is a user command, and generates undo"		| fixed |	fixed _ self selection string.	fixed _ fixed copyReplaceAll: String crlf with: String cr.	fixed _ fixed copyReplaceAll: String lf with: String cr. 	self replaceSelectionWith: fixed.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 16:58'!enclose: aKeyboardEvent	"Insert or remove bracket characters around the current selection."	"This is a user command, and generates undo"	| left right startIndex stopIndex oldSelection which |	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	((startIndex > 1 and: [stopIndex <= model textSize])			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 14:00'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList _ model actualContents attributesAt: (self pointIndex + self markIndex)//2.	attrList do: [:attr |		attr forTextActionInfoDo: [ :info |			^ self selection asString, '<', info, '>']].	"If none of the above"	attrList do: [:attr |		attr forTextColorDo: [ :color |			^ self selection asString, '<', color printString, '>']].	^ self selection asString, '[No hidden info]'! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 16:58'!inOutdent: aKeyboardEvent delta: delta	"Add/remove a tab at the front of every line occupied by the selection. 	Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	"This is a user command, and generates undo"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |	cr _ Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart _ self startIndex.	realStop _ self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and: [				realStart < 2 or: [(self privateCurrentString at: realStart - 1) == cr]])		ifTrue: [			delta < 0				ifTrue: [					morph flash]				ifFalse: [					self replaceSelectionWith: Character tab asSymbol.					self selectAt: realStart + 1].			^true].	lines _ paragraph lines.	startLine _ paragraph lineIndexFor: realStart.	stopLine _ paragraph lineIndexFor: (realStart max: realStop).	start _ (lines at: startLine) first.	stop _ (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart _ realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation _ (startLine to: stopLine) inject: 1000 into: [ :previousValue :each |		previousValue min: (paragraph indentationOfLineIndex: each ifBlank: [ :tabs | 1000 ])].				size _  stop + 1 - start.	numLines _ stopLine + 1 - startLine.	inStream _ ReadStream on: self privateCurrentString from: start to: stop.	newString _ String new: size + ((numLines * delta) max: 0).	outStream _ ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].	realStop _ realStop + outStream position - size.	"Prepare for another iteration"	indentation _ indentation + delta.	size _ outStream position.	inStream _ outStream setFrom: 1 to: size.	outStream		ifNil: [ 	"tried to outdent but some line(s) were already left flush"			morph flash]		ifNotNil: [			self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString _ outStream contents].			self replaceSelectionWith: newString].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 16:58'!makeCapitalized: aKeyboardEvent	"Force the current selection to uppercase.  Triggered by Cmd-X."	"This is a user command, and generates undo"	| prev |	prev _ $-.  "not a letter"	self replaceSelectionWith: 		(self selection string collect:			[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]]).	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 16:59'!makeLowercase: aKeyboardEvent	"Force the current selection to lowercase.  Triggered by Cmd-X."	"This is a user command, and generates undo"	self replaceSelectionWith: (self selection string asLowercase).	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 16:59'!makeUppercase: aKeyboardEvent	"Force the current selection to uppercase.  Triggered by Cmd-Y."	"This is a user command, and generates undo"	self replaceSelectionWith: (self selection string asUppercase).	^ true! !!TextEditor methodsFor: 'events' stamp: 'jmv 9/20/2011 08:43'!doubleClick: evt	| here |	here _ self pointIndex.	(here between: 2 and: model textSize)		ifTrue: [ self selectWord ]		ifFalse: [			"if at beginning or end, select entire string"			^self selectAll ].! !!TextEditor methodsFor: 'events' stamp: 'jmv 9/19/2011 10:06'!mouseDown: evt 	| clickPoint b |	"Multiple selection of text.	Windows uses Control, Mac uses Command (i.e. commandAlt)	On the Mac, command-button1 is translated to command-button3 by the VM. do:		Preferences disable: #commandClickOpensHalo	to disable this behavior and make command-button1 work for multiple selection. "	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [		self selectionInterval size > 0 ifTrue: [			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]	ifFalse: [		selectionStartBlocks _ #().		selectionStopBlocks _ #() ]	.	clickPoint _ evt position.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint) ifTrue: [		markBlock _ b.		pointBlock _ b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			markBlock _ b.			pointBlock _ b ]! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 17:22'!changeAlignment	"This is a user command, and generates undo"	| aList reply  |	aList _ #(leftFlush centered justified rightFlush).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ifNil:[^self].	self applyAttribute: (TextAlignment perform: reply).	^ true! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 11:20'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardStringOrText string.	s2 _ self privateCurrentString.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(TextModel new contents:		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))			openLabel: 'Comparison to Clipboard Text'! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 16:51'!cut	"Cut out the current selection and redisplay the paragraph if necessary."	"This is a user command, and generates undo"	| multiSelection |	selectionStartBlocks ifEmpty: [		self lineSelectAndEmptyCheck: [^ self]].	multiSelection _ self selection.	self zapMultiSelection.	self replaceSelectionWith: self nullText.	self clipboardTextPut: multiSelection.! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 16:56'!afterSelectionInsertAndSelect: aString	"This is a user command, and generates undo"	self insertAndSelect: aString at: self stopIndex ! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 16:57'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	"This is a user command, and generates undo"	| userSelection delta loc str |	aString = '#insert period' ifTrue: [		loc _ start.		str _ self privateCurrentString.		[(loc _ loc-1)>0 and: [(str at: loc) isSeparator]]			whileTrue: [loc _ loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	userSelection _ self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString.	delta _ aString size - (stop - start + 1).	self		selectInvisiblyFrom: userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ])! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 16:55'!insertAndSelect: aString at: anInteger	"This is a user command, and generates undo"	self replace: (anInteger to: anInteger - 1)		with: (Text string: (' ' , aString)					attributes: emphasisHere)		and: [self ]! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 14:14'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	(self hasSelection or: [ selectionStartBlocks notEmpty]) ifTrue:[^self].	self selectInterval: (model actualContents encompassLine: self selectionInterval)! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 9/19/2011 16:33'!blinkParen	"Used if Shout"	lastParenLocation ifNotNil: [		model textSize >= lastParenLocation ifTrue: [			model privateAddBoldAt: lastParenLocation ]]! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 9/19/2011 16:33'!blinkParenAt: parenLocation	model privateAddBoldAt: parenLocation.	lastParenLocation _ parenLocation! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 9/19/2011 11:20'!blinkPrevParen: aKeyboardEvent	"Used if not Shout"	| openDelimiter closeDelimiter level string here hereChar |	string _ self privateCurrentString.	here _ pointBlock stringIndex.	openDelimiter _ aKeyboardEvent keyCharacter.	closeDelimiter _ '([{' at: (')]}' indexOf: openDelimiter).	level _ 1.	[level > 0 and: [here > 1]]		whileTrue:			[hereChar _ string at: (here _ here - 1).			hereChar = closeDelimiter				ifTrue:					[level _ level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level _ level + 1]]]! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 9/20/2011 08:42'!clearParens	lastParenLocation ifNotNil: [		model textSize >= lastParenLocation ifTrue: [			model privateRemoveBoldAt: lastParenLocation ]].	lastParenLocation _ nil! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 9/19/2011 16:52'!addString: aString	"Think of a better name"	"This is a user command, and generates undo"	self zapSelectionWith: aString! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 9/19/2011 16:54'!backTo: startIndex	"During typing, backspace to startIndex."	"This is a user command, and generates undo"	self markIndex: startIndex.	self zapSelectionWith: self nullText.	markBlock _ pointBlock! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 9/19/2011 14:16'!setEmphasisHereFromTextForward: f	| i forward delta prevIsSeparator nextIsSeparator |	i _ self pointIndex.	"Try to set emphasisHere correctly after whitespace.	Most important after a cr, i.e. at the start of a new line"	prevIsSeparator _  i > 1 and: [ (model actualContents at: i-1) isSeparator ].	nextIsSeparator _ i <= model textSize and: [ (model actualContents at: i) isSeparator ].	forward _ prevIsSeparator = nextIsSeparator		ifTrue: [ f ]		ifFalse: [ nextIsSeparator ].	delta _ forward ifTrue: [ 1 ] ifFalse: [ 0 ].	emphasisHere _ (model actualContents attributesAt: (i - delta max: 1))					select: [:att | att mayBeExtended].	morph possiblyChanged ! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 16:54'!backWord: aKeyboardEvent	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else, delete the word before the caret."	"This is a user command, and generates undo"	| startIndex |	self hasCaret ifTrue: [ "a caret, delete at least one character"		startIndex _ 1 max: self markIndex - 1.		[startIndex > 1 and:			[(self privateCurrentString at: startIndex - 1) tokenish]]				whileTrue: [					startIndex _ startIndex - 1]]	ifFalse: [ "a non-caret, just delete it"		startIndex _ self markIndex].	self backTo: startIndex.	^false! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/20/2011 08:42'!forwardDelete: aKeyboardEvent	"Delete forward over the next character."	"This is a user command, and generates undo"	| startIndex stopIndex |	startIndex _ self markIndex.	startIndex > model textSize ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	stopIndex _ startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	^false! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 17:01'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	"This is a user command, and generates undo"	| where |	where _ model actualContents		findString: FindText		startingAt: self stopIndex		caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	selectionStartBlocks add: (paragraph characterBlockForIndex: where).	selectionStopBlocks add: (paragraph characterBlockForIndex: where + FindText size).	self selectInvisiblyFrom: where to: where + FindText size - 1.	"Repeat it here. Senders beware: only one of these should last"	ChangeText ~~ FindText ifTrue: [ self zapSelectionWith: ChangeText ].	indices nextPut: where.	^ true! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 16:57'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	"This is a user command, and generates undo"	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: [ "Choose as FindText..."		"jmvNote: must fix this!!"		FindText _ ''.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: [ "just inserted at a caret"			home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: [ "Show where the search will start"			home last = self selectionInterval last ifFalse: [				self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	selectionStartBlocks _ OrderedCollection new.	selectionStopBlocks _ OrderedCollection new.	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	"Last find was also stored in markBlock / pointBlock"	selectionStartBlocks notEmpty ifTrue: [		selectionStartBlocks removeLast.		selectionStopBlocks removeLast ].	indices isEmpty ifTrue: [  "none found"		self flash.		wasTypedKey ifFalse: [^self]]! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 17:23'!applyAttribute: aTextAttribute	"The user selected aTextAttribute via shortcut, menu or other means.	If there is a selection, apply the attribute to the selection.	In any case use the attribute for the user input (emphasisHere)"	"This generates undo"	| interval |	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.	interval _ self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].	model addAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	self userHasEdited.	morph possiblyChanged! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/20/2011 08:46'!privateCurrentString	"Answer the string I'm editing. Private. Just for internal Editor use."	^model actualContents string! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 17:29'!unapplyAttribute: aTextAttribute	"The user selected aTextAttribute to be removed.	If there is a selection, unapply the attribute to the selection.	In any case do not use the attribute for the user input (emphasisHere)"	"This generates undo"	| interval |	emphasisHere _ emphasisHere copyWithout: aTextAttribute.	interval _ self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].	model removeAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	morph possiblyChanged! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 17:03'!zapMultiSelection	"This generates undo"	| delta intervals mi pi start stop miAndPiUpdated |	miAndPiUpdated _ false.	mi _ self markIndex.	pi _ self pointIndex.	delta _ 0.	intervals _ (selectionStartBlocks with: selectionStopBlocks		collect: [ :strt :stp | strt stringIndex to: stp stringIndex ])			sorted: [ :a :b | a first < b first ].	intervals do: [ :interval |		miAndPiUpdated not ifTrue: [			interval first > mi				ifTrue: [					miAndPiUpdated _ true.					mi _ mi + delta.					pi _ pi + delta ]				ifFalse: [					interval last > mi ifTrue: [						miAndPiUpdated _ true.						mi _ interval first + delta.						pi _ mi ]]].		start _  interval first+delta.		stop _ interval last - 1 + delta.		model replaceFrom: start to: stop with: ''.		delta _ delta - (interval size-1).		paragraph			recomposeFrom: start			to:  start - 1			delta: delta ].	miAndPiUpdated not ifTrue: [		mi _ mi + delta.		pi _ pi + delta ].	selectionStartBlocks _ #().	selectionStopBlocks _ #().	self markIndex: mi pointIndex: pi! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 17:03'!zapSelectionWith: aTextOrString	"This generates undo"	| start stop replacement |	start _ self startIndex.	stop _ self stopIndex.	(aTextOrString isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (model actualContents attributesAt: start) select: [:att |			att mayBeExtended]].	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [		replacement _ self addAttributesForPasting: aTextOrString.		model replaceFrom: start to: stop - 1 with: replacement.		paragraph			recomposeFrom: start			to:  start + replacement size - 1			delta: replacement size - (stop-start).		self markIndex: start pointIndex: start + replacement size.		selectionStartBlocks _ #().		selectionStopBlocks _ #().		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged! !!TextEditor methodsFor: 'commands' stamp: 'jmv 9/20/2011 08:57'!insertMorph: aMorph at: relPt	"This is a user command, and generates undo"	| index newText |	"Warning: As undo will only be done for text in the model, undoing this will neither	kill the morph nor send it to another owner!! See implementors of #removeMorph: in TextMorphs.	A specific undo for inserting / removing morphs might be in order. But I doubt the	TextModel should be responsible for that."	self flag: #newundo.	index _ (paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ ' ', (Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aMorph)), ' '.	model replaceFrom: index to: index-1 with: newText.	paragraph recomposeFrom: index to: index + newText size -1 delta: newText size.! !!TextEditor methodsFor: 'commands' stamp: 'jmv 9/20/2011 08:56'!removeMorph: aMorph	"This is a user command, and generates undo"	| range |	"Warning: As undo will only be done for text in the model, undoing this will neither	recreate the morph nor add it to the TextMorph!! (See senders of #insertMorph:at:	A specific undo for inserting / removing morphs might be in order. But I doubt the	TextModel should be responsible for that."	self flag: #newundo.	range _ model actualContents find: (TextAnchor new anchoredFormOrMorph: aMorph).	range ifNotNil: [		model replaceFrom: range first to: range last with: Text new.		paragraph recomposeFrom: range first to: range first  -1 delta: range size negated ]! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 9/19/2011 16:55'!pasteInitials: aKeyboardEvent 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor."	"This is a user command, and generates undo"	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 13:53'!argAdvance: aKeyboardEvent	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.."	| start t |	t _ model actualContents.	start _ t findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [ start _ t size + 1].	self selectAt: start + 2.	^true! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 11:20'!crWithIndent: aKeyboardEvent	"Replace the current text selection with CR followed by as many tabs	as there are leading tabs on the current line (+/- bracket count)."	| char s i tabCount stopIndex |	s _ self privateCurrentString.	stopIndex _ self stopIndex.	i _ stopIndex.	tabCount _ 0.	[ (i _ i-1) > 0 and: [ (char _ s at: i) ~= Character cr ] ] whileTrue: [		"Count brackets"		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	[ (i _ i + 1) < stopIndex and: [ (char _ s at: i) isSeparator ] ] whileTrue: [		"Count leading tabs"		char = Character tab ifTrue: [ tabCount _ tabCount + 1 ]].	"Now inject CR with tabCount tabs"	self addString: (String streamContents: [ :strm | strm crtab: tabCount ]).	^ false! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 11:20'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc _ start + dir.	str _ self privateCurrentString.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc _ loc + dir].	^ loc! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 16:56'!notify: aString at: anInteger in: aStream 	"The compilation of text failed. The syntax error is noted as the argument, 	aString. Insert it in the text at starting character position anInteger."	"This is a user command, and generates undo"	| pos |	"This seems not to be needed..."	"	pos _ self selectionInterval notEmpty		ifTrue: [			self startIndex + anInteger - 1 ]		ifFalse: [anInteger].	"	pos _ anInteger.	self insertAndSelect: aString at: (pos max: 1)! !!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 11:20'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok _ false.	string _ self privateCurrentString.	stop _ self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop _ stop - 1].	sep _ stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok _ true. sep _ sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!SmalltalkEditor methodsFor: 'accessing-selection' stamp: 'jmv 9/19/2011 13:53'!selection	"Answer the text that is currently selected.	Redefined for Smalltalk code: if there's no regular selection, and all the selectionBlocks contain the same string,	answer that string."	| t regularSelection allPartsEqual samePart |	t _ model actualContents.	regularSelection _ ( t copyFrom: self startIndex to: self stopIndex - 1 ).	allPartsEqual _ true.	samePart _ nil.	^Text streamContents: [ :strm |		"Multiple selection"		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock | | toAppend |			toAppend _ t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1.			toAppend size > 0 ifTrue: [				samePart					ifNil: [ samePart _ toAppend ]					ifNotNil: [						allPartsEqual _ allPartsEqual and: [ samePart = toAppend ]].				strm nextPutAll: toAppend.				strm withAttributes: (toAppend attributesAt: toAppend size) do: [ strm cr ]].			].		(allPartsEqual and: [ regularSelection isEmpty ]) ifTrue: [			^samePart ifNil: ['']].		"Regular selection"		strm nextPutAll: regularSelection ]! !!TextModel methodsFor: 'accessing' stamp: 'jmv 9/19/2011 13:47'!textSize	^actualContents size! !!TextModel methodsFor: 'testing' stamp: 'jmv 9/20/2011 08:41'!isTextEmpty	^actualContents isEmpty! !!TextModel methodsFor: 'shout support' stamp: 'jmv 9/19/2011 16:33'!privateAddBoldAt: idx	"Just for shout. No undo."	actualContents 		addAttribute: TextEmphasis bold		from: idx		to: idx! !!TextModel methodsFor: 'shout support' stamp: 'jmv 9/19/2011 16:32'!privateRemoveBoldAt: idx	"Just for shout. No undo."	actualContents 		removeAttribute: TextEmphasis bold		from: idx		to: idx! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/19/2011 17:25'!addAttribute: aTextAttribute from: requestedStart to: requestedStop	"As requested."	"quizas, para todos estos, que forwardean tal cual al texto, un cambio al selector, para que sea explicito!!!!!!"self flag: #newundo print.thisContext print.(requestedStart to: requestedStop) print.aTextAttribute print.	actualContents addAttribute: aTextAttribute from: requestedStart to: requestedStop! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/19/2011 17:24'!removeAttribute: aTextAttribute from: requestedStart to: requestedStop	"As requested."	"quizas, para todos estos, que forwardean tal cual al texto, un cambio al selector, para que sea explicito!!!!!!"self flag: #newundo print.thisContext print.(requestedStart to: requestedStop) print.aTextAttribute print.	actualContents removeAttribute: aTextAttribute from: requestedStart to: requestedStop! !!TextModel methodsFor: 'undoable commands' stamp: 'jmv 9/19/2011 17:19'!replaceFrom: start to: stop with: replacement	"As requested."self flag: #newundo print.thisContext print.(start to: stop) print.replacement print.	actualContents replaceFrom: start to: stop with: replacement! !!TextModelMorph methodsFor: 'model access' stamp: 'jmv 9/19/2011 11:04'!text	"The returned object should be treated as read-only, and never modified"	^ model actualContents! !!TextStream methodsFor: 'as yet unclassified' stamp: 'jmv 9/19/2011 17:28'!applyAttribute: aTextAttribute beginningAt: startPos	collection addAttribute: aTextAttribute from: startPos to: self position! !!TextStream methodsFor: 'as yet unclassified' stamp: 'jmv 9/19/2011 17:28'!withAttribute: aTextAttribute do: strmBlock	| pos1 val |	pos1 _ self position.	val _ strmBlock value.	collection addAttribute: aTextAttribute from: pos1+1 to: self position.	^ val! !TextEditor removeSelector: #string!SimpleEditor removeSelector: #string!Paragraph removeSelector: #clickAt:for:!Paragraph removeSelector: #string!Paragraph removeSelector: #text!BareTextMorph removeSelector: #text!Smalltalk removeClassNamed: #TextPrintIt!