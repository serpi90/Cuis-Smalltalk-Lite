'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 8 April 2011 at 9:05:39 am'!!CharacterScanner methodsFor: 'private' stamp: 'jmv 4/7/2011 13:21'!setFont	| priorFont attributes |	"Set the font and other emphasis.	In fact set actual ParagraphStyle (or nil), alignment, font and emphasis"		priorFont _ font.	self setActualFont: (text fontAt: lastIndex).	attributes _ text attributesAt: lastIndex.	text		withFormattingAttributeValues: attributes		do: [ :familyNameInText :pointSizeInText :emphasisInText :kernInText :colorInText :alignmentInText :characterStyleInText :paragraphStyleInText |			colorInText ifNotNil: [ self textColor: colorInText ].			alignment _ alignmentInText.			kern _ kernInText.			paragraphStyle _ paragraphStyleInText ].		"Hardcoded color for TextAction"	attributes do: [ :attribute |		attribute forTextActionInfoDo: [ :info | self textColor: TextAction textActionColor ]].		priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].	destX _ destX - font descentKern.	kern _ kern - font baseKern.	"Install various parameters from the font."	spaceWidth _ font widthOf: Character space.	xTable _ font xTable.	map _ font characterToGlyphMap.	stopConditions _ DefaultStopConditions! !!CompositionScanner methodsFor: 'scanning' stamp: 'jmv 4/7/2011 11:15'!composeFrom: startIndex inRectangle: lineRectangle firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition xtraSpaceBefore spaceAfterParagraph |		lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font, style, etc"	"Set up margins"	leftMargin _ lineRectangle left.	rightMargin _ lineRectangle right.	xtraSpaceBefore _ 0.	spaceAfterParagraph _ 0.	paragraphStyle ifNotNil: [		leftSide ifTrue: [			leftMargin _ leftMargin +				((firstLine and: [ paragraphStyle isListStyle not ])					ifTrue: [ paragraphStyle firstIndent ]					ifFalse: [ paragraphStyle restIndent ])].		rightSide ifTrue: [			rightMargin _ rightMargin - paragraphStyle rightIndent].		firstLine ifTrue: [ xtraSpaceBefore _ paragraphStyle spaceBefore ].		spaceAfterParagraph _ paragraphStyle spaceAfter ].	destX _ spaceX _ leftMargin.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	line isFirstLine: firstLine.	spaceCount _ 0.	leftMargin _ destX.	line leftMargin: leftMargin.	done _ false.	self placeEmbeddedObject.	[ done ]		whileFalse: [			stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition) ifTrue: [				^ line 					lineHeight: lineHeight + xtraSpaceBefore + 						(stopCondition = #cr ifTrue: [spaceAfterParagraph] ifFalse: [0]) 					baseline: baseline + xtraSpaceBefore ]]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 13:22'!alignmentAt: characterIndex	self		withFormattingAttributeValues: (self attributesAt: characterIndex)		do: [ :familyName :pointSize :emphasis :kern :color :alignment :characterStyle :paragraphStyle |			^ alignment ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 13:23'!characterStyleOrNilAt: characterIndex	self		withFormattingAttributeValues: (self attributesAt: characterIndex)		do: [ :familyName :pointSize :emphasis :kern :color :alignment :characterStyle :paragraphStyle |			^ characterStyle ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 13:23'!characterStyleOrNilIfApplying: textAttributes	"Answer the ParagraphStyle for characters as specified by the argument."		self withFormattingAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :kern :color :alignment :characterStyle :paragraphStyle |		^characterStyle ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 13:23'!emphasisAt: characterIndex	"Answer the emphasis for characters in the run beginning at characterIndex."	self		withFormattingAttributeValues: (self attributesAt: characterIndex)		do: [ :familyName :pointSize :emphasis :kern :color :alignment :characterStyle :paragraphStyle |			^ emphasis ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 13:27'!fontIfApplying: textAttributes	"Answer the font for characters as specified by the argument.	Note: Does -not- include kern."	self withFormattingAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :kern :color :alignment :characterStyle :paragraphStyle |		^((AbstractFont familyName: familyName pointSize: pointSize) ifNil: [ AbstractFont default baseFont ])			emphasized: emphasis ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 13:24'!paragraphStyleOrNilAt: characterIndex	self		withFormattingAttributeValues: (self attributesAt: characterIndex)		do: [ :familyName :pointSize :emphasis :kern :color :alignment :characterStyle :paragraphStyle |			^ paragraphStyle ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 13:24'!paragraphStyleOrNilIfApplying: textAttributes	"Answer the ParagraphStyle for characters as specified by the argument."		self		withFormattingAttributeValues: textAttributes		do: [ :familyName :pointSize :emphasis :kern :color :alignment :characterStyle :paragraphStyle |			^paragraphStyle ]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/7/2011 11:23'!withFormattingAttributeValues: attributes do: aBlock	"Evaluate aBlock with the values of various attributes that affect text formatting, applied in the correct order	The order is (each overwriting the previous one)	1) basic defaults	2) ParagraphStyleReferene	3) CharacterStyleReference	4) TextFontReference	5) TextEmphasis"	| paragraphStyle characterStyle familyName pointSize emphasis alignment color kern |	paragraphStyle _ nil.	characterStyle _ nil.	familyName _ nil.	pointSize _ nil.	emphasis _ 0.	alignment _ 0.	color _ nil.	kern _ 0.		"ParagraphStyle is the first to set several values"	attributes do: [ :attribute |		attribute forParagraphStyleReferenceDo: [ :s |			paragraphStyle _ s.			familyName _ s familyName.			pointSize _ s pointSize.			emphasis _ s emphasis.			alignment _ s alignment.			s color ifNotNil: [ :c | color _ c ].			"kern is absolute if in a style"			kern _ s kern ]].	"CharacterStyle, if present, can override font and color"	attributes do: [ :attribute |		attribute forCharacterStyleReferenceDo: [ :s |			characterStyle _ s.			familyName _ s familyName.			pointSize _ s pointSize.			emphasis _ s emphasis.			s color ifNotNil: [ :c | color _ c ].			"kern is absolute if in a style"			kern _ s kern ]].	"These will not interfere with each other, and all of them take precedence over previous values"	attributes do: [ :attribute |		attribute forFontFamilyAndSizeDo: [ :fn :ps | familyName _ fn. pointSize _ ps ].		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].		attribute forTextColorDo: [ :c | color _ c ].		attribute forTextAlignmentDo: [ :a | alignment _ a ].		"kern is relative if not in a style"		attribute forTextKernDo: [ :k | kern _ kern + k ].	].		"Done. Now evaluate the block."	^aBlock valueWithArguments: { familyName. pointSize. emphasis. kern. color. alignment. characterStyle. paragraphStyle }! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 4/7/2011 11:15'!addEmptyTrailingLine	"The line to add is always the first line of a new paragraph"	| ts f h bs r lm rm w a leftMarginForAlignment s |	s _ theText size+1.	f _ editor		ifNotNil: [ editor lastFont ]		ifNil: [ theText fontAt: s ].	ts _ editor		ifNotNil: [ editor lastParagraphStyleOrNil ]		ifNil: [ theText paragraphStyleOrNilAt: s].	h _ f height.	bs _ f ascent.	lm _ 0.	rm _ 0.	w _ theContainer width.	a _ 0.	ts ifNotNil: [		h _h + ts spaceBefore + ts spaceAfter.		bs _ bs + ts spaceBefore.		lm _ (ts isListStyle not			ifTrue: [ts firstIndent]			ifFalse: [ts restIndent]).		rm _ ts rightIndent.		a _ ts alignment ].		leftMarginForAlignment _ a = CharacterScanner rightFlushCode		ifTrue: [ w - rm]		ifFalse: [			a = CharacterScanner centeredCode				ifTrue: [ (w - rm - lm) //2 + lm]				ifFalse: [ lm ]].	r _ theContainer left + leftMarginForAlignment @ currentY extent: 0@h.	lines addLast: (		EmptyLine new			firstIndex: s lastIndex: s - 1;			rectangle: r;			lineHeight: h baseline: bs;			paragraphStyle: ts)! !