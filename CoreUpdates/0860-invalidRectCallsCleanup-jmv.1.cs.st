'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 14 March 2011 at 10:07:49 am'!!LightWidget methodsFor: 'geometry' stamp: 'jmv 3/14/2011 09:33'!bounds: aRectangle	self redrawNeeded.	bounds _ aRectangle.	self redrawNeeded.	owner ifNotNil: [ owner layoutChanged ].! !!LightWidget methodsFor: 'geometry' stamp: 'jmv 3/14/2011 09:35'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [ ^ self ].  "Null change"	self redrawNeeded.	self privateFullMoveBy: delta.	self redrawNeeded.	owner ifNotNil: [ owner layoutChanged ]! !!CompositeLW methodsFor: 'submorphs-add/remove' stamp: 'jmv 3/14/2011 09:44'!removeAllMorphs	| oldMorphs myWorld |	myWorld _ self world.	myWorld ifNotNil: [ self redrawNeeded ].	submorphs do: [ :m | m privateOwner: nil ].	oldMorphs _ submorphs.	submorphs _ EmptyArray.	oldMorphs do: [ :m | self removedMorph: m ].	self layoutChanged! !!Morph methodsFor: 'drawing' stamp: 'jmv 3/14/2011 09:56'!clipSubmorphs: aBoolean	"Drawing specific. If this property is set, clip the receiver's submorphs to the receiver's clipping bounds."	self doLayoutIfNeeded; redrawNeeded.	aBoolean		ifTrue: [ self setProperty: #clipSubmorphs toValue: true ]		ifFalse: [ self removeProperty: #clipSubmorphs ].	self layoutChanged; doLayoutIfNeeded; redrawNeeded! !!Morph methodsFor: 'geometry' stamp: 'jmv 3/14/2011 10:01'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	self doLayoutIfNeeded; redrawNeeded.	self privateFullMoveBy: delta.	self redrawNeeded	owner ifNotNil: [ owner layoutChanged ]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 3/14/2011 10:02'!removeAllMorphs	| oldMorphs myWorld |	submorphs isEmpty ifTrue: [ ^self ].	myWorld _ self world.	(fullBounds notNil or: [ myWorld notNil ]) ifTrue: [ self doLayoutIfNeeded; redrawNeeded ].	submorphs do: [ :m |		m privateOwner: nil ].	oldMorphs _ submorphs.	submorphs _ EmptyArray.	oldMorphs do: [ :m |		self removedMorph: m ].	self layoutChanged! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 3/14/2011 10:03'!removeAllMorphsIn: aCollection	"greatly speeds up the removal of *lots* of submorphs"	| set myWorld |	aCollection isEmpty ifTrue: [ ^self ].	set _ IdentitySet new: aCollection size * 4 // 3.	aCollection do: [ :each | each owner == self ifTrue: [ set add: each]].	set isEmpty ifTrue: [ ^self ].	myWorld _ self world.	(fullBounds notNil or: [ myWorld notNil ]) ifTrue: [ self doLayoutIfNeeded; redrawNeeded ].	set do: [:m | m privateOwner: nil].	submorphs _ submorphs reject: [ :each | set includes: each].	set do: [ :m | self removedMorph: m ].	self layoutChanged! !!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:38'!image: anImage 	self redrawNeeded.	image _ anImage depth = 1 		ifTrue: [ ColorForm mappingWhiteToTransparentFrom: anImage ]		ifFalse: [ anImage ]. 	self basicExtent: image extent! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 3/14/2011 10:07'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |	event position y < self top 		ifTrue: [			scrollBar scrollUp: 1.			row := self rowAtLocation: scroller topLeft + (1 @ 1)]		ifFalse: [			row _ event position y > self bottom 				ifTrue: [					scrollBar scrollDown: 1.					self rowAtLocation: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^self].	"No change if model is locked"	dragOnOrOff ifNil: [			"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff _ (self listSelectionAt: row) not].	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [ self changeModelSelection: row ]		ifFalse: [ self changeModelSelection: 0 ].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].		"Select all in between if drag was too fast"	"self listSelectionAt: row put: dragOnOrOff."	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |		self listSelectionAt: r put: dragOnOrOff]! !!TransformMorph methodsFor: 'layout' stamp: 'jmv 3/14/2011 09:54'!doLayoutIfNeeded	"Overridden to do nothing, just as #fullBounds"	fullBounds ifNil: [ fullBounds _ bounds ].! !TransformMorph removeSelector: #fullBounds!