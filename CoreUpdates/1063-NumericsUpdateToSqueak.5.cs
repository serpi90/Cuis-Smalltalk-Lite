'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 27 August 2011 at 12:24:22 am'!!classDefinition: #Complex category: #'Kernel-Numbers'!Object subclass: #Complex	instanceVariableNames: 'real imaginary'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Complex commentStamp: 'mk 10/31/2003 22:19' prior: 0!I represent a complex number.real			--	real part of the complex numberimaginary	--	imaginary part of the complex numberComplex number constructors:	5 i	6 + 7 i.	5.6 - 8 i.	Complex real: 10 imaginary: 5.	Complex abs: 5 arg: (Float pi / 4)Arithmetic operation with other complex or non-complex numbers work.	(5 - 6 i) + (-5 + 8 i).			"Arithmetic between two complex numbers."	5 * (5 - 6 i).				"Arithmetic between a non-complex and a complex number."					It is also possible to perform arithmetic operations between a complex numberand a array of (complex) numbers:	2 * {1 + 2i.	     3 + 4i.	     5 + 6i}	5 + 5i * {1 + 2i.	          3.	          5 + 6i}It behaves analogously as it is with normal numbers and an array.NOTE: Although Complex something similiar to the Smalltalk's Number class, it wouldnot be a good idea to make a Complex to be a subclass of a Number because:- Number is subclass of Magnitude and Complex is certainly not a magnitude.  Complex does not behave very well as a Magnitude. Operations such as	<	>	<=	>=  do not have sense in case of complex numbers.- Methods in the following Number methods' categories do not have sense for a Complex numbers	trucation and round off	testing	intervals	comparing- However the following Number methods' categories do have sense for a Complex number	arithmetic (with the exception of operation		//		\\		quo:		rem:		mathematical functionsThus Complex is somewhat similar to a Number but it is not a subclass of it. Some operationswe would like to inherit (e.g. #abs, #negated, #reciprocal) but some of the Number operationdo not have sens to inherit or to overload. Classes are not always neat mechanism.!!!!!! We had to COPY the implementation of the		abs		negated		reciprocal		log:		isZero		reciprocal		...	methods from the Number class to the Complex class. Awful solution. Now I begin to	appreciate the Self.Missing methods	String | converting | asComplex	Complex | mathematical functions | arcSin	Complex | mathematical functions | arcCos	Complex | mathematical functions | arcTan!!classDefinition: #DomainError category: #'System-Exceptions Kernel'!ArithmeticError subclass: #DomainError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Exceptions Kernel'!!DomainError commentStamp: 'nice 4/20/2011 22:13' prior: 0!A DomainError is an error occuring when a mathematical function is used outside its domain of validity.!!classDefinition: #Integer category: #'Kernel-Numbers'!Number subclass: #Integer	instanceVariableNames: ''	classVariableNames: 'LowBitPerByteTable '	poolDictionaries: ''	category: 'Kernel-Numbers'!!Object methodsFor: 'testing' stamp: 'jmv 8/27/2011 00:04'!isComplex	"Answer true if receiver is a Complex number. False by default."	^ false! !!Complex methodsFor: 'accessing' stamp: 'mk 10/27/2003 17:39'!imaginary	^ imaginary! !!Complex methodsFor: 'accessing' stamp: 'mk 10/27/2003 17:39'!real	^ real! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/21/2004 11:25'!* anObject	"Answer the result of multiplying the receiver by aNumber."	| a b c d newReal newImaginary |	anObject isComplex		ifTrue:			[a := self real.			b := self imaginary.			c := anObject real.			d := anObject imaginary.			newReal := (a * c) - (b * d).			newImaginary := (a * d) + (b * c).			^ Complex real: newReal imaginary: newImaginary]		ifFalse:			[^ anObject adaptToComplex: self andSend: #*]! !!Complex methodsFor: 'arithmetic' stamp: 'mk 1/18/2004 23:31'!+ anObject	"Answer the sum of the receiver and aNumber."	| a b c d newReal newImaginary |	anObject isComplex		ifTrue:			[a := self real.			b := self imaginary.			c := anObject real.			d := anObject imaginary.			newReal := a + c.			newImaginary := b + d.			^ Complex real: newReal imaginary: newImaginary]		ifFalse:			[^ anObject adaptToComplex: self andSend: #+]! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:45'!- anObject	"Answer the difference between the receiver and aNumber."	| a b c d newReal newImaginary |	anObject isComplex		ifTrue:			[a := self real.			b := self imaginary.			c := anObject real.			d := anObject imaginary.			newReal := a - c.			newImaginary := b - d.			^ Complex real: newReal imaginary: newImaginary]		ifFalse:			[^ anObject adaptToComplex: self andSend: #-]! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:45'!/ anObject	"Answer the result of dividing receiver by aNumber"	| a b c d newReal newImaginary |	anObject isComplex ifTrue:		[a := self real.		b := self imaginary.		c := anObject real.		d := anObject imaginary.		newReal := ((a * c) + (b * d)) / ((c * c) + (d * d)).		newImaginary := ((b * c) - (a * d)) / ((c * c) + (d * d)).		^ Complex real: newReal imaginary: newImaginary].	^ anObject adaptToComplex: self andSend: #/.! !!Complex methodsFor: 'arithmetic' stamp: 'mk 10/27/2003 20:48'!abs	"Answer the distance of the receiver from zero (0 + 0 i)."	^ ((real * real) + (imaginary * imaginary)) sqrt! !!Complex methodsFor: 'arithmetic' stamp: 'nice 4/21/2011 21:47'!absSecure	"Answer the distance of the receiver from zero (0 + 0 i).	Try avoiding overflow and/or underflow"	| scale |	scale := real abs max: imaginary abs.	^scale isZero 		ifTrue: [scale]		ifFalse: [(self class real: real / scale imaginary: imaginary / scale) squaredNorm sqrt * scale]! !!Complex methodsFor: 'arithmetic' stamp: 'nice 4/20/2011 22:18'!arg	"Answer the argument of the receiver."	self isZero ifTrue: [self error: 'zero has no argument.'].	^imaginary arcTan: real! !!Complex methodsFor: 'arithmetic' stamp: 'nice 2/5/2006 03:24'!conjugated	"Return the complex conjugate of this complex number."	^self class real: real imaginary: imaginary negated! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:48'!divideFastAndSecureBy: anObject	"Answer the result of dividing receiver by aNumber"	" Both operands are scaled to avoid arithmetic overflow. 	  This algorithm works for a wide range of values, and it needs only three divisions.	  Note: #reciprocal uses #/ for devision "	 	| r d newReal newImaginary |	anObject isComplex ifTrue:		[anObject real abs > anObject imaginary abs		  ifTrue:		    [r := anObject imaginary / anObject real.			d := r*anObject imaginary + anObject real.			newReal := r*imaginary + real/d.			newImaginary := r negated * real + imaginary/d.		    ]		  ifFalse:		    [r := anObject real / anObject imaginary.			d := r*anObject real + anObject imaginary.			newReal := r*real + imaginary/d.			newImaginary := r*imaginary - real/d.		    ].				^ Complex real: newReal imaginary: newImaginary].	^ anObject adaptToComplex: self andSend: #/.! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:48'!divideSecureBy: anObject	"Answer the result of dividing receiver by aNumber"	" Both operands are scaled to avoid arithmetic overflow. This algorithm 	  works for a wide range of values, but it requires six divisions.  	  #divideFastAndSecureBy:  is also quite good, but it uses only 3 divisions.	   Note: #reciprocal uses #/ for devision"	 	| s ars ais brs bis newReal newImaginary |	anObject isComplex ifTrue:		[s := anObject real abs + anObject imaginary abs.		 ars := self real / s.		 ais := self imaginary / s.		 brs := anObject real / s.		 bis := anObject imaginary / s.		 s := brs squared + bis squared.				newReal := ars*brs + (ais*bis) /s.		newImaginary := ais*brs - (ars*bis)/s.		^ Complex real: newReal imaginary: newImaginary].	^ anObject adaptToComplex: self andSend: #/.! !!Complex methodsFor: 'arithmetic' stamp: 'nice 2/5/2006 03:25'!i	"Answer the result of multiplying the receiver with pure imaginary.		^self * 1 i	This is an obvious extension of method i implemented in Number."	^self class real: imaginary negated imaginary: real! !!Complex methodsFor: 'arithmetic' stamp: 'nice 4/20/2011 22:06'!negated	"Answer a Number that is the negation of the receiver."	^self class real: real negated imaginary: imaginary negated! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:47'!reciprocal	"Answer 1 divided by the receiver. Create an error notification if the 	receiver is 0."	self = 0		ifTrue: [^ (ZeroDivide dividend: self) signal]		ifFalse: [^1 / self]		! !!Complex methodsFor: 'arithmetic' stamp: 'nice 2/5/2006 03:27'!squaredNorm	"Answer the square of receiver norm."	^real * real + (imaginary * imaginary)! !!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29'!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'comparing' stamp: 'mk 10/27/2003 20:35'!hash	"Hash is reimplemented because = is implemented."		^ real hash bitXor: imaginary hash.! !!Complex methodsFor: 'converting' stamp: 'mk 10/27/2003 21:51'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Complex methodsFor: 'converting' stamp: 'mk 10/27/2003 18:32'!adaptToFloat: rcvr andSend: selector	"If I am involved in arithmetic with a Float, convert it to a Complex number."	^ rcvr asComplex perform: selector with: self! !!Complex methodsFor: 'converting' stamp: 'mk 10/27/2003 18:32'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert it to a Complex number."	^ rcvr asComplex perform: selector with: self! !!Complex methodsFor: 'converting' stamp: 'mk 10/27/2003 18:31'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Complex number."	^ rcvr asComplex perform: selector with: self! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/24/2011 22:44'!arCosh	"Answer receiver's area hyperbolic cosine.	That is the inverse function of cosh.	Some possible implementations:	^imaginary > 0 		ifTrue: [(self + (self * self - 1) sqrt) ln]		ifFalse: [(self + (self * self - 1) sqrt) ln negated]	^self arcCos i	This implementation provides an answer with a positive real part.	It also avoids creating intermediate Complex."		| x y tmp sh2x shx delta ch2x chx |	imaginary = 0 ifTrue: [real abs > 1			ifTrue: 				[y := real < 0					ifTrue: [Float pi]					ifFalse: [0].				x := real abs arCosh.				^self class real: x imaginary: y]			ifFalse: [^self class real: 0 imaginary: real arcCos]].	tmp := self squaredNorm - 1 / 2.	delta := tmp squared + imaginary squared.	sh2x := tmp + delta sqrt.	shx := sh2x sqrt.	ch2x := 1 + sh2x.	chx := ch2x sqrt.	x := shx arSinh.	y := imaginary copySignTo: (real / chx) arcCos.	^self class real: x imaginary: y! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:31'!arSinh	"Answer receiver's area hyperbolic sine.	That is the inverse function of sinh."	"Some possible implementation:	^imaginary * real < 0 		ifTrue: [(self + (self * self + 1) sqrt) ln]		ifFalse: [(self - (self * self + 1) sqrt) ln]"	^self i arcSin i negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:31'!arTanh	"Answer receiver's area hyperbolic tangent.	That is the inverse function of tanh."	"Some other possible implementation:	^((1 + self) / (1 - self)) ln / 2"	^self i arcTan i negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/24/2011 21:31'!arcCos	"Answer the arc cosine of the receiver.	This is the inverse function of cos."	| x y tmp sh2y shy delta ch2y chy |	imaginary = 0 ifTrue: [real abs > 1			ifTrue: 				[x := real < 0					ifTrue: [Float pi]					ifFalse: [0].				y := real copySignTo: real abs arCosh.				^self class real: x imaginary: y]			ifFalse: [^self class real: real arcCos imaginary: 0]].	tmp := self squaredNorm - 1 / 2.	delta := tmp squared + imaginary squared.	sh2y := tmp + delta sqrt.	shy := sh2y sqrt.	ch2y := 1 + sh2y.	chy := ch2y sqrt.	y := imaginary copySignTo: shy arSinh.	x := (real / chy) arcCos.	^self class real: x imaginary: y negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/24/2011 22:46'!arcSin	"Answer the arc sine of the receiver.	This is the inverse function of sin."	| x y tmp delta sh2y shy ch2y chy |	imaginary = 0 		ifTrue: 			[real abs > 1 				ifTrue: 					[x := Float pi / 2 * real sign.					y := (real copySignTo: real abs arCosh) negated.					^self class real: x imaginary: y]				ifFalse: [^self class real: real arcSin imaginary: 0]].	tmp := (self squaredNorm - 1) / 2.	delta := tmp squared + imaginary squared.	sh2y := tmp + delta sqrt.	shy := sh2y sqrt.	ch2y := 1 + sh2y.	chy := ch2y sqrt.	y := imaginary copySignTo: shy arSinh.	x := (real / chy) arcSin.	^self class real: x imaginary: y! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/21/2011 21:45'!arcTan	"Answer the arc tangent of the receiver.	This is the inverse function of tan."	| r2 |	r2 := self squaredNorm.	^self class		real: (real * 2 arcTan: 1 - r2) / 2		imaginary: ((r2 + (imaginary * 2) + 1) / (r2 - (imaginary * 2) + 1)) ln / 4! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:34'!arcTan: denominator 	"Answer the  four quadrants arc tangent of receiver over denominator."	^denominator isZero 		ifTrue: 			[self isZero 				ifTrue: 					["shouldn't it be an error ? ^DomainError signal: '0 arcTan: 0'"					^self class real: 0 imaginary: 0]				ifFalse: 					[self class						real: Float pi / (real copySignTo: 2)						imaginary: 0]]		ifFalse: 			[| res |			res := (self / denominator) arcTan.			denominator real < 0 ifTrue: [res := res + Float pi].			res real > Float pi 				ifTrue: [res := res - (Float pi * 2)].			res]! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!cos	"Answer receiver's cosine."	^self i cosh! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 21:30'!cosh	"Answer receiver's hyperbolic cosine.	Hyperbolic cosine is defined by same power serie expansion as for real numbers, that is in term of exponential:	^ (self exp + self negated exp) / 2.	This implementation avoids creating intermediate objects."		^self class		real: real cosh * imaginary cos		imaginary: real sinh * imaginary sin! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 00:38'!exp	"Answer the exponential of the receiver."	^ real exp * (imaginary cos + imaginary sin i)! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 00:39'!ln	"Answer the natural log of the receiver."	^ self abs ln + self arg i! !!Complex methodsFor: 'mathematical functions' stamp: 'mk 10/27/2003 22:05'!log: aNumber 	"Answer the log base aNumber of the receiver."	^self ln / aNumber ln! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 9/18/2008 22:51'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].		0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"	0 = self ifTrue: [				"Special case of self = 0"		aNumber < 0			ifTrue: [^ (ZeroDivide dividend: self) signal]			ifFalse: [^ self]].	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 9/18/2008 22:47'!raisedToInteger: operand 	"Answer the receiver raised to the power operand, an Integer."	"implementation note: this code is copied from Number.	This suggest that both Number and Complex should have an	ArithmeticValue common superclass like in Visualworks.	Or maybe should it be a Traits (a property of fields ?)"	| count result |	operand isInteger ifFalse: [^ ArithmeticError signal: 'parameter is not an Integer'].	operand = 0 ifTrue: [^ self class one].	operand = 1 ifTrue: [^ self].	operand < 0 ifTrue: [^ (self raisedToInteger: operand negated) reciprocal].	count := 1 bitShift: (operand-1) highBit.	result := self class one.	[count > 0]		whileTrue: 			[result := result * result.			(operand bitAnd: count)				= 0 ifFalse: [result := result * self].			count := count bitShift: -1].	^ result! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!sin	"Answer receiver's sine."	^self i sinh i negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 21:30'!sinh	"Answer receiver's hyperbolic sine.	Hyperbolic sine is defined by same power serie expansion as for real numbers, that is in term of exponential:	^ (self exp - self negated exp) / 2.	This implementation avoids creating intermediate objects."		^self class		real: real sinh * imaginary cos		imaginary: real cosh * imaginary sin! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/20/2011 21:58'!sqrt	"Return the square root of the receiver with a positive imaginary part."	| u v |	(imaginary = 0 and: [real >= 0])		ifTrue:	[^self class real: real sqrt imaginary: 0].	v := (self abs - real / 2) sqrt.	u := imaginary / 2 / v.	^self class real: u imaginary: v! !!Complex methodsFor: 'mathematical functions' stamp: 'md 7/20/2004 12:02'!squared	"Answer the receiver multipled by itself."	^self * self! !!Complex methodsFor: 'mathematical functions' stamp: 'mk 10/27/2003 22:04'!tan	"Answer receivers tangent."	^ self sin / self cos! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:55'!tanh	"Answer receiver's hyperbolic tangent."	"Some possible implementation are:	^self sinh / self cosh	| tr ti |	tr := real tanh.	ti := imaginary tan i.	^(tr + ti) / (tr * ti + 1)"	^self i tan i negated! !!Complex methodsFor: 'printing' stamp: 'mk 10/27/2003 18:02'!printOn: aStream	real printOn: aStream.	aStream nextPut: Character space.	0 <= imaginary		ifTrue: [aStream nextPut: $+]		ifFalse: [aStream nextPut: $-].	aStream nextPut: Character space.	imaginary abs printOn: aStream.	aStream nextPut: Character space.	aStream nextPut: $i! !!Complex methodsFor: 'testing' stamp: 'mk 10/27/2003 17:33'!isComplex	^ true! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!Complex methodsFor: 'testing' stamp: 'nice 4/20/2011 22:06'!isZero	^ real isZero and: [imaginary isZero]! !!Complex methodsFor: 'private' stamp: 'mk 10/27/2003 17:26'!imaginary: aNumber	imaginary := aNumber.! !!Complex methodsFor: 'private' stamp: 'mk 10/27/2003 17:26'!real: aNumber	real := aNumber.! !!Complex class methodsFor: 'instance creation' stamp: 'nice 4/22/2011 00:46'!abs: aNumber1 arg: aNumber2	^self		real: aNumber1 * aNumber2 cos		imaginary: aNumber1 * aNumber2 sin! !!Complex class methodsFor: 'instance creation' stamp: 'mk 10/27/2003 17:28'!new	^ self real: 0 imaginary: 0! !!Complex class methodsFor: 'instance creation' stamp: 'nice 9/18/2008 22:50'!one	^ self real: 1 imaginary: 0! !!Complex class methodsFor: 'instance creation' stamp: 'mk 10/27/2003 17:27'!real: aNumber1 imaginary: aNumber2	| newComplex |	newComplex := super new.	newComplex		real: aNumber1;		imaginary: aNumber2.	^ newComplex! !!Complex class methodsFor: 'instance creation' stamp: 'nice 9/18/2008 22:50'!zero	^ self real: 0 imaginary: 0! !!Number methodsFor: 'arithmetic' stamp: 'mk 10/27/2003 21:00'!arg	"Answer the argument of the receiver (see Complex | arg)."		self isZero ifTrue: [self error: 'Zero (0 + 0 i) does not have an argument.'].	0 < self		ifTrue: [^ 0]		ifFalse: [^ Float pi]! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arCosh	"Answer receiver's area hyperbolic cosine.	That is the inverse function of cosh."	^self asFloat arCosh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arSinh	"Answer receiver's area hyperbolic sine.	That is the inverse function of sinh."	^self asFloat arSinh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:09'!arTanh	"Answer receiver's area hyperbolic tangent.	That is the inverse function of tanh."	^self asFloat arTanh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:26'!copySignTo: aNumber	"Return a number with same magnitude as aNumber and same sign as self."	^ self positive		ifTrue: [aNumber abs]		ifFalse: [aNumber withNegativeSign].! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!cosh	"Answer receivers hyperbolic cosine."		^self asFloat cosh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 10/31/2010 22:03'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."		^ (90 - (180 + self \\ 360 - 180) abs) degreesToRadians sin! !!Number methodsFor: 'mathematical functions' stamp: 'nice 10/31/2010 22:01'!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."		^(90 - self) degreeCos! !!Number methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:24'!sign: aNumber	"Return a Number with the same sign as aNumber and same magnitude as self."	^ aNumber copySignTo: self! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!sinh	"Answer receivers hyperbolic sine"		^self asFloat sinh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:55'!tanh	"Answer receivers hyperbolic tangent"		^self asFloat tanh! !!Number methodsFor: 'truncation and round off' stamp: 'wiz 5/29/2011 17:54'!ceiling	"Answer the integer nearest the receiver toward  infinity."	| truncation |	truncation := self truncated.	self <= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation + 1]! !!Number methodsFor: 'truncation and round off' stamp: 'cbc 6/7/2011 22:20'!roundDownTo: aNumber 	"Answer the next multiple of aNumber toward negative infinity that is nearest the 	receiver." 	"Examples:		3.1479 roundDownTo: 0.01 -> 3.14		3.1479 roundDownTo: 0.1 -> 3.1		1923 roundDownTo: 10 -> 1920		3.1479 roundDownTo: 0.005 -> 3.145		-3.1479 roundDownTo: 0.01 -> -3.15"			^(self/aNumber) floor * aNumber! !!Number methodsFor: 'truncation and round off' stamp: 'cbc 6/7/2011 22:21'!roundUpTo: aNumber 	"Answer the next multiple of aNumber toward infinity that is nearest the 	receiver." 	"Examples:		3.1479 roundUpTo: 0.01 -> 3.15		3.1479 roundUpTo: 0.1 -> 3.2		1923 roundUpTo: 10 -> 1930		3.1479 roundUpTo: 0.005 -> 3.15		-3.1479 roundUpTo: 0.01 -> -3.14"	^(self/aNumber) ceiling * aNumber! !!Number methodsFor: 'truncation and round off' stamp: 'cbc 6/7/2011 22:18'!truncateTo: aNumber 	"Answer the next multiple of aNumber toward zero that is nearest the 	receiver."	"Examples:		3.1479 truncateTo: 0.01 -> 3.14		3.1479 truncateTo: 0.1 -> 3.1		1923 truncateTo: 10 -> 1920		3.1479 truncateTo: 0.005 -> 3.145		-3.1479 truncateTo: 0.01 -> -3.14"	^(self quo: aNumber)		* aNumber! !!Number methodsFor: 'converting' stamp: 'mk 10/27/2003 18:17'!i	^ Complex real: 0 imaginary: self! !!Number methodsFor: 'converting' stamp: 'nice 4/23/2011 02:25'!withNegativeSign	"Answer a number with same magnitude than receiver and negative sign."	^self abs negated! !!Number methodsFor: 'printing' stamp: 'nice 3/29/2011 21:48'!printOn: aStream showingDecimalPlaces: placesDesired	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator."	| rounder rounded roundedFractionPart |	placesDesired <= 0 ifTrue: [^ self rounded printOn: aStream].	rounder := 10 raisedToInteger: placesDesired.	rounded := self roundTo: rounder reciprocal.	rounded negative ifTrue: [aStream nextPut: $-].	rounded := rounded abs.	rounded integerPart truncated printOn: aStream.	aStream nextPut: $..	roundedFractionPart := (rounded fractionPart * rounder) truncated.	roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true! !!Number methodsFor: 'printing' stamp: 'nice 3/29/2011 21:39'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point."	^String new: placesDesired + 10 streamContents: [:aStream |		self printOn: aStream showingDecimalPlaces: placesDesired]"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 5-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2"! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arCosh	"Answer receiver's area hyperbolic cosine.	That is the inverse function of cosh."	self < 1 		ifTrue: 			[^DomainError signal: 'Receiver must be greater or equal to 1'].	^self + 1 = self 		ifTrue: [self abs ln + 2 ln]		ifFalse: [((self squared - 1) sqrt + self) ln]! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arSinh	"Answer receiver's area hyperbolic sine.	That is the inverse function of sinh."	self = 0.0 ifTrue: [^self].	"Handle negativeZero"  	^self + 1 = self 		ifTrue: [(self abs ln + 2 ln) * self sign]		ifFalse: [((self squared + 1) sqrt + self) ln]! !!Float methodsFor: 'mathematical functions' stamp: 'nice 5/4/2011 21:29'!arTanh	"Answer receiver's area hyperbolic tangent.	That is the inverse function of tanh."	self = 0.0 ifTrue: [^self].	"Handle negativeZero"	self abs = 1 ifTrue: [^self copySignTo: Float infinity].	self abs > 1 		ifTrue: 			[^DomainError signal: 'Receiver must be between -1.0 and 1.0'].	^((1 + self) / (1 - self)) ln / 2! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:17'!arcSin	"Answer the angle in radians."	((self < -1.0) or: [self > 1.0]) ifTrue: [DomainError signal: 'arcSin only takes values between -1 and 1'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi * self]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:26'!copySignTo: aNumber	"Return a number with same magnitude as aNumber and same sign as self.	Implementation note: take care of Float negativeZero, which is considered as having a negative sign."	(self > 0.0 or: [(self at: 1) = 0]) ifTrue: [^ aNumber abs].	^aNumber withNegativeSign! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:35'!cosh	"Answer receivers hyperbolic cosine."		| ex |	ex := self abs exp.	^(ex + ex reciprocal) / 2! !!Float methodsFor: 'mathematical functions' stamp: 'nice 11/1/2010 11:56'!degreeCos	"Take care of exceptional values"		self isFinite ifTrue: [^super degreeCos].	^self degreesToRadians cos! !!Float methodsFor: 'mathematical functions' stamp: 'nice 11/1/2010 11:56'!degreeSin	"Take care of exceptional values"		self isFinite ifTrue: [^super degreeSin].	^self degreesToRadians sin! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:16'!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [DomainError signal: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt := self exponent.	n := Ln2 * expt.	mant := self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x := mant - 1.0.	div := 1.0.	pow := delta := sum := x.	x := x negated.  "x <= 0"	eps := Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta.		"pass two: delta is negative"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:30'!sign: aNumber	"Return a Number with the same sign as aNumber and same magnitude as self.	Implementation is different from super to handle the special case of Float negativeZero."	(self = 0.0 and: [aNumber sign negative]) ifTrue: [^Float negativeZero].	^aNumber copySignTo: self! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:55'!sinh	"Answer receivers hyperbolic sine"		| ex |	ex := self abs exp.	^self copySignTo: (ex - ex reciprocal) / 2! !!Float methodsFor: 'mathematical functions' stamp: 'jmv 8/26/2011 19:51'!sqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	"Newton-Raphson"	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0]				ifFalse: [					^ DomainError signal: 'sqrt undefined for number less than zero.']].	"first guess is half the exponent"	exp := self exponent // 2.	guess := self timesTwoPower: 0 - exp.	"get eps value"	eps := guess * Epsilon.	eps := eps * eps.	delta := self - (guess * guess) / (guess * 2.0).	[delta * delta > eps]		whileTrue: 			[guess := guess + delta.			delta := self - (guess * guess) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:08'!tanh	"Answer hyperbolic tangent of receiver.	Trivial implementation is:		^self sinh/self cosh	This implementation takes care not to overflow."	| ex emx |	self = 0.0 ifTrue: [^self].	"Handle negativeZero"	self > 20.0 ifTrue: [^1.0].	self < -20.0 ifTrue: [^-1.0].	ex := self exp.	emx := ex reciprocal.	^(ex - emx) / (ex + emx)! !!Float methodsFor: 'truncation and round off' stamp: 'nice 5/4/2011 21:45'!ulp	"Answer the unit of least precision of self (the power of two corresponding to last bit of mantissa)"		| exponent |	self isFinite ifFalse: [^self abs].	self = 0.0 ifTrue: [^Float fmin].	exponent := self exponent.	^exponent < self class emin		ifTrue: [Float fminDenormalized] 		ifFalse: [Float epsilon timesTwoPower: exponent]! !!Float methodsFor: 'converting' stamp: 'mk 10/27/2003 18:16'!adaptToComplex: rcvr andSend: selector	"If I am involved in arithmetic with a Complex number, convert me to a Complex number."	^ rcvr perform: selector with: self asComplex! !!Float methodsFor: 'converting' stamp: 'mk 10/27/2003 17:46'!asComplex	"Answer a Complex number that represents value of the the receiver."	^ Complex real: self imaginary: 0! !!Float methodsFor: 'converting' stamp: 'nice 4/23/2011 02:24'!withNegativeSign	"Same as super, but handle the subtle case of Float negativeZero"		self = 0.0 ifTrue: [^self class negativeZero].  	^super withNegativeSign! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index 	"Avoid primitive in Object>>at:"	^self basicAt: index! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index put: value 	"Avoid primitive in Object>>at:put:"	^self basicAt: index put: value! !!Float class methodsFor: 'class initialization' stamp: 'jmv 8/26/2011 19:13'!initialize	"Float initialize"	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288		Pi/2 = 1.57079632679489661923132169163975144		Pi*2 = 6.28318530717958647692528676655900576		Pi/180 = 0.01745329251994329576923690768488612		2.0 ln = 0.69314718055994530941723212145817657		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi _ 3.14159265358979323846264338327950288.	Halfpi _ Pi / 2.0.	Twopi _ Pi * 2.0.	RadiansPerDegree _ Pi / 180.0.	Ln2 _ 0.69314718055994530941723212145817657.	Ln10 _ 10.0 ln.	Sqrt2 _ 1.41421356237309504880168872420969808.	E _ 2.718281828459045235360287471353.	Epsilon _ 0.000000000001.  "Defines precision of mathematical functions"	MaxVal _ 1.7976931348623157e308.	MaxValLn _ 709.782712893384.	MinValLogBase2 _ -1074.	Infinity _ MaxVal * MaxVal.	NegativeInfinity _ 0.0 - Infinity.	NaN _ Infinity - Infinity.	NegativeZero _ 1.0 / Infinity negated.! !!Float class methodsFor: 'constants' stamp: 'mtf 3/7/2011 10:42'!ln10	^ Ln10! !!Float class methodsFor: 'constants' stamp: 'mtf 3/7/2011 10:41'!ln2	^ Ln2! !!Fraction methodsFor: 'converting' stamp: 'mk 10/27/2003 18:13'!adaptToComplex: rcvr andSend: selector	"If I am involved in arithmetic with a Complex number, convert me to a Complex number."	^ rcvr perform: selector with: self asComplex! !!Fraction methodsFor: 'converting' stamp: 'mk 10/27/2003 18:13'!asComplex	"Answer a Complex number that represents value of the the receiver."	^ Complex real: self imaginary: 0! !!Fraction methodsFor: 'converting' stamp: 'nice 7/15/2011 14:40'!asFloat	"Answer a Float that closely approximates the value of the receiver.	This implementation will answer the closest floating point number to	the receiver.	It uses the IEEE 754 round to nearest even mode	(can happen in case denominator is a power of two)"		| a b q r exponent floatExponent n ha hb hq q1 |	a := numerator abs.	b := denominator abs.	ha := a highBit.	hb := b highBit.		"If both numerator and denominator are represented exactly in floating point number,	then fastest thing to do is to use hardwired float division"	(ha < 54 and: [hb < 54]) ifTrue: [^numerator asFloat / denominator asFloat].		"Try and obtain a mantissa with 54 bits.	First guess is rough, we might get one more bit or one less"	exponent := ha - hb - 54.	exponent > 0		ifTrue: [b := b bitShift: exponent]		ifFalse: [a := a bitShift: exponent negated].	q := a quo: b.	r := a - (q * b).	hq := q highBit.		"check for gradual underflow, in which case we should use less bits"	floatExponent := exponent + hq - 1.	n := floatExponent > -1023		ifTrue: [54]		ifFalse: [54 + floatExponent + 1022].		hq > n		ifTrue: [exponent := exponent + hq - n.			r := (q bitAnd: (1 bitShift: hq - n) - 1) * b + r.			q := q bitShift: n - hq].	hq < n		ifTrue: [exponent := exponent + hq - n.			q1 := (r bitShift: n - hq) quo: b.			q := (q bitShift: n - hq) bitAnd: q1.			r := (r bitShift: n - hq) - (q1 * b)].			"check if we should round upward.	The case of exact half (q bitAnd: 1) isZero not & (r isZero)	will be handled by Integer>>asFloat"	((q bitAnd: 1) isZero or: [r isZero])		ifFalse: [q := q + 1].			^ (self positive		ifTrue: [q asFloat]		ifFalse: [q = 0			ifTrue: [Float negativeZero]			ifFalse: [q asFloat negated]])		timesTwoPower: exponent! !!Fraction methodsFor: 'printing' stamp: 'nice 3/29/2011 22:56'!printOn: aStream showingDecimalPlaces: placesDesired	"Same as super, but provides a faster implementation by inlining some Fraction protocol thus avoiding intermediate Fraction creation."		| roundedFractionPart integerPart scaling |	placesDesired <= 0		ifTrue: [self rounded printOn: aStream]		ifFalse:			[scaling := 10 raisedToInteger: placesDesired.			integerPart := numerator abs quo: denominator.			roundedFractionPart := (numerator abs - (integerPart * denominator)) * scaling * 2 + denominator quo: denominator * 2.			roundedFractionPart = scaling				ifTrue:					[integerPart := integerPart + 1.					roundedFractionPart := 0].			"Don't print minus sign if result is rouded to zero"			(numerator negative and: [integerPart > 0 or: [roundedFractionPart > 0]]) ifTrue: [aStream nextPut: $-].			integerPart printOn: aStream.			aStream nextPut: $..			roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true].! !!Fraction methodsFor: 'printing' stamp: 'nice 3/29/2011 21:45'!printTruncatedOn: aStream showingDecimalPlaces: placesDesired	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator.	Print as if the receiver was truncated to requested precision."		| truncatedFractionPart integerPart scaling |	placesDesired <= 0		ifTrue: [self truncated printOn: aStream]		ifFalse:			[scaling := 10 raisedToInteger: placesDesired.			integerPart := numerator abs quo: denominator.			truncatedFractionPart := (numerator abs - (integerPart * denominator)) * scaling quo: denominator.			numerator negative ifTrue: [aStream nextPut: $-].			integerPart printOn: aStream.			aStream nextPut: $..			truncatedFractionPart printOn: aStream base: 10 length: placesDesired padded: true].! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:33'!ln	"This function is defined because super ln might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal ln negated].	self <= 0 ifTrue: [DomainError signal: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	int := self integerPart.	^int ln + (self / int) ln! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:35'!log	"This function is defined because super log might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal log negated].	self <= 0 ifTrue: [DomainError signal: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	int := self integerPart.	^int log + (self / int) log! !!Fraction methodsFor: 'testing' stamp: 'ul 11/29/2010 20:05'!negative	^numerator negative! !!Integer methodsFor: 'comparing' stamp: 'jmv 8/26/2011 19:32'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue: [		aNumber class == self class ifFalse: [ ^false ].		^ (self digitCompare: aNumber) = 0].	^ aNumber adaptToInteger: self andSend: #=! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:33'!ln	"This function is defined because super ln might overflow."	| res h |	self <= 0 ifTrue: [DomainError signal: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	h := self highBit.	^2 ln * h + (self / (1 << h)) asFloat ln! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:35'!log	"This function is defined because super log might overflow."	| res h |	self <= 0 ifTrue: [DomainError signal: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	h := self highBit.	^2 log * h + (self / (1 << h)) asFloat log! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 5/19/2011 02:08'!raisedTo: n modulo: m	"Answer the modular exponential.	Note: this implementation is optimized for case of large integers raised to large powers."	| a s mInv |	n = 0 ifTrue: [^1].	(self >= m or: [self < 0]) ifTrue: [^self \\ m raisedTo: n modulo: m].	n < 0 ifTrue: [^(self reciprocalModulo: m) raisedTo: n negated modulo: m].	(n < 4096 or: [m even])		ifTrue:			["Overhead of Montgomery method might cost more than naive divisions, use naive"			^self slidingLeftRightRaisedTo: n modulo: m].		mInv := 256 - ((m bitAnd: 255) reciprocalModulo: 256). 	"Initialize the result to R=256 raisedTo: m digitLength"	a := (1 bitShift: m digitLength*8) \\ m.		"Montgomerize self (multiply by R)"	(s := self montgomeryTimes: (a*a \\ m) modulo: m mInvModB: mInv)		ifNil:			["No Montgomery primitive available ? fallback to naive divisions"			^self slidingLeftRightRaisedTo: n modulo: m].	"Exponentiate self*R"	a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.	"Demontgomerize the result (divide by R)"	^a montgomeryTimes: 1 modulo: m mInvModB: mInv! !!Integer methodsFor: 'mathematical functions' stamp: 'jmv 8/26/2011 19:38'!raisedToInteger: exp modulo: m	"	self deprecated: 'rather use #raisedTo:modulo: for efficiency'.	"	(exp = 0) ifTrue: [^ 1].	exp even		ifTrue: [^ (self raisedToInteger: (exp // 2) modulo: m) squared \\ m]		ifFalse: [^ (self * (self raisedToInteger: (exp - 1) modulo: m)) \\ m].! !!Integer methodsFor: 'bit manipulation' stamp: 'ul 7/18/2011 17:28'!lowBit	"Answer the index of the low order bit of this number."		| index digit |	index := 0.	[ (digit := self digitAt: (index := index + 1)) = 0 ] whileTrue.	^(LowBitPerByteTable at: digit) + (index - 1 * 8)! !!Integer methodsFor: 'converting' stamp: 'mk 10/27/2003 17:45'!adaptToComplex: rcvr andSend: selector	"If I am involved in arithmetic with a Complex number, convert me to a Complex number."	^ rcvr perform: selector with: self asComplex! !!Integer methodsFor: 'converting' stamp: 'mk 10/27/2003 17:44'!asComplex	"Answer a Complex number that represents value of the the receiver."	^ Complex real: self imaginary: 0! !!Integer methodsFor: 'printing' stamp: 'nice 6/17/2011 04:10'!numberOfDigitsInBase: b 	"Return how many digits are necessary to print this number in base b.	This does not count any place for minus sign, radix prefix or whatever.	Note that this algorithm may cost a few operations on LargeInteger."	| nDigits q total |	self negative ifTrue: [^self negated numberOfDigitsInBase: b].	self < b ifTrue: [^1].	b isPowerOfTwo ifTrue: [^self highBit + b highBit - 2 quo: b highBit - 1].		"A conversion from base 2 to base b has to be performed.	This algorithm avoids Float computations like (self log: b) floor + 1,	1) because they are inexact	2) because LargeInteger might overflow	3) because this algorithm might be cheaper than conversion"	q := self.	total := 0.	["Make an initial nDigits guess that is lower than or equal to required number of digits"	nDigits := b = 10		ifTrue: [((q highBit - 1) * 1233 >> 12) + 1. "This is because (2 log)/(10 log)*4096 is slightly greater than 1233"]		ifFalse: [q highBit quo: b highBit].	total := total + nDigits.		"See how many digits remains above these first nDigits guess"	(q := q quo: (b raisedToInteger: nDigits)) < b] whileFalse.	^q = 0		ifTrue: [total]		ifFalse: [total + 1]! !!Integer methodsFor: 'printing' stamp: 'nice 3/29/2011 21:58'!printOn: aStream showingDecimalPlaces: placesDesired	"Same as super, but provides a faster implementation because fraction part and rounding are trivial."		self printOn: aStream base: 10.	placesDesired <= 0		ifFalse:			[aStream nextPut: $..			0 printOn: aStream base: 10 length: placesDesired padded: true].! !!Integer methodsFor: 'private' stamp: 'nice 5/14/2011 22:17'!isProbablyPrimeWithK: k andQ: q 	"Algorithm P, probabilistic primality test, from	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description."	"P1"	| x j y |	x := (self - 2) atRandom + 1.	"P2"	j := 0.	y := x raisedTo: q modulo: self.	"P3"		[((j = 0 and: [y = 1]) or: [y = (self - 1)]) ifTrue: [^true].	(j > 0 and: [y = 1]) ifTrue: [^false].	"P5"	j := j + 1.	j < k		ifTrue: [y := y squared \\ self]		ifFalse:[^ false]] repeat! !!Integer methodsFor: 'private' stamp: 'nice 5/19/2011 02:08'!montgomeryRaisedTo: n times: y modulo: m mInvModB: mInv	"Private - do a Montgomery exponentiation of self modulo m.	The operation is equivalent to (self/y raisedTo: n)*y \\ m,	with y is (256 raisedTo: m digitLength),	with (m bitAnd: 255) * mInv \\ 256 = 255."		| pow j k w index oddPowersOfSelf square |		"Precompute powers of self for odd bit patterns xxxx1 up to length w + 1.	The width w is chosen with respect to the total bit length of n,	such that each bit pattern will on average be encoutered P times in the whole bit sequence of n.	This costs (2 raisedTo: w) multiplications, but more will be saved later (see below)."	k := n highBit.	w := (k highBit - 1 >> 1 min: 16) max: 1.	oddPowersOfSelf := Array new: 1 << w.	oddPowersOfSelf at: 1 put: (pow := self).	square := self montgomeryTimes: self modulo: m mInvModB: mInv.	2 to: oddPowersOfSelf size do: [:i | pow := oddPowersOfSelf at: i put: (pow montgomeryTimes: square modulo: m mInvModB: mInv)].		"Now exponentiate by searching precomputed bit patterns with a sliding window"	pow := y.	[k > 0]		whileTrue:			[pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.			"Skip bits set to zero (the sliding window)"			(n bitAt: k) = 0				ifFalse:					["Find longest odd bit pattern up to window length (w + 1)"					j := k - w max: 1.					[j < k and: [(n bitAt: j) = 0]] whileTrue: [j := j + 1].					"We found a bit pattern of length k-j+1;					perform the square powers for each bit					(same cost as bitwise algorithm);					compute the index of this bit pattern in the precomputed powers."					index := 0.					[k > j] whileTrue:						[pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.						index := index << 1 + (n bitAt: k).						k := k - 1].					"Perform a single multiplication for the whole bit pattern.					This saves up to (k-j) multiplications versus a naive algorithm operating bit by bit"					pow := pow montgomeryTimes: (oddPowersOfSelf at: index + 1) modulo: m mInvModB: mInv].			k := k - 1].	^pow! !!Integer methodsFor: 'private' stamp: 'nice 5/18/2011 22:29'!montgomeryTimes: a modulo: m mInvModB: mInv	"Answer the result of a Montgomery multiplication	self * a * (256 raisedTo: m digitLength) inv \\ m	NOTE: it is assumed that:	self digitLength <= m digitLength	a digitLength <= m digitLength	mInv * m \\ 256 = (-1 \\ 256) = 255 (this implies m odd)		Answer nil in case of absent plugin or other failure."		<primitive: 'primMontgomeryTimesModulo' module:'LargeIntegers'>	^nil! !!Integer methodsFor: 'private' stamp: 'nice 5/19/2011 02:00'!slidingLeftRightRaisedTo: n modulo: m	"Private - compute (self raisedTo: n) \\ m,	Note: this method has to be fast because it is generally used with large integers in cryptography.	It thus operate on exponent bits from left to right by packets with a sliding window rather than bit by bit (see below)."		| pow j k w index oddPowersOfSelf square |		"Precompute powers of self for odd bit patterns xxxx1 up to length w + 1.	The width w is chosen with respect to the total bit length of n,	such that each bit pattern will on average be encoutered P times in the whole bit sequence of n.	This costs (2 raisedTo: w) multiplications, but more will be saved later (see below)."	k := n highBit.	w := (k highBit - 1 >> 1 min: 16) max: 1.	oddPowersOfSelf := Array new: 1 << w.	oddPowersOfSelf at: 1 put: (pow := self).	square := self * self \\\ m.	2 to: oddPowersOfSelf size do: [:i | pow := oddPowersOfSelf at: i put: pow * square \\\ m].		"Now exponentiate by searching precomputed bit patterns with a sliding window"	pow := 1.	[k > 0]		whileTrue:			[pow := pow * pow \\\ m.			"Skip bits set to zero (the sliding window)"			(n bitAt: k) = 0				ifFalse:					["Find longest odd bit pattern up to window length (w + 1)"					j := k - w max: 1.					[j < k and: [(n bitAt: j) = 0]] whileTrue: [j := j + 1].					"We found an odd bit pattern of length k-j+1;					perform the square powers for each bit					(same cost as bitwise algorithm);					compute the index of this bit pattern in the precomputed powers."					index := 0.					[k > j] whileTrue:						[pow := pow * pow \\\ m.						index := index << 1 + (n bitAt: k).						k := k - 1].					"Perform a single multiplication for the whole bit pattern.					This saves up to (k-j) multiplications versus a naive algorithm operating bit by bit"					pow := pow * (oddPowersOfSelf at: index + 1) \\\ m].			k := k - 1].	^pow normalize! !!Integer class methodsFor: 'prime numbers' stamp: 'nice 6/15/2011 00:21'!largePrimesUpTo: max do: aBlock	"Evaluate aBlock with all primes up to maxValue.	The Algorithm is adapted from http://www.rsok.com/~jrm/printprimes.html	It encodes prime numbers much more compactly than #primesUpTo: 	38.5 integer per byte (2310 numbers per 60 byte) allow for some fun large primes.	(all primes up to SmallInteger maxVal can be computed within ~27MB of memory;	the regular #primesUpTo: would require 4 *GIGA*bytes).	Note: The algorithm could be re-written to produce the first primes (which require	the longest time to sieve) faster but only at the cost of clarity."	| limit flags maskBitIndex bitIndex maskBit byteIndex index primesUpTo2310 indexLimit |	limit := max asInteger - 1.	indexLimit := max asInteger sqrtFloor + 1.	"Create the array of flags."	flags := ByteArray new: (limit + 2309) // 2310 * 60 + 60.	flags atAllPut: 16rFF. "set all to true"	"Compute the primes up to 2310"	primesUpTo2310 := self primesUpTo: 2310.	"Create a mapping from 2310 integers to 480 bits (60 byte)"	maskBitIndex := Array new: 2310.	bitIndex := -1. "for pre-increment"	maskBitIndex at: 1 put: (bitIndex := bitIndex + 1).	maskBitIndex at: 2 put: (bitIndex := bitIndex + 1).	1 to: 5 do:[:i| aBlock value: (primesUpTo2310 at: i)].	index := 6.	2 to: 2309 do:[:n|		[(primesUpTo2310 at: index) < n] 			whileTrue:[index := index + 1].		n = (primesUpTo2310 at: index) ifTrue:[			maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1).		] ifFalse:[			"if modulo any of the prime factors of 2310, then could not be prime"			(n \\ 2 = 0 or:[n \\ 3 = 0 or:[n \\ 5 = 0 or:[n \\ 7 = 0 or:[n \\ 11 = 0]]]]) 				ifTrue:[maskBitIndex at: n+1 put: 0]				ifFalse:[maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1)].		].	].	"Now the real work begins...	Start with 13 since multiples of 2,3,5,7,11 are handled by the storage method;	increment by 2 for odd numbers only."	13 to: limit by: 2 do:[:n|		(maskBit := maskBitIndex at: (n \\ 2310 + 1)) = 0 ifFalse:["not a multiple of 2,3,5,7,11"			byteIndex := n // 2310 * 60 + (maskBit-1 bitShift: -3) + 1.			bitIndex := 1 bitShift: (maskBit bitAnd: 7).			((flags at: byteIndex) bitAnd: bitIndex) = 0 ifFalse:["not marked -- n is prime"				aBlock value: n.				"Start with n*n since any integer < n has already been sieved 				(e.g., any multiple of n with a number k < n has been cleared 				when k was sieved); add 2 * i to avoid even numbers and				mark all multiples of this prime. Note: n < indexLimit below				limits running into LargeInts -- nothing more."				n < indexLimit ifTrue:[					index := n * n.					[index <= limit] whileTrue:[						(maskBit := maskBitIndex at: (index \\ 2310 + 1)) = 0 ifFalse:[							byteIndex := (index // 2310 * 60) + (maskBit-1 bitShift: -3) + 1.							maskBit := 255 - (1 bitShift: (maskBit bitAnd: 7)).							flags at: byteIndex put: ((flags at: byteIndex) bitAnd: maskBit).						].						index := index + (2 * n)].				].			].		].	].! !!Integer class methodsFor: 'prime numbers' stamp: 'nice 6/17/2011 02:21'!primesUpTo: max do: aBlock	"Compute aBlock with all prime integers up to the given integer."	"Integer primesUpTo: 100"	| index limit limitSqrtFloor sieve increment |	limit := max asInteger.	limit <= 1 ifTrue: [ ^self ].	"Fall back into #largePrimesUpTo:do: if we'd require more than 100k of memory; 	the alternative will only requre 1/154th of the amount we need here and is almost as fast."	limit > 25000 ifTrue:[ ^self largePrimesUpTo: limit do: aBlock ].	limit := limit - 1. "upTo:"	sieve := Array new: limit withAll: true.	sieve at: 1 put: false.	index := 2.	limitSqrtFloor := limit sqrtFloor.	increment := 1.	[ index <= limitSqrtFloor ] whileTrue: [		(sieve at: index) ifTrue: [			| notPrimeIndex notPrimeIncrement |			aBlock value: index.			notPrimeIndex := index * index.			notPrimeIncrement := increment * index.			[ notPrimeIndex <= limit ] whileTrue: [				sieve at: notPrimeIndex put: false.				notPrimeIndex := notPrimeIndex + notPrimeIncrement ] ].		index := index + increment.		increment := 2].	[ index <= limit ] whileTrue: [		(sieve at: index) ifTrue: [			aBlock value: index ].		index := index + increment.		increment := 2]! !!Integer class methodsFor: 'class initialization' stamp: 'ul 7/18/2011 17:23'!initialize	"Integer initialize"	"Ensure we have the right compact class index"	"LPI has been a compact class forever - just ensure basic correctness"	(LargePositiveInteger indexIfCompact = 5) ifFalse:[		(Smalltalk compactClassesArray at: 5)			ifNil:[LargePositiveInteger becomeCompactSimplyAt: 5]			ifNotNil:[self error: 'Unexpected compact class setup']].	"Cog requires LNI to be compact at 4 (replacing PseudoContext)"	(LargeNegativeInteger indexIfCompact = 4) ifFalse:[		"PseudoContext will likely get removed at some point so write this test		without introducing a hard dependency"		(Smalltalk compactClassesArray at: 4) name == #PseudoContext			ifTrue:[Smalltalk compactClassesArray at: 4 put: nil].		(Smalltalk compactClassesArray at: 4)			ifNil:[LargeNegativeInteger becomeCompactSimplyAt: 4]			ifNotNil:[self error: 'Unexpected compact class setup']].			self initializeLowBitPerByteTable! !!Integer class methodsFor: 'class initialization' stamp: 'ul 7/18/2011 17:24'!initializeLowBitPerByteTable	"Initialize LowBitPerByteTable which is a ByteArray that contains the index of the lowest set bit of the integers between 1 and 255. It's defined as a class variable because it's used from the instance side and subclasses."	"The low bits table can be obtained with:	((1 to: 8) inject: #[1] into: [:lowBits :rank | (lowBits copy at: 1 put: lowBits first + 1; yourself) , lowBits]) allButFirst	or with it's symmetric pair:	((1 to: 8) inject: #[1] into: [:lowBits :rank | lowBits, (lowBits copy atLast: 1 put: lowBits last + 1; yourself)]) allButLast."		LowBitPerByteTable := #[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'nice 5/20/2011 23:00'!bitAt: anInteger	"Optimize super algorithm to avoid long bit operations.	Instead work on digits which are known to be SmallInteger and fast.	Note that this algorithm does not work for negative integers."		| digitIndex bitIndex |	digitIndex := anInteger - 1 // 8 + 1.	digitIndex > self digitLength ifTrue: [^0].	bitIndex := (anInteger - 1 bitAnd: 2r111) + 1.	^(self digitAt: digitIndex) bitAt: bitIndex! !!LargePositiveInteger methodsFor: 'printing' stamp: 'nice 6/17/2011 04:12'!printOn: aStream base: b	"Append a representation of this number in base b on aStream.	In order to reduce cost of LargePositiveInteger ops, split the number in approximately two equal parts in number of digits."		| halfDigits halfPower head tail nDigitsUnderestimate |	"Don't engage any arithmetic if not normalized"	(self digitLength = 0 or: [(self digitAt: self digitLength) = 0]) ifTrue: [^self normalize printOn: aStream base: b].		nDigitsUnderestimate := b = 10		ifTrue: [((self highBit - 1) * 1233 >> 12) + 1. "This is because (2 log)/(10 log)*4096 is slightly greater than 1233"]		ifFalse: [self highBit quo: b highBit].			"splitting digits with a whole power of two is more efficient"	halfDigits := 1 bitShift: nDigitsUnderestimate highBit - 2.		halfDigits <= 1		ifTrue: ["Hmmm, this could happen only in case of a huge base b... Let lower level fail"			^self printOn: aStream base: b nDigits: (self numberOfDigitsInBase: b)].		"Separate in two halves, head and tail"	halfPower := b raisedToInteger: halfDigits.	head := self quo: halfPower.	tail := self - (head * halfPower).		"print head"	head printOn: aStream base: b.		"print tail without the overhead to count the digits"	tail printOn: aStream base: b nDigits: halfDigits! !!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'nice 5/20/2011 23:01'!bitAt: anInteger	"super would not work because we have to pretend we are in two-complement.	this has to be tricky..."		| digitIndex bitIndex i |	digitIndex := anInteger - 1 // 8 + 1.	digitIndex > self digitLength ifTrue: [^1].	bitIndex := (anInteger - 1 bitAnd: 2r111) + 1.	i := 1.	[i = digitIndex		ifTrue:			["evaluate two complement (bitInvert + 1) on the digit :			(if digitIndex > 1, we must still add 1 due to the carry).			but x bitInvert is -1-x, bitInvert+1 is just x negated..."			^(self digitAt: digitIndex) negated bitAt: bitIndex].	(self digitAt: i) = 0]		whileTrue: [			"two complement (bitInvert + 1) raises a carry:			0 bitInvert -> 2r11111111.  2r11111111 + 1 -> 0 with carry...			Thus we must inquire one digit forward"			i := i + 1].		"We escaped the while loop, because there is no more carry.	Do a simple bitInvert without a carry"	^1 - ((self digitAt: digitIndex) bitAt: bitIndex)! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'ul 7/18/2011 17:27'!lowBit	" Answer the index of the low order one bit.		2r00101000 lowBit       (Answers: 4)		2r-00101000 lowBit      (Answers: 4)	  First we skip bits in groups of 8, then do a lookup in a table.	  While not optimal, this is a good tradeoff; long	  integer #lowBit always invokes us with bytes."	| n result lastByte |	n := self.	n = 0 ifTrue: [ ^ 0 ].	result := 0.	[(lastByte := n bitAnd: 16rFF) = 0]		whileTrue: [			result := result + 8.			n := n bitShift: -8 ].	^result + (LowBitPerByteTable at: lastByte)! !!SmallInteger methodsFor: 'printing' stamp: 'ul 12/8/2010 03:59'!printOn: stream base: base 	"Append a representation of this number in base b on aStream."	self printOn: stream base: base length: 0 padded: false! !!SmallInteger methodsFor: 'printing' stamp: 'ul 11/30/2010 01:38'!printOn: stream base: base length: minimumLength padded: padWithZeroes	| n numberOfDigits totalLength divisor |	self < 0		ifTrue: [			n := self negated.			totalLength := 1 ]		ifFalse: [			n := self.			totalLength := 0 ].	numberOfDigits := n numberOfDigitsInBase: base.	totalLength := totalLength + numberOfDigits.	padWithZeroes ifFalse: [		[ totalLength < minimumLength ] whileTrue: [			stream space.			totalLength := totalLength + 1 ] ].	n = self ifFalse: [ stream nextPut: $- ].	padWithZeroes ifTrue: [		[ totalLength < minimumLength ] whileTrue: [			stream nextPut: $0.			totalLength := totalLength + 1 ] ].	divisor := (base raisedToInteger: numberOfDigits - 1).	[ divisor > 0 ] whileTrue: [		| digit |		digit := n // divisor.		stream nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: digit + 1).		n := n - (digit * divisor).		divisor := divisor // base ]! !!SmallInteger methodsFor: 'printing' stamp: 'ul 12/8/2010 04:00'!printOn: aStream base: b nDigits: n 	"Append a representation of this number in base b on aStream using nDigits.	self must be positive."	self printOn: aStream base: b length: n padded: true! !Integer initialize!!classDefinition: #Integer category: #'Kernel-Numbers'!Number subclass: #Integer	instanceVariableNames: ''	classVariableNames: 'LowBitPerByteTable'	poolDictionaries: ''	category: 'Kernel-Numbers'!Fraction removeSelector: #asNonFraction!Float initialize!Number removeSelector: #asNonFraction!