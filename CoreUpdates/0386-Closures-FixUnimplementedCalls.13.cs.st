'From Cuis 1.0 of 28 November 2009 [latest update: #337] on 31 December 2009 at 12:11:21 pm'!!Object methodsFor: 'error handling' stamp: 'jmv 12/31/2009 10:44'!subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	self error: 'My subclass should have overridden ', thisContext sender selector printString! !!Object methodsFor: 'testing' stamp: 'jmv 12/31/2009 10:29'!isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^false! !!Behavior methodsFor: 'compiling' stamp: 'jmv 12/31/2009 09:48'!binding	^ nil -> self! !!BlockNode methodsFor: 'printing' stamp: 'jmv 12/31/2009 10:51'!decompileText	"Answer a text description of the parse tree whose root is the receiver."	^ TextStream contents: [:strm | self printOn: strm indent: 0]! !!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 12/31/2009 10:27'!instVarNameForIndex: index	"Answer the named instance variable with index index or nil if none."	| superInstSize |	index > self instSize ifTrue: [^nil].	superInstSize := superclass isNil ifTrue: [0] ifFalse: [superclass instSize].	index > superInstSize ifTrue:		[^instanceVariables at: index - superInstSize].	superclass isNil ifTrue: [^nil].	^superclass instVarNameForIndex: index! !!Class methodsFor: 'compiling' stamp: 'jmv 12/31/2009 09:49'!binding	^ Smalltalk associationAt: name ifAbsent: [nil -> self]! !!Collection methodsFor: 'testing' stamp: 'jmv 12/31/2009 10:29'!isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^true! !!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/31/2009 11:50'!searchForClass	"search me in all classes, if found, return my class. Slow!!"	Smalltalk allBehaviorsDo: [:class | 		(class methodDict keyAtIdentityValue: self ifAbsent: [nil]) ifNotNil: [^class]].	^nil! !!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/31/2009 11:51'!searchForSelector	"search me in all classes, if found, return my selector. Slow!!"	| selector |	Smalltalk allBehaviorsDo: [:class | 		(selector := class methodDict keyAtIdentityValue: self ifAbsent: [nil]) ifNotNil: [^selector]].	^nil! !!Compiler methodsFor: 'public access' stamp: 'jmv 12/31/2009 11:52'!format: textOrStream in: aClass notifying: aRequestor contentsSymbol: aSymbol	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode := self format: sourceStream noPattern: false ifFail: [^ nil].	^aNode decompileString! !!ContextPart methodsFor: 'mirror primitives' stamp: 'jmv 12/31/2009 10:39'!objectClass: anObject	<primitive: 111>	self primitiveFailed! !!Debugger methodsFor: 'accessing' stamp: 'jmv 12/31/2009 10:32'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		result := self contents: aText notifying: aController.		self contentsChanged.		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	contents := aText.	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	World		addAlarm: #changed:		withArguments: #(contentsSelection)		for: self		at: (Time millisecondClockValue + 200).	^true! !!Debugger methodsFor: '*Shout-Styling' stamp: 'jmv 12/31/2009 10:31'!shoutAboutToStyle: aSHTextStyler	"This is a notification that aSHTextStyler is about to re-style its text.	Set the classOrMetaClass in aSHTextStyler, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"		self shoutIsModeStyleable ifFalse: [^false].	aSHTextStyler 		classOrMetaClass: self selectedClassOrMetaClass;		sourceMap: self debuggerMap.	^true! !!Debugger methodsFor: 'tally support' stamp: 'jmv 12/31/2009 10:23'!tally	self getTextMorphWithSelection ifNotNil: [ :o| o tallyIt ] ifNil: [ Beeper beep ]! !!Dictionary class methodsFor: 'instance creation' stamp: 'jmv 12/31/2009 10:35'!newFromPairs: anArray 	"Answer an instance of me associating (anArray at:i) to (anArray at: i+i)	 for each odd i.  anArray must have an even number of entries."	| newDictionary |	newDictionary := self new: (anArray size/2).	1 to: (anArray size-1) by: 2 do: [ :i|		newDictionary at: (anArray at: i) put: (anArray at: i+1).	].	^ newDictionary	"  Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}. "! !!Encoder methodsFor: 'initialize-release' stamp: 'jmv 12/30/2009 22:33'!init: aClass context: aContext notifying: req	requestor := req.	class := aClass.	nTemps := 0.	supered := false.	self initScopeAndLiteralTables.	class variablesAndOffsetsDo: [ :variable "<String>" :offset "<Integer>" |		scopeTable			at: variable			put: (offset >= 0					ifTrue: [InstanceVariableNode new								name: variable index: offset]					ifFalse: [MaybeContextInstanceVariableNode new								name: variable index: offset negated])].	aContext ~~ nil ifTrue:		[| homeNode |		 homeNode := self bindTemp: self doItInContextName.		 "0th temp = aContext passed as arg"		 aContext tempNames withIndexDo:			[:variable :index|			scopeTable				at: variable				put: (MessageAsTempNode new						receiver: homeNode						selector: #namedTempAt:						arguments: (Array with: (self encodeLiteral: index))						precedence: 3						from: self)]].	sourceRanges := Dictionary new: 32.	globalSourceRanges := OrderedCollection new: 32! !!DictionaryInspector methodsFor: 'menu' stamp: 'jmv 12/31/2009 10:16'!renameEntry	| newKey aKey value |	value := object at: (keyArray at: selectionIndex - self numberOfFixedFields).	newKey := FillInTheBlank request: 'Enter new key, then type RETURN.(Expression will be evaluated for value.)Examples:  #Fred    ''a string''   3+4'		 initialAnswer: (keyArray at: selectionIndex - self numberOfFixedFields) printString.	newKey = '' ifTrue: [		^self ].	aKey := Compiler evaluate: newKey.	object removeKey: (keyArray at: selectionIndex - self numberOfFixedFields).	object at: aKey put: value.	self calculateKeyArray.	selectionIndex := self numberOfFixedFields + (keyArray indexOf: aKey).	self changed: #selectionIndex.	self changed: #inspectObject.	self changed: #fieldList.	self update! !!LiteralDictionary methodsFor: 'as yet unclassified' stamp: 'jmv 12/31/2009 10:07'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [			self literalEquality: element key and: anObject ])				ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self error: 'There is no free space in this collection!!'! !!Process methodsFor: 'changing suspended state' stamp: 'jmv 12/31/2009 10:57'!popTo: aContext value: aValue	"Replace the suspendedContext with aContext, releasing all contexts 	between the currently suspendedContext and it."	| callee |	self == Processor activeProcess		ifTrue: [^ self error: 'The active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ self].  "aContext is on top"	self return: callee value: aValue! !!ProcessBrowser methodsFor: 'accessing' stamp: 'jmv 12/31/2009 10:48'!selectedSelector	"Answer the class in which the currently selected context's method was  	found."	^ selectedSelector		ifNil: [selectedSelector := selectedContext receiver				ifNil: [selectedClass := selectedContext method methodClass					   selectedContext method selector]				ifNotNil: [selectedContext selector]]! !!SHTextStyler methodsFor: 'styling' stamp: 'jmv 12/31/2009 11:53'!styledTextFor: aText	"Answer a copy of aText that is both formatted and styled"		| formattedText |		formattedText := self privateFormat: aText.	self privateStyle: formattedText.	^formattedText! !!SmalltalkEditor methodsFor: 'private' stamp: 'jmv 12/31/2009 10:10'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = ${ and: [string last = $}]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str := string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!Symbol class methodsFor: 'access' stamp: 'jmv 12/30/2009 22:37'!allSymbols	"Answer all interned symbols"	^Array streamContents:[:s|		s nextPutAll: NewSymbols.		s nextPutAll: OneCharacterSymbols.		s nextPutAll: SymbolTable.	]! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 12/31/2009 10:04'!unimplemented	"Answer an Array of each message that is sent by an expression in a method but is not implemented by any object in the system."	| all unimplemented entry |	all _ IdentitySet new: Symbol instanceCount * 2.	Cursor wait showWhile: 		[self allBehaviorsDo: [:cl | cl selectorsDo: [:aSelector | all add: aSelector]]].	unimplemented _ IdentityDictionary new.	Cursor execute showWhile: [		self allBehaviorsDo: [:cl |			 cl selectorsDo: [:sel |				(cl compiledMethodAt: sel) messages do: [:m |					(all includes: m) ifFalse: [						entry _ unimplemented at: m ifAbsent: [Array new].						entry _ entry copyWith: (cl name, '>', sel).						unimplemented at: m put: entry]]]]].	"remove some clutter from the result:"	#(DoIt DoItIn: doPrimitive: primitiveFail success:)		do: [ :sel | unimplemented removeKey: sel ifAbsent: []].	^ unimplemented! !!TestRunner methodsFor: 'initialize' stamp: 'jmv 12/30/2009 22:35'!gatherTestNames	^(self testCases collect: [:each | each name]) asSortedCollection! !!TestRunner methodsFor: 'menus' stamp: 'jmv 12/31/2009 11:03'!listMenu: aMenu shifted: shiftState	aMenu title: 'Test Cases'.	aMenu add: 'select all' target: self selector: #selectAll.	aMenu add: 'deselect all' target: self selector: #deselectAll.	aMenu add: 'toggle selections' target: self selector: #toggleSelections.	aMenu add: 'filter' target: self selector: #setFilter.	running ifNotNil: [		aMenu add: 'stop' target: self selector: #terminateRun		].	selectedSuite > 0 ifTrue: [ | cls |		cls _ (tests at: selectedSuite ifAbsent: ['']) copyUpTo: Character space.		cls _ cls asSymbol.		cls _ (Smalltalk at: cls ifAbsent: []).		cls ifNotNil: [ | mtc |			aMenu addLine.			aMenu add: 'browse' target: self selector: #browse: argument: cls.		].	].	shiftState ifTrue: [		aMenu addLine.		testsList addCustomMenuItems: aMenu hand: ActiveHand.	].	^aMenu! !!TestRunner methodsFor: 'processing' stamp: 'jmv 12/30/2009 22:34'!addTestsFor: testName toSuite: suite 	| cls |	(testName indexOf: $() > 0		ifFalse: [			cls _ testName asSymbol sunitAsClass.			cls isAbstract				ifTrue: [cls allSubclasses						do: [:each | each isAbstract								ifFalse: [each addToSuiteFromSelectors: suite]]]				ifFalse: [cls addToSuiteFromSelectors: suite]].	^ suite! !!TestRunner methodsFor: 'updating' stamp: 'jmv 12/31/2009 10:26'!refreshWindow	| pc |	pc _ self class windowColor.	passFailText color: pc.	detailsText color: pc.	self updateErrors: TestResult new.	self updateFailures: TestResult new.	self displayPassFail: 'N/A'.	self displayDetails: '...'! !!TestRunner methodsFor: 'updating' stamp: 'jmv 12/31/2009 10:26'!runWindow	| pc |	pc _ self class windowColor.	passFailText color: pc.	detailsText color: pc.	self updateErrors: TestResult new.	self updateFailures: TestResult new.	self displayPassFail: 'Running...'.	self displayDetails: '...'! !!TestRunner methodsFor: 'updating' stamp: 'jmv 12/31/2009 10:26'!updatePartColors: aColor	passFailText color: aColor.	 detailsText color: aColor! !!Utilities class methodsFor: 'closure support' stamp: 'jmv 12/30/2009 22:38'!compileUsingClosures	"Utilities compileUsingClosures"	"Recompile the system and do some minimal clean-ups"	| classes compilationErrors |	Preferences setPreference: #allowBlockArgumentAssignment toValue: true.	compilationErrors := Set new.	classes := Smalltalk forgetDoIts allClasses reject: [:c| c name == #GeniePlugin].	'Recompiling The System' displayProgressAt: Sensor cursorPoint		from: 0 to: classes size during:[:bar |			classes withIndexDo:[:c :i|				bar value: i.				{ c. c class } do:[:b|					"Transcript cr; print: b; endEntry."					b selectors "asSortedCollection" do:[:s| 						"Transcript cr; show: b asString, '>>', s."						[b recompile: s from: b] on: Error do:[:ex|							Transcript								cr; nextPutAll: 'COMPILATION ERROR: ';								print: b; nextPutAll: '>>'; nextPutAll: s; flush.							compilationErrors add: (MethodReference class: b selector: s)]]]]].	compilationErrors notEmpty ifTrue:[		Smalltalk			browseMessageList: compilationErrors asSortedCollection			name: 'Compilation Errors']! !!Utilities class methodsFor: 'closure support' stamp: 'jmv 12/31/2009 11:05'!postRecompileCleanup	"Utilities postRecompileCleanup"	"Cleanup after loading closure bootstrap"	| unboundMethods contexts |	World removeAllKnownFailing.	ProcessorScheduler startUp.	WeakArray restartFinalizationProcess.	MethodChangeRecord allInstancesDo:[:x| x noteNewMethod: nil].	Undeclared removeUnreferencedKeys.	Delay startTimerEventLoop.	EventSensor install.	WorldState allInstancesDo:[:ws| ws convertAlarms; convertStepList].	Workspace allInstancesDo:[:ws| ws setBindings: nil].	Smalltalk garbageCollect.	Smalltalk		at: #DebuggerMethodMap		ifPresent: [:dmm| dmm voidMapCache].	Smalltalk forgetDoIts.	Smalltalk garbageCollect.	unboundMethods := CompiledMethod allInstances select:[:m|		m methodClass isNil or: [m ~~ (m methodClass compiledMethodAt: m selector ifAbsent: nil)]].	unboundMethods := unboundMethods reject:[:m| m selector isDoIt].	unboundMethods notEmpty ifTrue:		[unboundMethods inspectWithLabel: 'Unbound Methods'].	contexts := BlockContext allInstances.	contexts ifNotEmpty:[contexts inspect. self inform: 'There are left-over BlockContexts'].	(unboundMethods isEmpty and:[contexts isEmpty]) ifTrue:[		self inform:'Congratulations - The bootstrap is now complete.'.	].! !!Workspace methodsFor: 'binding' stamp: 'jmv 12/31/2009 10:21'!hasBindingOf: aString	^bindings notNil and: [		bindings includesKey: aString ]! !TextStream removeSelector: #withColor:emphasis:do:!TextStream removeSelector: #withStyleFor:do:!!TextStream reorganize!('as yet unclassified' applyAttribute:beginningAt: nextPutAll: withAttribute:do: withAttributes:do:)!TestRunner removeSelector: #recordInteractionFor:!Stream removeSelector: #withStyleFor:do:!!Stream reorganize!('accessing' binary contents flush localName next next: next:put: nextMatchAll: nextMatchFor: nextPut: nextPutAll: openReadOnly printOn: readOnly upToEnd)('testing' atEnd closed isStream isTypeHTTP nextWordsPutAll:)('enumerating' do:)('printing' print:)('as yet unclassified' sleep)('file open/close' close)!MethodContext removeSelector: #capturedTempNames!MethodContext removeSelector: #doItScope!MethodContext removeSelector: #freeNamesAndValues!MessageNode removeSelector: #asMorphicCaseOn:indent:!MessageNode removeSelector: #morphFromKeywords:arguments:on:indent:!Integer removeSelector: #byteEncode:base:!Inspector removeSelector: #buildCodePaneWith:!Inspector removeSelector: #buildFieldListWith:!Inspector removeSelector: #buildValuePaneWith:!Inspector removeSelector: #buildWith:!!Inspector reorganize!('accessing' baseFieldList context: fieldList i1 i2 initialExtent modelWakeUpIn: noteSelectionIndex:for: object object: selectedClass selectedClassOrMetaClass stepTimeIn: timeOfLastListUpdate trash trash: update wantsSteps)('selecting' accept: contentsIsString replaceSelectionValue: selectedSlotName selection selectionIndex selectionPrintString selectionUnmodifiable toggleIndex:)('code' doItContext doItReceiver)('menu commands' addCollectionItemsTo: chasePointers classOfSelection classVarRefs defsOfSelection explorePointers exploreSelection fieldListMenu: inspectBasic inspectElement inspectSelection inspectorKey:from: objectReferencesToSelection referencesToSelection spawnFullProtocol spawnProtocol)('code pane menu' editorClass)('updating' updateListsAndCodeIn:)('message list menu' browseClass browseClassRefs browseClassVarRefs browseClassVariables browseFullProtocol browseInstVarDefs browseInstVarRefs browseMethodFull classHierarchy copyName)('initialize-release' initialize inspect:)('object fileIn' convertToCurrentVersion:refStream:)('private' printStringErrorText)('stepping' stepAt:in:)!ImageSegment removeSelector: #copySmartRootsExport:!Float removeSelector: #byteEncode:base:!DebuggerMethodMapForClosureCompiledMethods removeSelector: #ensureExtentsMapsInitialized!Debugger removeSelector: #aboutToStyle:!Debugger removeSelector: #buildFullWith:!Debugger removeSelector: #buildNotifierWith:label:message:!Debugger removeSelector: #buildWith:!Debugger removeSelector: #preDebugMessageString!Debugger removeSelector: #wantsAnnotationPane!!Debugger reorganize!('initialize' buttonRowForPreDebugWindow: customButtonRow customButtonSpecs debugAt: errorWasInUIProcess: initialExtent notifierButtonHeight openFullMorphicLabel: openFullNoSuspendLabel: openNotifierContents:label: optionalButtonPairs preDebugButtonQuads release wantsOptionalButtons windowIsClosing)('accessing' contents contents:notifying: contextVariablesInspector debuggerMap doNothing: interruptedContext interruptedProcess isNotifier labelString labelString: proceedValue proceedValue: receiver receiverInspector receiverInspectorObject:context: stringContents)('notifier menu' debug storeLog)('context stack (message list)' contextStackIndex contextStackList expandStack fullyExpandStack messageListIndex selectedMessage selectedMessageName toggleContextStackIndex:)('context stack menu' abandon abandon: askForCategoryIn:default: browseMessages browseSendersOfMessages browseVersions buildMorphicNotifierLabelled:message: contextStackKey:from: contextStackMenu:shifted: debugProceedMenu: doStep down fullStack implement:inClass: messageListMenu:shifted: peelToFirst populateImplementInMenu: proceed proceed: restart returnValue selectPC send stepIntoBlock up where)('code pane' contentsSelection doItContext doItReceiver pc pcRange)('code pane menu' codePaneMenu:shifted: perform:orSendTo: runToSelection:)('message category list' selectedMessageCategoryName)('class list' selectedClass selectedClassOrMetaClass)('dependents access' step updateInspectors wantsSteps)('private' askForSuperclassOf:toImplement:ifCancel: checkContextSelection contextStackIndex:oldContextWas: createMethod externalInterrupt: lowSpaceChoices newStack: process:controller:context: resetContext: resumeProcess: selectedContext)('controls' addOptionalButtonsTo:at:plus:)('breakpoints' toggleBreakOnEntry)('*Shout-Styling' shoutAboutToStyle:)('as yet unclassified' paneMenu:shifted:editorClass:)('tally support' getSelectedText getTextMorphWithSelection tally)!ContextPart removeSelector: #methodNodeFormattedAndDecorated:!ContextPart removeSelector: #methodSelector!!ContextPart reorganize!('accessing' at: at:put: basicAt: basicAt:put: basicSize client contextForLocalVariables home method methodNode methodReturnContext receiver size tempAt: tempAt:put:)('instruction decoding' doDup doPop jump: jump:if: methodReturnConstant: methodReturnReceiver methodReturnTop popIntoLiteralVariable: popIntoReceiverVariable: popIntoRemoteTemp:inVectorAt: popIntoTemporaryVariable: pushActiveContext pushClosureCopyNumCopiedValues:numArgs:blockSize: pushConstant: pushLiteralVariable: pushNewArrayOfSize: pushReceiver pushReceiverVariable: pushRemoteTemp:inVectorAt: pushTemporaryVariable: return:from: send:super:numArgs: storeIntoLiteralVariable: storeIntoReceiverVariable: storeIntoRemoteTemp:inVectorAt: storeIntoTemporaryVariable:)('debugger access' contextStack depthBelow: errorReportOn: longStack methodClass namedTempAt: namedTempAt:put: pc print:on: release releaseTo: selector sender shortStack singleRelease sourceCode stack stackOfSize: swapSender: tempNames tempsAndValues tempsAndValuesLimitedTo:indent:)('controlling' activateMethod:withArgs:receiver:class: blockCopy: closureCopy:copiedValues: hasSender: jump pop push: quickSend:to:with:super: restart resume resume: return return: return:to: runUntilErrorOrReturnFrom: send:to:with:super: terminate terminateTo: top)('printing' printDetails: printOn:)('system simulation' completeCallee: quickStep runSimulated:contextAtEachStep: step stepToCallee stepToSendOrReturn)('private' activateReturn:value: cannotReturn:to: copyTo:blocks: cut: doPrimitive:method:receiver:args: insertSender: privSender: push:fromIndexable: stackPtr stackp: tryNamedPrimitiveIn:for:withArgs: tryPrimitiveFor:receiver:args:)('private-exceptions' canHandleSignal: findNextHandlerContextStarting findNextUnwindContextUpTo: handleSignal: isHandlerContext isUnwindContext nextHandlerContext unwindTo:)('objects from disk' storeDataOn:)('private-debugger' cachesStack)('query' bottomContext copyStack copyTo: findContextSuchThat: findSecondToOldestSimilarSender findSimilarSender hasContext: isBottomContext isClosureContext isContext isDead secondFromBottom)('mirror primitives' objectClass:)!CompilerTest removeSelector: #testScaledDecimalLiterals!CompiledMethod removeSelector: #methodNodeFormattedAndDecorated:!Smalltalk removeClassNamed: #ColoredCodeStream!Smalltalk removeClassNamed: #FieldNode!