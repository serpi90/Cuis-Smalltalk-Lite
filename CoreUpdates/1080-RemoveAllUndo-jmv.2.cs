'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 19 September 2011 at 9:57:34 am'!!BareTextMorph methodsFor: 'private' stamp: 'jmv 9/19/2011 09:46'!updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, and current typing emphasis."	| sel oldEditor |	paragraph ifNotNil: [		editor ifNotNil: [			oldEditor := editor.			sel := editor selectionInterval.			editor storeSelectionInParagraph].		self fit.		self layoutChanged.		sel ifNotNil: [			editor ifNil: [				"Reinstate selection after, eg, style change"				self installEditorToReplace: oldEditor]]].	editView setScrollDeltas! !!Editor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 09:46'!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary."	self		replace: self selectionInterval		with: self clipboardStringOrText		and: [ self selectAt: self pointIndex ]! !!SimpleEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 09:47'!copySelection	"Copy the current selection and store it in the Clipboard, unless a caret."	self lineSelectAndEmptyCheck: [^ self].	self clipboardTextPut: self selection! !!SimpleEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 09:47'!cut	"Cut out the current selection and redisplay the paragraph if necessary."	self lineSelectAndEmptyCheck: [^ self].	self replaceSelectionWith: ''. 	self clipboardTextPut: self selection! !!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 9/19/2011 09:47'!processKeyStroke: aKeyboardEvent	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters."	(self dispatchOn: aKeyboardEvent) ifTrue: [		^self].	self markIndex: self pointIndex! !!SimpleEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 09:47'!forwardDelete: aKeyboardEvent	"Delete forward over the next character."	| startIndex stopIndex |	startIndex _ self markIndex.	startIndex > string size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: ''.		^ false].	"Null selection - do the delete forward"	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [ stopIndex := (self nextWordStart: stopIndex) - 1 ].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: ''.	self selectFrom: startIndex to: startIndex-1.	^false! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 09:46'!replace: anInterval with: newText and: selectingBlock 	"Replace the text in anInterval with newText and execute selectingBlock to establish the new selection."	| currentInterval |	currentInterval _ self selectionInterval.	currentInterval = anInterval ifFalse: [ self selectInterval: anInterval ].	self zapSelectionWith: newText.	selectingBlock value! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/19/2011 09:48'!replaceSelectionWith: aTextOrString	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval."	self zapSelectionWith: aTextOrString.! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 9/19/2011 09:38'!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	paragraph _ aParagraph.	paragraph editor: self! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 9/19/2011 09:40'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	markBlock _ paragraph defaultCharacterBlock.	pointBlock _ markBlock.	self setEmphasisHereFromText.	selectionStartBlocks _ #().	selectionStopBlocks _ #()! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 09:45'!again	"Text substitution. If the left shift key is down, the substitution is made 	throughout the entire Paragraph. Otherwise, only the next possible 	substitution is made."	"If last command was also 'again', use same keys as before"	"jmvnote: fix it"	self againOrSame: false! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 09:45'!copySelection	"Copy the current selection and store it in the Clipboard, unless a caret."	| multiSelection |	self lineSelectAndEmptyCheck: [^ self].	multiSelection _ self selection.	self clipboardTextPut: multiSelection! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 09:45'!cut	"Cut out the current selection and redisplay the paragraph if necessary."	| multiSelection |	selectionStartBlocks ifEmpty: [		self lineSelectAndEmptyCheck: [^ self]].	multiSelection _ self selection.	self zapMultiSelection.	self replaceSelectionWith: self nullText.	self clipboardTextPut: multiSelection.! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 9/19/2011 09:26'!undo	self halt: 'toBeImplemented'! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 9/19/2011 09:45'!processKeyStroke: aKeyboardEvent	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters."	(self dispatchOn: aKeyboardEvent) ifTrue: [		self storeSelectionInParagraph.		^self].	markBlock _ pointBlock.	self storeSelectionInParagraph! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 09:32'!doAgainMany: aKeyboardEvent 	"Do the previous thing again repeatedly. 1/26/96 sw"	"jmvnote: fix it"	self againOrSame: false many: true.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 09:39'!forwardDelete: aKeyboardEvent	"Delete forward over the next character."	| startIndex stopIndex |	startIndex _ self markIndex.	startIndex > self text size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	^false! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 09:44'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: [ "Choose as FindText..."		"jmvNote: must fix this!!"		FindText _ ''.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: [ "just inserted at a caret"			home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: [ "Show where the search will start"			home last = self selectionInterval last ifFalse: [				self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	selectionStartBlocks _ OrderedCollection new.	selectionStopBlocks _ OrderedCollection new.	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	"Last find was also stored in markBlock / pointBlock"	selectionStartBlocks notEmpty ifTrue: [		selectionStartBlocks removeLast.		selectionStopBlocks removeLast ].	indices isEmpty ifTrue: [  "none found"		self flash.		wasTypedKey ifFalse: [^self]]! !!TextEditor methodsFor: 'private' stamp: 'jmv 9/19/2011 09:40'!zapSelectionWith: replacement	| start stop rep |	start _ self startIndex.	stop _ self stopIndex.	(replacement isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (self text attributesAt: start) select: [:att | att mayBeExtended]].	(start = stop and: [ replacement isEmpty ]) ifFalse: [		rep _ self addAttributesForPasting: replacement.		self text replaceFrom: start to: stop - 1 with: rep.		paragraph			recomposeFrom: start			to:  start + rep size - 1			delta: rep size - (stop-start).		self markIndex: start pointIndex: start + rep size.		selectionStartBlocks _ #().		selectionStopBlocks _ #().		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/19/2011 09:47'!argAdvance: aKeyboardEvent	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.."	| start t |	t _ self text.	start _ t findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [ start _ t size + 1].	self selectAt: start + 2.	^true! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/19/2011 09:40'!initializeBasicCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor test"	"Editor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		"arranged in QWERTY keyboard order"	cmds _ #(		$w #backWord:		$a #selectAll:		$f #find:		$g #findAgain:		$h #setSearchString:		$z #undo:		$x #cut:		$c #copySelection:		$v #paste:		$R	#indent:		$Y	#makeUppercase:		$U	#changeLfToCr:		$S	#search:		$H	#cursorTopHome:		$J	#doAgainMany:		$L	#outdent:		$Z	#makeCapitalized:		$X	#makeLowercase:		$C	#compareToClipboard:	).	1 to: cmds size		by: 2		do: [ :i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions _ cmdMap! !!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 9/19/2011 09:49'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers for managing again."  	"TextEditor initialize"	FindText _ ChangeText _ Text new.	self initializeCmdKeyShortcuts.	self initializeMenu! !TextEditor initialize!!SmalltalkEditor reorganize!('editing keys' browseIt: doIt: exploreIt: fileItIn: implementorsOfIt: inspectIt: pasteInitials: printIt: referencesToIt: save: sendersOfIt:)('do-its' compileSelectionFor:in: debug:receiver:in: debugIt doIt evaluateSelectionAndDo:ifFail: exploreIt inspectIt printIt)('menu messages' browseClassFromIt browseIt classCommentsContainingIt explain fileItIn implementorsOfIt methodSourceContainingIt methodStringsContainingit referencesToIt selectedSelector selectedSymbol sendersOfIt)('typing/selecting keys' argAdvance: crWithIndent: displayIfFalse: displayIfTrue: doAgainOnce:)('explain' explainAnySel: explainChar: explainClass: explainCtxt: explainGlobal: explainInst: explainMySel: explainNumber: explainPartSel: explainScan: explainTemp:)('new selection' nextTokenFrom:direction: notify:at:in: selectPrecedingIdentifier selectWord)('private' codeProvider explainDelimitor:)('accessing-selection' selection)!TextEditor removeSelector: #isDoing!TextEditor removeSelector: #isRedoing!TextEditor removeSelector: #isUndoing!TextEditor removeSelector: #noUndoer!TextEditor removeSelector: #selectCurrentTypeIn:!TextEditor removeSelector: #undoAgain:andReselect:typedKey:!TextEditor removeSelector: #undoAndReselect:redoAndReselect:!TextEditor removeSelector: #undoCutCopy:!TextEditor removeSelector: #undoMessage:forRedo:!TextEditor removeSelector: #undoReplace!TextEditor removeSelector: #undoer:!TextEditor removeSelector: #undoer:with:!TextEditor removeSelector: #undoer:with:with:!TextEditor removeSelector: #undoer:with:with:with:!!TextEditor reorganize!('accessing' currentAttributes currentCharacterStyleOrNil currentParagraphStyle lastFont lastParagraphStyleOrNil replace:with:and: replaceSelectionWith: setSearch: string text)('accessing-selection' hasCaret markIndex markIndex: markIndex:pointIndex: pointIndex pointIndex: selection selectionAsStream startBlock startIndex stopBlock stopIndex)('as yet unclassified' totalTextHeight visibleHeight)('attributes' changeEmphasisOrAlignment changeTextFont offerColorMenu offerFontMenu)('current selection' recomputeSelection)('displaying' flash)('editing keys' align: cancel: changeEmphasis: changeLfToCr: chooseColor compareToClipboard: copyHiddenInfo enclose: hiddenInfo inOutdent:delta: indent: makeCapitalized: makeLowercase: makeUppercase: offerColorMenu: offerFontMenu: outdent: undo:)('events' doubleClick: mouseDown: mouseMove: mouseUp:)('initialize-release' changeParagraph: initialize resetState stateArray stateArrayPut:)('menu commands' offerMenuFromEsc:)('menu messages' accept again align cancel changeAlignment chooseAlignment compareToClipboard copySelection cut find findAgain pasteRecent setSearchString undo)('model access' model:)('new selection' afterSelectionInsertAndSelect: correctFrom:to:with: insertAndSelect:at: lineSelectAndEmptyCheck: selectAt: selectFrom:to: selectInterval: selectLine)('nonediting/nontyping keys' cursorEnd: cursorHome: openMenu setSearchString:)('parenblinking' blinkParen blinkParenAt: blinkPrevParen: clearParens)('scrolling' scrollBy:)('typing support' addString: backTo: cmdActions dispatchOn: processKeyStroke: setEmphasisHereFromText setEmphasisHereFromTextForward:)('typing/selecting keys' backWord: clearSelection doAgainMany: find: findAgain: forwardDelete: search: selectAll selectAll:)('private' addAttributesForPasting: againOnce: againOrSame: againOrSame:many: applyAttribute: beginningOfLine: endOfLine: indent:fromStream:toStream: isDisjointFrom: moveCursor:forward:event: nullText pageHeight sameColumn:newLine:forward: storeSelectionInParagraph unapplyAttribute: zapMultiSelection zapSelectionWith:)('binding' bindingOf:)!