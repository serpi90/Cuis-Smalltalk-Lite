'From Cuis 2.0 of 24 February 2010 [latest update: #440] on 2 March 2010 at 8:49:50 am'!!Decompiler commentStamp: 'nice 3/1/2010 19:56' prior: 0!I decompile a method in three phases:	Reverser: postfix byte codes -> prefix symbolic codes (nodes and atoms)	Parser: prefix symbolic codes -> node tree (same as the compiler)	Printer: node tree -> text (done by the nodes)	instance vars:	constructor <DecompilerConstructor> an auxiliary knowing how to generate Abstract Syntax Tree (node tree)	method <CompiledMethod> the method being decompiled	instVars <Array of: String> the instance variables of the class implementing method	tempVars <String | (OrderedCollection of: String)> hold the names of temporary variables (if known)		NOTE: POLYMORPHISM WILL BE RESOLVED IN #initSymbols:	constTable <Collection of: ParseNode> parse node associated with byte encoded constants (nil true false 0 1 -1 etc...)	stack <OrderedCollection of: (ParseNode | String | Integer) > multipurpose...	statements <OrderedCollection of: ParseNode> the statements of the method being decompiled 	lastPc <Integer>	exit <Integer>	caseExits <OrderedCollection of: Integer> - stack of exit addresses that have been seen in the branches of caseOf:'s	lastJumpPc <Integer>	lastReturnPc <Integer>	limit <Integer>	hasValue <Boolean>	blockStackBase <Integer>	numLocaltemps <Integer | Symbol> - number of temps local to a block; also a flag indicating decompiling a block	blockStartsToTempVars <Dictionary key: Integer value: (OrderedCollection of: String)>	tempVarCount <Integer> number of temp vars used by the method!!BlockNode methodsFor: 'code generation (closures)' stamp: 'jmv 3/2/2010 08:40'!addRemoteTemp: aTempVariableNode rootNode: rootNode "<MethodNode>"	"Add aTempVariableNode to my actualScope's sequence of	 remote temps.  If I am an optimized block then the actual	 scope is my actualScopeIfOptimized, otherwise it is myself."	remoteTempNode ifNil: [		remoteTempNode := RemoteTempVectorNode new								name: self remoteTempNodeName								index: arguments size + temporaries size								type: LdTempType								scope: 0.		 actualScopeIfOptimized			ifNil: [				self addTempNode: remoteTempNode.				remoteTempNode definingScope: self]			ifNotNil: [actualScopeIfOptimized addHoistedTemps: { remoteTempNode }]].	remoteTempNode addRemoteTemp: aTempVariableNode encoder: rootNode encoder.		"use remove:ifAbsent: because the deferred analysis for optimized	 loops can result in the temp has already been hoised into the root."	self removeTempNode: aTempVariableNode ifAbsent: [		self actualScope removeTempNode: aTempVariableNode ifAbsent: ["should not happen"]].	^remoteTempNode! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'nice 3/1/2010 23:14'!addTempNode: aTempVariableNode	"Utilities for when we want to add some temporaries."		self makeTemporariesRemovable.	^temporaries add: aTempVariableNode! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'nice 3/1/2010 23:01'!makeTemporariesRemovable	"Utilities for when we want to remove some temporaries."		temporaries isArray ifTrue:		[temporaries := temporaries asOrderedCollection].! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'nice 3/1/2010 23:13'!removeTempNode: aTempVariableNode ifAbsent: aBlock	"Utilities for when we want to remove some temporaries."		self makeTemporariesRemovable.	^temporaries remove: aTempVariableNode ifAbsent: aBlock	! !!Parser methodsFor: 'private' stamp: 'jmv 3/2/2010 08:25'!init: sourceStream notifying: req failBlock: aBlock	requestor := req.	failBlock := aBlock.	requestorOffset := 0.	self scan: sourceStream.	prevMark := hereMark := mark.	self advance! !!Parser methodsFor: 'expression types' stamp: 'nice 2/25/2010 17:52'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode := self newMethodNode comment: messageComment.	^methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!Parser methodsFor: 'expression types' stamp: 'nice 2/25/2010 17:52'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	encoder := encoderToUse.	^self method: doit context: ctxt! !!Parser methodsFor: 'public access' stamp: 'nice 2/25/2010 17:52'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 self encoder init: class context: ctxt notifying: self.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := ReadStream on: requestor text string].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !