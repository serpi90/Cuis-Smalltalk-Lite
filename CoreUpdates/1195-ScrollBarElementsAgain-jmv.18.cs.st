'From Cuis 4.0 of 16 November 2011 [latest update: #1144] on 3 January 2012 at 4:31:40 pm'!!classDefinition: #PluggableButtonMorph category: #'Morphic-Views for Models'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font icon getStateSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle '	classVariableNames: 'Arrows CurrentArrowSize '	poolDictionaries: ''	category: 'Morphic-Views for Models'!!classDefinition: #DraggeableButtonMorph category: #'Morphic-Views for Models'!PluggableButtonMorph subclass: #DraggeableButtonMorph	instanceVariableNames: 'grabSelector dragSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!classDefinition: #ScrollBar category: #'Morphic-Support'!PluggableMorph subclass: #ScrollBar	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton pagingArea scrollDelta pageDelta interval nextPageDirection '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 1/3/2012 15:16'!                         drawOn: aCanvas	| rectangle w x0 y0 h y1 y2 |	aCanvas frameAndFillRectangle: self bounds fillColor: self color borderWidth: borderWidth borderColor: borderColor.	x0 _ bounds left+1.	y0 _ bounds top+1.	w _ bounds width-2.	completer entryCount > self class itemsPerPage  ifTrue: [		w _ bounds width-Preferences scrollbarThickness -2.		aCanvas			frameRectangle: (bounds topRight - (Preferences scrollbarThickness@0)				extent: Preferences scrollbarThickness @ bounds height)			borderWidth: 1			color: borderColor.		aCanvas			image: (PluggableButtonMorph arrowOfDirection: #top)			at: bounds topRight - (Preferences scrollbarThickness@0).		aCanvas			image: (PluggableButtonMorph arrowOfDirection: #bottom)			at: bounds bottomRight - Preferences scrollbarThickness.		h _ bounds height - (2 * Preferences scrollbarThickness).		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + Preferences scrollbarThickness-1.		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + Preferences scrollbarThickness -1.		aCanvas fillRectangle: (bounds right - Preferences scrollbarThickness+2@y1 corner: bounds right-2 @ y2) colorOrInfiniteForm: Color veryLightGray.		aCanvas		].	self firstVisible		to: self lastVisible		do: [ :index |			rectangle _ x0@y0 extent: w@self class itemHeight.			index = self selected				ifTrue: [					aCanvas fillRectangle: rectangle colorOrInfiniteForm: (Theme current listHighlightFocused: true) ].			aCanvas				drawString: (completer entries at: index) asString				in: rectangle				font: self class listFont				color: Theme current text.			y0 _ y0 + self itemHeight ]! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 1/3/2012 15:16'!                            expandedForm	^PluggableButtonMorph arrowOfDirection: #bottom! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 1/3/2012 15:16'!                   notExpandedForm	^PluggableButtonMorph arrowOfDirection: #right! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/3/2012 15:02'!                 draw3DLookOn: aCanvas	| w f center x y borderStyleSymbol c availableW l labelMargin |	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].	c _ color.	self mouseIsOver ifTrue: [ c _ c  lighter ].	aCanvas		fillRectangle: bounds		colorOrInfiniteForm: c		borderWidth: borderWidth		borderStyleSymbol: borderStyleSymbol.	f _ self fontToUse.	center _ bounds center.	label ifNotNil: [		labelMargin _ 4.		w _ f widthOfString: label.		availableW _ bounds width-labelMargin-labelMargin-1.		availableW >= w			ifTrue: [				x _ center x - (w // 2).				l _ label ]			ifFalse: [				x _ bounds left + labelMargin.				l _ label squeezedTo: (label size * availableW / w) rounded ].		y _ center y - (f height // 2).		self isPressed ifTrue: [			x _ x + 1.			y _ y + 1 ].		aCanvas			drawString: l			in: (x@y extent: bounds extent - (labelMargin*2-2@4))			font: f			color: Theme current buttonLabel ]! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:03'!     handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	^true! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:03'!  handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?" 	^true! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:56'!             handlesMouseStillDown: evt	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"	"Acting when down (instead of waiting until releasing the button)	also means that the button actin is repeated if the button is kept pressed"	^actWhen == #buttonDown! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:26'!                        mouseDown: event	event mouseButton2Pressed ifTrue: [ ^ self mouseButton2Activity ].	isPressed _ true.	self redrawNeeded.	actWhen == #buttonDown		ifTrue: [			self performAction ]		ifFalse: [			"Don't make multi-click slower if we act on button down, just do multiple actions"			event hand				waitForClicksOrDragOrSimulatedMouseButton2: self				event: event				clkSel: nil				clkNHalf: nil				dblClkSel: #doubleClick:				dblClkNHalfSel: nil				tripleClkSel: nil ]! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:56'!              mouseStillDown: evt	"Acting when down (instead of waiting until releasing the button)	also means that the button actin is repeated if the button is kept pressed.	See #handlesMouseStillDown:"	self performAction! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:03'!                      mouseStillDownStepRate	"At what rate do I want to receive #mouseStillDown: notifications?"	^40! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:40'!           mouseUp: aMouseEvent	isPressed _ false.	mouseIsOver _ false.	(actWhen == #buttonUp and: [self containsPoint: aMouseEvent position])		ifTrue: [ self performAction ].	self redrawNeeded! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 1/3/2012 15:01'!                defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/3/2012 15:21'!                              updateDownButtonImage	"update the receiver's as a downButton.  put a new image inside"	icon _ self class arrowOfDirection: #bottom size: bounds extent.	actionSelector _ #scrollDown.	self		roundButtonStyle: false;		actWhen: #buttonDown;		"to enable multiple action if held down"		redrawNeeded! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/3/2012 15:21'!                              updateLeftButtonImage	"update the receiver's as a downButton.  put a new image inside"	icon _ self class arrowOfDirection: #left size: bounds extent.	actionSelector _ #scrollUp.	self		roundButtonStyle: false;		actWhen: #buttonDown;		"to enable multiple action if held down"		redrawNeeded! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/3/2012 15:21'!  updateRightButtonImage	"update the receiver's as a downButton.  put a new image inside"	icon _ self class arrowOfDirection: #right size: bounds extent.	actionSelector _ #scrollDown.	self		roundButtonStyle: false;		actWhen: #buttonDown;		"to enable multiple action if held down"		redrawNeeded! !!PluggableButtonMorph methodsFor: 'scrollbar button' stamp: 'jmv 1/3/2012 15:21'!                              updateUpButtonImage	"update the receiver's as a upButton. put a new image inside"	icon _ self class arrowOfDirection: #top size: bounds extent.	actionSelector _ #scrollUp.	self		roundButtonStyle: false;		actWhen: #buttonDown;		"to enable multiple action if held down"		redrawNeeded! !!DraggeableButtonMorph methodsFor: 'initialization' stamp: 'jmv 1/3/2012 15:55'!        initialize	"initialize the state of the receiver"	super initialize.	grabSelector _ nil.	dragSelector _ nil.! !!DraggeableButtonMorph methodsFor: 'accessing' stamp: 'jmv 1/3/2012 15:37'!                               dragSelector: aSymbol	dragSelector _ aSymbol! !!DraggeableButtonMorph methodsFor: 'accessing' stamp: 'jmv 1/3/2012 15:53'!  grabSelector: aSymbol	grabSelector _ aSymbol! !!DraggeableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:54'!                             mouseDown: aMouseEvent	"Inform the model that this button has been released. "	super mouseDown: aMouseEvent.	grabSelector ifNotNil: [		model perform: grabSelector ]! !!DraggeableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 15:42'!  mouseMove: aMouseEvent	dragSelector ifNotNil: [		model perform: dragSelector with: aMouseEvent targetPoint ]! !!DraggeableButtonMorph methodsFor: 'event handling' stamp: 'jmv 1/3/2012 16:05'!                            mouseUp: aMouseEvent	isPressed _ false.	mouseIsOver _ false.	actWhen == #buttonUp		ifTrue: [ self performAction ].	self redrawNeeded! !!DraggeableButtonMorph methodsFor: 'testing' stamp: 'jmv 1/3/2012 15:59'!        isRoundButton	^false! !!PluggableButtonMorph class methodsFor: 'images' stamp: 'jmv 1/3/2012 16:31'!                       arrowOfDirection: aSymbol	"answer a form with an arrow based on the parameters, of the current size"	Arrows ifNil: [		"Some arbitrary size. Not really important."		self initializeArrows: 13@13 ].	^Arrows at: aSymbol! !!PluggableButtonMorph class methodsFor: 'images' stamp: 'jmv 1/3/2012 15:11'!                 arrowOfDirection: aSymbol size: finalSizeInteger	"answer a form with an arrow based on the parameters"	CurrentArrowSize = finalSizeInteger ifFalse: [		self initializeArrows: finalSizeInteger ].	^Arrows at: aSymbol! !!PluggableButtonMorph class methodsFor: 'images' stamp: 'jmv 1/3/2012 15:11'!                    createArrowIn: aRectangle 	"PRIVATE - create an arrow bounded in aRectangle"	"	(self createArrowOfDirection: #up in: (0@0 extent: 20@20)) openInWorld	"	| arrow vertices |	vertices _ self verticesForSimpleArrow: aRectangle.	arrow _ PolygonMorph 				vertices: vertices				color: Color darkGray				borderWidth: 0				borderColor: Color black.	arrow bounds: (arrow bounds insetBy: (aRectangle width / 6) rounded).	^arrow! !!PluggableButtonMorph class methodsFor: 'images' stamp: 'jmv 1/3/2012 15:12'!createArrowOfDirection: aSymbolDirection size: finalSizeInteger	"PRIVATE - create an arrow with aSymbolDirectionDirection,  	finalSizeInteger and aColor  	 	aSymbolDirectionDirection = #top, #bottom. #left or #right  	 (self createArrowOfDirection: #up size: 120) display	"	| resizeFactor outerBox arrowMorph resizedForm f |	resizeFactor _ 4.	outerBox _ RectangleMorph new.	outerBox		extent: finalSizeInteger asPoint * resizeFactor;		borderWidth: 0;		color: Color transparent.		arrowMorph _ self createArrowIn: outerBox bounds.	arrowMorph position: outerBox bounds center - (arrowMorph extent // 2).	outerBox addMorphFront: arrowMorph.		f _ outerBox imageForm: 32.	resizedForm _ f				magnify: f boundingBox				by: 1 / resizeFactor				smoothing: 4.	aSymbolDirection == #right		ifTrue: [resizedForm _ resizedForm rotateBy: 90].	aSymbolDirection == #bottom		ifTrue: [resizedForm _ resizedForm rotateBy:  180].	aSymbolDirection == #left		ifTrue: [resizedForm _ resizedForm rotateBy:  270].			aSymbolDirection == #up		ifFalse: [ resizedForm _ resizedForm			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].			^resizedForm! !!PluggableButtonMorph class methodsFor: 'images' stamp: 'jmv 1/3/2012 15:12'!                              initializeArrows: finalSizeInteger	Arrows _ Dictionary new.	#(#top #bottom #left #right ) do: [ :dir |		Arrows at: dir put: (self createArrowOfDirection: dir size: finalSizeInteger) ].	CurrentArrowSize _ finalSizeInteger! !!PluggableButtonMorph class methodsFor: 'images' stamp: 'jmv 1/3/2012 15:12'!             verticesForSimpleArrow: aRectangle 	"PRIVATE - answer a collection of vertices to draw a simple arrow"	| vertices |	vertices _ OrderedCollection new.		vertices add: aRectangle bottomLeft.	vertices add: aRectangle center x @ (aRectangle top + (aRectangle width / 8)).	vertices add: aRectangle bottomRight.		^ vertices! !!ScrollBar methodsFor: 'access' stamp: 'jmv 1/3/2012 15:31'!                        color: aColor	"Change the color of the scrollbar to go with aColor."	| buttonColor |	super color: aColor.	buttonColor _ color alphaMixed: 0.7 with: (Color gray: 0.95).	upButton color: buttonColor.	downButton color: buttonColor.	slider color: buttonColor slightlyLighter.	sliderShadow color: (color alphaMixed: 0.45 with: Color white)! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 1/3/2012 15:18'!     initializeDownButton	"initialize the receiver's downButton"	| e |	e _ self buttonExtent.	downButton _ PluggableButtonMorph new.	downButton model: self.	self addMorph: downButton.	downButton bounds: (self innerBounds bottomRight - e extent: e).	bounds isWide		ifTrue: [ downButton updateRightButtonImage ]		ifFalse: [ downButton updateDownButtonImage ]! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 1/3/2012 15:53'!                initializeSlider	"initialize the receiver's slider"	sliderShadow _ RectangleMorph new.	sliderShadow borderWidth: 0.	self addMorph: sliderShadow.	sliderShadow bounds: self totalSliderArea.	sliderShadow hide.			slider _ DraggeableButtonMorph new.	slider model: self.	slider grabSelector: #sliderGrabbed.	slider dragSelector: #scrollAbsolute:.	slider action: #sliderReleased.	self addMorph: slider.	slider bounds: self totalSliderArea.	self computeSlider! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 1/3/2012 15:18'!      initializeUpButton	"initialize the receiver's upButton"	upButton _ PluggableButtonMorph new.	upButton model: self.	self addMorph: upButton.	upButton		bounds: (self innerBounds topLeft extent: self buttonExtent).	bounds isWide		ifTrue: [ upButton updateLeftButtonImage ]		ifFalse: [ upButton updateUpButtonImage ].! !!ScrollBar methodsFor: 'initialize' stamp: 'jmv 1/3/2012 14:51'!                       recreateSubmorphs	self removeAllMorphs.	self		initializeUpButton;		initializeDownButton;		initializeSlider.	"Set color for submorphs"	self color: color.! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 1/3/2012 15:36'!                            scrollAbsolute: aPoint	| r p |	r _ self roomToMove.	bounds isWide		ifTrue: [r width = 0 ifTrue: [^ self]]		ifFalse: [r height = 0 ifTrue: [^ self]].	p _ aPoint adhereTo: r.	self setValue: (bounds isWide 		ifTrue: [(p x - r left) asFloat / r width]		ifFalse: [(p y - r top) asFloat / r height])! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 1/3/2012 15:13'!             scrollDown	self scrollDown: 1! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 1/3/2012 15:13'!                             scrollUp	self scrollUp: 1! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 1/3/2012 15:57'! sliderGrabbed	sliderShadow		bounds: slider bounds;		show! !!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 1/3/2012 15:44'!sliderReleased	sliderShadow hide! !!ScrollBar methodsFor: 'drawing' stamp: 'jmv 1/3/2012 16:01'!                           drawOn: aCanvas	aCanvas		fillRectangle: bounds		colorOrInfiniteForm: (color alphaMixed: 0.3 with: Color white)		borderWidth: borderWidth		borderStyleSymbol: #simple		baseColorForBorder: borderColor! !!ScrollBar methodsFor: 'event handling' stamp: 'jmv 1/3/2012 14:52'!           handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	^true! !!ScrollBar methodsFor: 'event handling' stamp: 'jmv 1/3/2012 14:52'!             handlesMouseStillDown: evt	"Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"	^true! !!ScrollBar methodsFor: 'event handling' stamp: 'jmv 1/3/2012 14:53'!     mouseDown: aMouseEvent	"Update visual feedback"	super mouseDown: aMouseEvent.	self setNextDirectionFromEvent: aMouseEvent.	self scrollByPage! !!ScrollBar methodsFor: 'event handling' stamp: 'jmv 1/3/2012 14:53'!      mouseStillDown: evt	self scrollByPage! !!methodRemoval: ScrollBar #initializePagingArea!ScrollBar removeSelector: #initializePagingArea!!methodRemoval: ScrollBar #sliderShadow!ScrollBar removeSelector: #sliderShadow!!methodRemoval: ScrollBar #sliderShadowColor!ScrollBar removeSelector: #sliderShadowColor!!classDefinition: #ScrollBar category: #'Morphic-Support'!PluggableMorph subclass: #ScrollBar	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton scrollDelta pageDelta interval nextPageDirection'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!classDefinition: #PluggableButtonMorph category: #'Morphic-Views for Models'!PluggableMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'label font icon getStateSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle'	classVariableNames: 'Arrows CurrentArrowSize'	poolDictionaries: ''	category: 'Morphic-Views for Models'!!classRemoval: #ScrollbarButton!Smalltalk removeClassNamed: #ScrollbarButton!!classRemoval: #ScrollbarElement!Smalltalk removeClassNamed: #ScrollbarElement!!classRemoval: #ScrollbarPagingArea!Smalltalk removeClassNamed: #ScrollbarPagingArea!!classRemoval: #ScrollbarSlider!Smalltalk removeClassNamed: #ScrollbarSlider!!classRemoval: #ScrollbarSliderShadow!Smalltalk removeClassNamed: #ScrollbarSliderShadow!