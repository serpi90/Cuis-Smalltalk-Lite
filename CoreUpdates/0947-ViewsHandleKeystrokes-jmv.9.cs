'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 25 April 2011 at 10:35:34 am'!!classDefinition: #Debugger category: #'Tools-Debugger'!CodeProvider subclass: #Debugger	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC savedCursor errorWasInUIProcess labelString '	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Tools-Debugger'!!CodeWindow methodsFor: 'misc' stamp: 'jmv 4/25/2011 09:26'!useSelector: incomingSelector orGetSelectorAndSendQuery: querySelector to: queryPerformer	"If incomingSelector is not nil, use it, else obtain a selector from user type-in.   Using the determined selector, send the query to the performer provided."	| aSelector |	incomingSelector		ifNotNil: [			queryPerformer perform: querySelector with: incomingSelector]		ifNil: [			aSelector _FillInTheBlank request: 'Type selector:' initialAnswer: 'flag:'.			aSelector isEmptyOrNil ifFalse:				[(Symbol hasInterned: aSelector ifTrue:					[:aSymbol | queryPerformer perform: querySelector with: aSymbol])					ifFalse:						[self inform: 'no such selector']]]! !!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:38'!classListKey: aChar from: view 	"Respond to a Command key.  I am a model with a list of classes and a 	code pane, and I also have a listView that has a list of methods.  The 	view knows how to get the list and selection."	aChar == $r ifTrue: [^ model recent].	aChar == $h ifTrue: [		^ self browseHierarchy].	aChar == $x ifTrue: [^ model removeClass].	^ self messageListKey: aChar from: view! !!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:31'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ model toggleDiffing].	sel _ model selectedMessageName.	aChar == $m ifTrue: [  "These next two put up a type in if no message selected"		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].	aChar == $n ifTrue: [		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].	"The following require a class selection"	(class _ model selectedClassOrMetaClass) ifNil: [^ self ].	aChar == $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self browseHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: [		aChar == $o ifTrue: [^ model fileOutMessage].		aChar == $c ifTrue: [^ model copySelector].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ model removeMessage]]! !!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:41'!packageListKey: aChar from: view	"Respond to a Command key in the package pane in the PackageBrowser"	aChar == $f ifTrue: [^ self findClass].	^ self classListKey: aChar from: view! !!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:50'!systemCatListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findClass].	aChar == $x ifTrue: [^ model removeSystemCategory].	^ self classListKey: aChar from: view! !!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:43'!buildMorphicMessageCatList	| myMessageCatList |	myMessageCatList _ PluggableMessageCategoryListMorph		model: model		listGetter: #messageCategoryList		indexGetter: #messageCategoryListIndex		indexSetter: #messageCategoryListIndex:		mainView: self		menuGetter: #messageCategoryMenu		keystrokeAction: nil		rawListGetter: #rawMessageCategoryList.	myMessageCatList enableDragNDrop: false.	^myMessageCatList! !!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 4/25/2011 09:48'!systemCatSingletonMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList: #(		('find class... (f)'				findClass)		-		('browse all'				browseAllClasses)		('browse'					openSystemCategoryBrowser)		-		('fileOut'					fileOutSystemCategory				''		model)		-		('update'					updateSystemCategories				''		model)		('rename...'					renameSystemCategory				''		model)		('remove'					removeSystemCategory				''		model)).	^aMenu! !!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 4/25/2011 09:48'!systemCategoryMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList: #(		('find class... (f)'				findClass)		('recent classes... (r)'		recent									''		model)		-		('browse all'				browseAllClasses)		('browse'					openSystemCategoryBrowser)		-		('fileOut'					fileOutSystemCategory				''		model)		-		('reorganize'				editSystemCategories					''		model)		('alphabetize'				alphabetizeSystemCategories		''		model)		-		('update'					updateSystemCategories				''		model)		('add item...'				addSystemCategory					''		model)		('rename...'					renameSystemCategory				''		model)		('remove'					removeSystemCategory				''		model)		-		('move to top'				moveSystemCategoryTop				''		model)		('move up'					moveSystemCategoryUp				''		model)		('move down'				moveSystemCategoryDown			''		model)		('move to bottom' 			moveSystemCategoryBottom			''		model)).	^aMenu! !!BrowserWindow methodsFor: 'commands' stamp: 'jmv 4/25/2011 09:45'!findClass	"Search for a class by name."	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |	model okToChange ifFalse: [^ self flash].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self flash].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ model potentialClassNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self flash].	exactMatch _ classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].	index = 0 ifTrue: [^ self flash].	foundClass _ Smalltalk at: (classNames at: index) asSymbol. 	model selectCategoryForClass: foundClass.	model selectClass: foundClass! !!BrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:19'!systemCatSingletonKey: aChar from: aView	^ self messageListKey: aChar from: aView! !!ChangeListWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:21'!changeListKey: aChar from: view	"Respond to a Command key in the list pane."	aChar == $D ifTrue: [^ model toggleDiffing].	aChar == $a ifTrue: [^ model selectAll]! !!ChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:00'!changeSetListKey: aChar from: view	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."	aChar == $c ifTrue: [^ model copyAllToOther].	aChar == $D ifTrue: [^ model toggleDiffing]. 	aChar == $m ifTrue: [^ model newCurrent].	aChar == $n ifTrue: [^ model newSet].	aChar == $o ifTrue: [^ model fileOut].	aChar == $p ifTrue: [^ model addPreamble].	aChar == $r ifTrue: [^ model rename].	aChar == $x ifTrue: [^ model remove].	aChar == $- ifTrue: [^ model subtractOtherSide].	^ self messageListKey: aChar from: view! !!ChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:40'!classListKey: aChar from: view	"Respond to a Command key in the class-list pane."	aChar == $x ifTrue: [^ model removeClass].	aChar == $d ifTrue: [^ model forgetClass]. 	^ self messageListKey: aChar from: view "picks up b,h,p"! !!ChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:23'!messageListKey: aChar from: view	"Respond to a Command key in the message-list pane."	aChar == $d ifTrue: [^ model forget].	super messageListKey: aChar from: view! !!DebuggerWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:04'!contextStackKey: aChar from: view	"Respond to a keystroke in the context list"	aChar == $e ifTrue: [^ model send].	aChar == $t ifTrue: [^ model doStep].	aChar == $T ifTrue: [^ model stepIntoBlock].	aChar == $p ifTrue: [^ model proceed].	aChar == $r ifTrue: [^ model restart].	aChar == $f ifTrue: [^ model fullStack].	aChar == $w ifTrue: [^ model where].	^ self messageListKey: aChar from: view! !!DebuggerWindow class methodsFor: 'Notifier window' stamp: 'jmv 4/25/2011 08:45'!openMorphicNotifierLabelled: label message: messageString debugger: aDebugger	| notifyPane window extentToUse |	aDebugger expandStack.	messageString		ifNil: [			notifyPane _ PluggableListMorph				model: aDebugger				listGetter: #contextStackList				indexGetter: #contextStackIndex				indexSetter: #debugAt:				mainView: self				menuGetter: nil				keystrokeAction: nil ]		ifNotNil: [			notifyPane _ TextModelMorph withText: messageString.			notifyPane askBeforeDiscardingEdits: false ].	window _ SystemWindow new model: aDebugger.	window layoutMorph		addMorph: (self buttonRowForPreDebugWindow: aDebugger) proportionalHeight: 0.2;		addAdjusterAndMorph: notifyPane proportionalHeight: 0.8.	window setLabel: label.	window widgetsColor: Theme current debugger.	extentToUse _ 650 @ 320.	"nice and wide to show plenty of the error msg"	^ window openInWorldExtent: extentToUse.! !!DualChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:00'!changeSetListKey: aChar from: view	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."	aChar == $c ifTrue: [^ view model copyAllToOther].	aChar == $D ifTrue: [^ view model toggleDiffing]. 	aChar == $m ifTrue: [^ view model newCurrent].	aChar == $n ifTrue: [^ view model newSet].	aChar == $o ifTrue: [^ view model fileOut].	aChar == $p ifTrue: [^ view model addPreamble].	aChar == $r ifTrue: [^ view model rename].	aChar == $x ifTrue: [^ view model remove].	aChar == $- ifTrue: [^ view model subtractOtherSide].	^ self messageListKey: aChar from: view! !!DualChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:40'!classListKey: aChar from: view	"Respond to a Command key in the class-list pane."	aChar == $x ifTrue: [^ view model removeClass].	aChar == $d ifTrue: [^ view model forgetClass]. 	^ self messageListKey: aChar from: view "picks up b,h,p"! !!DualChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:23'!messageListKey: aChar from: view	"Respond to a Command key in the message-list pane."	aChar == $d ifTrue: [^ view model forget].	super messageListKey: aChar from: view! !!FileContentsBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:46'!buildMorphicWindow	"Create a pluggable version of all the views for a Browser, including views and controllers."	| list1 list2 upperPanes |	model systemCategoryListIndex: 1.	list1 _ PluggableListMorph 			model: model 			listGetter: #systemCategorySingleton			indexGetter: #indexIsOne 			indexSetter: #indexIsOne:			mainView: self			menuGetter: #packageListMenu			keystrokeAction: #packageListKey:from:.	list1 hideScrollBarsIndefinitely.		list2 _ PluggableListMorph 			model: model 			listGetter: #messageCategoryList			indexGetter: #messageCategoryListIndex 			indexSetter: #messageCategoryListIndex:			mainView: self			menuGetter: #messageCategoryMenu			keystrokeAction: nil.	upperPanes _ LayoutMorph newRow.	upperPanes		addMorph: self buildMorphicClassColumn proportionalWidth: 0.3;		addAdjusterAndMorph: list2 proportionalWidth: 0.3;		addAdjusterAndMorph: self buildMorphicMessageList proportionalWidth: 0.4.	self layoutMorph		addMorph: list1 fixedHeight: Preferences standardCodeFont height + 10;		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.	model changed: #editSelection! !!FileContentsBrowserWindow methodsFor: 'menu building' stamp: 'jmv 4/25/2011 09:49'!packageListMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addList: #(		('find class... (f)'				findClass)		-		('fileIn'						fileInPackage					''		model)		('file into new changeset'	fileIntoNewChangeSet			''		model)		('fileOut'					fileOutPackage					''		model)		('remove existing'			removeUnmodifiedClasses		''		model)).	^ aMenu! !!FileContentsBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:39'!classListKey: aChar from: view	aChar == $b ifTrue: [^ self browseMethodFull].	aChar == $N ifTrue: [^ self browseClassRefs].	self packageListKey: aChar from: view! !!FileContentsBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:23'!messageListKey: aChar from: view	aChar == $b ifTrue: [^ self browseMethodFull].	super messageListKey: aChar from: view! !!FileContentsBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:42'!packageListKey: aChar from: view	aChar == $f ifTrue: [^ self findClass]! !!FileContentsBrowserWindow methodsFor: 'commands' stamp: 'jmv 4/25/2011 09:44'!findClass	| pattern foundClass classNames index foundPackage |	model okToChange ifFalse: [^ self flash].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	classNames addAll: model selectedPackage classes keys.	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size = 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.		(model selectedPackage classes includesKey: (classNames at: index)) ifTrue:[			foundClass := model selectedPackage classes at: (classNames at: index).			foundPackage := model selectedPackage].	foundClass ifNotNil: [	 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundPackage packageName asSymbol).		model classListIndex: (model classList indexOf: foundClass name) ]! !!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:46'!morphicDirectoryTreePaneself flag: #ojo. "keystrokeAction era nil, no soportabamos flechitas aca..."	^(SimpleHierarchicalListMorph 		model: model		listGetter: #initialDirectoryList		indexGetter: #currentDirectorySelected		indexSetter: #setSelectedDirectoryTo:		mainView: self		menuGetter: #volumeMenu		keystrokeAction: nil)			autoDeselect: false;			enableDrag: false;			enableDrop: true;			yourself! !!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:46'!morphicFileListPane	^(PluggableListMorph 		model: model 		listGetter: #fileList 		indexGetter: #fileListIndex		indexSetter: #fileListIndex: 		mainView: self		menuGetter: #fileListMenu		keystrokeAction: nil)			enableDrag: true;			enableDrop: false;			yourself! !!HierarchyBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:19'!systemCatSingletonKey: aChar from: aView	^ self systemCatListKey: aChar from: aView! !!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 10:28'!buildMorphicWindow	" Inspector openAsMorphOn: SystemOrganization "	| contentsText list upperRow evaluatorText |	self flag: #ojo.	"buscar doubleClickSelector: #, porque esto es lo que me abre inspectors locos al double click trucho (no intencional) (y ademas estoy haciendo pelota los metodos en el modelo!!)"	(list _ PluggableListMorph			model: model 			listGetter: #fieldList			indexGetter: #selectionIndex			indexSetter: #toggleIndex:			mainView: self			menuGetter: #fieldListMenu			keystrokeAction: #inspectorKey:from:)			doubleClickSelector: #inspectSelection.	contentsText _ TextModelMorph			textProvider: model			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection.	evaluatorText _ (TextModelMorph textProvider: model)			askBeforeDiscardingEdits: false.	upperRow _ LayoutMorph newRow.	upperRow		addMorph: list proportionalWidth: 0.3;		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.	self layoutMorph		addMorph: upperRow proportionalHeight: 0.7;		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.	self setLabel: model object defaultLabelForInspector.	self setUpdatablePanesFrom: #(fieldList)! !!InspectorWindow methodsFor: 'menu commands' stamp: 'jmv 4/25/2011 10:10'!browseClassRefs	model selectedClass ifNotNil: [ :cls | 		Smalltalk browseAllCallsOnClass: cls theNonMetaClass]! !!InspectorWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:09'!inspectorKey: aChar from: view	"Respond to a Command key issued while the cursor is over my field list"	aChar == $i ifTrue: [^ self inspectSelection].	aChar == $I ifTrue: [^ self exploreSelection].	aChar == $b ifTrue:[^ self browseMethodFull].	aChar == $h ifTrue:[^ self browseHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	aChar == $N ifTrue: [^ self browseClassRefs]! !!MessageNamesWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:55'!selectorListKey: aChar from: view	"Respond to a Command key in the message-list pane."	aChar == $n ifTrue: [ ^ self browseSenders ].	aChar == $b ifTrue: [ ^ self browseMethodFull ].	aChar == $m ifTrue: [ ^ self browseImplementors ].! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 4/25/2011 10:33'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |self flag: #ojo."borrar"	"The following require a class selection"	(class _ self selectedClassOrMetaClass) ifNil: [^ self ].	aChar == $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self browseHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $c ifTrue: [^ self copySelector].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage]]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 4/25/2011 09:46'!packageListKey: aChar from: view	"Respond to a Command key in the package pane in the PackageBrowser"	self flag: #ojo.	"borrar"	aChar == $f ifTrue: [^ self findClass].	^ self classListKey: aChar from: view! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 4/25/2011 09:50'!systemCatListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."self flag: #ojo.	"borrar"	aChar == $f ifTrue: [^ self findClass].	aChar == $x ifTrue: [^ self removeSystemCategory].	^ self classListKey: aChar from: view! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 4/25/2011 10:20'!systemCatSingletonKey: aChar from: aViewself flag: #ojo.	"borrar"	^ self messageListKey: aChar from: aView! !!Browser methodsFor: 'system category functions' stamp: 'jmv 4/25/2011 09:46'!findClass	"Search for a class by name."	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |self flag: #ojo.	"borrar"	self okToChange ifFalse: [^ self classNotFound].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self classNotFound].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ self potentialClassNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self classNotFound].	exactMatch _ classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].	index = 0 ifTrue: [^ self classNotFound].	foundClass _ Smalltalk at: (classNames at: index) asSymbol. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 4/25/2011 09:34'!messageListKey: aChar from: view	"Respond to a Command key in the message-list pane."self flag: #ojo."borrar"	aChar == $d ifTrue: [^ self forget].	super messageListKey: aChar from: view! !!Debugger class methodsFor: 'class initialization' stamp: 'jmv 4/25/2011 10:05'!initialize	ErrorRecursion _ false.	"Debugger initialize"! !!FileContentsBrowser methodsFor: 'class list' stamp: 'jmv 4/25/2011 09:46'!findClass	| pattern foundClass classNames index foundPackage |	self flag: #ojo.	"borrar"	self okToChange ifFalse: [^ self classNotFound].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	classNames addAll: thePackage classes keys.	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size = 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.		(thePackage classes includesKey: (classNames at: index)) ifTrue:[			foundClass := thePackage classes at: (classNames at: index).			foundPackage := thePackage].	foundClass ifNotNil: [	 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).		self classListIndex: (self classList indexOf: foundClass name) ]! !!FileContentsBrowser methodsFor: 'keys' stamp: 'jmv 4/25/2011 09:34'!messageListKey: aChar from: viewself flag: #ojo."borrar"	aChar == $b ifTrue: [^ self browseMethodFull].	super messageListKey: aChar from: view! !!FileContentsBrowser methodsFor: 'keys' stamp: 'jmv 4/25/2011 09:46'!packageListKey: aChar from: viewself flag: #ojo.	"borrar"	aChar == $f ifTrue: [^ self findClass]! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'jmv 4/25/2011 10:20'!systemCatSingletonKey: aChar from: aViewself flag: #ojo.	"borrar"	^ self systemCatListKey: aChar from: aView! !!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:13'!buildMorphicWindow	| listMorph textMorph |	.listMorph _ SimpleHierarchicalListMorph 			model: model			listGetter: #getList			indexGetter: #getCurrentSelection			indexSetter: #noteNewSelection:			mainView: model			menuGetter: #genericMenu			keystrokeAction: #explorerKey:from:.	listMorph autoDeselect: false.	textMorph _ (TextModelMorph textProvider: model)			askBeforeDiscardingEdits: false.	self layoutMorph		addMorph: listMorph proportionalHeight: 0.8;		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.	self setLabel: (model rootObject printStringLimitedTo: 64)! !!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 4/25/2011 10:06'!browseClassRefs	Smalltalk browseAllCallsOnClass: model object class theNonMetaClass! !!ObjectExplorerWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:07'!explorerKey: aChar from: view	model getCurrentSelection ifNotNil: [		aChar == $i ifTrue: [^ self inspectSelection].		aChar == $I ifTrue: [^ self exploreSelection].		aChar == $b ifTrue: [^ self browseMethodFull].		aChar == $h ifTrue: [^ self browseHierarchy].		aChar == $p ifTrue: [^ self browseFullProtocol].		aChar == $N ifTrue: [^ self browseClassRefs]]! !!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 4/25/2011 08:42'!keyStroke: event 	"Process keys"		| aCharacter |	(self focusKeyboardFor: event)		ifTrue: [ ^ self ].	(self scrollByKeyboard: event) 		ifTrue: [ ^self ].	aCharacter _ event keyCharacter.	(self arrowKey: aCharacter)		ifTrue: [ ^self ].	aCharacter asciiValue = 27 ifTrue: [	" escape key"		^ self mouseButton2Activity].	(event anyModifierKeyPressed or: [ self handlesBasicKeys not ])		ifTrue: [			(self keystrokeAction: aCharacter)				ifTrue: [ ^self ]].	^ self keyboardSearch: aCharacter! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 4/24/2011 22:42'!doubleClickSelector: aSymbol	self flag: #ojo. "ver senders. chequear comportamiento. esta bien que lo ejecute el modelo? eliminar?"	doubleClickSelector _ aSymbol! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 4/25/2011 08:39'!keyboardSearch: aChar 	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	milliSeconds _ Time millisecondClockValue.	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"		lastKeystrokes _ ''].	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.	lastKeystrokeTime _ milliSeconds.	nextSelectionList _ OrderedCollection newFrom: (self getList copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self getList copyFrom: 1 to: oldSelection).	"Get rid of blanks and style used in some lists"	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]				ifNone: [^ self flash"match not found"].	model okToChange ifFalse: [^ self].	nextSelection _ self getList findFirst: [:a | a == nextSelectionText].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 4/25/2011 08:42'!keystrokeAction: aChar 	| args |	keystrokeActionSelector ifNil: [^false].	args _ keystrokeActionSelector numArgs.	args = 1 ifTrue: [		mainView perform: keystrokeActionSelector with: aChar.		^true ].	args = 2 		ifTrue: [			mainView 				perform: keystrokeActionSelector				with: aChar				with: self.			^true ].	^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 4/25/2011 08:21'!arrowKey: aChar	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."	| keyEvent oldSelection nextSelection max min howMany answer |	answer _ false.	keyEvent _ aChar asciiValue.	oldSelection _ self getCurrentSelectionIndex.	nextSelection _ oldSelection.	max _ self maximumSelection.	min _ self minimumSelection.	howMany _ self numSelectionsInView.	"get this exactly??"	keyEvent = 31 ifTrue: [		"down-arrow; move down one, wrapping to top if needed"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [ nextSelection _ 1 ]].	keyEvent = 30 ifTrue: [		"up arrow; move up one, wrapping to bottom if needed"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [ nextSelection _ max ]].	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"	nextSelection = oldSelection ifFalse: [		self okToChange ifTrue: [			self changeModelSelection: nextSelection.			answer _ true ]].	^answer! !!PluggableListMorphOfMany class methodsFor: 'instance creation' stamp: 'jmv 4/25/2011 08:45'!model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	^self new model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel! !!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 4/25/2011 10:15'!inspectProcessself flag: #ojo. "borrar, este y otros en esta clase"	selectedProcess inspect! !!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 4/25/2011 10:15'!processListKey: aKey from: aView self flag: #ojo. "borrar"	^ aKey caseOf: {		[$i] -> [self inspectProcess].		[$I] -> [self exploreProcess].		[$P] -> [self inspectPointers].		[$t] -> [self terminateProcess].		[$r] -> [self resumeProcess].		[$s] -> [self suspendProcess].		[$d] -> [self debugProcess].		[$p] -> [self changePriority].		[$m] -> [self messageTally].		[$f] -> [self findContext].		[$g] -> [self nextContext].		[$a] -> [self toggleAutoUpdate].		[$u] -> [self updateProcessList].		[$S] -> [self signalSemaphore].		[$k] -> [self moreStack]}		 otherwise: []! !!ProcessBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:07'!buildMorphicWindow	"Create a pluggable version of me, answer a window"	| aTextMorph list1 list2 upperRow |	list1 _ (PluggableListMorph				model: model				listGetter: #processNameList				indexGetter: #processListIndex				indexSetter: #processListIndex:				mainView: self				menuGetter: #processListMenu				keystrokeAction: #processListKey:from:)			enableDragNDrop: false.	list2 _ (PluggableListMorph				model: model				listGetter: #stackNameList				indexGetter: #stackListIndex				indexSetter: #stackListIndex:				mainView: self				menuGetter: #stackListMenu				keystrokeAction: #stackListKey:from:)			enableDragNDrop: false.	upperRow _ LayoutMorph newRow.	upperRow		addMorph: list1 proportionalWidth: 0.5;		addAdjusterAndMorph: list2 proportionalWidth: 0.5.	aTextMorph _ TextModelMorph				textProvider: model				textGetter: #selectedMethod.	aTextMorph askBeforeDiscardingEdits: false.	self layoutMorph		addMorph: upperRow proportionalHeight: 0.5;		addAdjusterAndMorph: aTextMorph proportionalHeight: 0.5.	self setUpdatablePanesFrom: #(#processNameList #stackNameList ).	self setLabel: 'Process Browser'.	model startedCPUWatcher ifTrue: [ self setUpdateCallbackAfter: 7 ]! !!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 4/25/2011 10:17'!browseContext	model selectedContext		ifNil: [^ self].	BrowserWindow fullOnClass: model selectedClass selector: model selectedSelector! !!ProcessBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:14'!processListKey: aKey from: aView 	^ aKey caseOf: {		[$i] -> [self inspectProcess].		[$I] -> [self exploreProcess].		[$P] -> [self inspectPointers].		[$t] -> [model terminateProcess].		[$r] -> [model resumeProcess].		[$s] -> [model suspendProcess].		[$d] -> [self debugProcess].		[$p] -> [self changePriority].		[$m] -> [self messageTally].		[$f] -> [self findContext].		[$g] -> [model nextContext].		[$a] -> [model toggleAutoUpdate].		[$u] -> [model updateProcessList].		[$S] -> [model signalSemaphore].		[$k] -> [model moreStack]}		 otherwise: []! !!ProcessBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 10:17'!stackListKey: aKey from: aView 	^ aKey caseOf: {		[$c] -> [self inspectContext].		[$C] -> [self exploreContext].		[$i] -> [self inspectReceiver].		[$I] -> [self exploreReceiver].		[$b] -> [self browseContext]}		 otherwise: []! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 4/25/2011 08:34'!keyStroke: event 	"Process potential command keys"	| args aCharacter |	(self focusKeyboardFor: event)		ifTrue: [ ^ self ].	(self scrollByKeyboard: event)		ifTrue: [ ^self ].	aCharacter _ event keyCharacter.	(self arrowKey: aCharacter)		ifTrue: [ ^self ].	keystrokeActionSelector ifNil: [^self].	(args _ keystrokeActionSelector numArgs) = 1 		ifTrue: [^mainView perform: keystrokeActionSelector with: aCharacter].	args = 2 		ifTrue: [			^mainView 				perform: keystrokeActionSelector				with: aCharacter				with: self].	^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 4/25/2011 08:15'!model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSelself flag: #ojo."A esta no le estaba andando bien la navegacion por teclado. Pero tiene un metodo que intenta navegar, solo que si NO tiene keystrokeactionsel.Revisar, limpiar, hacer andar"	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	mainView _ aMainView.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self list: self getList.! !!SimpleHierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 4/25/2011 08:26'!arrowKey: aChar	"Handle a keyboard navigation character. Answer true if handled, false if not."	| keyEvent |	keyEvent _ aChar asciiValue.     keyEvent = 31 ifTrue: [ "down"		self setSelectionIndex: self getSelectionIndex+1.		^true].     keyEvent = 30 ifTrue: [ "up"		self setSelectionIndex: (self getSelectionIndex-1 max: 1).		^true].     keyEvent = 1  ifTrue: [ "home"		self setSelectionIndex: 1.		^true].     keyEvent = 4  ifTrue: [ "end"		self setSelectionIndex: scroller submorphs size.		^true].      keyEvent = 11 ifTrue: [ "page up"		self setSelectionIndex: (self getSelectionIndex - self numSelectionsInView max: 1).		^true].     keyEvent = 12  ifTrue: [ "page down"		self setSelectionIndex: self getSelectionIndex + self numSelectionsInView.		^true].	keyEvent = 29 ifTrue: [ "right"		selectedMorph ifNotNil:[			(selectedMorph canExpand and:[selectedMorph isExpanded not])				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: self getSelectionIndex+1].		].		^true].	keyEvent = 28 ifTrue: [ "left"		selectedMorph ifNotNil:[			(selectedMorph isExpanded)				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: (self getSelectionIndex-1 max: 1)].		].		^true].	^false! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:46'!buildErrorsList	^ PluggableListMorph		model: model		listGetter: #errorsList		indexGetter: #selectedErrorTest		indexSetter: #debugErrorTest:		mainView: self		menuGetter: nil		keystrokeAction: nil! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:47'!buildFailuresList	^ PluggableListMorph		model: model		listGetter: #failuresList		indexGetter: #selectedFailureTest		indexSetter: #debugFailureTest:		mainView: self		menuGetter: nil		keystrokeAction: nil! !!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 4/25/2011 08:47'!buildUpperControls	| refreshButton filterButton stopButton runOneButton runButton row column1 column2 column3 theTestsList |	refreshButton _ self buildRefreshButton.	filterButton _ self buildFilterButton.	stopButton _ self buildStopButton.	column1 _ LayoutMorph newColumn.	column1 addMorphs: { refreshButton . filterButton . stopButton }.	theTestsList _ PluggableListMorphOfMany				model: model				listGetter: #tests				primarySelectionGetter: #selectedSuite				primarySelectionSetter: #selectedSuite:				listSelectionGetter: #listSelectionAt:				listSelectionSetter: #listSelectionAt:put:				mainView: self				menuGetter: #listMenu				keystrokeAction: nil.	theTestsList autoDeselect: false.	theTestsList color: Color veryVeryLightGray.	column2 _ LayoutMorph newColumn.	column2		addMorph: theTestsList proportionalHeight: 1;		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.	runOneButton _ self buildRunOneButton.	runButton _ self buildRunButton.		column3 _ LayoutMorph newColumn.	column3 addMorphs: { runOneButton . runButton }.		row _ LayoutMorph newRow.	row		addMorph: column1 fixedWidth: 80;		addMorph: column2 proportionalWidth: 1;		addMorph: column3 fixedWidth: 120.	^row! !!VersionsBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 4/25/2011 09:22'!changeListKey: aChar from: view	"Respond to a Command key in the list pane. of the versions browser"	^ self messageListKey: aChar from: view! !!VersionsBrowserWindow reorganize!('GUI building' buildMorphicWindow optionalModelButtonTuples windowColor)('menu building' classCommentVersionsMenu listMenu methodVersionsMenu)('menu commands' findOriginalChangeSet)('keyboard shortcuts' changeListKey:from:)!VersionsBrowser removeSelector: #changeListKey:from:!TimeProfileBrowser removeSelector: #block!TimeProfileBrowser removeSelector: #messageListKey:from:!!ProcessBrowserWindow reorganize!('GUI building' buildMorphicWindow)('updating' setUpdateCallbackAfter:)('menu building' processListMenu stackListMenu)('menu commands' browseContext changePriority debugProcess exploreContext exploreProcess exploreReceiver findContext inspectContext inspectPointers inspectProcess inspectReceiver messageTally startCPUWatcher stopCPUWatcher)('keyboard shortcuts' processListKey:from: stackListKey:from:)!ProcessBrowser removeSelector: #browseContext!ProcessBrowser removeSelector: #exploreContext!ProcessBrowser removeSelector: #exploreReceiver!ProcessBrowser removeSelector: #inspectContext!ProcessBrowser removeSelector: #inspectReceiver!ProcessBrowser removeSelector: #stackListKey:from:!PluggableListMorph removeSelector: #basicKeyPressed:!PluggableListMorph removeSelector: #modifierKeyPressed:!PluggableListMorph removeSelector: #specialKeyPressed:!!PluggableListMorph reorganize!('accessing' handlesBasicKeys: itemFromPoint: rowAtLocation:)('as yet unclassified' listMorph)('drag and drop' acceptDroppingMorph:event: potentialDropItem potentialDropRow resetPotentialDropRow startDrag:)('drawing' drawOn: highlightSelection unhighlightSelection)('dropping/grabbing' wantsDroppedMorph:event:)('event handling' handlesKeyboard handlesMouseOverDragging: keyStroke: keyboardFocusChange: mouseEnter:)('events' doubleClick: handlesBasicKeys mouseDown: mouseEnterDragging: mouseLeaveDragging: mouseMove: mouseUp:)('events-processing' handleMouseMove:)('geometry' resizeScroller scrollDeltaHeight scrollDeltaWidth)('initialization' autoDeselect: doubleClickSelector: font font: initForKeystrokes listItemHeight model:listGetter:indexGetter:indexSetter:mainView:menuGetter:keystrokeAction: textColor)('menu' getMenu)('menus' addCustomMenuItems:hand: copyListToClipboard copySelectionToClipboard setListFont)('model access' changeModelSelection: getCurrentSelectionIndex getList getListItem: getListSize itemSelectedAmongMultiple: keyboardSearch: keystrokeAction:)('scrolling' hTotalScrollRange vTotalScrollRange)('selection' getListSelector maximumSelection minimumSelection numSelectionsInView scrollSelectionIntoView selectedMorph: selection selection: selectionIndex selectionIndex: setSelectedMorph:)('updating' alertUserContentsChanged update: updateList verifyContents)('keyboard navigation' arrowKey:)!!ObjectExplorerWindow reorganize!('GUI building' buildMorphicWindow)('building menus' genericMenu)('menu commands' browseClassRefs browseFullProtocol browseHierarchy browseMethodFull exploreObjectPointers exploreSelection inspectBasic inspectSelection)('keyboard shortcuts' explorerKey:from:)!ObjectExplorer removeSelector: #browseClassRefs!ObjectExplorer removeSelector: #browseFullProtocol!ObjectExplorer removeSelector: #browseHierarchy!ObjectExplorer removeSelector: #browseMethodFull!ObjectExplorer removeSelector: #exploreSelection!ObjectExplorer removeSelector: #explorerKey:from:!ObjectExplorer removeSelector: #inspectSelection!MessageNames removeSelector: #selectorListKey:from:!Inspector removeSelector: #browseFullProtocol!Inspector removeSelector: #browseHierarchy!Inspector removeSelector: #browseMethodFull!Inspector removeSelector: #classOfSelection!Inspector removeSelector: #exploreSelection!Inspector removeSelector: #inspectSelection!Inspector removeSelector: #inspectorKey:from:!!Inspector reorganize!('accessing' baseFieldList context: fieldList i1 i2 initialExtent modelWakeUpIn: noteSelectionIndex:for: object object: selectedClass selectedClassOrMetaClass stepTimeIn: timeOfLastListUpdate update wantsSteps)('selecting' accept: contentsIsString replaceSelectionValue: selectedSlotName selection selectionIndex selectionPrintString selectionUnmodifiable toggleIndex:)('code' doItContext doItReceiver)('code pane menu' editorClass)('updating' updateListsAndCodeIn:)('initialize-release' initialize inspect:)('object fileIn' convertToCurrentVersion:refStream:)('private' printStringErrorText)('stepping' stepAt:in:)('contents' acceptedStringOrText)!FileContentsBrowser removeSelector: #browseVersions!Debugger initialize!Debugger removeSelector: #browseVersions!Debugger removeSelector: #contextStackKey:from:!!classDefinition: #Debugger category: #'Tools-Debugger'!CodeProvider subclass: #Debugger	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC savedCursor errorWasInUIProcess labelString'	classVariableNames: 'ErrorRecursion'	poolDictionaries: ''	category: 'Tools-Debugger'!ChangeSorter removeSelector: #browseVersions!ChangeSorter removeSelector: #changeSetListKey:from:!ChangeList removeSelector: #browseVersions!ChangeList removeSelector: #changeListKey:from:!CodeProvider removeSelector: #browseVersions!CodeProvider removeSelector: #useSelector:orGetSelectorAndSendQuery:to:!Model removeSelector: #arrowKey:from:!!MessageNamesWindow reorganize!('GUI building' buildMorphicWindow windowColor)('menu building' selectorListMenu)('keyboard shortcuts' selectorListKey:from:)!!InspectorWindow reorganize!('GUI building' buildMorphicWindow)('menu building' fieldListMenu)('menu commands' addEntry browseClassRefs browseFullProtocol browseHierarchy browseMethodFull exploreObjectPointers exploreSelection inspectBasic inspectSelection renameEntry sendersOfSelectedKey)('keyboard shortcuts' inspectorKey:from:)!!HierarchyBrowserWindow reorganize!('keyboard shortcuts' systemCatSingletonKey:from:)!!FileContentsBrowserWindow reorganize!('GUI building' buildMorphicWindow windowColor)('menu building' classListMenu messageCategoryMenu messageListMenu packageListMenu)('menu commands' browseMethodFull browseVersions methodHierarchy)('keyboard shortcuts' classListKey:from: messageListKey:from: packageListKey:from:)('commands' findClass)!!DualChangeSorterWindow reorganize!('GUI building' buildMorphicUIIn:for: buildMorphicWindow windowColor)('updating' decorateForInheritance)('menu building' changeSetMenuFor: classListMenuFor: messageMenuFor: shiftedChangeSetMenuFor:)('menu commands' browseMethodConflicts: browseMethodConflictsWithOtherSide: offerShiftedChangeSetMenuFor: offerUnshiftedChangeSetMenuFor:)('keyboard shortcuts' changeSetListKey:from: classListKey:from: messageListKey:from:)!!DebuggerWindow reorganize!('GUI building' buildLowerPanes buildMorphicWindow customButtonRow customButtonSpecs optionalButtonTuples windowColor)('updating' update:)('menu building' contextFieldListMenu contextStackMenu receiverFieldListMenu)('menu commands' contextClassHierarchy exploreContextSelection exploreReceiverSelection receiverClassHierarchy)('keyboard shortcuts' contextStackKey:from:)!!ChangeSorterWindow reorganize!('GUI building' buildMorphicWindow windowColor)('menu building' changeSetMenu classListMenu messageMenu shiftedChangeSetMenu)('menu commands' browseMethodConflicts browseVersions offerShiftedChangeSetMenu offerUnshiftedChangeSetMenu)('keyboard shortcuts' changeSetListKey:from: classListKey:from: messageListKey:from:)!!ChangeListWindow reorganize!('GUI building' buildMorphicCodePane buildMorphicWindow optionalButtonRow optionalModelButtonTuples windowColor)('menu commands' browseCurrentVersionsOfSelections browseVersions)('menu building' listMenu)('keyboard shortcuts' changeListKey:from:)!!BrowserWindow reorganize!('GUI building' buildLowerPanes buildMorphicClassColumn buildMorphicClassList buildMorphicCommentPane buildMorphicMessageCatList buildMorphicMessageList buildMorphicSwitches buildMorphicSystemCatList buildMorphicWindow buildNoSysCatMorphicWindow windowColor)('menu building' addExtraShiftedItemsTo: classListMenu messageCategoryMenu messageListMenu shiftedClassListMenu shiftedMessageListMenu systemCatSingletonMenu systemCategoryMenu)('menu commands' browseAllClasses openSystemCategoryBrowser)('commands' findClass)('keyboard shortcuts' systemCatSingletonKey:from:)!CodeWindow removeSelector: #xmessageListKey:from:!!CodeWindow reorganize!('as yet unclassified' hasUnacceptedEdits)('GUI building' buildLowerPanes buildMorphicAnnotationsPane buildMorphicCodePane defaultAnnotationPaneHeight lineDiffButton optionalButtonRow optionalButtonTuples prettyLineDiffButton prettyWordDiffButton windowColor wordDiffButton)('accessing' buttonWithSelector: inheritanceButton)('updating' decorateButtons decorateForInheritance update:)('top window' activateAndSendTopToBack:)('menu commands' browseAllMessages browseClassRefs browseClassVarRefs browseClassVariables browseFullProtocol browseHierarchy browseImplementors browseInstVarDefs browseInstVarRefs browseLocalImplementors browseLocalSendersOfMessages browseMessages browseMethodFull browseProtocol browseSenders browseSendersOfMessages browseUnusedMethods browseVersions findMethodInChangeSets inspectInstances inspectSubInstances makeSampleInstance methodHierarchy openSingleMessageBrowser showUnreferencedClassVars showUnreferencedInstVars)('menu building' addContentsTogglesTo: offerShiftedClassListMenu offerUnshiftedClassListMenu offerWhatToShowMenu openMessageListMenu openShiftedMessageListMenu)('misc' getSelectorAndSendQuery:to: getSelectorAndSendQuery:to:with: selectMessageAndEvaluate: sendQuery:to: useSelector:orGetSelectorAndSendQuery:to:)('keyboard shortcuts' classListKey:from: messageListKey:from: packageListKey:from: systemCatListKey:from:)!