'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 14 November 2011 at 6:25 pm'!!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 11/14/2011 17:49'!  openCompletionMenu	| theEditor |	theEditor _ textMorph editor.	position _ theEditor startIndex - 1.	self closeMenu.	self computeEntries.	entries notEmpty		ifTrue: [ 			menuMorph _  AutoCompleterMorph 				completer: self				position: theEditor startBlock bottomLeft + textMorph position ]! !!LightWidget methodsFor: 'accessing' stamp: 'jmv 11/14/2011 17:48'!             morphsAt: aPoint behind: aMorph unlocked: aBool 	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."	| isBack all |	all _ (aMorph isNil or: [owner isNil]) 				ifTrue: [					"Traverse down"					(bounds containsPoint: aPoint) ifFalse: [^#()].					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].					nil]				ifFalse: ["Traverse up"					all _ owner 								morphsAt: aPoint								behind: self								unlocked: aBool.					WriteStream with: all].	isBack _ aMorph isNil.	(isBack and: [self containsPoint: aPoint]) 		ifTrue: [			all ifNil: [^Array with: self].			all nextPut: self].	^all ifNil: [#()] ifNotNil: [all contents]! !!LightWidget methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:54'!         fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"		self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:[^self].		self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].	aCanvas clipBy: self bounds during: [ :c | self drawOn: c ].! !!LightWidget methodsFor: 'geometry' stamp: 'jmv 11/14/2011 17:57'!                        worldBoundsForHalo	"Answer the rectangle to be used as the inner dimension of my halos.	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle.""Incluir transformaciones hacia owners"	| r |	r _ (Preferences haloEnclosesFullBounds)		ifFalse: [ self bounds ]		ifTrue: [ self fullBounds ].	Preferences showBoundsInHalo ifTrue: [ ^r outsetBy: 1 ].	^r! !!LightWidget methodsFor: 'halos and balloon help' stamp: 'jmv 11/14/2011 18:00'!                            transferHalo: event from: formerHaloOwner	"Progressively transfer the halo to the next likely recipient"	| w |	"Never transfer halo to top-most world"	(self isWorldMorph and:[owner isNil]) ifFalse:[		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 			ifTrue:[^self addHalo: event from: formerHaloOwner]].	event shiftPressed ifTrue:[		"Pass it outwards"		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].		"We're at the top level; throw the event back in to find recipient"		formerHaloOwner removeHalo.		^self processEvent: event copy resetHandlerFields.	].	"We're at the bottom most level; throw the event back up to the root to find recipient"	formerHaloOwner removeHalo.	(w _ self world) ifNil: [ ^self ].	^w processEvent: event copy resetHandlerFields! !!LightWidget methodsFor: 'meta actions' stamp: 'jmv 11/14/2011 17:59'!                      mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: anEvent.	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: anEvent		clkSel: nil		dblClkSel: nil.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!CompositeLW methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:53'!                  fullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas"		self visible ifFalse: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse:[^self].		self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].	aCanvas clipBy: self bounds during: [ :c | self drawOn: c ].	self drawSubmorphsOn: aCanvas! !!CompositeLW methodsFor: 'events-processing' stamp: 'jmv 11/14/2011 17:32'!                handleDropMorph: anEvent	"Handle a dropping morph."	| aMorph localPt |	aMorph _ anEvent contents.	"Do a symmetric check if both morphs like each other"	((self wantsDroppedMorph: aMorph event: anEvent)	"I want her"		and: [aMorph wantsToBeDroppedInto: self])		"she wants me"		ifFalse: [				^ self].	anEvent wasHandled: true.	localPt _ aMorph referencePosition.	aMorph referencePosition: localPt.	self acceptDroppingMorph: aMorph event: anEvent.	aMorph justDroppedInto: self event: anEvent.! !!CompositeLW methodsFor: 'submorphs-accessing' stamp: 'jmv 11/14/2011 17:47'!                         morphsAt: aPoint behind: aMorph unlocked: aBool 	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."	| isBack found all |	all _ (aMorph isNil or: [owner isNil]) 				ifTrue: [					"Traverse down"					(bounds containsPoint: aPoint) ifFalse: [^#()].					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].					nil]				ifFalse: ["Traverse up"					all _ owner 								morphsAt: aPoint								behind: self								unlocked: aBool.					WriteStream with: all].	isBack _ aMorph isNil.	self submorphsDo: [ :m | 			isBack 				ifTrue: [					found _ m 								morphsAt: aPoint								behind: nil								unlocked: aBool.					found notEmpty 						ifTrue: [							all ifNil: [all _ WriteStream on: #()].							all nextPutAll: found]].			m == aMorph ifTrue: [isBack _ true]].	(isBack and: [self containsPoint: aPoint]) 		ifTrue: [			all ifNil: [^Array with: self].			all nextPut: self].	^all ifNil: [#()] ifNotNil: [all contents]! !!CompositeLW methodsFor: 'halos and balloon help' stamp: 'jmv 11/14/2011 18:19'!             transferHalo: event from: formerHaloOwner	"Progressively transfer the halo to the next likely recipient"	| w |	"Never transfer halo to top-most world"	(self isWorldMorph and:[owner isNil]) ifFalse:[		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 			ifTrue:[^self addHalo: event from: formerHaloOwner]].	event shiftPressed ifTrue:[		"Pass it outwards"		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].		"We're at the top level; throw the event back in to find recipient"		formerHaloOwner removeHalo.		^self processEvent: event copy resetHandlerFields.	].	self submorphsDo: [ :m |		(m fullContainsPoint: event position) 			ifTrue:[^m transferHalo: event from: formerHaloOwner].	].	"We're at the bottom most level; throw the event back up to the root to find recipient"	formerHaloOwner removeHalo.	(w _ self world) ifNil: [ ^self ].	^w processEvent: event copy resetHandlerFields! !!ListLW methodsFor: 'focus handling' stamp: 'jmv 11/14/2011 17:57'!                       focused: aSubmorph	"Default is to do nothing."		| delta |	delta _ aSubmorph bounds amountToTranslateWithin: bounds.	delta = (0@0) ifFalse: [		submorphs do: [ :m |			m privateFullMoveBy: delta ].		self redrawNeeded ]! !!ListLW methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/14/2011 17:57'!                  addMorph: aMorph	| p |	p _ submorphs isEmpty 		ifFalse: [submorphs last bounds bottomLeft]		ifTrue: [bounds topLeft].	self addMorphBack: aMorph.	aMorph position: p! !!ListLW methodsFor: 'geometry' stamp: 'jmv 11/14/2011 17:57'!                    scrollInterval	"Answer an interval to draw the proportional thumb of a scroll bar"	| b top bottom subTop subBottom thumbTop thumbBottom scale |	top _ bounds top.	bottom _ bounds bottom.	subTop _ top.	subBottom _ bottom.	self submorphsDo:[:m |		b _ m bounds.		subTop _ subTop min: b top.		subBottom _ subBottom max: b bottom ].	scale _ 1.0 /  (subBottom - subTop) * (bottom - top ).	thumbTop _ 1.0 * top - subTop * scale + top.	thumbBottom _ 1.0 * bottom - subTop * scale + top.	^ Interval from: thumbTop rounded to: thumbBottom rounded! !!ListOldLW methodsFor: 'focus handling' stamp: 'jmv 11/14/2011 17:57'!             focused: aSubmorph	"Default is to do nothing."		| delta |	delta _ aSubmorph bounds amountToTranslateWithin: bounds.	delta = (0@0) ifFalse: [		submorphs do: [ :m |			m privateFullMoveBy: delta ].		self redrawNeeded ]! !!ListOldLW methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/14/2011 17:57'!               addMorph: aMorph	| p |	p _ submorphs isEmpty 		ifFalse: [submorphs last bounds bottomLeft]		ifTrue: [bounds topLeft].	self addMorphBack: aMorph.	aMorph position: p! !!ListOldLW methodsFor: 'geometry' stamp: 'jmv 11/14/2011 17:57'!                 scrollInterval	"Answer an interval to draw the proportional thumb of a scroll bar"	| b top bottom subTop subBottom thumbTop thumbBottom scale |	top _ bounds top.	bottom _ bounds bottom.	subTop _ top.	subBottom _ bottom.	self submorphsDo:[:m |		b _ m bounds.		subTop _ subTop min: b top.		subBottom _ subBottom max: b bottom ].	scale _ 1.0 /  (subBottom - subTop) * (bottom - top ).	thumbTop _ 1.0 * top - subTop * scale + top.	thumbBottom _ 1.0 * bottom - subTop * scale + top.	^ Interval from: thumbTop rounded to: thumbBottom rounded! !!Morph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:55'!                        imageForm	^ self imageForm: Display depth forRectangle: self fullBounds! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 11/14/2011 17:49'!            slideBackToFormerSituation: evt 	| slideForm formerOwner formerPosition aWorld startPoint endPoint |	formerOwner _ self formerOwner.	formerPosition _ self formerPosition.	aWorld _ evt hand world.	slideForm _ self imageForm offset: 0 @ 0.	startPoint _ evt hand fullBounds origin.	endPoint _ formerPosition.	owner removeMorph: self.	aWorld displayWorld.	slideForm 		slideFrom: startPoint		to: endPoint		nSteps: 12		delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt! !!Morph methodsFor: 'events-processing' stamp: 'jmv 11/14/2011 17:35'!                     containsPoint: aPoint event: anEvent	"Return true if aPoint is considered to be inside the receiver for the given event.	The default implementation treats locked children as integral part of their owners."	(self fullBounds containsPoint: aPoint) ifFalse: [ ^false ].	(self containsPoint: aPoint) ifTrue: [ ^true ].	self submorphsDo: [ :m |		(m isLocked and: [ m fullContainsPoint: aPoint ]) ifTrue: [ ^true ]].	^false! !!Morph methodsFor: 'events-processing' stamp: 'jmv 11/14/2011 17:35'!             handleDropMorph: anEvent	"Handle a dropping morph."	| aMorph localPt |	aMorph _ anEvent contents.	"Do a symmetric check if both morphs like each other"	((self wantsDroppedMorph: aMorph event: anEvent)	"I want her"		and: [aMorph wantsToBeDroppedInto: self])		"she wants me"		ifFalse: [				^ self].	anEvent wasHandled: true.	localPt _ aMorph referencePosition.	aMorph referencePosition: localPt.	self acceptDroppingMorph: aMorph event: anEvent.	aMorph justDroppedInto: self event: anEvent.! !!Morph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 17:57'!         worldBoundsForHalo	"Answer the rectangle to be used as the inner dimension of my halos.	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."	| r |	r _ Preferences haloEnclosesFullBounds		ifFalse: [ self bounds ]		ifTrue: [ self fullBounds ].	Preferences showBoundsInHalo ifTrue: [ ^r outsetBy: 1 ].	^r! !!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 11/14/2011 18:19'!             transferHalo: event from: formerHaloOwner	"Progressively transfer the halo to the next likely recipient"	| w |	"Never transfer halo to top-most world"	(self isWorldMorph and:[owner isNil]) ifFalse: [		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 			ifTrue:[^self addHalo: event from: formerHaloOwner]].	event shiftPressed ifTrue: [		"Pass it outwards"		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].		"We're at the top level; throw the event back in to find recipient"		formerHaloOwner removeHalo.		^self processEvent: event copy resetHandlerFields.	].	self submorphsDo: [ :m |		(m fullContainsPoint: event position) 			ifTrue:[^m transferHalo: event from: formerHaloOwner].	].	"We're at the bottom most level; throw the event back up to the root to find recipient"	formerHaloOwner removeHalo.	(w _ self world) ifNil: [ ^self ].	^w processEvent: event copy resetHandlerFields.! !!Morph methodsFor: 'macpal' stamp: 'jmv 11/14/2011 17:57'!                             flash	Display flash: self bounds! !!Morph methodsFor: 'menus' stamp: 'jmv 11/14/2011 17:55'!changeColor	"Change the color of the receiver -- triggered, e.g. from a menu"	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: self activeHand;		target: self;		selector: #color:;		originalColor: self color;		putUpFor: self near: self fullBounds! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 11/14/2011 17:55'!              changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"	self flag: #arNote. "Simplify this due to anObject == self for almost all cases"	^ ColorPickerMorph new		choseModalityFromPreference;		sourceHand: aHand;		target: anObject;		selector: aSymbol;		originalColor: aColor;		putUpFor: anObject near: ((anObject is: #Morph)					ifTrue: [ Rectangle center: self position extent: 20 ]					ifFalse: [ anObject == self world								ifTrue: [ anObject viewBox bottomLeft + (20@-20) extent: 200 ]								ifFalse: [ anObject fullBounds ]]);		yourself! !!Morph methodsFor: 'meta-actions' stamp: 'jmv 11/14/2011 18:00'!                           mouseButton3Down: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h doNotDrag |	h _ anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag _ false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag _ true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag _ true].		(self hasOwner: h target) ifTrue:[doNotDrag _ true]].	"cmd-drag on flexed morphs works better this way"	h _ self addHalo: anEvent.	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: anEvent		clkSel: nil		dblClkSel: nil.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 11/14/2011 17:50'!             morphsAt: aPoint behind: aMorph unlocked: aBool 	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."	| isBack found all |	all _ (aMorph isNil or: [owner isNil]) 				ifTrue: [					"Traverse down"					(self fullBounds containsPoint: aPoint) ifFalse: [^#()].					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].					nil]				ifFalse: ["Traverse up"					all _ owner 								morphsAt: aPoint								behind: self								unlocked: aBool.					WriteStream with: all].	isBack _ aMorph isNil.	self submorphsDo: [ :m |			isBack 				ifTrue: [					found _ m 								morphsAt: aPoint								behind: nil								unlocked: aBool.					found notEmpty 						ifTrue: 							[all ifNil: [all _ WriteStream on: #()].							all nextPutAll: found]].			m == aMorph ifTrue: [isBack _ true]].	(isBack and: [self containsPoint: aPoint]) 		ifTrue: 			[all ifNil: [^Array with: self].			all nextPut: self].	^all ifNil: [#()] ifNotNil: [all contents]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 11/14/2011 17:35'!              morphsAt: aPoint unlocked: aBool do: aBlock	"Evaluate aBlock with all the morphs starting at the receiver which appear at aPoint. If aBool is true take only visible, unlocked morphs into account."	| |	(self fullBounds containsPoint: aPoint) ifFalse:[^self].	(aBool and:[self isLocked or:[self visible not]]) ifTrue:[^self].	self submorphsDo: [ :m |		m morphsAt: aPoint unlocked: aBool do: aBlock].	(self containsPoint: aPoint) ifTrue:[aBlock value: self].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/14/2011 17:44'!    addMorphFront: aMorph fromWorldPosition: aPoint	self addMorphFront: aMorph.	aMorph position: aPoint! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/14/2011 17:49'!            addMorphFrontFromWorldPosition: aMorph	^self addMorphFront: aMorph fromWorldPosition: aMorph position.! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 11/14/2011 17:53'!               pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt oldCursor |	aHand _ aMorph isNil		ifTrue: [self world activeHand] 		ifFalse: [ aMorph activeHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullBounds.	self owner ifNil: [^ self].	oldCursor _ Sensor currentCursor.	ColorPickerMorph eyeDropperCursor show.	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	localPt _World activeHand position - bounds topLeft.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt) ifTrue:			["Click or drag the drag-dot means to anchor as a modeless picker"			^ self anchorAndRunModeless: aHand].	].	(clickedTranslucency _ TransparentBox containsPoint: localPt)		ifTrue: [selectedColor _ originalColor].	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	aHand newMouseFocus: nil;		flushEvents.	oldCursor show.	self delete.		  ! !!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 11/14/2011 17:52'!           addToWorld: world near: box	| goodLocation |	goodLocation _ self bestPositionNear: box inWorld: world.	world allMorphsDo:		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:			[(p selector == selector and: [p argument == argument])				ifTrue: [^ p comeToFront  "uncover existing picker"]				ifFalse: ["place second picker relative to first"						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].	self position: goodLocation.	world addMorphFront: self.	self redrawNeeded! !!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 11/14/2011 17:53'!  putUpFor: aMorph near: aRectangle	"Put the receiver up on the screen.   Note highly variant behavior depending on the setting of the #modalColorPickers preference"	| layerNumber |	(aMorph is: #Morph) ifTrue: [		layerNumber _ aMorph morphicLayerNumber.		aMorph allOwnersDo: [ : m|			layerNumber _ layerNumber min: m morphicLayerNumber].		self setProperty: #morphicLayerNumber toValue: layerNumber - 0.1 ].	isModal == true "backward compatibility"		ifTrue: [			self pickUpColorFor: aMorph]		ifFalse: [			self addToWorld:				((aMorph notNil and: [aMorph world notNil])					ifTrue: [ aMorph world ]					ifFalse: [ self currentWorld ])		  		near:					(aRectangle ifNil:						[aMorph ifNil: [100@100 extent: 1@1] ifNotNil: [ aMorph fullBounds ]])]! !!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 17:32'!                            pickColorAt: aGlobalPoint	| alpha selfRelativePoint pickedColor |	clickedTranslucency ifNil: [clickedTranslucency _ false].	selfRelativePoint _ aGlobalPoint - bounds topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue:		[clickedTranslucency ifFalse: [^ self].  "Can't wander into translucency control"		alpha _ (selfRelativePoint x - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"		self 			updateColor: (selectedColor alpha: alpha)			feedbackColor: (selectedColor alpha: alpha).		^ self].	"pick up color, either inside or outside this world"	clickedTranslucency ifTrue: [^ self].  "Can't wander out of translucency control"	self locationIndicator visible: false. self refreshWorld.	pickedColor _ Display colorAt: aGlobalPoint.	self locationIndicator visible: true. self refreshWorld.	self 		updateColor: (			((selectedColor is: #Color) and: [ selectedColor isOpaque not ])						ifTrue: [ pickedColor alpha: selectedColor alpha ]						ifFalse: [ pickedColor ]		)		feedbackColor: pickedColor! !!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 17:32'!         trackColorAt: aGlobalPoint 	"Before the mouse comes down in a modal color picker, track the color under the cursor, and show it in the feedback box, but do not make transparency changes"	| selfRelativePoint pickedColor |	selfRelativePoint _ aGlobalPoint - bounds topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue: [^ self].	"pick up color, either inside or outside this world"	pickedColor _ Display colorAt: aGlobalPoint.	self updateColor: (pickedColor alpha: originalColor alpha)		feedbackColor: pickedColor! !!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 11/14/2011 17:47'!                 startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.	positionOffset _ dragHandle referencePosition - target position! !!HaloMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 17:33'!                           mouseMove: evt	"Drag our target around"	| thePoint |	thePoint _ evt position - positionOffset.	target position: thePoint! !!HaloMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 17:47'!popUpFor: aMorph event: evt	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."	| hand anEvent |	self flag: #workAround.	"We should really have some event/hand here..."	anEvent _ evt				ifNil: [					hand _ aMorph world activeHand.					hand ifNil: [ hand _ aMorph world firstHand ]. 					hand lastEvent ]				ifNotNil: [					hand _ evt hand.					evt ].	self target: aMorph.	hand halo: self.	hand world addMorphFront: self.	positionOffset _ anEvent position - aMorph position.	self startStepping! !!HaloMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 17:37'!                transferHalo: event	"Transfer the halo to the next likely recipient"	target ifNil: [ ^self delete ].	target transferHalo: event from: target.! !!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 11/14/2011 17:47'!      mouseButton3Down: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset _ event position - target position.	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		clkSel: #transferHalo:		dblClkSel: nil! !!HaloMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 17:54'!redrawNeeded	"Quicker to invalidate handles individually if target is large (especially the world)"	bounds extent > (200@200)		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [					"Invalidate 4 outer strips first, thus subsuming separate damage."					(self fullBounds areasOutside: target bounds) do:						[ :r | self invalidRect: r ]].				self submorphsDo: [:m | m redrawNeeded]]		ifFalse: [ super redrawNeeded ]! !!HaloMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 17:33'!       doDrag: evt with: dragHandle	| thePoint |	evt hand obtainHalo: self.	thePoint _ evt position - positionOffset.	target position: thePoint! !!HaloMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 17:47'!               doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |self revisar.	evt hand obtainHalo: self.	degrees _ (evt position - target referencePosition) degrees.	degrees _ degrees - angleOffset degrees.	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	self removeAllHandlesBut: rotHandle.	target rotationDegrees: degrees.	rotHandle position: evt position - (rotHandle extent // 2).	self layoutChanged! !!HaloMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 17:48'!        startGrow: evt with: growHandle	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	| botRt |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.	botRt _ target bounds bottomRight.	positionOffset _ (self world viewBox containsPoint: botRt)		ifTrue: [evt position - botRt]		ifFalse: [0@0]! !!HaloMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 17:48'!    startRot: evt with: rotHandle	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"	self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.	growingOrRotating _ true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset _ evt position - target referencePosition.	angleOffset _ Point			r: angleOffset r			degrees: angleOffset degrees - target rotationDegrees! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:54'!                        fullDrawOn: aCanvas 	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	self visible ifFalse: [^self].	(aCanvas isVisible: self fullBounds) ifFalse: [^self].	self nonCachingFullDrawOn: aCanvas.! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:54'!                savePatchFrom: aCanvas 	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| damageRect myBnds |	damageRect _ myBnds _ self fullBounds.	damageRect _ myBnds _ self bounds.	savedPatch ifNotNil: [		damageRect _ myBnds merge: (savedPatch offset extent: savedPatch extent)].	(savedPatch isNil or: [savedPatch extent ~= myBnds extent]) 		ifTrue: [			"allocate new patch form if needed"			savedPatch _ Form extent: myBnds extent depth: aCanvas depth ].	aCanvas		contentsOfArea: (myBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: myBnds topLeft.	^damageRect! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:57'!              savePatchFrom: aCanvas appendDamageTo: aStream	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| ownBnds fullBnds bw |	ownBnds _ self bounds.	fullBnds _ self fullBounds.	(savedPatch isNil or: [savedPatch extent ~= fullBnds extent]) 		ifTrue: [			"allocate new patch form if needed"			savedPatch _ Form extent: fullBnds extent depth: aCanvas depth ].	aCanvas		contentsOfArea: (fullBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: fullBnds topLeft.	Preferences fastDragWindowForMorphic ifTrue: [		bw _ HandMorph fastDragBorderWidth.		aStream nextPut: ownBnds.		prevBounds ifNotNil: [ aStream nextPut: prevBounds ].		(fullBnds areasOutside: (fullBnds insetBy: bw)) do: [ :r |			aStream nextPut: r ].		prevFullBounds ifNotNil: [			(prevFullBounds areasOutside: (prevFullBounds insetBy: bw)) do: [ :r |				aStream nextPut: r ]]]	ifFalse: [		prevFullBounds ifNil: [			aStream nextPut: fullBnds ]		ifNotNil: [			aStream nextPut: (fullBnds merge: prevFullBounds)]].	prevBounds _ ownBnds.	prevFullBounds _ fullBnds! !!HandMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:54'!                       shadowForm	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"	| bnds canvas |	bnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	canvas _ Display defaultCanvasClass forShadowOver: bnds.	self drawSubmorphsOn: canvas.	^ canvas formWithOffset! !!HandMorph methodsFor: 'private events' stamp: 'jmv 11/14/2011 17:38'!                        sendFocusEvent: anEvent to: focusHolder in: world	"Send the event to focusHolder, the morph currently holding the focus"	| result |	world becomeActiveDuring: [		ActiveHand _ self.		ActiveEvent _ anEvent.		result _ focusHolder handleFocusEvent: anEvent ].	^result! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:51'! drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle 			borderWidth: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].	selectedMorph  ifNotNil: [		aCanvas			fillRectangle: (selectedMorph bounds intersect: scroller bounds)			colorOrInfiniteForm: (Theme current listHighlightFocused: self hasKeyboardFocus)].	Preferences showLinesInHierarchyViews ifTrue:[		self drawLinesOn: aCanvas ]! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 17:34'!                   itemFromPoint: aPoint	"Return the list element (morph) at the given point or nil if outside"	| ptY |	self flag: #jmvVer. "Pensar, creo que en estas si vamos a agregar un morph nuevo para reem al scroller. Sera una nueve clase. ver.	La nueva clase ya esta. Falta aprovecharla mas, mandandole codibo que esta aca...	Hacer esto de forma consistente con los otros pluggable morphs..."	scroller hasSubmorphs ifFalse:[^nil].	(scroller fullBounds containsPoint: aPoint) ifFalse:[^nil].	ptY _ aPoint y.	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"	scroller firstSubmorph top > ptY ifTrue:[^nil].	scroller lastSubmorph bottom < ptY ifTrue:[^nil].	"now use binary search"	^scroller 		findSubmorphBinary:[:item|			(item top <= ptY and:[item bottom >= ptY])				ifTrue:[0] "found"				ifFalse:[ (item top + item bottom // 2) > ptY ifTrue:[-1] ifFalse:[1]]]! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 17:34'!      mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and: [ aMorph inToggleArea: evt position ])		ifTrue: [ ^self toggleExpandedState: aMorph event: evt ]. 	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [ ^ self mouseButton2Activity ].	aMorph ifNil: [ ^super mouseDown: evt ].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: evt 		clkSel: #click:		dblClkSel: nil		tripleClkSel: nil! !!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:57'!                           drawOn: aCanvas	aCanvas roundRect: bounds color: self color radius: 2.	aCanvas		paragraph: paragraph		bounds: (self bounds insetBy: 4)		color: Color black! !!InnerTextMorph methodsFor: 'anchors' stamp: 'jmv 11/14/2011 17:31'!                     anchorMorph: aMorph at: aPoint	| relPt |	aMorph owner == self ifTrue: [ self removeMorph: aMorph ].	self addMorphFront: aMorph.	relPt _ aPoint - bounds topLeft.	editor insertMorph: aMorph at: relPt.	self fit.! !!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:57'!drawOn: aCanvas	"Draw the receiver on a canvas"	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"	aCanvas paragraph: self paragraph bounds: self bounds color: color.	"Drawing the paragraph might change the #lastCaretRect, and therefore might	require a second update."	paragraph lastCaretRectNeedsRedraw ifTrue: [		paragraph lastCaretRect ifNotNil: [ :r | self invalidRect: r ]]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 17:38'!       autoScrollView: evt	"This is kind of a hack because the PluggableTextMorph expects me to first expand the selection before auto scrolling will work."	super mouseMove: evt.	editView scrollSelectionIntoView: evt.! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 17:59'!                         mouseMove: evt	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].	self handleInteraction: [editor mouseMove: (evt translatedBy: bounds topLeft negated)].	(evt position y between: editView top and: editView bottom) ifFalse: [		"Start auto-scrolling"		self startStepping: #autoScrollView:			at: Time millisecondClockValue			arguments: (Array with: evt)			stepTime: 100. "fast enough"	] ifTrue: [		self stopSteppingSelector: #autoScrollView:.	]! !!MenuMorph methodsFor: 'control' stamp: 'jmv 11/14/2011 17:54'!    popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| delta tryToPlace selectedOffset |	hand world startSteppingSubmorphsOf: self.	popUpOwner _ sourceItem.	selectedOffset := (selectedItem ifNil:[self items first]) position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MorphicEvent methodsFor: 'initialize' stamp: 'jmv 11/14/2011 18:20'!                              resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"	self flag: #jmvVer. "All this stuff of copying events to reset this data is pretty ugly."! !!DropEvent methodsFor: 'initialize' stamp: 'jmv 11/14/2011 18:20'!  resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"	self flag: #jmvVer. "All this stuff of copying events to reset this data is pretty ugly."	wasHandled _ false.! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 17:21'!                             readFrom: aStream	"Read a MorphicEvent from the given stream."	| typeString c |	typeString _ String streamContents:		[:s |   [(c _ aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove' ifTrue:[^MouseMoveEvent type: #mouseMove readFrom: aStream].	typeString = 'mouseDown' ifTrue:[^MouseButtonEvent type: #mouseDown readFrom: aStream].	typeString = 'mouseUp' ifTrue:[^MouseButtonEvent type: #mouseUp readFrom: aStream].	typeString = 'keystroke' ifTrue:[^KeyboardEvent type: #keystroke readFrom: aStream].	typeString = 'keyDown' ifTrue:[^KeyboardEvent type: #keyDown readFrom: aStream].	typeString = 'keyUp' ifTrue:[^KeyboardEvent type: #keyUp readFrom: aStream].	typeString = 'mouseOver' ifTrue:[^MouseEvent type: #mouseOver readFrom: aStream].	typeString = 'mouseEnter' ifTrue:[^MouseEvent type: #mouseEnter readFrom: aStream].	typeString = 'mouseLeave' ifTrue:[^MouseEvent type: #mouseLeave readFrom: aStream].	^nil! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 11/14/2011 17:39'!             dispatchDefault: anEvent with: aMorph	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."	| inside |	"See if we're fully outside aMorphs bounds"	(aMorph fullBounds containsPoint: anEvent position) ifFalse: [ ^#rejected ]. "outside"	"Traverse children"	inside _ false.	aMorph submorphsDo: [ :eachChild |		inside ifFalse: [			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [				"Not rejected. The event was in some submorph of the receiver"				inside _ true			]]].	"Check for being inside the receiver"	inside ifFalse: [ inside _ aMorph containsPoint: anEvent position event: anEvent ].	inside ifTrue: [ ^aMorph handleEvent: anEvent ].	^ #rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 11/14/2011 17:40'!            dispatchDropEvent: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."	| inside |	"Try to get out quickly"	(aMorph fullBounds containsPoint: anEvent position)		ifFalse: [ ^#rejected ].	"Give aMorph a chance to repel the dropping morph"	aMorph rejectDropEvent: anEvent.	anEvent wasHandled ifTrue:[^self].	"Go looking if any of our submorphs wants it"	inside _ false.	aMorph submorphsDo: [ :eachChild |		inside ifFalse: [			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [				inside _ true			]]].	inside ifFalse: [ inside _ aMorph containsPoint: anEvent position event: anEvent ].	inside ifTrue: [ ^aMorph handleEvent: anEvent ].	^#rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 11/14/2011 17:41'!                               dispatchMouseDown: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. Default rules:	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event."	| globalPt handler inside lastHandler |	"Try to get out quickly"	globalPt _ anEvent position.	(aMorph fullBounds containsPoint: globalPt) ifFalse: [ ^#rejected ].	"Install the prospective handler for the receiver"	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"	handler _ aMorph handlerForMouseDown: anEvent.	handler ifNotNil: [ anEvent handler: handler ].	"Now give our submorphs a chance to handle the event"	inside _ false.	aMorph submorphsDo: [ :eachChild |		inside ifFalse: [			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [				"Some child did contain the point so we're part of the top-most chain."				inside _ true.			]]].	(inside or: [ aMorph containsPoint: anEvent position event: anEvent ]) ifTrue:[		"Receiver is in the top-most unlocked, visible chain."		handler ifNotNil: [ handler handleEvent: anEvent ].		"Note: Re-installing the handler is not really necessary but good style."		anEvent handler: lastHandler.		^self ].	"Mouse was not on receiver nor any of its children"	anEvent handler: lastHandler.	^#rejected! !!MouseClickState methodsFor: 'event handling' stamp: 'jmv 11/14/2011 17:41'!     handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| timedOut distance |	timedOut _ (evt timeStamp - firstClickDown timeStamp) > DoubleClickTimeout.	distance _ (evt position - firstClickDown position) r.	evt isMouseDown ifTrue: [		buttonDownCount _ buttonDownCount + 1  ].	evt isMouseUp ifTrue: [		clickCount _ clickCount + 1.		lastClickTimestamp _ evt timeStamp ].	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."	(buttonDownCount = 1 and: [clickCount = 0]) ifTrue: [		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [			aHand resetClickState.			clickClient mouseButton2Activity.			^true ].		"If we have already moved, then it won't be a double or triple click... why wait?"		distance > 0 ifTrue: [			aHand resetClickState.			self click.			^true ]].	"Simple click."	clickCount = 1 ifTrue: [		self click.		"If timedOut or the client's not interested in dbl clicks get outta here"		(timedOut or: [ dblClickSelector isNil or: [ distance > 0 ]]) ifTrue: [			aHand resetClickState.			^true ].		"This means: if a mouseDown, then don't further process this event (so we can turn it into double click on next buttonUp)"		^ evt isMouseDown not ].	"Double click."	(clickCount = 2 and: [ distance = 0 ]) ifTrue: [		self doubleClick.		"If timedOut or the client's not interested intriple clicks get outta here"		(timedOut or: [ tripleClickSelector isNil ]) ifTrue: [			aHand resetClickState.			^true ].		"This means: if a mouseDown, then don't further process this event (so we can turn it into triple click on next buttonUp)"		^ evt isMouseDown not ].		"Triple click"	(clickCount = 3 and: [ distance = 0 ]) ifTrue: [		aHand resetClickState.		self tripleClick.		^true ].	^true! !!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 11/14/2011 17:43'!                processMouseOver: anEvent 	"Re-establish the z-order for all morphs wrt the given event"	| hand focus evt |	hand := anEvent hand.	leftMorphs := mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs := WriteStream on: (Array new: leftMorphs size).	enteredMorphs := WriteStream on: #().	"Now go looking for eventual mouse overs"	hand handleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."		(leftMorphs isEmpty and: [enteredMorphs position = 0])])		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].	focus := hand mouseFocus.	"Send #mouseLeave as appropriate"	evt := anEvent asMouseLeave.	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"	leftMorphs size > 1 		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].	leftMorphs do: [ :m | 			(m == focus or: [m hasOwner: focus]) 				ifTrue: [					m handleEvent: evt]				ifFalse: [overMorphs nextPut: m]].	"Send #mouseEnter as appropriate"	evt := anEvent asMouseEnter.	enteredMorphs ifNil: [			"inform: was called in handleEvent:"			^leftMorphs := enteredMorphs := overMorphs := nil].	enteredMorphs := enteredMorphs contents.	enteredMorphs reverseDo: [ :m | 			(m == focus or: [m hasOwner: focus]) 				ifTrue: [					m handleEvent: evt]].	"And remember the over list"	overMorphs ifNil: [			"inform: was called in handleEvent:"			^leftMorphs := enteredMorphs := overMorphs := nil].	mouseOverMorphs := overMorphs contents.	leftMorphs := enteredMorphs := overMorphs := nil! !!Paragraph methodsFor: 'editing' stamp: 'jmv 11/14/2011 17:57'!                  clickAt: clickPoint	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action target range boxes box t |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	t _ model actualContents.	(t attributesAt: startBlock stringIndex) do: [ :att | 		att mayActOnClick ifTrue:				[(target _ model) ifNil: [ target _ editor morph].				range _ t rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint] ifNone: nil.				box ifNotNil: [					box _ editor morph bounds.					editor morph allOwnersDo: [ :m | box _ box intersect: (m bounds) ].					Utilities						awaitMouseUpIn: box						repeating: nil						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action _ true]].					Cursor currentCursor == Cursor webLink ifTrue:[Cursor normal show].				]]].	^ action! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 11/14/2011 17:55'!             acceptDroppingMorph: dropped event: evt 	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"	| aMorph |	aMorph := self morphToDropFrom: dropped.	self isWorldMorph 		ifTrue: 			["Add the given morph to this world and start stepping it if it wants to be."			self addMorphFront: aMorph.			(aMorph fullBounds intersects: self viewBox) 				ifFalse: [					Beeper beep.					aMorph position: bounds center]]		ifFalse: [super acceptDroppingMorph: aMorph event: evt].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self world startSteppingSubmorphsOf: aMorph! !!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 11/14/2011 17:56'!addMorph: aMorph centeredNear: aPoint	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."	| trialRect delta |	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.	delta _ trialRect amountToTranslateWithin: bounds.	aMorph position: trialRect origin + delta.	self addMorph: aMorph.! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 17:44'!      rowAtLocation: aPoint	"Return the row at the given point or 0 if outside"	^self listMorph rowAtLocation: aPoint.! !!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 17:56'!                             setupMorphs	|  w h |	w _ ((labelMorph width max: subLabelMorph width) max: progress width) + 2.	h _ labelMorph height + subLabelMorph height + progress height + 2.	self bounds: (0@0 extent: w@h).	self borderWidth: 2.	self borderColor: Color black.	self color: Color veryLightGray.	self align: self fullBounds center with: Display boundingBox center! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 17:57'!                           initialFrameFor: aView initialExtent: initialExtent world: aWorld 	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	Preferences reverseWindowStagger 		ifTrue: 			[^self 				strictlyStaggeredInitialFrameFor: aView				initialExtent: initialExtent				world: aWorld].	allowedArea := self maximumUsableAreaInWorld: aWorld.	screenRight := allowedArea right.	screenBottom := allowedArea bottom.	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not]) 						collect: [:w | w bounds].	allOrigins := otherFrames collect: [:f | f origin].	(self standardPositionsInWorld: aWorld) do: 			[:aPosition | 			"First see if one of the standard positions is free"			(allOrigins includes: aPosition) 				ifFalse: 					[^(aPosition extent: initialExtent) 						translatedAndSquishedToBeWithin: allowedArea]].	staggerOrigin := (self standardPositionsInWorld: aWorld) first.	"Fallback: try offsetting from top left"	putativeOrigin := staggerOrigin.		[putativeOrigin := putativeOrigin + StaggerOffset.	putativeFrame := putativeOrigin extent: initialExtent.	putativeFrame bottom < screenBottom 		and: [putativeFrame right < screenRight]] 			whileTrue: 				[(allOrigins includes: putativeOrigin) 					ifFalse: 						[^(putativeOrigin extent: initialExtent) 							translatedAndSquishedToBeWithin: allowedArea]].	^(self scrollBarSetback @ self screenTopSetback extent: initialExtent) 		translatedAndSquishedToBeWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 17:57'!                 strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 	"This method implements a staggered window placement policy that I (di) like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible."	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea := (self maximumUsableAreaInWorld: aWorld) 				insetBy: (self scrollBarSetback @ self screenTopSetback extent: 0 @ 0).	"Number to be staggered at each corner (less on small screens)"	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame := 0 @ 0 extent: initialExtent.	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400"	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not]) 						collect: [:w | w bounds].	0 to: maxLevel		do: 			[:level | 			1 to: 4				do: 					[:ci | 					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.					corner := allowedArea perform: cornerSel.					"The extra grid//2 in delta helps to keep title tabs distinct"					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"					putativeCorner := corner + delta.					free := true.					otherFrames 						do: [:w | free := free & ((w perform: cornerSel) ~= putativeCorner)].					free 						ifTrue: 							[^(initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].	"If all else fails..."	^(self scrollBarSetback @ self screenTopSetback 		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !!SystemWindow methodsFor: 'menu' stamp: 'jmv 11/14/2011 17:56'!  changeColor	"Change the color of the receiver -- triggered, e.g. from a menu.  This variant allows the recolor triggered from the window's halo recolor handle to have the same result as choosing change-window-color from the window-title menu"	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: self activeHand;		target: self;		selector: #setWindowColor:;		originalColor: self color;		putUpFor: self near: self fullBounds! !!SystemWindow methodsFor: 'menu' stamp: 'jmv 11/14/2011 17:56'! setWindowColor	"Allow the user to select a new basic color for the window"	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: self activeHand;		target: self;		selector: #setWindowColor:;		originalColor: self widgetsColor;		putUpFor: self near: self fullBounds! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/14/2011 17:56'!                           chooseColor	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"	| attribute |	(ColorPickerMorph new)		choseModalityFromPreference;		sourceHand: morph activeHand;		target: (attribute := TextColor color: Color black);		selector: #color:;		originalColor: Color black;		putUpFor: morph near: morph fullBounds.	"default"	^attribute! !!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 11/14/2011 18:01'!                           scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta rectToTest cpHere |	selRects _ self textMorph selectionRects.	selRects isEmpty ifTrue: [ ^ false ].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [ event anyButtonPressed ]) ifTrue: [  "Check for autoscroll"self flag: #jmvVer. "Revisar"		cpHere _ event position.		cpHere y <= bounds top			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]			ifFalse: [				cpHere y >= bounds bottom					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]					ifFalse: [ ^ false ]]].	rectToTest height > bounds height		ifTrue: [ ^ false ].  "Would not fit, even if we tried to scroll"	(delta _ rectToTest amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true ].	^ false! !!UserInputEvent methodsFor: 'initialize' stamp: 'jmv 11/14/2011 18:20'!             resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"	self flag: #jmvVer. "All this stuff of copying events to reset this data is pretty ugly."	handler _ nil.	wasHandled _ false.! !!WorldState methodsFor: 'hands' stamp: 'jmv 11/14/2011 17:56'! selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result hBnds |	result _ OrderedCollection new.	hands do: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					hBnds _ h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: nil)						ifNotNil: [result add: h]]]].	^ result! !!WorldState methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:56'!                           drawHand: aHandMorph	| bw r |	Preferences fastDragWindowForMorphic ifTrue: [		bw _ HandMorph fastDragBorderWidth // 2.		r _ aHandMorph fullBounds.		canvas frameRectangle: r borderWidth: bw color: Color black.		canvas frameRectangle: (r insetBy: bw) borderWidth: bw color: Color white.		canvas clipBy: aHandMorph bounds during: [ :c | aHandMorph drawOn: c ]]	ifFalse: [		aHandMorph fullDrawOn: canvas ]! !!WorldState methodsFor: 'drawing' stamp: 'jmv 11/14/2011 17:56'!                               drawInvalidAreasWorld: aWorld submorphs: submorphs	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."	initialRectsToRepair _ OrderedCollection new.	(damageRecorder invalidRectsFullBounds: aWorld viewBox) do: [ :r |		r ifNotNil: [ initialRectsToRepair addLast: r ]].	damageRecorder reset.	currentRectsToRepair _ OrderedCollection new.	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.	morphsToDraw _ OrderedCollection new.	rectsForEachMorph _ OrderedCollection new.	thisMorphRects _ OrderedCollection new.	n _ submorphs size.	i _ 1.	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [		morph _ submorphs at: i.		morph visible ifTrue: [			morphBounds _morph fullBounds.			reuse _ currentRectsToRepair.			currentRectsToRepair _ newRectsToRepair.			newRectsToRepair _ reuse removeAll.			currentRectsToRepair do: [ :r |				(morphBounds intersects: r)					ifTrue: [						morphClipRect _ morphBounds intersect: r.						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]					ifFalse: [						newRectsToRepair add: r ]].			thisMorphRects ifNotEmpty: [				morphsToDraw add: morph.				rectsForEachMorph add: thisMorphRects.				thisMorphRects _ OrderedCollection new.			]].		i _ i + 1 ].	i > n  ifTrue: [		newRectsToRepair do: [ :r |			(canvas copyClipRect: r) clipBy: aWorld bounds during: [ :c | aWorld drawOn: c ]]].	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |		"Here we could merge all xrects into just one call... Most likely, that would be slower, though.""		rr _ nil."		xrects do: [ :r |"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."			m fullDrawOn: (canvas copyClipRect: r)		]."		(canvas copyClipRect: rr) fullDrawMorph: m "	].		"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...	(think of vnc over slow networks)"	^ initialRectsToRepair! !MouseMoveEvent removeSelector: #externalizeFromOwnerOf:to:!MouseMoveEvent removeSelector: #internalizeTo:from:!MouseMoveEvent removeSelector: #internalizeToOwnerOf:from:!MouseEvent removeSelector: #noticeMouseOver:!UserInputEvent removeSelector: #copyHandlerState:!UserInputEvent removeSelector: #externalizeFromOwnerOf:to:!UserInputEvent removeSelector: #externalizedFromOwnerOf:to:!UserInputEvent removeSelector: #internalizeTo:from:!UserInputEvent removeSelector: #internalizeToOwnerOf:from:!UserInputEvent removeSelector: #internalizedTo:from:!UserInputEvent removeSelector: #internalizedToOwnerOf:from:!UserInputEvent removeSelector: #setPosition:!DropEvent removeSelector: #copyHandlerState:!DropEvent removeSelector: #externalizeFromOwnerOf:to:!DropEvent removeSelector: #externalizedFromOwnerOf:to:!DropEvent removeSelector: #internalizeTo:from:!DropEvent removeSelector: #internalizeToOwnerOf:from:!DropEvent removeSelector: #internalizedTo:from:!DropEvent removeSelector: #internalizedToOwnerOf:from:!MorphicEvent removeSelector: #copyHandlerState:!MorphicEvent removeSelector: #externalizedFromOwnerOf:to:!MorphicEvent removeSelector: #internalizedTo:from:!MorphicEvent removeSelector: #internalizedToOwnerOf:from:!ColorPickerMorph removeSelector: #argument:!Morph removeSelector: #bounds:in:!Morph removeSelector: #displayBounds!Morph removeSelector: #externalizePosition:to:!Morph removeSelector: #externalizePositionFromOwner:to:!Morph removeSelector: #externalizeVector:to:!Morph removeSelector: #fullDisplayBounds!Morph removeSelector: #internalizePosition:from:!Morph removeSelector: #internalizePositionToOwner:from:!Morph removeSelector: #positionInWorld!Message removeSelector: #argument:!LightWidget removeSelector: #displayBounds!LightWidget removeSelector: #externalizePosition:to:!LightWidget removeSelector: #externalizePositionFromOwner:to:!LightWidget removeSelector: #fullDisplayBounds!LightWidget removeSelector: #internalizePosition:from:!LightWidget removeSelector: #internalizePositionToOwner:from:!Smalltalk removeClassNamed: #MorphicUnknownEvent!