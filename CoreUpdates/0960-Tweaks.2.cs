'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 6 May 2011 at 8:36:48 am'!!Point commentStamp: 'jmv 5/4/2011 08:37' prior: 0!I represent an x-y pair of numbers usually designating a location on the screen.When dealing with display coordinates, the y axis is usually considered to increase downwards. However, the standard math convention is to consider it increasing upwards. Points don't need to know about this. In the first case, theta increases clockwise. In the second case, it increases counter-clockwise, also the standard math convention.Any method that doesn't follow this (because it assumes one specific convention) include this fact in the selector and in a comment.!!Float methodsFor: 'printing' stamp: 'jmv 5/5/2011 16:52'!printPaddedLeft: integerDigits decimalPlaces: fractionDigits	"	Can be enhanced, especially for infinities and nans...	Add an extra leading space for positive numbers	Float pi printPaddedLeft: 3 decimalPlaces: 3	Float pi *1000 printPaddedLeft: 3 decimalPlaces: 3	Float pi negated printPaddedLeft: 3 decimalPlaces: 3	"	| i f integerString fractionString n |	n _ self abs.	i _ n truncated.	f _ n - i.	integerString _ i printPaddedWith: $0 to: integerDigits.	fractionString _ f printShowingDecimalPlaces: fractionDigits.	^self > 0		ifTrue: [ ' ', integerString, (fractionString copyFrom: 2 to: fractionString size) ]		ifFalse: [ '-', integerString, (fractionString copyFrom: 2 to: fractionString size) ]! !!Float class methodsFor: 'constants' stamp: 'jmv 9/21/2008 07:42'!negativeInfinity	"Answer the value used to represent an negative infinite magnitude"	^ NegativeInfinity! !!Form methodsFor: 'converting' stamp: 'jmv 5/4/2011 10:23'!asFormOfDepth: d	| newForm |	d = self depth ifTrue: [ ^self ].	newForm _ Form extent: self extent depth: d.	(BitBlt current toForm: newForm)		colorMap: (self colormapIfNeededFor: newForm);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	"If we build a 32bpp from one of smaller depth,	it will have zero in the alpha channel (until BitBlt is fixed!!)"	d = 32 ifTrue: [		newForm fixAlpha ].	^newForm! !!Form methodsFor: 'copying' stamp: 'ar 6/9/2000 18:59'!contentsOfArea: aRect 	"Return a new form which derives from the portion of the original form delineated by aRect."	^self contentsOfArea: aRect 		into: (self class extent: aRect extent depth: depth).! !!Form methodsFor: 'copying' stamp: 'ar 6/9/2000 19:00'!contentsOfArea: aRect into: newForm 	"Return a new form which derives from the portion of the original form delineated by aRect."	^ newForm copyBits: aRect from: self at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil! !!FormCanvas methodsFor: 'drawing' stamp: 'jmv 5/3/2011 08:24'!paragraph: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner _ DisplayScanner new 			text: para text			foreground: (shadowColor ifNil: [ c ])			ignoreColorChanges: self isShadowDrawing.	scanner setPort: (port clippedBy: (bounds translateBy: origin)).	para		displayOn: (self copyClipRect: bounds)		using: scanner		at: origin+ bounds topLeft! !!Inspector methodsFor: 'selecting' stamp: 'jmv 5/5/2011 16:52'!selectionPrintString	| text |	selectionUpdateTime := [text := [self selection printStringLimitedTo: 12000]						on: Error						do: [text := self printStringErrorText.							text								addAttribute: TextColor red								from: 1								to: text size.							text]] timeToRun.	^ text! !!Matrix methodsFor: 'printing' stamp: 'jmv 5/5/2011 16:49'!printOn: aStream	1 to: self height do: [ :i |		aStream nextPutAll: '| '.		1 to: self width do: [ :j |			aStream nextPutAll: ((self i: i j: j) printPaddedLeft: 1 decimalPlaces: 2).			"aStream print: ((self i: i j: j) roundTo: 0.001)."			aStream nextPut: $  ].		aStream nextPut: $|; cr ]! !!Timespan methodsFor: 'squeak protocol' stamp: 'jmv 5/4/2011 08:24'!intersection: aTimespan	 "Return the Timespan both have in common, or nil"	"Warning: There's something possibly wrong here. See 	http://lists.gforge.inria.fr/pipermail/pharo-project/2011-May/048253.html		It seems reasonable to expect this to answer true. However it answers false:	|start end span|	start :=DateAndTime now.	end := start + 1 hour.	span := Timespan starting: start ending: end.	(span intersection: span) = span	"	 | aBegin anEnd |	 aBegin _ self start max: aTimespan start.	 anEnd _ self end min: aTimespan end.	 anEnd < aBegin ifTrue: [^nil].	 ^ Timespan starting: aBegin ending: anEnd! !GrafPort removeSelector: #displayScannerFor:foreground:ignoreColorChanges:!