'From Cuis 3.2 of 12 April 2011 [latest update: #914] on 1 June 2011 at 11:14:07 am'!!ChangeSorter class methodsFor: 'adding' stamp: 'jmv 6/1/2011 09:53'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet |	oldChanges _ ChangeSet current.	PreviousSet _ oldChanges name. 		"so a Bumper update can find it"	newName _ aName sansPeriodSuffix.	newSet _ self basicNewChangeSet: newName.	[		newSet ifNotNil: [			ChangeSet  newChanges: newSet.			aStream fileInAnnouncing: 'Loading ', newName, '...'.			Transcript show: 'File ', aName, ' successfully filed in to change set ', newName; cr].		aStream close	] ensure: [			ChangeSet  newChanges: oldChanges].	^ newSet! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/31/2011 10:28'!selection	"Answer the text that is currently selected."	| t |	t _ self text.	^Text streamContents: [ :strm |		"Multiple selection"		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock | | toAppend |			toAppend _ t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1.			toAppend size > 0 ifTrue: [				strm nextPutAll: toAppend.				strm withAttributes: (toAppend attributesAt: toAppend size) do: [ strm cr ]]].		"Regular selection"		strm nextPutAll: ( t copyFrom: self startIndex to: self stopIndex - 1 ) ]! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 6/1/2011 09:51'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	(self hasSelection or: [ selectionStartBlocks notEmpty]) ifFalse: [morph flash.  ^ returnBlock value]! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 6/1/2011 09:49'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	(self hasSelection or: [ selectionStartBlocks notEmpty]) ifTrue:[^self].	self selectInterval: (self text encompassLine: self selectionInterval)! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 6/1/2011 09:30'!selectAll: aKeyboardEvent 	"select everything, invoked by cmd-a.  1/17/96 sw"	selectionStartBlocks _ {}.	selectionStopBlocks _ {}.	^super selectAll: aKeyboardEvent! !!SmalltalkEditor methodsFor: 'accessing-selection' stamp: 'jmv 6/1/2011 09:52'!selection	"Answer the text that is currently selected.	Redefined for Smalltalk code: if there's no regular selection, and all the selectionBlocks contain the same string,	answer that string."	| t regularSelection allPartsEqual samePart |	t _ self text.	regularSelection _ ( t copyFrom: self startIndex to: self stopIndex - 1 ).	allPartsEqual _ true.	samePart _ nil.	^Text streamContents: [ :strm |		"Multiple selection"		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock | | toAppend |			toAppend _ t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1.			toAppend size > 0 ifTrue: [				samePart					ifNil: [ samePart _ toAppend ]					ifNotNil: [						allPartsEqual _ allPartsEqual and: [ samePart = toAppend ]].				strm nextPutAll: toAppend.				strm withAttributes: (toAppend attributesAt: toAppend size) do: [ strm cr ]].			].		(allPartsEqual and: [ regularSelection isEmpty ]) ifTrue: [			^samePart ].		"Regular selection"		strm nextPutAll: regularSelection ]! !