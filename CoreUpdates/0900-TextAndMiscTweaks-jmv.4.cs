'From Cuis 3.1 of 4 March 2011 [latest update: #850] on 4 April 2011 at 5:07:33 pm'!!classDefinition: #TextFontFamilyAndSize category: #'System-TextAttributes'!TextAttribute subclass: #TextFontFamilyAndSize	instanceVariableNames: 'familyName pointSize'	classVariableNames: ''	poolDictionaries: ''	category: 'System-TextAttributes'!!TextURL commentStamp: '<historical>' prior: 0!('Some text ', (Text string: 'theLink' attributes: {TextURL new url: 'www.koko.kom'}), ' blah, blah.') edit!!BareTextMorph methodsFor: 'anchors' stamp: 'jmv 4/1/2011 11:02'!anchorMorph: aMorph at: aPoint	| relPt index newText |	aMorph owner == self ifTrue: [ self removeMorph: aMorph ].	self addMorphFront: aMorph.	relPt _ self internalizePosition: aPoint from: self world.	index _ (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ ' ', (Text string: '*' attribute: (TextAnchor new anchoredFormOrMorph: aMorph)), ' '.	self text replaceFrom: index to: index-1 with: newText.	self paragraph recomposeFrom: index to: index + newText size -1 delta: newText size.	self fit.! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 4/1/2011 10:16'!enterClickableRegion: evt	| index isLink |	evt hand hasSubmorphs ifTrue: [ ^self ].	paragraph ifNotNil:[		index _ (paragraph characterBlockAtPoint: evt position) stringIndex.		isLink _ (self text attributesAt: index) 					anySatisfy: [ :attr | attr mayActOnClick ].		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !!BareTextMorph methodsFor: 'editing' stamp: 'jmv 4/1/2011 10:16'!handleInteraction: interactionBlock	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple ParagraphEditor to Morphic keyboard events"	| oldEditor oldParagraph oldSize |	oldEditor _ editor.	oldParagraph _ paragraph.	oldSize _ oldParagraph text size.	self selectionChanged.  "Note old selection"		interactionBlock value.	(oldParagraph == paragraph) ifTrue:[		"this will not work if the paragraph changed"		editor _ oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	(oldSize = self text size)		ifFalse: [ self updateFromParagraph ]! !!BareTextMorph methodsFor: 'private' stamp: 'jmv 4/1/2011 11:02'!removedMorph: aMorph	| range |	range _ self text find: (TextAnchor new anchoredFormOrMorph: aMorph).	range ifNotNil: [		self text replaceFrom: range first to: range last with: Text new.		self paragraph recomposeFrom: range first to: range first  -1 delta: range size negated.		self fit ].	super removedMorph: aMorph! !!Paragraph methodsFor: 'composition' stamp: 'jmv 4/1/2011 10:49'!recomposeFrom: startArg to: stopArg delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed.	Expand the requested interval to include whole paragraphs because there could be paragraph attributes."	| intervalToFix start stop startLine newLines |	"Have to recompose line above in case a word-break was affected."	intervalToFix _ self text encompassParagraph: (startArg to: stopArg).	start _ intervalToFix first.	stop _ intervalToFix last.	startLine _ (self lineIndexFor: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	newLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].	self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top! !!RunArray methodsFor: 'adding' stamp: 'jmv 4/1/2011 14:13'!coalesce	"Try to combine adjacent runs"	| ind |	ind _ 2.	[ ind > values size ] whileFalse: [		(self canJoin: (values at: ind-1) and: (values at: ind))			ifFalse: [ ind _ ind + 1 ]			ifTrue: [		"two are the same, combine them"				values _ values copyReplaceFrom: ind to: ind with: #().				runs at: ind-1 put: (runs at: ind-1) + (runs at: ind).				runs _ runs copyReplaceFrom: ind to: ind with: #() ]]! !!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 4/1/2011 10:28'!replaceStringForRangesWithType: aSymbol with: aString in: aText 	"Answer aText if no replacements, or a copy of aText with 	each range with a type of aSymbol replaced by aString"	| answer toReplace increaseInLength |	"We don't handle format and conversion for debuggers"	disableFormatAndConvert ifTrue: [ ^aText ].		toReplace := (self rangesIn: aText setWorkspace: false) 		select: [:each | each type = aSymbol].	toReplace isEmpty ifTrue: [^aText].	answer := aText copy.	increaseInLength := 0.	(toReplace asArray sort: [:a :b | a start <= b start]) 		do: [:each | | end start thisIncrease | 			start := each start + increaseInLength.			end := each end + increaseInLength.			answer replaceFrom: start to: end with: aString.			thisIncrease := aString size - each length.			increaseInLength := increaseInLength + thisIncrease ].	^answer! !!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 3/31/2011 15:24'!fromUser: priorFont 	"StrikeFont fromUser"	"Present a menu of available fonts, and if one is chosen, return it.	Otherwise return nil.	Show only baseFonts i.e. FamilyName, pointSize (but do not include emphasis, such as italic or bold)"	| fontList fontMenu active ptMenu label spec |	fontList := AbstractFont familyNames.	fontMenu := MenuMorph new defaultTarget: self.	fontList do: [:fontName | 			active := priorFont familyName sameAs: fontName.			ptMenu := MenuMorph new defaultTarget: self.			(AbstractFont pointSizesFor:fontName ) do: [ :pt | 					(active and: [pt = priorFont pointSize]) 						ifTrue: [label := '<on>']						ifFalse: [label := '<off>'].					label := label , pt printString , ' pt'.					ptMenu 						add: label						target: fontMenu						selector: #modalSelection:						argument: { 								fontName.								pt}].			active ifTrue: [label := '<on>'] ifFalse: [label := '<off>'].			label := label , fontName.			fontMenu add: label subMenu: ptMenu].	spec := fontMenu invokeModal.	spec ifNil: [^nil].	^AbstractFont familyName: spec first pointSize: spec last! !!Text methodsFor: 'accessing' stamp: 'jmv 4/1/2011 13:58'!embeddedMorphs	"return the list of morphs embedded in me"	^self embeddedMorphsFrom: 1 to: self size! !!Text methodsFor: 'accessing' stamp: 'jmv 4/1/2011 11:48'!embeddedMorphsFrom: start to: stop 	"return the list of morphs embedded in me"	| morphs |	morphs _ IdentitySet new.	self attributesFrom: start to: stop do: [:attr |		attr anchoredFormOrMorph ifNotNil: [ :m |			(m is: #Morph) ifTrue: [				morphs add: m]]].	^morphs! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/1/2011 11:48'!attributesFrom: start to: stop do: aBlock	"evaluate aBlock for each attribute in the specified range.	Warning: aBlock might be evaluated several times for each attribute, but not as many as the characters that it applies to!!."	runs runsFrom: start to: stop do: [ :attributes |		attributes do: [ :attribute |			aBlock value: attribute ]]! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/4/2011 15:34'!font: aFont	"Apply aFont to the entire contents.	Note: use #baseFont. If emphasis is desired, add it separatedly."	self addAttribute: (TextFontFamilyAndSize			familyName: aFont familyName			pointSize: aFont pointSize)! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/1/2011 12:49'!removeAttributes: attributesToRemove from: requestedStart to: requestedStop	"Remove the attribute over the interval start to stop."	| intervalToFix start stop |	start _ requestedStart.	stop _ requestedStop.		"If att must be applied to whole paragraphs, do so."	(attributesToRemove anySatisfy: [ :att | att isParagraphAttribute ]) ifTrue: [		intervalToFix _ self encompassParagraph: (start to: stop).		start _ intervalToFix first.		stop _ intervalToFix last ].	self privateSetRuns: (runs		copyReplaceFrom: start		to: stop		with: ((runs copyFrom: start to: stop) mapValues: [ :attributes | 			attributes copyWithoutAll: attributesToRemove])).	runs coalesce! !!Text methodsFor: 'emphasis' stamp: 'jmv 4/1/2011 15:38'!withAttributeValues: attributes do: aBlock	"Evaluate aBlock with the values of various attributes applied in the correct order	The order is (each overwriting the previous one)	1) initialStyle	2) ParagraphStyleReferene	3) CharacterStyleReference	4) TextFontReference	5) TextEmphasis"	| paragraphStyle characterStyle font emphasis alignment color kern |	paragraphStyle _ nil.	characterStyle _ nil.	font _ StrikeFont default baseFont.	emphasis _ 0.	alignment _ 0.	color _ nil.	kern _ 0.		"ParagraphStyle is the first to set several values"	attributes do: [ :attribute |		attribute forParagraphStyleReferenceDo: [ :s | 			paragraphStyle _ s]].	paragraphStyle		ifNotNil: [			font _ paragraphStyle font.			alignment _ paragraphStyle alignment.			paragraphStyle color ifNotNil: [ :c | color _ c ]].	"CharacterStyle, if present, can override font and color"	attributes do: [ :attribute |		attribute forCharacterStyleReferenceDo: [ :s | 			characterStyle _ s.			font _ characterStyle font.			characterStyle color ifNotNil: [ :c | color _ c ]]].		"Hardcoded color for TextAction comes before TextColor"	attributes do: [ :attribute |		attribute forTextActionInfoDo: [ :info | color _ TextAction purple ]].	"These will not interfere with each other, and all of them take precedence over previous values"	attributes do: [ :attribute |		attribute forBaseFontDo: [ :f | font _ f ].		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].		attribute forTextColorDo: [ :c | color _ c ].		attribute forTextAlignmentDo: [ :a | alignment _ a ].		attribute forTextKernDo: [ :k | kern _ kern + k ].	].	"Finally, the font must include any specified emphasis"	font _ font emphasized: emphasis.		"Done. Now evaluate the block."	^aBlock valueWithArguments: {font. color. alignment. paragraphStyle. characterStyle. kern }! !!Text class methodsFor: 'instance creation' stamp: 'jmv 4/4/2011 15:33'!initialFont: aStrikeFont string: aString attribute: att	"Answer an instance of me whose characters are aString.	att is a TextAttribute.	Note: use #baseFont. If emphasis is desired, add it separatedly."	^self		string: aString		attributes: {TextFontFamilyAndSize			familyName: aStrikeFont familyName			pointSize: aStrikeFont pointSize.			att}! !!Text class methodsFor: 'instance creation' stamp: 'jmv 4/4/2011 15:33'!initialFont: aStrikeFont stringOrText: aStringOrText	"Answer an instance of me whose characters are aString.	Note: use #baseFont. If emphasis is desired, add it separatedly."	(aStringOrText isKindOf: Text) ifTrue: [		^ aStringOrText font: aStrikeFont ].		^self string: aStringOrText attributes: {TextFontFamilyAndSize		familyName: aStrikeFont familyName		pointSize: aStrikeFont pointSize }! !!TextAttribute methodsFor: 'iterating' stamp: 'jmv 3/31/2011 15:52'!forBaseFontDo: aBlock	"No action is the default"! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/1/2011 10:14'!currentAttributes	| i t |	i _ self startIndex.	t _ self text.	^i > t size		ifTrue: [			emphasisHere ]		ifFalse: [			"paragraph attributes at the current paragraph will later be applied.			include them in the answer"			(emphasisHere reject: [ :attr | attr isParagraphAttribute ]),				((t attributesAt: i) select: [ :attr | attr isParagraphAttribute ]) ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/1/2011 10:14'!currentCharacterStyleOrNil	"Answer the CharacterStyle for the current selection or cursor location if any"	^self hasSelection		ifTrue: [ self text characterStyleOrNilAt: self startIndex ]		ifFalse: [ self text characterStyleOrNilIfApplying: emphasisHere ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/1/2011 10:14'!currentParagraphStyle	"Answer the ParagraphStyle for the current selection or cursor location if any"		| i t |	i _ self startIndex.	t _ self text.	^i > t size		ifTrue: [ t paragraphStyleOrNilIfApplying: emphasisHere ]		ifFalse: [ t paragraphStyleOrNilAt: i ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/1/2011 10:15'!lastFont	"Answer the Font for to be used if positioned at the end of the text"		| t |	t _ self text.	^self startIndex > t size		ifTrue: [ t fontIfApplying: emphasisHere ]		ifFalse: [ t fontAt: t size +1 ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/1/2011 10:15'!lastParagraphStyleOrNil	"Answer the ParagraphStyle for to be used if positioned at the end of the text"		| t |	t _ self text.	^self startIndex > t size		ifTrue: [ t paragraphStyleOrNilIfApplying: emphasisHere ]		ifFalse: [ t paragraphStyleOrNilAt: t size +1 ]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/1/2011 10:12'!text	"Answer the text being edited."	^model actualContents! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/1/2011 10:22'!selection	"Answer the text that is currently selected."	^self text copyFrom: self startIndex to: self stopIndex - 1 ! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 4/1/2011 10:19'!changeEmphasisOrAlignment	| menuStrings aList reply  code align menuList startIndex attribute t |	startIndex _ self startIndex.	aList _ #(normal bold italic underlined struckOut leftFlush centered rightFlush justified).		t _ self text.	align _ t alignmentAt: startIndex.	code _ t emphasisAt: startIndex.	menuList _ WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal'.	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue: [ '<on>', emph asString ]			ifFalse: [ '<off>', emph asString ]]).	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collectWithIndex: [ :type :i |		align = (i-1)			ifTrue: [ '<on>', type asString ]			ifFalse: [ '<off>', type asString ]]).	menuStrings _ menuList contents.	aList _ #(normal bold italic underlined struckOut leftFlush centered rightFlush justified).	reply _ (SelectionMenu labelList: menuStrings lines: #(1 5) selections: aList) startUpWithoutKeyboard.	reply ifNotNil: [		(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue: [				attribute _TextAlignment perform: reply]			ifFalse: [				attribute _ TextEmphasis perform: reply].		((menuStrings at: (aList indexOf: reply)) beginsWith: '<on>')			ifTrue: [ self unapplyAttribute: attribute ]			ifFalse: [ self applyAttribute:  attribute ]].	^ true! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 4/4/2011 15:34'!changeTextFont	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.	Note: use #baseFont. If emphasis is desired, add it separatedly."	| curFont newFont attr startIndex |	startIndex _ self startIndex.	curFont _ self text fontAt: startIndex.	newFont _ StrikeFont fromUser: curFont.	newFont ifNil: [ ^self ].	attr _ TextFontFamilyAndSize			familyName: newFont familyName			pointSize: newFont pointSize.	self applyAttribute: attr! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 4/1/2011 10:20'!enclose: aKeyboardEvent	"Insert or remove bracket characters around the current selection."	| left right startIndex stopIndex oldSelection which t |	self closeTypeIn.	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	t _ self text.	((startIndex > 1 and: [stopIndex <= t size])			and: [ (t at: startIndex-1) = left and: [(t at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 4/1/2011 10:15'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList _ self text attributesAt: (self pointIndex + self markIndex)//2.	attrList do: [:attr |		attr forTextActionInfoDo: [ :info |			^ self selection asString, '<', info, '>']].	"If none of the above"	attrList do: [:attr |		attr forTextColorDo: [ :color |			^ self selection asString, '<', color printString, '>']].	^ self selection asString, '[No hidden info]'! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/1/2011 09:41'!pasteRecent	"Paste an item chose from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	self clipboardTextPut: clipping.	^ self paste! !!TextEditor methodsFor: 'mvc compatibility' stamp: 'jmv 4/1/2011 13:02'!zapSelectionWith: replacement	| start stop rep |	self deselect.	start _ self startIndex.	stop _ self stopIndex.	(replacement isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (self text attributesAt: start) select: [:att | att mayBeExtended]].	(start = stop and: [ replacement isEmpty ]) ifFalse: [		rep _ (replacement is: #Text)			ifTrue: [ replacement ]			ifFalse: [ Text string: replacement attributes: emphasisHere ].		self text replaceFrom: start to: stop - 1 with: rep.		paragraph			recomposeFrom: start			to:  start + rep size - 1			delta: rep size - (stop-start).		self markIndex: start; pointIndex: start + rep size.		UndoInterval _ otherInterval _ self selectionInterval.		self userHasEdited  " -- note text now dirty" ].	morph possiblyChanged ! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 4/1/2011 10:21'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	self hasSelection ifTrue:[^self].	self selectInterval: (self text encompassLine: self selectionInterval)! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 4/1/2011 10:14'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over;	(3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock		ifNil: [self openTypeIn. UndoSelection _ self nullText. self stopIndex]		ifNotNil: [self startOfTyping].	self markIndex: startIndex.	startIndex < saveLimit ifTrue: [		newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(self text copyFrom: startIndex to: saveLimit - 1).		UndoMessage hasArguments ifTrue: [ 			UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers]].	self zapSelectionWith: self nullText.	self unselect! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 4/1/2011 10:22'!setEmphasisHereFromTextForward: f	| i t forward delta prevIsSeparator nextIsSeparator |	i _ self pointIndex.	t _ self text.	"Try to set emphasisHere correctly after whitespace.	Most important after a cr, i.e. at the start of a new line"	prevIsSeparator _  i > 1 and: [ (t at: i-1) isSeparator ].	nextIsSeparator _ i <= t size and: [ (t at: i) isSeparator ].	forward _ prevIsSeparator = nextIsSeparator		ifTrue: [ f ]		ifFalse: [ nextIsSeparator ].	delta _ forward ifTrue: [ 1 ] ifFalse: [ 0 ].	emphasisHere _ (t attributesAt: (i - delta max: 1))					select: [:att | att mayBeExtended].	morph possiblyChanged ! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/1/2011 10:23'!forwardDelete: aKeyboardEvent	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ self markIndex.	startIndex > self text size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock ifNil: [	"no previous typing.  openTypeIn"		self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval copy.	upara _ UndoParagraph copy.	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection is: #Text) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with: self nullText]].	^false! !!TextEditor methodsFor: 'private' stamp: 'jmv 4/1/2011 10:18'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ self text				findString: FindText				startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [ self zapSelectionWith: ChangeText ].	indices nextPut: where.	^ true! !!TextEditor methodsFor: 'private' stamp: 'jmv 4/1/2011 12:57'!applyAttribute: aTextAttribute	"The user selected aTextAttribute via shortcut, menu or other means.	If there is a selection, apply the attribute to the selection.	In any case use the attribute for the user input (emphasisHere)"	| interval |	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.		interval _ self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].		self text addAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	morph possiblyChanged! !!TextEditor methodsFor: 'private' stamp: 'jmv 4/1/2011 10:21'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start _ self startIndex.	stop _ self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue: [			before _ prior last < start.			selection _ self selection.			priorSelection _ self text copyFrom: prior first to: prior last.			delta _ before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta _ before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval _ prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval _ start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse: [			morph flash]! !!TextEditor methodsFor: 'private' stamp: 'jmv 4/1/2011 12:57'!unapplyAttribute: aTextAttribute	"The user selected aTextAttribute to be removed.	If there is a selection, unapply the attribute to the selection.	In any case do not use the attribute for the user input (emphasisHere)"	| interval |	emphasisHere _ emphasisHere copyWithout: aTextAttribute.	interval _ self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].		self text removeAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	morph possiblyChanged! !!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/1/2011 10:16'!argAdvance: aKeyboardEvent	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start t |	self closeTypeIn.	t _ self text.	start _ t findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [ start _ t size + 1].	self selectAt: start + 2.	^true! !!TextFontFamilyAndSize methodsFor: 'accessing' stamp: 'jmv 3/31/2011 15:49'!familyName	^familyName! !!TextFontFamilyAndSize methodsFor: 'accessing' stamp: 'jmv 3/31/2011 16:13'!familyName: aString pointSize: aNumber	familyName _ aString.	pointSize _ aNumber! !!TextFontFamilyAndSize methodsFor: 'accessing' stamp: 'jmv 3/31/2011 15:46'!font	^ AbstractFont familyName: familyName pointSize: pointSize! !!TextFontFamilyAndSize methodsFor: 'accessing' stamp: 'jmv 3/31/2011 15:49'!pointSize	^pointSize! !!TextFontFamilyAndSize methodsFor: 'comparing' stamp: 'jmv 3/31/2011 15:49'!= other 	^ (other class == self class) 		and: [ other pointSize == pointSize			and: [ other familyName == familyName ]]! !!TextFontFamilyAndSize methodsFor: 'comparing' stamp: 'jmv 3/31/2011 15:49'!dominates: other	^ other class == self class! !!TextFontFamilyAndSize methodsFor: 'comparing' stamp: 'jmv 3/31/2011 15:49'!hash	"#hash is re-implemented because #= is re-implemented"	^familyName hash bitXor: pointSize hash! !!TextFontFamilyAndSize methodsFor: 'iterating' stamp: 'jmv 3/31/2011 15:52'!forBaseFontDo: aBlock	aBlock value: self font! !!TextFontFamilyAndSize class methodsFor: 'instance creation' stamp: 'jmv 3/31/2011 16:13'!familyName: aString pointSize: aNumber	"Reference only baseFonts. Any emphasis should be done with TextEmphasis.	Store only familiName and pointSize"	^ self new familyName: aString pointSize: aNumber! !!TextModelMorph methodsFor: 'menu commands' stamp: 'jmv 4/1/2011 09:42'!pasteRecent	"Paste an item chosen from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	self editor clipboardTextPut: clipping.	^ self handleEdit: [ self editor paste ]! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 4/1/2011 10:39'!stylerStyled	"jmv - 11/2010 The next line used to be commented out but it is needed to fix lines whose	length might change due to font change (i.e., styled comments are shorter than unstyled)"	textMorph paragraph composeAll.	"older comment: caused chars to appear in wrong order esp. in demo mode. remove this line when sure it is fixed"		textMorph updateFromParagraph.	selectionInterval 		ifNotNil: [			self editor				selectInvisiblyFrom: selectionInterval first to: selectionInterval last;				storeSelectionInParagraph;				setEmphasisHereFromText].	self editor blinkParen.	self scrollSelectionIntoView! !!TextURL methodsFor: 'as yet unclassified' stamp: 'jmv 3/30/2011 15:47'!actOnClickFor: anObject 	"Do what you can with this URL.  Later a web browser."	^true! !!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'jmv 3/31/2011 16:02'!contents	^String streamContents: [ :strm |		entries do: [ :e |			strm nextPutAll: e; cr ]]! !TextFontFamilyAndSize class removeSelector: #toFont:!TextFontFamilyAndSize removeSelector: #toFont:!TextEditor removeSelector: #unapplyAttributesThat:fromWholeParagraph:!TextAttribute removeSelector: #forFontReferenceDo:!Text removeSelector: #removeAttributesThat:replaceAttributesThat:by:!Text removeSelector: #removeAttributesThat:replaceAttributesThat:by:signalIfWholeParagraphAttribute:!Paragraph removeSelector: #replaceFrom:to:with:!Smalltalk removeClassNamed: #FormSetFont!Smalltalk removeClassNamed: #TextFontReference!